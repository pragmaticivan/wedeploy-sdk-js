(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.io = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var parser = _dereq_('socket.io-parser');
var Manager = _dereq_('./manager');
var debug = _dereq_('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_('./manager');
exports.Socket = _dereq_('./socket');

},{"./manager":2,"./socket":4,"./url":5,"debug":14,"socket.io-parser":40}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var eio = _dereq_('engine.io-client');
var Socket = _dereq_('./socket');
var Emitter = _dereq_('component-emitter');
var parser = _dereq_('socket.io-parser');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:manager');
var indexOf = _dereq_('indexof');
var Backoff = _dereq_('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function(){
  this.lastPing = new Date;
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function(){
  this.emitAll('pong', new Date - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function(){
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  debug('cleanup');

  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' == this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":3,"./socket":4,"backo2":8,"component-bind":11,"component-emitter":12,"debug":14,"engine.io-client":16,"indexof":32,"socket.io-parser":40}],3:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],4:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_('socket.io-parser');
var Emitter = _dereq_('component-emitter');
var toArray = _dereq_('to-array');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:socket');
var hasBin = _dereq_('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function(compress){
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":3,"component-bind":11,"component-emitter":12,"debug":14,"has-binary":30,"socket.io-parser":40,"to-array":43}],5:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_('parseuri');
var debug = _dereq_('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"debug":14,"parseuri":38}],6:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],7:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],8:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],9:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();

},{}],10:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],11:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],12:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],13:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],14:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":15}],15:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":35}],16:[function(_dereq_,module,exports){

module.exports =  _dereq_('./lib/');

},{"./lib/":17}],17:[function(_dereq_,module,exports){

module.exports = _dereq_('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_('engine.io-parser');

},{"./socket":18,"engine.io-parser":27}],18:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_('./transports');
var Emitter = _dereq_('component-emitter');
var debug = _dereq_('debug')('engine.io-client:socket');
var index = _dereq_('indexof');
var parser = _dereq_('engine.io-parser');
var parseuri = _dereq_('parseuri');
var parsejson = _dereq_('parsejson');
var parseqs = _dereq_('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

  // other options for Node.js client
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }
  }

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_('./transport');
Socket.transports = _dereq_('./transports');
Socket.parser = _dereq_('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function(){
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if('function' == typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' == typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./transport":19,"./transports":20,"component-emitter":26,"debug":14,"engine.io-parser":27,"indexof":32,"parsejson":36,"parseqs":37,"parseuri":38}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_('engine.io-parser');
var Emitter = _dereq_('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":26,"engine.io-parser":27}],20:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
var XHR = _dereq_('./polling-xhr');
var JSONP = _dereq_('./polling-jsonp');
var websocket = _dereq_('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling-jsonp":21,"./polling-xhr":22,"./websocket":24,"xmlhttprequest-ssl":25}],21:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_('./polling');
var inherit = _dereq_('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  }
  else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling":23,"component-inherit":13}],22:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
var Polling = _dereq_('./polling');
var Emitter = _dereq_('component-emitter');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling":23,"component-emitter":26,"component-inherit":13,"debug":14,"xmlhttprequest-ssl":25}],23:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parseqs = _dereq_('parseqs');
var parser = _dereq_('engine.io-parser');
var inherit = _dereq_('component-inherit');
var yeast = _dereq_('yeast');
var debug = _dereq_('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":19,"component-inherit":13,"debug":14,"engine.io-parser":27,"parseqs":37,"xmlhttprequest-ssl":25,"yeast":45}],24:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parser = _dereq_('engine.io-parser');
var parseqs = _dereq_('parseqs');
var inherit = _dereq_('component-inherit');
var yeast = _dereq_('yeast');
var debug = _dereq_('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  try {
    WebSocket = _dereq_('ws');
  } catch (e) { }
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'buffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function(packet) {
      parser.encodePacket(packet, self.supportsBinary, function(data) {
        if (!BrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        //Sometimes the websocket has already been closed but the browser didn't
        //have a chance of informing us about it yet, in that case send will
        //throw an error
        try {
          if (BrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e){
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done(){
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function(){
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"../transport":19,"component-inherit":13,"debug":14,"engine.io-parser":27,"parseqs":37,"ws":undefined,"yeast":45}],25:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":31}],26:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],27:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_('./keys');
var hasBinary = _dereq_('has-binary');
var sliceBuffer = _dereq_('arraybuffer.slice');
var base64encoder = _dereq_('base64-arraybuffer');
var after = _dereq_('after');
var utf8 = _dereq_('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./keys":28,"after":6,"arraybuffer.slice":7,"base64-arraybuffer":9,"blob":10,"has-binary":29,"utf8":44}],28:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],29:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"isarray":33}],30:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"isarray":33}],31:[function(_dereq_,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],32:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],33:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],34:[function(_dereq_,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],35:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],36:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],37:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],38:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],39:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_('isarray');
var isBuf = _dereq_('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./is-buffer":41,"isarray":33}],40:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_('debug')('socket.io-parser');
var json = _dereq_('json3');
var isArray = _dereq_('isarray');
var Emitter = _dereq_('component-emitter');
var binary = _dereq_('./binary');
var isBuf = _dereq_('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":39,"./is-buffer":41,"component-emitter":42,"debug":14,"isarray":33,"json3":34}],41:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],42:[function(_dereq_,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],43:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],44:[function(_dereq_,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],45:[function(_dereq_,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}]},{},[1])(1)
});

(function() {
this.wedeploy = this.wedeploy || {};
this.wedeployNamed = this.wedeployNamed || {};
var babelHelpers = {};
babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
};

babelHelpers.classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

babelHelpers.createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

babelHelpers.inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

babelHelpers.possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

babelHelpers.slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

babelHelpers.toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

babelHelpers;
'use strict';

/**
 * A collection of core utility functions.
 * @const
 */

(function () {
	var core = function () {
		function core() {
			babelHelpers.classCallCheck(this, core);
		}

		babelHelpers.createClass(core, null, [{
			key: 'abstractMethod',

			/**
    * When defining a class Foo with an abstract method bar(), you can do:
    * Foo.prototype.bar = core.abstractMethod
    *
    * Now if a subclass of Foo fails to override bar(), an error will be thrown
    * when bar() is invoked.
    *
    * @type {!Function}
    * @throws {Error} when invoked to indicate the method should be overridden.
    */
			value: function abstractMethod() {
				throw Error('Unimplemented abstract method');
			}

			/**
    * Loops constructor super classes collecting its properties values. If
    * property is not available on the super class `undefined` will be
    * collected as value for the class hierarchy position.
    * @param {!function()} constructor Class constructor.
    * @param {string} propertyName Property name to be collected.
    * @return {Array.<*>} Array of collected values.
    * TODO(*): Rethink superclass loop.
    */

		}, {
			key: 'collectSuperClassesProperty',
			value: function collectSuperClassesProperty(constructor, propertyName) {
				var propertyValues = [constructor[propertyName]];
				while (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {
					constructor = constructor.__proto__;
					propertyValues.push(constructor[propertyName]);
				}
				return propertyValues;
			}

			/**
    * Gets the name of the given function. If the current browser doesn't
    * support the `name` property, this will calculate it from the function's
    * content string.
    * @param {!function()} fn
    * @return {string}
    */

		}, {
			key: 'getFunctionName',
			value: function getFunctionName(fn) {
				if (!fn.name) {
					var str = fn.toString();
					fn.name = str.substring(9, str.indexOf('('));
				}
				return fn.name;
			}

			/**
    * Gets an unique id. If `opt_object` argument is passed, the object is
    * mutated with an unique id. Consecutive calls with the same object
    * reference won't mutate the object again, instead the current object uid
    * returns. See {@link core.UID_PROPERTY}.
    * @param {Object=} opt_object Optional object to be mutated with the uid. If
    *     not specified this method only returns the uid.
    * @param {boolean=} opt_noInheritance Optional flag indicating if this
    *     object's uid property can be inherited from parents or not.
    * @throws {Error} when invoked to indicate the method should be overridden.
    */

		}, {
			key: 'getUid',
			value: function getUid(opt_object, opt_noInheritance) {
				if (opt_object) {
					var id = opt_object[core.UID_PROPERTY];
					if (opt_noInheritance && !opt_object.hasOwnProperty(core.UID_PROPERTY)) {
						id = null;
					}
					return id || (opt_object[core.UID_PROPERTY] = core.uniqueIdCounter_++);
				}
				return core.uniqueIdCounter_++;
			}

			/**
    * The identity function. Returns its first argument.
    * @param {*=} opt_returnValue The single value that will be returned.
    * @return {?} The first argument.
    */

		}, {
			key: 'identityFunction',
			value: function identityFunction(opt_returnValue) {
				return opt_returnValue;
			}

			/**
    * Returns true if the specified value is a boolean.
    * @param {?} val Variable to test.
    * @return {boolean} Whether variable is boolean.
    */

		}, {
			key: 'isBoolean',
			value: function isBoolean(val) {
				return typeof val === 'boolean';
			}

			/**
    * Returns true if the specified value is not undefined.
    * @param {?} val Variable to test.
    * @return {boolean} Whether variable is defined.
    */

		}, {
			key: 'isDef',
			value: function isDef(val) {
				return val !== undefined;
			}

			/**
    * Returns true if value is not undefined or null.
    * @param {*} val
    * @return {boolean}
    */

		}, {
			key: 'isDefAndNotNull',
			value: function isDefAndNotNull(val) {
				return core.isDef(val) && !core.isNull(val);
			}

			/**
    * Returns true if value is a document.
    * @param {*} val
    * @return {boolean}
    */

		}, {
			key: 'isDocument',
			value: function isDocument(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : babelHelpers.typeof(val)) === 'object' && val.nodeType === 9;
			}

			/**
    * Returns true if value is a dom element.
    * @param {*} val
    * @return {boolean}
    */

		}, {
			key: 'isElement',
			value: function isElement(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : babelHelpers.typeof(val)) === 'object' && val.nodeType === 1;
			}

			/**
    * Returns true if the specified value is a function.
    * @param {?} val Variable to test.
    * @return {boolean} Whether variable is a function.
    */

		}, {
			key: 'isFunction',
			value: function isFunction(val) {
				return typeof val === 'function';
			}

			/**
    * Returns true if value is null.
    * @param {*} val
    * @return {boolean}
    */

		}, {
			key: 'isNull',
			value: function isNull(val) {
				return val === null;
			}

			/**
    * Returns true if the specified value is a number.
    * @param {?} val Variable to test.
    * @return {boolean} Whether variable is a number.
    */

		}, {
			key: 'isNumber',
			value: function isNumber(val) {
				return typeof val === 'number';
			}

			/**
    * Returns true if value is a window.
    * @param {*} val
    * @return {boolean}
    */

		}, {
			key: 'isWindow',
			value: function isWindow(val) {
				return val !== null && val === val.window;
			}

			/**
    * Returns true if the specified value is an object. This includes arrays
    * and functions.
    * @param {?} val Variable to test.
    * @return {boolean} Whether variable is an object.
    */

		}, {
			key: 'isObject',
			value: function isObject(val) {
				var type = typeof val === 'undefined' ? 'undefined' : babelHelpers.typeof(val);
				return type === 'object' && val !== null || type === 'function';
			}

			/**
    * Returns true if value is a Promise.
    * @param {*} val
    * @return {boolean}
    */

		}, {
			key: 'isPromise',
			value: function isPromise(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : babelHelpers.typeof(val)) === 'object' && typeof val.then === 'function';
			}

			/**
    * Returns true if value is a string.
    * @param {*} val
    * @return {boolean}
    */

		}, {
			key: 'isString',
			value: function isString(val) {
				return typeof val === 'string' || val instanceof String;
			}

			/**
    * Merges the values of a static property a class with the values of that
    * property for all its super classes, and stores it as a new static
    * property of that class. If the static property already existed, it won't
    * be recalculated.
    * @param {!function()} constructor Class constructor.
    * @param {string} propertyName Property name to be collected.
    * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled
    *   with the values of the property for the current class and all its super classes.
    *   Should return the merged value to be stored on the current class.
    * @return {boolean} Returns true if merge happens, false otherwise.
    */

		}, {
			key: 'mergeSuperClassesProperty',
			value: function mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {
				var mergedName = propertyName + '_MERGED';
				if (constructor.hasOwnProperty(mergedName)) {
					return false;
				}

				var merged = core.collectSuperClassesProperty(constructor, propertyName);
				if (opt_mergeFn) {
					merged = opt_mergeFn(merged);
				}
				constructor[mergedName] = merged;
				return true;
			}

			/**
    * Null function used for default values of callbacks, etc.
    * @return {void} Nothing.
    */

		}, {
			key: 'nullFunction',
			value: function nullFunction() {}
		}]);
		return core;
	}();

	/**
  * Unique id property prefix.
  * @type {String}
  * @protected
  */


	core.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

	/**
  * Counter for unique id.
  * @type {Number}
  * @private
  */
	core.uniqueIdCounter_ = 1;

	this.wedeploy.core = core;
}).call(this);
'use strict';

(function () {
	var core = this.wedeploy.core;

	var array = function () {
		function array() {
			babelHelpers.classCallCheck(this, array);
		}

		babelHelpers.createClass(array, null, [{
			key: 'equal',

			/**
    * Checks if the given arrays have the same content.
    * @param {!Array<*>} arr1
    * @param {!Array<*>} arr2
    * @return {boolean}
    */
			value: function equal(arr1, arr2) {
				if (arr1.length !== arr2.length) {
					return false;
				}
				for (var i = 0; i < arr1.length; i++) {
					if (arr1[i] !== arr2[i]) {
						return false;
					}
				}
				return true;
			}

			/**
    * Returns the first value in the given array that isn't undefined.
    * @param {!Array} arr
    * @return {*}
    */

		}, {
			key: 'firstDefinedValue',
			value: function firstDefinedValue(arr) {
				for (var i = 0; i < arr.length; i++) {
					if (arr[i] !== undefined) {
						return arr[i];
					}
				}
			}

			/**
    * Transforms the input nested array to become flat.
    * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
    * @param {Array.<*>} opt_output Optional output array.
    * @return {Array.<*>} Flat array.
    */

		}, {
			key: 'flatten',
			value: function flatten(arr, opt_output) {
				var output = opt_output || [];
				for (var i = 0; i < arr.length; i++) {
					if (Array.isArray(arr[i])) {
						array.flatten(arr[i], output);
					} else {
						output.push(arr[i]);
					}
				}
				return output;
			}

			/**
    * Removes the first occurrence of a particular value from an array.
    * @param {Array.<T>} arr Array from which to remove value.
    * @param {T} obj Object to remove.
    * @return {boolean} True if an element was removed.
    * @template T
    */

		}, {
			key: 'remove',
			value: function remove(arr, obj) {
				var i = arr.indexOf(obj);
				var rv;
				if (rv = i >= 0) {
					array.removeAt(arr, i);
				}
				return rv;
			}

			/**
    * Removes from an array the element at index i
    * @param {Array} arr Array or array like object from which to remove value.
    * @param {number} i The index to remove.
    * @return {boolean} True if an element was removed.
    */

		}, {
			key: 'removeAt',
			value: function removeAt(arr, i) {
				return Array.prototype.splice.call(arr, i, 1).length === 1;
			}

			/**
    * Slices the given array, just like Array.prototype.slice, but this
    * is faster and working on all array-like objects (like arguments).
    * @param {!Object} arr Array-like object to slice.
    * @param {number} start The index that should start the slice.
    * @param {number=} opt_end The index where the slice should end, not
    *   included in the final array. If not given, all elements after the
    *   start index will be included.
    * @return {!Array}
    */

		}, {
			key: 'slice',
			value: function slice(arr, start, opt_end) {
				var sliced = [];
				var end = core.isDef(opt_end) ? opt_end : arr.length;
				for (var i = start; i < end; i++) {
					sliced.push(arr[i]);
				}
				return sliced;
			}
		}]);
		return array;
	}();

	this.wedeploy.array = array;
}).call(this);
/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */

'use strict';

(function () {
	var async = {};

	/**
  * Throw an item without interrupting the current execution context.  For
  * example, if processing a group of items in a loop, sometimes it is useful
  * to report an error while still allowing the rest of the batch to be
  * processed.
  * @param {*} exception
  */
	async.throwException = function (exception) {
		// Each throw needs to be in its own context.
		async.nextTick(function () {
			throw exception;
		});
	};

	/**
  * Fires the provided callback just before the current callstack unwinds, or as
  * soon as possible after the current JS execution context.
  * @param {function(this:THIS)} callback
  * @param {THIS=} opt_context Object to use as the "this value" when calling
  *     the provided function.
  * @template THIS
  */
	async.run = function (callback, opt_context) {
		if (!async.run.workQueueScheduled_) {
			// Nothing is currently scheduled, schedule it now.
			async.nextTick(async.run.processWorkQueue);
			async.run.workQueueScheduled_ = true;
		}

		async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
	};

	/** @private {boolean} */
	async.run.workQueueScheduled_ = false;

	/** @private {!Array.<!async.run.WorkItem_>} */
	async.run.workQueue_ = [];

	/**
  * Run any pending async.run work items. This function is not intended
  * for general use, but for use by entry point handlers to run items ahead of
  * async.nextTick.
  */
	async.run.processWorkQueue = function () {
		// NOTE: additional work queue items may be pushed while processing.
		while (async.run.workQueue_.length) {
			// Don't let the work queue grow indefinitely.
			var workItems = async.run.workQueue_;
			async.run.workQueue_ = [];
			for (var i = 0; i < workItems.length; i++) {
				var workItem = workItems[i];
				try {
					workItem.fn.call(workItem.scope);
				} catch (e) {
					async.throwException(e);
				}
			}
		}

		// There are no more work items, reset the work queue.
		async.run.workQueueScheduled_ = false;
	};

	/**
  * @constructor
  * @final
  * @struct
  * @private
  *
  * @param {function()} fn
  * @param {Object|null|undefined} scope
  */
	async.run.WorkItem_ = function (fn, scope) {
		/** @const */
		this.fn = fn;
		/** @const */
		this.scope = scope;
	};

	/**
  * Fires the provided callbacks as soon as possible after the current JS
  * execution context. setTimeout(, 0) always takes at least 5ms for legacy
  * reasons.
  * @param {function(this:SCOPE)} callback Callback function to fire as soon as
  *     possible.
  * @param {SCOPE=} opt_context Object in whose scope to call the listener.
  * @template SCOPE
  */
	async.nextTick = function (callback, opt_context) {
		var cb = callback;
		if (opt_context) {
			cb = callback.bind(opt_context);
		}
		cb = async.nextTick.wrapCallback_(cb);
		// Introduced and currently only supported by IE10.
		// Verify if variable is defined on the current runtime (i.e., node, browser).
		// Can't use typeof enclosed in a function (such as core.isFunction) or an
		// exception will be thrown when the function is called on an environment
		// where the variable is undefined.
		if (typeof setImmediate === 'function') {
			setImmediate(cb);
			return;
		}
		// Look for and cache the custom fallback version of setImmediate.
		if (!async.nextTick.setImmediate_) {
			async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
		}
		async.nextTick.setImmediate_(cb);
	};

	/**
  * Cache for the setImmediate implementation.
  * @type {function(function())}
  * @private
  */
	async.nextTick.setImmediate_ = null;

	/**
  * Determines the best possible implementation to run a function as soon as
  * the JS event loop is idle.
  * @return {function(function())} The "setImmediate" implementation.
  * @private
  */
	async.nextTick.getSetImmediateEmulator_ = function () {
		// Create a private message channel and use it to postMessage empty messages
		// to ourselves.
		var Channel;

		// Verify if variable is defined on the current runtime (i.e., node, browser).
		// Can't use typeof enclosed in a function (such as core.isFunction) or an
		// exception will be thrown when the function is called on an environment
		// where the variable is undefined.
		if (typeof MessageChannel === 'function') {
			Channel = MessageChannel;
		}

		// If MessageChannel is not available and we are in a browser, implement
		// an iframe based polyfill in browsers that have postMessage and
		// document.addEventListener. The latter excludes IE8 because it has a
		// synchronous postMessage implementation.
		if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
			/** @constructor */
			Channel = function Channel() {
				// Make an empty, invisible iframe.
				var iframe = document.createElement('iframe');
				iframe.style.display = 'none';
				iframe.src = '';
				document.documentElement.appendChild(iframe);
				var win = iframe.contentWindow;
				var doc = win.document;
				doc.open();
				doc.write('');
				doc.close();
				var message = 'callImmediate' + Math.random();
				var origin = win.location.protocol + '//' + win.location.host;
				var onmessage = function (e) {
					// Validate origin and message to make sure that this message was
					// intended for us.
					if (e.origin !== origin && e.data !== message) {
						return;
					}
					this.port1.onmessage();
				}.bind(this);
				win.addEventListener('message', onmessage, false);
				this.port1 = {};
				this.port2 = {
					postMessage: function postMessage() {
						win.postMessage(message, origin);
					}
				};
			};
		}
		if (typeof Channel !== 'undefined') {
			var channel = new Channel();
			// Use a fifo linked list to call callbacks in the right order.
			var head = {};
			var tail = head;
			channel.port1.onmessage = function () {
				head = head.next;
				var cb = head.cb;
				head.cb = null;
				cb();
			};
			return function (cb) {
				tail.next = {
					cb: cb
				};
				tail = tail.next;
				channel.port2.postMessage(0);
			};
		}
		// Implementation for IE6-8: Script elements fire an asynchronous
		// onreadystatechange event when inserted into the DOM.
		if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
			return function (cb) {
				var script = document.createElement('script');
				script.onreadystatechange = function () {
					// Clean up and call the callback.
					script.onreadystatechange = null;
					script.parentNode.removeChild(script);
					script = null;
					cb();
					cb = null;
				};
				document.documentElement.appendChild(script);
			};
		}
		// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
		// or more.
		return function (cb) {
			setTimeout(cb, 0);
		};
	};

	/**
  * Helper function that is overrided to protect callbacks with entry point
  * monitor if the application monitors entry points.
  * @param {function()} callback Callback function to fire as soon as possible.
  * @return {function()} The wrapped callback.
  * @private
  */
	async.nextTick.wrapCallback_ = function (opt_returnValue) {
		return opt_returnValue;
	};

	this.wedeploy.async = async;
}).call(this);
'use strict';

/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

(function () {
	var Disposable = function () {
		function Disposable() {
			babelHelpers.classCallCheck(this, Disposable);

			/**
    * Flag indicating if this instance has already been disposed.
    * @type {boolean}
    * @protected
    */
			this.disposed_ = false;
		}

		/**
   * Disposes of this instance's object references. Calls `disposeInternal`.
   */


		babelHelpers.createClass(Disposable, [{
			key: 'dispose',
			value: function dispose() {
				if (!this.disposed_) {
					this.disposeInternal();
					this.disposed_ = true;
				}
			}

			/**
    * Subclasses should override this method to implement any specific
    * disposing logic (like clearing references and calling `dispose` on other
    * disposables).
    */

		}, {
			key: 'disposeInternal',
			value: function disposeInternal() {}

			/**
    * Checks if this instance has already been disposed.
    * @return {boolean}
    */

		}, {
			key: 'isDisposed',
			value: function isDisposed() {
				return this.disposed_;
			}
		}]);
		return Disposable;
	}();

	this.wedeploy.Disposable = Disposable;
}).call(this);
'use strict';

(function () {
	var object = function () {
		function object() {
			babelHelpers.classCallCheck(this, object);
		}

		babelHelpers.createClass(object, null, [{
			key: 'mixin',

			/**
    * Copies all the members of a source object to a target object.
    * @param {Object} target Target object.
    * @param {...Object} var_args The objects from which values will be copied.
    * @return {Object} Returns the target object reference.
    */
			value: function mixin(target) {
				var key, source;
				for (var i = 1; i < arguments.length; i++) {
					source = arguments[i];
					for (key in source) {
						target[key] = source[key];
					}
				}
				return target;
			}

			/**
    * Returns an object based on its fully qualified external name.
    * @param {string} name The fully qualified name.
    * @param {object=} opt_obj The object within which to look; default is
    *     <code>window</code>.
    * @return {?} The value (object or primitive) or, if not found, undefined.
    */

		}, {
			key: 'getObjectByName',
			value: function getObjectByName(name, opt_obj) {
				var scope = opt_obj || window;
				var parts = name.split('.');
				return parts.reduce(function (part, key) {
					return part[key];
				}, scope);
			}

			/**
    * Returns a new object with the same keys as the given one, but with
    * their values set to the return values of the specified function.
    * @param {!Object} obj
    * @param {!function(string, *)} fn
    * @return {!Object}
    */

		}, {
			key: 'map',
			value: function map(obj, fn) {
				var mappedObj = {};
				var keys = Object.keys(obj);
				for (var i = 0; i < keys.length; i++) {
					mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
				}
				return mappedObj;
			}

			/**
    * Checks if the two given objects are equal. This is done via a shallow
    * check, including only the keys directly contained by the 2 objects.
    * @return {boolean}
    */

		}, {
			key: 'shallowEqual',
			value: function shallowEqual(obj1, obj2) {
				if (obj1 === obj2) {
					return true;
				}

				var keys1 = Object.keys(obj1);
				var keys2 = Object.keys(obj2);
				if (keys1.length !== keys2.length) {
					return false;
				}

				for (var i = 0; i < keys1.length; i++) {
					if (obj1[keys1[i]] !== obj2[keys1[i]]) {
						return false;
					}
				}
				return true;
			}
		}]);
		return object;
	}();

	this.wedeploy.object = object;
}).call(this);
'use strict';

(function () {
	var string = function () {
		function string() {
			babelHelpers.classCallCheck(this, string);
		}

		babelHelpers.createClass(string, null, [{
			key: 'collapseBreakingSpaces',

			/**
    * Removes the breaking spaces from the left and right of the string and
    * collapses the sequences of breaking spaces in the middle into single spaces.
    * The original and the result strings render the same way in HTML.
    * @param {string} str A string in which to collapse spaces.
    * @return {string} Copy of the string with normalized breaking spaces.
    */
			value: function collapseBreakingSpaces(str) {
				return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
			}

			/**
   * Escapes characters in the string that are not safe to use in a RegExp.
   * @param {*} str The string to escape. If not a string, it will be casted
   *     to one.
   * @return {string} A RegExp safe, escaped copy of {@code s}.
   */

		}, {
			key: 'escapeRegex',
			value: function escapeRegex(str) {
				return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
			}

			/**
   * Returns a string with at least 64-bits of randomness.
   * @return {string} A random string, e.g. sn1s7vb4gcic.
   */

		}, {
			key: 'getRandomString',
			value: function getRandomString() {
				var x = 2147483648;
				return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
			}

			/**
    * Calculates the hashcode for a string. The hashcode value is computed by
    * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
    * property of using 31 prime is that the multiplication can be replaced by
    * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
    * Modern VMs do this sort of optimization automatically.
    * @param {String} val Target string.
    * @return {Number} Returns the string hashcode.
    */

		}, {
			key: 'hashCode',
			value: function hashCode(val) {
				var hash = 0;
				for (var i = 0, len = val.length; i < len; i++) {
					hash = 31 * hash + val.charCodeAt(i);
					hash %= 0x100000000;
				}
				return hash;
			}

			/**
    * Replaces interval into the string with specified value, e.g.
    * `replaceInterval("abcde", 1, 4, "")` returns "ae".
    * @param {string} str The input string.
    * @param {Number} start Start interval position to be replaced.
    * @param {Number} end End interval position to be replaced.
    * @param {string} value The value that replaces the specified interval.
    * @return {string}
    */

		}, {
			key: 'replaceInterval',
			value: function replaceInterval(str, start, end, value) {
				return str.substring(0, start) + value + str.substring(end);
			}
		}]);
		return string;
	}();

	this.wedeploy.string = string;
}).call(this);
'use strict';

(function () {
  var core = this.wedeploy.core;
  var array = this.wedeploy.array;
  var async = this.wedeploy.async;
  var Disposable = this.wedeploy.Disposable;
  var object = this.wedeploy.object;
  var string = this.wedeploy.string;
  this.wedeploy.metal = core;
  this.wedeployNamed.metal = this.wedeployNamed.metal || {};
  this.wedeployNamed.metal.core = core;
  this.wedeployNamed.metal.array = array;
  this.wedeployNamed.metal.async = async;
  this.wedeployNamed.metal.Disposable = Disposable;
  this.wedeployNamed.metal.object = object;
  this.wedeployNamed.metal.string = string;
}).call(this);
'use strict';

(function () {
	var Disposable = this.wedeployNamed.metal.Disposable;

	/**
  * A cached reference to the create function.
  */

	var create = Object.create;

	/**
  * Case insensitive string Multimap implementation. Allows multiple values for
  * the same key name.
  * @extends {Disposable}
  */

	var MultiMap = function (_Disposable) {
		babelHelpers.inherits(MultiMap, _Disposable);

		function MultiMap() {
			babelHelpers.classCallCheck(this, MultiMap);

			var _this = babelHelpers.possibleConstructorReturn(this, (MultiMap.__proto__ || Object.getPrototypeOf(MultiMap)).call(this));

			_this.keys = create(null);
			_this.values = create(null);
			return _this;
		}

		/**
   * Adds value to a key name.
   * @param {string} name
   * @param {*} value
   * @chainable
   */


		babelHelpers.createClass(MultiMap, [{
			key: 'add',
			value: function add(name, value) {
				this.keys[name.toLowerCase()] = name;
				this.values[name.toLowerCase()] = this.values[name.toLowerCase()] || [];
				this.values[name.toLowerCase()].push(value);
				return this;
			}

			/**
    * Clears map names and values.
    * @chainable
    */

		}, {
			key: 'clear',
			value: function clear() {
				this.keys = create(null);
				this.values = create(null);
				return this;
			}

			/**
    * Checks if map contains a value to the key name.
    * @param {string} name
    * @return {boolean}
    * @chainable
    */

		}, {
			key: 'contains',
			value: function contains(name) {
				return name.toLowerCase() in this.values;
			}

			/**
    * @inheritDoc
    */

		}, {
			key: 'disposeInternal',
			value: function disposeInternal() {
				this.values = null;
			}

			/**
    * Creates a `MultiMap` instance from the given object.
    * @param {!Object} obj
    * @return {!MultiMap}
    */

		}, {
			key: 'get',


			/**
    * Gets the first added value from a key name.
    * @param {string} name
    * @return {*}
    * @chainable
    */
			value: function get(name) {
				var values = this.values[name.toLowerCase()];
				if (values) {
					return values[0];
				}
			}

			/**
    * Gets all values from a key name.
    * @param {string} name
    * @return {Array.<*>}
    */

		}, {
			key: 'getAll',
			value: function getAll(name) {
				return this.values[name.toLowerCase()];
			}

			/**
    * Returns true if the map is empty, false otherwise.
    * @return {boolean}
    */

		}, {
			key: 'isEmpty',
			value: function isEmpty() {
				return this.size() === 0;
			}

			/**
    * Gets array of key names.
    * @return {Array.<string>}
    */

		}, {
			key: 'names',
			value: function names() {
				var _this2 = this;

				return Object.keys(this.values).map(function (key) {
					return _this2.keys[key];
				});
			}

			/**
    * Removes all values from a key name.
    * @param {string} name
    * @chainable
    */

		}, {
			key: 'remove',
			value: function remove(name) {
				delete this.keys[name.toLowerCase()];
				delete this.values[name.toLowerCase()];
				return this;
			}

			/**
    * Sets the value of a key name. Relevant to replace the current values with
    * a new one.
    * @param {string} name
    * @param {*} value
    * @chainable
    */

		}, {
			key: 'set',
			value: function set(name, value) {
				this.keys[name.toLowerCase()] = name;
				this.values[name.toLowerCase()] = [value];
				return this;
			}

			/**
    * Gets the size of the map key names.
    * @return {number}
    */

		}, {
			key: 'size',
			value: function size() {
				return this.names().length;
			}

			/**
    * Returns the parsed values as a string.
    * @return {string}
    */

		}, {
			key: 'toString',
			value: function toString() {
				return JSON.stringify(this.values);
			}
		}], [{
			key: 'fromObject',
			value: function fromObject(obj) {
				var map = new MultiMap();
				var keys = Object.keys(obj);
				for (var i = 0; i < keys.length; i++) {
					map.set(keys[i], obj[keys[i]]);
				}
				return map;
			}
		}]);
		return MultiMap;
	}(Disposable);

	this.wedeploy.MultiMap = MultiMap;
}).call(this);
'use strict';

(function () {
	var array = this.wedeployNamed.metal.array;

	/**
  * Generic tree node data structure with arbitrary number of child nodes.
  * @param {V} value Value.
  * @constructor
  */

	var TreeNode = function () {
		function TreeNode(value) {
			babelHelpers.classCallCheck(this, TreeNode);

			/**
    * The value.
    * @private {V}
    */
			this.value_ = value;

			/**
    * Reference to the parent node or null if it has no parent.
    * @private {TreeNode}
    */
			this.parent_ = null;

			/**
    * Child nodes or null in case of leaf node.
    * @private {Array<!TreeNode>}
    */
			this.children_ = null;
		}

		/**
   * Appends a child node to this node.
   * @param {!TreeNode} child Orphan child node.
   */


		babelHelpers.createClass(TreeNode, [{
			key: 'addChild',
			value: function addChild(child) {
				assertChildHasNoParent(child);
				child.setParent(this);
				this.children_ = this.children_ || [];
				this.children_.push(child);
			}

			/**
    * Tells whether this node is the ancestor of the given node.
    * @param {!TreeNode} node A node.
    * @return {boolean} Whether this node is the ancestor of {@code node}.
    */

		}, {
			key: 'contains',
			value: function contains(node) {
				var current = node.getParent();
				while (current) {
					if (current === this) {
						return true;
					}
					current = current.getParent();
				}
				return false;
			}

			/**
    * @return {!Array<TreeNode>} All ancestor nodes in bottom-up order.
    */

		}, {
			key: 'getAncestors',
			value: function getAncestors() {
				var ancestors = [];
				var node = this.getParent();
				while (node) {
					ancestors.push(node);
					node = node.getParent();
				}
				return ancestors;
			}

			/**
    * Gets the child node of this node at the given index.
    * @param {number} index Child index.
    * @return {?TreeNode} The node at the given index
    * or null if not found.
    */

		}, {
			key: 'getChildAt',
			value: function getChildAt(index) {
				return this.getChildren()[index] || null;
			}

			/**
    * @return {?Array<!TreeNode>} Child nodes or null in case of leaf node.
    */

		}, {
			key: 'getChildren',
			value: function getChildren() {
				return this.children_ || TreeNode.EMPTY_ARRAY;
			}

			/**
    * @return {number} The number of children.
    */

		}, {
			key: 'getChildCount',
			value: function getChildCount() {
				return this.getChildren().length;
			}

			/**
    * @return {number} The number of ancestors of the node.
    */

		}, {
			key: 'getDepth',
			value: function getDepth() {
				var depth = 0;
				var node = this;
				while (node.getParent()) {
					depth++;
					node = node.getParent();
				}
				return depth;
			}

			/**
    * @return {?TreeNode} Parent node or null if it has no parent.
    */

		}, {
			key: 'getParent',
			value: function getParent() {
				return this.parent_;
			}

			/**
    * @return {!TreeNode} The root of the tree structure, i.e. the farthest
    * ancestor of the node or the node itself if it has no parents.
    */

		}, {
			key: 'getRoot',
			value: function getRoot() {
				var root = this;
				while (root.getParent()) {
					root = root.getParent();
				}
				return root;
			}

			/**
    * Gets the value.
    * @return {V} The value.
    */

		}, {
			key: 'getValue',
			value: function getValue() {
				return this.value_;
			}

			/**
    * @return {boolean} Whether the node is a leaf node.
    */

		}, {
			key: 'isLeaf',
			value: function isLeaf() {
				return !this.getChildCount();
			}

			/**
    * Removes the given child node of this node.
    * @param {TreeNode} child The node to remove.
    * @return {TreeNode} The removed node if any, null otherwise.
    */

		}, {
			key: 'removeChild',
			value: function removeChild(child) {
				if (array.remove(this.getChildren(), child)) {
					return child;
				}
				return null;
			}

			/**
    * Sets the parent node of this node. The callers must ensure that the
    * parent node and only that has this node among its children.
    * @param {TreeNode} parent The parent to set. If null, the node will be
    * detached from the tree.
    * @protected
    */

		}, {
			key: 'setParent',
			value: function setParent(parent) {
				this.parent_ = parent;
			}

			/**
    * Traverses the subtree. The first callback starts with this node,
    * and visits the descendant nodes depth-first, in preorder.
    * The second callback, starts with deepest child then visits
    * the ancestor nodes depth-first, in postorder. E.g.
    *
    *  	 A
    *    / \
    *   B   C
    *  /   / \
    * D   E   F
    *
    * preorder -> ['A', 'B', 'D', 'C', 'E', 'F']
    * postorder -> ['D', 'B', 'E', 'F', 'C', 'A']
    *
    * @param {function=} opt_preorderFn The callback to execute when visiting a node.
    * @param {function=} opt_postorderFn The callback to execute before leaving a node.
    */

		}, {
			key: 'traverse',
			value: function traverse(opt_preorderFn, opt_postorderFn) {
				if (opt_preorderFn) {
					opt_preorderFn(this);
				}
				this.getChildren().forEach(function (child) {
					return child.traverse(opt_preorderFn, opt_postorderFn);
				});
				if (opt_postorderFn) {
					opt_postorderFn(this);
				}
			}
		}]);
		return TreeNode;
	}();

	/**
  * Constant for empty array to avoid unnecessary allocations.
  * @private
  */


	TreeNode.EMPTY_ARRAY = [];

	/**
  * Asserts that child has no parent.
  * @param {TreeNode} child A child.
  * @private
  */
	var assertChildHasNoParent = function assertChildHasNoParent(child) {
		if (child.getParent()) {
			throw new Error('Cannot add child with parent.');
		}
	};

	this.wedeploy.TreeNode = TreeNode;
}).call(this);
'use strict';

(function () {
  var MultiMap = this.wedeploy.MultiMap;
  var TreeNode = this.wedeploy.TreeNode;
  this.wedeployNamed.structs = this.wedeployNamed.structs || {};
  this.wedeployNamed.structs.MultiMap = MultiMap;
  this.wedeployNamed.structs.TreeNode = TreeNode;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var MultiMap = this.wedeployNamed.structs.MultiMap;

	/**
  * Represents a client message (e.g. a request or a response).
  */

	var ClientMessage = function () {
		function ClientMessage() {
			babelHelpers.classCallCheck(this, ClientMessage);

			this.headers_ = new MultiMap();
		}

		/**
   * Fluent getter and setter for request body.
   * @param {*=} opt_body Request body to be set. If none is given,
   *   the current value of the body will be returned.
   * @return {*} Returns request body if no body value was given. Otherwise
   *   returns the {@link ClientMessage} object itself, so calls can be chained.
   * @chainable Chainable when used as setter.
   */


		babelHelpers.createClass(ClientMessage, [{
			key: 'body',
			value: function body(opt_body) {
				if (core.isDef(opt_body)) {
					this.body_ = opt_body;
					return this;
				}
				return this.body_;
			}

			/**
    * Adds a header. If a header with the same name already exists, it will not be
    * overwritten, but the new value will be stored as well. The order is preserved.
    * @param {string} name
    * @param {string} value
    * @chainable
    */

		}, {
			key: 'header',
			value: function header(name, value) {
				if (arguments.length !== 2) {
					throw new Error('Invalid arguments');
				}
				this.headers_.set(name, value);
				return this;
			}

			/**
    * Fluent getter and setter for request headers.
    * @param {MultiMap|Object=} opt_headers Request headers list to
    *   be set. If none is given the current value of the headers will
    *   be returned.
    * @return {!MultiMap|ClientMessage} Returns map of request headers
    *   if no new value was given. Otherwise returns the {@link ClientMessage}
    *   object itself, so calls can be chained.
    * @chainable Chainable when used as setter.
    */

		}, {
			key: 'headers',
			value: function headers(opt_headers) {
				if (core.isDef(opt_headers)) {
					if (opt_headers instanceof MultiMap) {
						this.headers_ = opt_headers;
					} else {
						this.headers_.values = opt_headers;
					}
					return opt_headers;
				}
				return this.headers_;
			}

			/**
    * Removes the body.
    */

		}, {
			key: 'removeBody',
			value: function removeBody() {
				this.body_ = undefined;
			}
		}]);
		return ClientMessage;
	}();

	this.wedeploy.ClientMessage = ClientMessage;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var ClientMessage = this.wedeploy.ClientMessage;
	var MultiMap = this.wedeployNamed.structs.MultiMap;

	/**
  * Represents a client request object.
  * @extends {ClientMessage}
  */

	var ClientRequest = function (_ClientMessage) {
		babelHelpers.inherits(ClientRequest, _ClientMessage);

		function ClientRequest() {
			babelHelpers.classCallCheck(this, ClientRequest);

			var _this = babelHelpers.possibleConstructorReturn(this, (ClientRequest.__proto__ || Object.getPrototypeOf(ClientRequest)).call(this));

			_this.params_ = new MultiMap();
			_this.withCredentials_ = true;
			return _this;
		}

		/**
   * Fluent getter and setter for with credentials option.
   * @param {boolean=} opt_withCredentials
   * @chainable Chainable when used as setter.
   */


		babelHelpers.createClass(ClientRequest, [{
			key: 'withCredentials',
			value: function withCredentials(opt_withCredentials) {
				if (core.isDef(opt_withCredentials)) {
					this.withCredentials_ = !!opt_withCredentials;
					return this;
				}
				return this.withCredentials_;
			}

			/**
    * Fluent getter and setter for request method.
    * @param {string=} opt_method Request method to be set. If none is given,
    *   the current method value will be returned.
    * @return {!ClientMessage|string} Returns request method if no new value was
    *   given. Otherwise returns the {@link ClientMessage} object itself, so
    *   calls can be chained.
    * @chainable Chainable when used as setter.
    */

		}, {
			key: 'method',
			value: function method(opt_method) {
				if (core.isDef(opt_method)) {
					this.method_ = opt_method;
					return this;
				}
				return this.method_ || ClientRequest.DEFAULT_METHOD;
			}

			/**
    * Adds a query. If a query with the same name already exists, it will not
    * be overwritten, but new value will be stored as well. The order is preserved.
    * @param {string} name
    * @param {string} value
    * @chainable
    */

		}, {
			key: 'param',
			value: function param(name, value) {
				if (arguments.length !== 2) {
					throw new Error('Invalid arguments');
				}
				this.params_.set(name, value);
				return this;
			}

			/**
    * Fluent getter and setter for request querystring.
    * @param {MultiMap|Object=} opt_params Request querystring map to be set.
    *   If none is given the current value of the params will be returned.
    * @return {!MultiMap|ClientMessage} Returns map of request querystring if
    *   no new value was given. Otherwise returns the {@link ClientMessage}
    *   object itself, so calls can be chained.
    */

		}, {
			key: 'params',
			value: function params(opt_params) {
				if (core.isDef(opt_params)) {
					if (opt_params instanceof MultiMap) {
						this.params_ = opt_params;
					} else {
						this.params_.values = opt_params;
					}
					return opt_params;
				}
				return this.params_;
			}

			/**
    * Fluent getter and setter for request url.
    * @param {string=} opt_url Request url to be set. If none is given,
    *   the current value of the url will be returned.
    * @return {!ClientMessage|string} Returns request url if no new value was given.
    *   Otherwise returns the {@link ClientMessage} object itself, so calls can be
    *   chained.
    * @chainable Chainable when used as setter.
    */

		}, {
			key: 'url',
			value: function url(opt_url) {
				if (core.isDef(opt_url)) {
					this.url_ = opt_url;
					return this;
				}
				return this.url_;
			}
		}]);
		return ClientRequest;
	}(ClientMessage);

	ClientRequest.DEFAULT_METHOD = 'GET';

	this.wedeploy.ClientRequest = ClientRequest;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var ClientMessage = this.wedeploy.ClientMessage;

	/**
  * Represents a client response object.
  * @extends {ClientMessage}
  */

	var ClientResponse = function (_ClientMessage) {
		babelHelpers.inherits(ClientResponse, _ClientMessage);

		function ClientResponse(clientRequest) {
			babelHelpers.classCallCheck(this, ClientResponse);

			var _this = babelHelpers.possibleConstructorReturn(this, (ClientResponse.__proto__ || Object.getPrototypeOf(ClientResponse)).call(this));

			if (!clientRequest) {
				throw new Error('Can\'t create response without request');
			}
			_this.clientRequest_ = clientRequest;
			return _this;
		}

		/**
   * Returns request that created this response.
   * @return {!ClientRequest}
   */


		babelHelpers.createClass(ClientResponse, [{
			key: 'request',
			value: function request() {
				return this.clientRequest_;
			}

			/**
    * Fluent getter and setter for response status code.
    * @param {number=} opt_statusCode Request status code to be set. If none is given,
    *   the current status code value will be returned.
    * @return {!ClientMessage|number} Returns response status code if no new value was
    *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
    *   be chained.
    * @chainable Chainable when used as setter.
    */

		}, {
			key: 'statusCode',
			value: function statusCode(opt_statusCode) {
				if (core.isDef(opt_statusCode)) {
					this.statusCode_ = opt_statusCode;
					return this;
				}
				return this.statusCode_;
			}

			/**
    * Fluent getter and setter for response status text.
    * @param {string=} opt_statusText Request status text to be set. If none is given,
    *   the current status text value will be returned.
    * @return {!ClientMessage|number} Returns response status text if no new value was
    *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
    *   be chained.
    * @chainable Chainable when used as setter.
    */

		}, {
			key: 'statusText',
			value: function statusText(opt_statusText) {
				if (core.isDef(opt_statusText)) {
					this.statusText_ = opt_statusText;
					return this;
				}
				return this.statusText_;
			}

			/**
    * Checks if response succeeded. Any status code 2xx or 3xx is considered valid.
    * @return {boolean}
    */

		}, {
			key: 'succeeded',
			value: function succeeded() {
				return this.statusCode() >= 200 && this.statusCode() <= 399;
			}
		}]);
		return ClientResponse;
	}(ClientMessage);

	this.wedeploy.ClientResponse = ClientResponse;
}).call(this);
'use strict';

/**
 * Provides a convenient interface for data transport.
 * @interface
 */

(function () {
	var Transport = function () {
		function Transport() {
			babelHelpers.classCallCheck(this, Transport);
		}

		babelHelpers.createClass(Transport, [{
			key: 'send',


			/**
    * Sends a message for the specified client.
    * @param {!ClientRequest} clientRequest
    * @return {!Promise} Deferred request.
    */
			value: function send() {}
		}]);
		return Transport;
	}();

	this.wedeploy.Transport = Transport;
}).call(this);
'use strict';

/**
 * Parses the given uri string into an object.
 * @param {*=} opt_uri Optional string URI to parse
 */

(function () {
	function parseFromAnchor(opt_uri) {
		var link = document.createElement('a');
		link.href = opt_uri;
		return {
			hash: link.hash,
			hostname: link.hostname,
			password: link.password,
			pathname: link.pathname[0] === '/' ? link.pathname : '/' + link.pathname,
			port: link.port,
			protocol: link.protocol,
			search: link.search,
			username: link.username
		};
	}

	this.wedeploy.parseFromAnchor = parseFromAnchor;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var parseFromAnchor = this.wedeploy.parseFromAnchor;

	/**
  * Parses the given uri string into an object. The URL function will be used
  * when present, otherwise we'll fall back to the anchor node element.
  * @param {*=} opt_uri Optional string URI to parse
  */

	function parse(opt_uri) {
		if (core.isFunction(URL) && URL.length) {
			return new URL(opt_uri);
		} else {
			return parseFromAnchor(opt_uri);
		}
	}

	this.wedeploy.parse = parse;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var string = this.wedeployNamed.metal.string;
	var parse = this.wedeploy.parse;
	var MultiMap = this.wedeployNamed.structs.MultiMap;


	var parseFn_ = parse;

	var Uri = function () {

		/**
   * This class contains setters and getters for the parts of the URI.
   * The following figure displays an example URIs and their component parts.
   *
   *                                  path
   *	                             
   *	  abc://example.com:123/path/data?key=value#fragid1
   *	                  
   * protocol  hostname  port            search    hash
   *          
   *                host
   *
   * @param {*=} opt_uri Optional string URI to parse
   * @constructor
   */
		function Uri() {
			var opt_uri = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
			babelHelpers.classCallCheck(this, Uri);

			this.url = Uri.parse(this.maybeAddProtocolAndHostname_(opt_uri));
		}

		/**
   * Adds parameters to uri from a <code>MultiMap</code> as source.
   * @param {MultiMap} multimap The <code>MultiMap</code> containing the
   *   parameters.
   * @protected
   * @chainable
   */


		babelHelpers.createClass(Uri, [{
			key: 'addParametersFromMultiMap',
			value: function addParametersFromMultiMap(multimap) {
				var _this = this;

				multimap.names().forEach(function (name) {
					multimap.getAll(name).forEach(function (value) {
						_this.addParameterValue(name, value);
					});
				});
				return this;
			}

			/**
    * Adds the value of the named query parameters.
    * @param {string} key The parameter to set.
    * @param {*} value The new value. Will be explicitly casted to String.
    * @chainable
    */

		}, {
			key: 'addParameterValue',
			value: function addParameterValue(name, value) {
				this.ensureQueryInitialized_();
				if (core.isDef(value)) {
					value = String(value);
				}
				this.query.add(name, value);
				return this;
			}

			/**
    * Adds the values of the named query parameter.
    * @param {string} key The parameter to set.
    * @param {*} value The new value.
    * @chainable
    */

		}, {
			key: 'addParameterValues',
			value: function addParameterValues(name, values) {
				var _this2 = this;

				values.forEach(function (value) {
					return _this2.addParameterValue(name, value);
				});
				return this;
			}

			/**
    * Ensures query internal map is initialized and synced with initial value
    * extracted from URI search part.
    * @protected
    */

		}, {
			key: 'ensureQueryInitialized_',
			value: function ensureQueryInitialized_() {
				var _this3 = this;

				if (this.query) {
					return;
				}
				this.query = new MultiMap();
				var search = this.url.search;
				if (search) {
					search.substring(1).split('&').forEach(function (param) {
						var _param$split = param.split('=');

						var _param$split2 = babelHelpers.slicedToArray(_param$split, 2);

						var key = _param$split2[0];
						var value = _param$split2[1];

						if (core.isDef(value)) {
							value = Uri.urlDecode(value);
						}
						_this3.addParameterValue(key, value);
					});
				}
			}

			/**
    * Gets the hash part of uri.
    * @return {string}
    */

		}, {
			key: 'getHash',
			value: function getHash() {
				return this.url.hash || '';
			}

			/**
    * Gets the host part of uri. E.g. <code>[hostname]:[port]</code>.
    * @return {string}
    */

		}, {
			key: 'getHost',
			value: function getHost() {
				var host = this.getHostname();
				if (host) {
					var port = this.getPort();
					if (port && port !== '80') {
						host += ':' + port;
					}
				}
				return host;
			}

			/**
    * Gets the hostname part of uri without protocol and port.
    * @return {string}
    */

		}, {
			key: 'getHostname',
			value: function getHostname() {
				var hostname = this.url.hostname;
				if (hostname === Uri.HOSTNAME_PLACEHOLDER) {
					return '';
				}
				return hostname;
			}

			/**
    * Gets the origin part of uri. E.g. <code>http://[hostname]:[port]</code>.
    * @return {string}
    */

		}, {
			key: 'getOrigin',
			value: function getOrigin() {
				var host = this.getHost();
				if (host) {
					return this.getProtocol() + '//' + host;
				}
				return '';
			}

			/**
    * Returns the first value for a given parameter or undefined if the given
    * parameter name does not appear in the query string.
    * @param {string} paramName Unescaped parameter name.
    * @return {string|undefined} The first value for a given parameter or
    *   undefined if the given parameter name does not appear in the query
    *   string.
    */

		}, {
			key: 'getParameterValue',
			value: function getParameterValue(name) {
				this.ensureQueryInitialized_();
				return this.query.get(name);
			}

			/**
    * Returns the value<b>s</b> for a given parameter as a list of decoded
    * query parameter values.
    * @param {string} name The parameter to get values for.
    * @return {!Array<?>} The values for a given parameter as a list of decoded
    *   query parameter values.
    */

		}, {
			key: 'getParameterValues',
			value: function getParameterValues(name) {
				this.ensureQueryInitialized_();
				return this.query.getAll(name);
			}

			/**
    * Returns the name<b>s</b> of the parameters.
    * @return {!Array<string>} The names for the parameters as a list of
    *   strings.
    */

		}, {
			key: 'getParameterNames',
			value: function getParameterNames() {
				this.ensureQueryInitialized_();
				return this.query.names();
			}

			/**
    * Gets the function currently being used to parse URIs.
    * @return {!function()}
    */

		}, {
			key: 'getPathname',


			/**
    * Gets the pathname part of uri.
    * @return {string}
    */
			value: function getPathname() {
				return this.url.pathname;
			}

			/**
    * Gets the port number part of uri as string.
    * @return {string}
    */

		}, {
			key: 'getPort',
			value: function getPort() {
				return this.url.port;
			}

			/**
    * Gets the protocol part of uri. E.g. <code>http:</code>.
    * @return {string}
    */

		}, {
			key: 'getProtocol',
			value: function getProtocol() {
				return this.url.protocol;
			}

			/**
    * Gets the search part of uri. Search value is retrieved from query
    * parameters.
    * @return {string}
    */

		}, {
			key: 'getSearch',
			value: function getSearch() {
				var _this4 = this;

				var search = '';
				var querystring = '';
				this.getParameterNames().forEach(function (name) {
					_this4.getParameterValues(name).forEach(function (value) {
						querystring += name;
						if (core.isDef(value)) {
							querystring += '=' + encodeURIComponent(value);
						}
						querystring += '&';
					});
				});
				querystring = querystring.slice(0, -1);
				if (querystring) {
					search += '?' + querystring;
				}
				return search;
			}

			/**
    * Checks if uri contains the parameter.
    * @param {string} name
    * @return {boolean}
    */

		}, {
			key: 'hasParameter',
			value: function hasParameter(name) {
				this.ensureQueryInitialized_();
				return this.query.contains(name);
			}

			/**
    * Makes this URL unique by adding a random param to it. Useful for avoiding
    * cache.
    */

		}, {
			key: 'makeUnique',
			value: function makeUnique() {
				this.setParameterValue(Uri.RANDOM_PARAM, string.getRandomString());
				return this;
			}

			/**
    * Maybe adds protocol and a hostname placeholder on a parial URI if needed.
    * Relevent for compatibility with <code>URL</code> native object.
    * @param {string=} opt_uri
    * @return {string} URI with protocol and hostname placeholder.
    */

		}, {
			key: 'maybeAddProtocolAndHostname_',
			value: function maybeAddProtocolAndHostname_(opt_uri) {
				var url = opt_uri;
				if (opt_uri.indexOf('://') === -1 && opt_uri.indexOf('javascript:') !== 0) {
					// jshint ignore:line

					url = Uri.DEFAULT_PROTOCOL;
					if (opt_uri[0] !== '/' || opt_uri[1] !== '/') {
						url += '//';
					}

					switch (opt_uri.charAt(0)) {
						case '.':
						case '?':
						case '#':
							url += Uri.HOSTNAME_PLACEHOLDER;
							url += '/';
							url += opt_uri;
							break;
						case '':
						case '/':
							if (opt_uri[1] !== '/') {
								url += Uri.HOSTNAME_PLACEHOLDER;
							}
							url += opt_uri;
							break;
						default:
							url += opt_uri;
					}
				}
				return url;
			}

			/**
    * Normalizes the parsed object to be in the expected standard.
    * @param {!Object}
    */

		}, {
			key: 'removeParameter',


			/**
    * Removes the named query parameter.
    * @param {string} name The parameter to remove.
    * @chainable
    */
			value: function removeParameter(name) {
				this.ensureQueryInitialized_();
				this.query.remove(name);
				return this;
			}

			/**
    * Removes uniqueness parameter of the uri.
    * @chainable
    */

		}, {
			key: 'removeUnique',
			value: function removeUnique() {
				this.removeParameter(Uri.RANDOM_PARAM);
				return this;
			}

			/**
    * Sets the hash.
    * @param {string} hash
    * @chainable
    */

		}, {
			key: 'setHash',
			value: function setHash(hash) {
				this.url.hash = hash;
				return this;
			}

			/**
    * Sets the hostname.
    * @param {string} hostname
    * @chainable
    */

		}, {
			key: 'setHostname',
			value: function setHostname(hostname) {
				this.url.hostname = hostname;
				return this;
			}

			/**
    * Sets the value of the named query parameters, clearing previous values
    * for that key.
    * @param {string} key The parameter to set.
    * @param {*} value The new value.
    * @chainable
    */

		}, {
			key: 'setParameterValue',
			value: function setParameterValue(name, value) {
				this.removeParameter(name);
				this.addParameterValue(name, value);
				return this;
			}

			/**
    * Sets the values of the named query parameters, clearing previous values
    * for that key.
    * @param {string} key The parameter to set.
    * @param {*} value The new value.
    * @chainable
    */

		}, {
			key: 'setParameterValues',
			value: function setParameterValues(name, values) {
				var _this5 = this;

				this.removeParameter(name);
				values.forEach(function (value) {
					return _this5.addParameterValue(name, value);
				});
				return this;
			}

			/**
    * Sets the pathname.
    * @param {string} pathname
    * @chainable
    */

		}, {
			key: 'setPathname',
			value: function setPathname(pathname) {
				this.url.pathname = pathname;
				return this;
			}

			/**
    * Sets the port number.
    * @param {*} port Port number.
    * @chainable
    */

		}, {
			key: 'setPort',
			value: function setPort(port) {
				this.url.port = port;
				return this;
			}

			/**
    * Sets the function that will be used for parsing the original string uri
    * into an object.
    * @param {!function()} parseFn
    */

		}, {
			key: 'setProtocol',


			/**
    * Sets the protocol. If missing <code>http:</code> is used as default.
    * @param {string} protocol
    * @chainable
    */
			value: function setProtocol(protocol) {
				this.url.protocol = protocol;
				if (this.url.protocol[this.url.protocol.length - 1] !== ':') {
					this.url.protocol += ':';
				}
				return this;
			}

			/**
    * @return {string} The string form of the url.
    * @override
    */

		}, {
			key: 'toString',
			value: function toString() {
				var href = '';
				var host = this.getHost();
				if (host) {
					href += this.getProtocol() + '//';
				}
				href += host + this.getPathname() + this.getSearch() + this.getHash();
				return href;
			}

			/**
    * Joins the given paths.
    * @param {string} basePath
    * @param {...string} ...paths Any number of paths to be joined with the base url.
    * @static
    */

		}], [{
			key: 'getParseFn',
			value: function getParseFn() {
				return parseFn_;
			}
		}, {
			key: 'normalizeObject',
			value: function normalizeObject(parsed) {
				var length = parsed.pathname ? parsed.pathname.length : 0;
				if (length > 1 && parsed.pathname[length - 1] === '/') {
					parsed.pathname = parsed.pathname.substr(0, length - 1);
				}
				return parsed;
			}

			/**
    * Parses the given uri string into an object.
    * @param {*=} opt_uri Optional string URI to parse
    */

		}, {
			key: 'parse',
			value: function parse(opt_uri) {
				return Uri.normalizeObject(parseFn_(opt_uri));
			}
		}, {
			key: 'setParseFn',
			value: function setParseFn(parseFn) {
				parseFn_ = parseFn;
			}
		}, {
			key: 'joinPaths',
			value: function joinPaths(basePath) {
				for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					paths[_key - 1] = arguments[_key];
				}

				if (basePath.charAt(basePath.length - 1) === '/') {
					basePath = basePath.substring(0, basePath.length - 1);
				}
				paths = paths.map(function (path) {
					return path.charAt(0) === '/' ? path.substring(1) : path;
				});
				return [basePath].concat(paths).join('/').replace(/\/$/, '');
			}

			/**
    * URL-decodes the string. We need to specially handle '+'s because
    * the javascript library doesn't convert them to spaces.
    * @param {string} str The string to url decode.
    * @return {string} The decoded {@code str}.
    */

		}, {
			key: 'urlDecode',
			value: function urlDecode(str) {
				return decodeURIComponent(str.replace(/\+/g, ' '));
			}
		}]);
		return Uri;
	}();

	/**
  * Default protocol value.
  * @type {string}
  * @default http:
  * @static
  */


	Uri.DEFAULT_PROTOCOL = 'http:';

	/**
  * Hostname placeholder. Relevant to internal usage only.
  * @type {string}
  * @static
  */
	Uri.HOSTNAME_PLACEHOLDER = 'hostname' + Date.now();

	/**
  * Name used by the param generated by `makeUnique`.
  * @type {string}
  * @static
  */
	Uri.RANDOM_PARAM = 'zx';

	this.wedeploy.Uri = Uri;
}).call(this);
/*!
 * Promises polyfill from Google's Closure Library.
 *
 *      Copyright 2013 The Closure Library Authors. All Rights Reserved.
 *
 * NOTE(eduardo): Promise support is not ready on all supported browsers,
 * therefore core.js is temporarily using Google's promises as polyfill. It
 * supports cancellable promises and has clean and fast implementation.
 */

'use strict';

(function () {
  var core = this.wedeployNamed.metal.core;
  var async = this.wedeployNamed.metal.async;

  /**
   * Provides a more strict interface for Thenables in terms of
   * http://promisesaplus.com for interop with {@see CancellablePromise}.
   *
   * @interface
   * @extends {IThenable.<TYPE>}
   * @template TYPE
   */

  var Thenable = function Thenable() {};

  /**
   * Adds callbacks that will operate on the result of the Thenable, returning a
   * new child Promise.
   *
   * If the Thenable is fulfilled, the {@code onFulfilled} callback will be
   * invoked with the fulfillment value as argument, and the child Promise will
   * be fulfilled with the return value of the callback. If the callback throws
   * an exception, the child Promise will be rejected with the thrown value
   * instead.
   *
   * If the Thenable is rejected, the {@code onRejected} callback will be invoked
   * with the rejection reason as argument, and the child Promise will be rejected
   * with the return value of the callback or thrown value.
   *
   * @param {?(function(this:THIS, TYPE):
   *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A
   *     function that will be invoked with the fulfillment value if the Promise
   *     is fullfilled.
   * @param {?(function(*): *)=} opt_onRejected A function that will be invoked
   *     with the rejection reason if the Promise is rejected.
   * @param {THIS=} opt_context An optional context object that will be the
   *     execution context for the callbacks. By default, functions are executed
   *     with the default this.
   * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the
   *     result of the fulfillment or rejection callback.
   * @template RESULT,THIS
   */
  Thenable.prototype.then = function () {};

  /**
   * An expando property to indicate that an object implements
   * {@code Thenable}.
   *
   * {@see addImplementation}.
   *
   * @const
   */
  Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';

  /**
   * Marks a given class (constructor) as an implementation of Thenable, so
   * that we can query that fact at runtime. The class must have already
   * implemented the interface.
   * Exports a 'then' method on the constructor prototype, so that the objects
   * also implement the extern {@see Thenable} interface for interop with
   * other Promise implementations.
   * @param {function(new:Thenable,...[?])} ctor The class constructor. The
   *     corresponding class must have already implemented the interface.
   */
  Thenable.addImplementation = function (ctor) {
    ctor.prototype.then = ctor.prototype.then;
    ctor.prototype.$goog_Thenable = true;
  };

  /**
   * @param {*} object
   * @return {boolean} Whether a given instance implements {@code Thenable}.
   *     The class/superclass of the instance must call {@code addImplementation}.
   */
  Thenable.isImplementedBy = function (object) {
    if (!object) {
      return false;
    }
    try {
      return !!object.$goog_Thenable;
    } catch (e) {
      // Property access seems to be forbidden.
      return false;
    }
  };

  /**
   * Like bind(), except that a 'this object' is not required. Useful when the
   * target function is already bound.
   *
   * Usage:
   * var g = partial(f, arg1, arg2);
   * g(arg3, arg4);
   *
   * @param {Function} fn A function to partially apply.
   * @param {...*} var_args Additional arguments that are partially applied to fn.
   * @return {!Function} A partially-applied form of the function bind() was
   *     invoked as a method of.
   */
  var partial = function partial(fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      // Clone the array (with slice()) and append additional arguments
      // to the existing arguments.
      var newArgs = args.slice();
      newArgs.push.apply(newArgs, arguments);
      return fn.apply(this, newArgs);
    };
  };

  /**
   * Promises provide a result that may be resolved asynchronously. A Promise may
   * be resolved by being fulfilled or rejected with a value, which will be known
   * as the fulfillment value or the rejection reason. Whether fulfilled or
   * rejected, the Promise result is immutable once it is set.
   *
   * Promises may represent results of any type, including undefined. Rejection
   * reasons are typically Errors, but may also be of any type. Closure Promises
   * allow for optional type annotations that enforce that fulfillment values are
   * of the appropriate types at compile time.
   *
   * The result of a Promise is accessible by calling {@code then} and registering
   * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise
   * resolves, the relevant callbacks are invoked with the fulfillment value or
   * rejection reason as argument. Callbacks are always invoked in the order they
   * were registered, even when additional {@code then} calls are made from inside
   * another callback. A callback is always run asynchronously sometime after the
   * scope containing the registering {@code then} invocation has returned.
   *
   * If a Promise is resolved with another Promise, the first Promise will block
   * until the second is resolved, and then assumes the same result as the second
   * Promise. This allows Promises to depend on the results of other Promises,
   * linking together multiple asynchronous operations.
   *
   * This implementation is compatible with the Promises/A+ specification and
   * passes that specification's conformance test suite. A Closure Promise may be
   * resolved with a Promise instance (or sufficiently compatible Promise-like
   * object) created by other Promise implementations. From the specification,
   * Promise-like objects are known as "Thenables".
   *
   * @see http://promisesaplus.com/
   *
   * @param {function(
   *             this:RESOLVER_CONTEXT,
   *             function((TYPE|IThenable.<TYPE>|Thenable)),
   *             function(*)): void} resolver
   *     Initialization function that is invoked immediately with {@code resolve}
   *     and {@code reject} functions as arguments. The Promise is resolved or
   *     rejected with the first argument passed to either function.
   * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the
   *     resolver function. If unspecified, the resolver function will be executed
   *     in the default scope.
   * @constructor
   * @struct
   * @final
   * @implements {Thenable.<TYPE>}
   * @template TYPE,RESOLVER_CONTEXT
   */
  var CancellablePromise = function CancellablePromise(resolver, opt_context) {
    /**
     * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
     * BLOCKED.
     * @private {CancellablePromise.State_}
     */
    this.state_ = CancellablePromise.State_.PENDING;

    /**
     * The resolved result of the Promise. Immutable once set with either a
     * fulfillment value or rejection reason.
     * @private {*}
     */
    this.result_ = undefined;

    /**
     * For Promises created by calling {@code then()}, the originating parent.
     * @private {CancellablePromise}
     */
    this.parent_ = null;

    /**
     * The list of {@code onFulfilled} and {@code onRejected} callbacks added to
     * this Promise by calls to {@code then()}.
     * @private {Array.<CancellablePromise.CallbackEntry_>}
     */
    this.callbackEntries_ = null;

    /**
     * Whether the Promise is in the queue of Promises to execute.
     * @private {boolean}
     */
    this.executing_ = false;

    if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
      /**
       * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater
       * than 0 milliseconds. The ID is set when the Promise is rejected, and
       * cleared only if an {@code onRejected} callback is invoked for the
       * Promise (or one of its descendants) before the delay is exceeded.
       *
       * If the rejection is not handled before the timeout completes, the
       * rejection reason is passed to the unhandled rejection handler.
       * @private {number}
       */
      this.unhandledRejectionId_ = 0;
    } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
      /**
       * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a
       * boolean that is set if the Promise is rejected, and reset to false if an
       * {@code onRejected} callback is invoked for the Promise (or one of its
       * descendants). If the rejection is not handled before the next timestep,
       * the rejection reason is passed to the unhandled rejection handler.
       * @private {boolean}
       */
      this.hadUnhandledRejection_ = false;
    }

    try {
      var self = this;
      resolver.call(opt_context, function (value) {
        self.resolve_(CancellablePromise.State_.FULFILLED, value);
      }, function (reason) {
        self.resolve_(CancellablePromise.State_.REJECTED, reason);
      });
    } catch (e) {
      this.resolve_(CancellablePromise.State_.REJECTED, e);
    }
  };

  /**
   * The delay in milliseconds before a rejected Promise's reason is passed to
   * the rejection handler. By default, the rejection handler rethrows the
   * rejection reason so that it appears in the developer console or
   * {@code window.onerror} handler.
   * Rejections are rethrown as quickly as possible by default. A negative value
   * disables rejection handling entirely.
   * @type {number}
   */
  CancellablePromise.UNHANDLED_REJECTION_DELAY = 0;

  /**
   * The possible internal states for a Promise. These states are not directly
   * observable to external callers.
   * @enum {number}
   * @private
   */
  CancellablePromise.State_ = {
    /** The Promise is waiting for resolution. */
    PENDING: 0,

    /** The Promise is blocked waiting for the result of another Thenable. */
    BLOCKED: 1,

    /** The Promise has been resolved with a fulfillment value. */
    FULFILLED: 2,

    /** The Promise has been resolved with a rejection reason. */
    REJECTED: 3
  };

  /**
   * Typedef for entries in the callback chain. Each call to {@code then},
   * {@code thenCatch}, or {@code thenAlways} creates an entry containing the
   * functions that may be invoked once the Promise is resolved.
   *
   * @typedef {{
   *   child: CancellablePromise,
   *   onFulfilled: function(*),
   *   onRejected: function(*)
   * }}
   * @private
   */
  CancellablePromise.CallbackEntry_ = null;

  /**
   * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value
   * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved
   *     with the given value.
   * @template TYPE
   */
  CancellablePromise.resolve = function (opt_value) {
    return new CancellablePromise(function (resolve) {
      resolve(opt_value);
    });
  };

  /**
   * @param {*=} opt_reason
   * @return {!CancellablePromise} A new Promise that is immediately rejected with the
   *     given reason.
   */
  CancellablePromise.reject = function (opt_reason) {
    return new CancellablePromise(function (resolve, reject) {
      reject(opt_reason);
    });
  };

  /**
   * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
   * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the
   *     first Promise (or Promise-like) input to complete.
   * @template TYPE
   */
  CancellablePromise.race = function (promises) {
    return new CancellablePromise(function (resolve, reject) {
      if (!promises.length) {
        resolve(undefined);
      }
      for (var i = 0, promise; promise = promises[i]; i++) {
        promise.then(resolve, reject);
      }
    });
  };

  /**
   * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
   * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of
   *     every fulfilled value once every input Promise (or Promise-like) is
   *     successfully fulfilled, or is rejected by the first rejection result.
   * @template TYPE
   */
  CancellablePromise.all = function (promises) {
    return new CancellablePromise(function (resolve, reject) {
      var toFulfill = promises.length;
      var values = [];

      if (!toFulfill) {
        resolve(values);
        return;
      }

      var onFulfill = function onFulfill(index, value) {
        toFulfill--;
        values[index] = value;
        if (toFulfill === 0) {
          resolve(values);
        }
      };

      var onReject = function onReject(reason) {
        reject(reason);
      };

      for (var i = 0, promise; promise = promises[i]; i++) {
        promise.then(partial(onFulfill, i), onReject);
      }
    });
  };

  /**
   * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
   * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of
   *     the first input to be fulfilled, or is rejected with a list of every
   *     rejection reason if all inputs are rejected.
   * @template TYPE
   */
  CancellablePromise.firstFulfilled = function (promises) {
    return new CancellablePromise(function (resolve, reject) {
      var toReject = promises.length;
      var reasons = [];

      if (!toReject) {
        resolve(undefined);
        return;
      }

      var onFulfill = function onFulfill(value) {
        resolve(value);
      };

      var onReject = function onReject(index, reason) {
        toReject--;
        reasons[index] = reason;
        if (toReject === 0) {
          reject(reasons);
        }
      };

      for (var i = 0, promise; promise = promises[i]; i++) {
        promise.then(onFulfill, partial(onReject, i));
      }
    });
  };

  /**
   * Adds callbacks that will operate on the result of the Promise, returning a
   * new child Promise.
   *
   * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked
   * with the fulfillment value as argument, and the child Promise will be
   * fulfilled with the return value of the callback. If the callback throws an
   * exception, the child Promise will be rejected with the thrown value instead.
   *
   * If the Promise is rejected, the {@code onRejected} callback will be invoked
   * with the rejection reason as argument, and the child Promise will be rejected
   * with the return value (or thrown value) of the callback.
   *
   * @override
   */
  CancellablePromise.prototype.then = function (opt_onFulfilled, opt_onRejected, opt_context) {
    return this.addChildPromise_(core.isFunction(opt_onFulfilled) ? opt_onFulfilled : null, core.isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);
  };
  Thenable.addImplementation(CancellablePromise);

  /**
   * Adds a callback that will be invoked whether the Promise is fulfilled or
   * rejected. The callback receives no argument, and no new child Promise is
   * created. This is useful for ensuring that cleanup takes place after certain
   * asynchronous operations. Callbacks added with {@code thenAlways} will be
   * executed in the same order with other calls to {@code then},
   * {@code thenAlways}, or {@code thenCatch}.
   *
   * Since it does not produce a new child Promise, cancellation propagation is
   * not prevented by adding callbacks with {@code thenAlways}. A Promise that has
   * a cleanup handler added with {@code thenAlways} will be canceled if all of
   * its children created by {@code then} (or {@code thenCatch}) are canceled.
   *
   * @param {function(this:THIS): void} onResolved A function that will be invoked
   *     when the Promise is resolved.
   * @param {THIS=} opt_context An optional context object that will be the
   *     execution context for the callbacks. By default, functions are executed
   *     in the global scope.
   * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.
   * @template THIS
   */
  CancellablePromise.prototype.thenAlways = function (onResolved, opt_context) {
    var callback = function callback() {
      try {
        // Ensure that no arguments are passed to onResolved.
        onResolved.call(opt_context);
      } catch (err) {
        CancellablePromise.handleRejection_.call(null, err);
      }
    };

    this.addCallbackEntry_({
      child: null,
      onRejected: callback,
      onFulfilled: callback
    });
    return this;
  };

  /**
   * Adds a callback that will be invoked only if the Promise is rejected. This
   * is equivalent to {@code then(null, onRejected)}.
   *
   * @param {!function(this:THIS, *): *} onRejected A function that will be
   *     invoked with the rejection reason if the Promise is rejected.
   * @param {THIS=} opt_context An optional context object that will be the
   *     execution context for the callbacks. By default, functions are executed
   *     in the global scope.
   * @return {!CancellablePromise} A new Promise that will receive the result of the
   *     callback.
   * @template THIS
   */
  CancellablePromise.prototype.thenCatch = function (onRejected, opt_context) {
    return this.addChildPromise_(null, onRejected, opt_context);
  };

  /**
   * Alias of {@link CancellablePromise.prototype.thenCatch}
   */
  CancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;

  /**
   * Cancels the Promise if it is still pending by rejecting it with a cancel
   * Error. No action is performed if the Promise is already resolved.
   *
   * All child Promises of the canceled Promise will be rejected with the same
   * cancel error, as with normal Promise rejection. If the Promise to be canceled
   * is the only child of a pending Promise, the parent Promise will also be
   * canceled. Cancellation may propagate upward through multiple generations.
   *
   * @param {string=} opt_message An optional debugging message for describing the
   *     cancellation reason.
   */
  CancellablePromise.prototype.cancel = function (opt_message) {
    if (this.state_ === CancellablePromise.State_.PENDING) {
      async.run(function () {
        var err = new CancellablePromise.CancellationError(opt_message);
        err.IS_CANCELLATION_ERROR = true;
        this.cancelInternal_(err);
      }, this);
    }
  };

  /**
   * Cancels this Promise with the given error.
   *
   * @param {!Error} err The cancellation error.
   * @private
   */
  CancellablePromise.prototype.cancelInternal_ = function (err) {
    if (this.state_ === CancellablePromise.State_.PENDING) {
      if (this.parent_) {
        // Cancel the Promise and remove it from the parent's child list.
        this.parent_.cancelChild_(this, err);
      } else {
        this.resolve_(CancellablePromise.State_.REJECTED, err);
      }
    }
  };

  /**
   * Cancels a child Promise from the list of callback entries. If the Promise has
   * not already been resolved, reject it with a cancel error. If there are no
   * other children in the list of callback entries, propagate the cancellation
   * by canceling this Promise as well.
   *
   * @param {!CancellablePromise} childPromise The Promise to cancel.
   * @param {!Error} err The cancel error to use for rejecting the Promise.
   * @private
   */
  CancellablePromise.prototype.cancelChild_ = function (childPromise, err) {
    if (!this.callbackEntries_) {
      return;
    }
    var childCount = 0;
    var childIndex = -1;

    // Find the callback entry for the childPromise, and count whether there are
    // additional child Promises.
    for (var i = 0, entry; entry = this.callbackEntries_[i]; i++) {
      var child = entry.child;
      if (child) {
        childCount++;
        if (child === childPromise) {
          childIndex = i;
        }
        if (childIndex >= 0 && childCount > 1) {
          break;
        }
      }
    }

    // If the child Promise was the only child, cancel this Promise as well.
    // Otherwise, reject only the child Promise with the cancel error.
    if (childIndex >= 0) {
      if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {
        this.cancelInternal_(err);
      } else {
        var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];
        this.executeCallback_(callbackEntry, CancellablePromise.State_.REJECTED, err);
      }
    }
  };

  /**
   * Adds a callback entry to the current Promise, and schedules callback
   * execution if the Promise has already been resolved.
   *
   * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing
   *     {@code onFulfilled} and {@code onRejected} callbacks to execute after
   *     the Promise is resolved.
   * @private
   */
  CancellablePromise.prototype.addCallbackEntry_ = function (callbackEntry) {
    if ((!this.callbackEntries_ || !this.callbackEntries_.length) && (this.state_ === CancellablePromise.State_.FULFILLED || this.state_ === CancellablePromise.State_.REJECTED)) {
      this.scheduleCallbacks_();
    }
    if (!this.callbackEntries_) {
      this.callbackEntries_ = [];
    }
    this.callbackEntries_.push(callbackEntry);
  };

  /**
   * Creates a child Promise and adds it to the callback entry list. The result of
   * the child Promise is determined by the state of the parent Promise and the
   * result of the {@code onFulfilled} or {@code onRejected} callbacks as
   * specified in the Promise resolution procedure.
   *
   * @see http://promisesaplus.com/#the__method
   *
   * @param {?function(this:THIS, TYPE):
   *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that
   *     will be invoked if the Promise is fullfilled, or null.
   * @param {?function(this:THIS, *): *} onRejected A callback that will be
   *     invoked if the Promise is rejected, or null.
   * @param {THIS=} opt_context An optional execution context for the callbacks.
   *     in the default calling context.
   * @return {!CancellablePromise} The child Promise.
   * @template RESULT,THIS
   * @private
   */
  CancellablePromise.prototype.addChildPromise_ = function (onFulfilled, onRejected, opt_context) {

    var callbackEntry = {
      child: null,
      onFulfilled: null,
      onRejected: null
    };

    callbackEntry.child = new CancellablePromise(function (resolve, reject) {
      // Invoke onFulfilled, or resolve with the parent's value if absent.
      callbackEntry.onFulfilled = onFulfilled ? function (value) {
        try {
          var result = onFulfilled.call(opt_context, value);
          resolve(result);
        } catch (err) {
          reject(err);
        }
      } : resolve;

      // Invoke onRejected, or reject with the parent's reason if absent.
      callbackEntry.onRejected = onRejected ? function (reason) {
        try {
          var result = onRejected.call(opt_context, reason);
          if (!core.isDef(result) && reason.IS_CANCELLATION_ERROR) {
            // Propagate cancellation to children if no other result is returned.
            reject(reason);
          } else {
            resolve(result);
          }
        } catch (err) {
          reject(err);
        }
      } : reject;
    });

    callbackEntry.child.parent_ = this;
    this.addCallbackEntry_(
    /** @type {CancellablePromise.CallbackEntry_} */callbackEntry);
    return callbackEntry.child;
  };

  /**
   * Unblocks the Promise and fulfills it with the given value.
   *
   * @param {TYPE} value
   * @private
   */
  CancellablePromise.prototype.unblockAndFulfill_ = function (value) {
    if (this.state_ !== CancellablePromise.State_.BLOCKED) {
      throw new Error('CancellablePromise is not blocked.');
    }
    this.state_ = CancellablePromise.State_.PENDING;
    this.resolve_(CancellablePromise.State_.FULFILLED, value);
  };

  /**
   * Unblocks the Promise and rejects it with the given rejection reason.
   *
   * @param {*} reason
   * @private
   */
  CancellablePromise.prototype.unblockAndReject_ = function (reason) {
    if (this.state_ !== CancellablePromise.State_.BLOCKED) {
      throw new Error('CancellablePromise is not blocked.');
    }
    this.state_ = CancellablePromise.State_.PENDING;
    this.resolve_(CancellablePromise.State_.REJECTED, reason);
  };

  /**
   * Attempts to resolve a Promise with a given resolution state and value. This
   * is a no-op if the given Promise has already been resolved.
   *
   * If the given result is a Thenable (such as another Promise), the Promise will
   * be resolved with the same state and result as the Thenable once it is itself
   * resolved.
   *
   * If the given result is not a Thenable, the Promise will be fulfilled or
   * rejected with that result based on the given state.
   *
   * @see http://promisesaplus.com/#the_promise_resolution_procedure
   *
   * @param {CancellablePromise.State_} state
   * @param {*} x The result to apply to the Promise.
   * @private
   */
  CancellablePromise.prototype.resolve_ = function (state, x) {
    if (this.state_ !== CancellablePromise.State_.PENDING) {
      return;
    }

    if (this === x) {
      state = CancellablePromise.State_.REJECTED;
      x = new TypeError('CancellablePromise cannot resolve to itself');
    } else if (Thenable.isImplementedBy(x)) {
      x = /** @type {!Thenable} */x;
      this.state_ = CancellablePromise.State_.BLOCKED;
      x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);
      return;
    } else if (core.isObject(x)) {
      try {
        var then = x.then;
        if (core.isFunction(then)) {
          this.tryThen_(x, then);
          return;
        }
      } catch (e) {
        state = CancellablePromise.State_.REJECTED;
        x = e;
      }
    }

    this.result_ = x;
    this.state_ = state;
    this.scheduleCallbacks_();

    if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {
      CancellablePromise.addUnhandledRejection_(this, x);
    }
  };

  /**
   * Attempts to call the {@code then} method on an object in the hopes that it is
   * a Promise-compatible instance. This allows interoperation between different
   * Promise implementations, however a non-compliant object may cause a Promise
   * to hang indefinitely. If the {@code then} method throws an exception, the
   * dependent Promise will be rejected with the thrown value.
   *
   * @see http://promisesaplus.com/#point-70
   *
   * @param {Thenable} thenable An object with a {@code then} method that may be
   *     compatible with the Promise/A+ specification.
   * @param {!Function} then The {@code then} method of the Thenable object.
   * @private
   */
  CancellablePromise.prototype.tryThen_ = function (thenable, then) {
    this.state_ = CancellablePromise.State_.BLOCKED;
    var promise = this;
    var called = false;

    var resolve = function resolve(value) {
      if (!called) {
        called = true;
        promise.unblockAndFulfill_(value);
      }
    };

    var reject = function reject(reason) {
      if (!called) {
        called = true;
        promise.unblockAndReject_(reason);
      }
    };

    try {
      then.call(thenable, resolve, reject);
    } catch (e) {
      reject(e);
    }
  };

  /**
   * Executes the pending callbacks of a resolved Promise after a timeout.
   *
   * Section 2.2.4 of the Promises/A+ specification requires that Promise
   * callbacks must only be invoked from a call stack that only contains Promise
   * implementation code, which we accomplish by invoking callback execution after
   * a timeout. If {@code startExecution_} is called multiple times for the same
   * Promise, the callback chain will be evaluated only once. Additional callbacks
   * may be added during the evaluation phase, and will be executed in the same
   * event loop.
   *
   * All Promises added to the waiting list during the same browser event loop
   * will be executed in one batch to avoid using a separate timeout per Promise.
   *
   * @private
   */
  CancellablePromise.prototype.scheduleCallbacks_ = function () {
    if (!this.executing_) {
      this.executing_ = true;
      async.run(this.executeCallbacks_, this);
    }
  };

  /**
   * Executes all pending callbacks for this Promise.
   *
   * @private
   */
  CancellablePromise.prototype.executeCallbacks_ = function () {
    while (this.callbackEntries_ && this.callbackEntries_.length) {
      var entries = this.callbackEntries_;
      this.callbackEntries_ = [];

      for (var i = 0; i < entries.length; i++) {
        this.executeCallback_(entries[i], this.state_, this.result_);
      }
    }
    this.executing_ = false;
  };

  /**
   * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}
   * or {@code onRejected} callback based on the resolved state of the Promise.
   *
   * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the
   *     onFulfilled and/or onRejected callbacks for this step.
   * @param {CancellablePromise.State_} state The resolution status of the Promise,
   *     either FULFILLED or REJECTED.
   * @param {*} result The resolved result of the Promise.
   * @private
   */
  CancellablePromise.prototype.executeCallback_ = function (callbackEntry, state, result) {
    if (state === CancellablePromise.State_.FULFILLED) {
      callbackEntry.onFulfilled(result);
    } else {
      this.removeUnhandledRejection_();
      callbackEntry.onRejected(result);
    }
  };

  /**
   * Marks this rejected Promise as having being handled. Also marks any parent
   * Promises in the rejected state as handled. The rejection handler will no
   * longer be invoked for this Promise (if it has not been called already).
   *
   * @private
   */
  CancellablePromise.prototype.removeUnhandledRejection_ = function () {
    var p;
    if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
      for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {
        clearTimeout(p.unhandledRejectionId_);
        p.unhandledRejectionId_ = 0;
      }
    } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
      for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
        p.hadUnhandledRejection_ = false;
      }
    }
  };

  /**
   * Marks this rejected Promise as unhandled. If no {@code onRejected} callback
   * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}
   * expires, the reason will be passed to the unhandled rejection handler. The
   * handler typically rethrows the rejection reason so that it becomes visible in
   * the developer console.
   *
   * @param {!CancellablePromise} promise The rejected Promise.
   * @param {*} reason The Promise rejection reason.
   * @private
   */
  CancellablePromise.addUnhandledRejection_ = function (promise, reason) {
    if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
      promise.unhandledRejectionId_ = setTimeout(function () {
        CancellablePromise.handleRejection_.call(null, reason);
      }, CancellablePromise.UNHANDLED_REJECTION_DELAY);
    } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
      promise.hadUnhandledRejection_ = true;
      async.run(function () {
        if (promise.hadUnhandledRejection_) {
          CancellablePromise.handleRejection_.call(null, reason);
        }
      });
    }
  };

  /**
   * A method that is invoked with the rejection reasons for Promises that are
   * rejected but have no {@code onRejected} callbacks registered yet.
   * @type {function(*)}
   * @private
   */
  CancellablePromise.handleRejection_ = async.throwException;

  /**
   * Sets a handler that will be called with reasons from unhandled rejected
   * Promises. If the rejected Promise (or one of its descendants) has an
   * {@code onRejected} callback registered, the rejection will be considered
   * handled, and the rejection handler will not be called.
   *
   * By default, unhandled rejections are rethrown so that the error may be
   * captured by the developer console or a {@code window.onerror} handler.
   *
   * @param {function(*)} handler A function that will be called with reasons from
   *     rejected Promises. Defaults to {@code async.throwException}.
   */
  CancellablePromise.setUnhandledRejectionHandler = function (handler) {
    CancellablePromise.handleRejection_ = handler;
  };

  /**
   * Error used as a rejection reason for canceled Promises.
   *
   * @param {string=} opt_message
   * @constructor
   * @extends {Error}
   * @final
   */
  CancellablePromise.CancellationError = function (_Error) {
    babelHelpers.inherits(_class, _Error);

    function _class(opt_message) {
      babelHelpers.classCallCheck(this, _class);

      var _this = babelHelpers.possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, opt_message));

      if (opt_message) {
        _this.message = opt_message;
      }
      return _this;
    }

    return _class;
  }(Error);

  /** @override */
  CancellablePromise.CancellationError.prototype.name = 'cancel';

  this.wedeployNamed.Promise = this.wedeployNamed.Promise || {};
  this.wedeployNamed.Promise.CancellablePromise = CancellablePromise;
  this.wedeploy.Promise = CancellablePromise;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var Uri = this.wedeploy.Uri;
	var Promise = this.wedeployNamed.Promise.CancellablePromise;

	var Ajax = function () {
		function Ajax() {
			babelHelpers.classCallCheck(this, Ajax);
		}

		babelHelpers.createClass(Ajax, null, [{
			key: 'parseResponseHeaders',


			/**
    * XmlHttpRequest's getAllResponseHeaders() method returns a string of
    * response headers according to the format described on the spec:
    * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}.
    * This method parses that string into a user-friendly name/value pair
    * object.
    * @param {string} allHeaders All headers as string.
    * @return {!Array.<Object<string, string>>}
    */
			value: function parseResponseHeaders(allHeaders) {
				var headers = [];
				if (!allHeaders) {
					return headers;
				}
				var pairs = allHeaders.split('\r\n');
				for (var i = 0; i < pairs.length; i++) {
					var index = pairs[i].indexOf(': ');
					if (index > 0) {
						var name = pairs[i].substring(0, index);
						var value = pairs[i].substring(index + 2);
						headers.push({
							name: name,
							value: value
						});
					}
				}
				return headers;
			}

			/**
    * Requests the url using XMLHttpRequest.
    * @param {!string} url
    * @param {!string} method
    * @param {?string} body
    * @param {MultiMap=} opt_headers
    * @param {MultiMap=} opt_params
    * @param {number=} opt_timeout
    * @param {boolean=} opt_sync
    * @param {boolean=} opt_withCredentials
    * @return {Promise} Deferred ajax request.
    * @protected
    */

		}, {
			key: 'request',
			value: function request(url, method, body, opt_headers, opt_params, opt_timeout, opt_sync, opt_withCredentials) {
				url = url || '';
				method = method || 'GET';

				var request = new XMLHttpRequest();

				var promise = new Promise(function (resolve, reject) {
					request.onload = function () {
						if (request.aborted) {
							request.onerror();
							return;
						}
						resolve(request);
					};
					request.onerror = function () {
						var error = new Error('Request error');
						error.request = request;
						reject(error);
					};
				}).thenCatch(function (reason) {
					request.abort();
					throw reason;
				}).thenAlways(function () {
					clearTimeout(timeout);
				});

				if (opt_params) {
					url = new Uri(url).addParametersFromMultiMap(opt_params).toString();
				}

				request.open(method, url, !opt_sync);

				if (opt_withCredentials) {
					request.withCredentials = true;
				}

				if (opt_headers) {
					opt_headers.names().forEach(function (name) {
						request.setRequestHeader(name, opt_headers.getAll(name).join(', '));
					});
				}

				request.send(core.isDef(body) ? body : null);

				if (core.isDefAndNotNull(opt_timeout)) {
					var timeout = setTimeout(function () {
						promise.cancel('Request timeout');
					}, opt_timeout);
				}

				return promise;
			}
		}]);
		return Ajax;
	}();

	this.wedeploy.Ajax = Ajax;
}).call(this);
'use strict';

(function () {
	var Ajax = this.wedeploy.Ajax;
	var Transport = this.wedeploy.Transport;
	var ClientResponse = this.wedeploy.ClientResponse;

	/**
  * The implementation of an ajax transport to be used with {@link WeDeploy}.
  * @extends {Transport}
  */

	var AjaxTransport = function (_Transport) {
		babelHelpers.inherits(AjaxTransport, _Transport);

		function AjaxTransport() {
			babelHelpers.classCallCheck(this, AjaxTransport);
			return babelHelpers.possibleConstructorReturn(this, (AjaxTransport.__proto__ || Object.getPrototypeOf(AjaxTransport)).apply(this, arguments));
		}

		babelHelpers.createClass(AjaxTransport, [{
			key: 'send',

			/**
    * @inheritDoc
    */
			value: function send(clientRequest) {
				var deferred = Ajax.request(clientRequest.url(), clientRequest.method(), clientRequest.body(), clientRequest.headers(), clientRequest.params(), null, false, clientRequest.withCredentials());

				return deferred.then(function (response) {
					var clientResponse = new ClientResponse(clientRequest);
					clientResponse.body(response.responseText);
					clientResponse.statusCode(response.status);
					clientResponse.statusText(response.statusText);
					Ajax.parseResponseHeaders(response.getAllResponseHeaders()).forEach(function (header) {
						clientResponse.header(header.name, header.value);
					});
					return clientResponse;
				});
			}
		}]);
		return AjaxTransport;
	}(Transport);

	this.wedeploy.AjaxTransport = AjaxTransport;
}).call(this);
'use strict';

(function () {
	var AjaxTransport = this.wedeploy.AjaxTransport;

	/**
  * Provides a factory for data transport.
  */

	var TransportFactory = function () {
		function TransportFactory() {
			babelHelpers.classCallCheck(this, TransportFactory);

			this.transports = {};
			this.transports[TransportFactory.DEFAULT_TRANSPORT_NAME] = TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME];
		}

		/**
   * Returns {@link TransportFactory} instance.
   */


		babelHelpers.createClass(TransportFactory, [{
			key: 'get',


			/**
    * Gets an instance of the transport implementation with the given name.
    * @param {string} implementationName
    * @return {!Transport}
    */
			value: function get(implementationName) {
				var TransportClass = this.transports[implementationName];

				if (!TransportClass) {
					throw new Error('Invalid transport name: ' + implementationName);
				}

				try {
					return new TransportClass();
				} catch (err) {
					throw new Error('Can\'t create transport', err);
				}
			}

			/**
    * Returns the default transport implementation.
    * @return {!Transport}
    */

		}, {
			key: 'getDefault',
			value: function getDefault() {
				return this.get(TransportFactory.DEFAULT_TRANSPORT_NAME);
			}
		}], [{
			key: 'instance',
			value: function instance() {
				if (!TransportFactory.instance_) {
					TransportFactory.instance_ = new TransportFactory();
				}
				return TransportFactory.instance_;
			}
		}]);
		return TransportFactory;
	}();

	TransportFactory.DEFAULT_TRANSPORT_NAME = 'default';

	TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME] = AjaxTransport;

	this.wedeploy.TransportFactory = TransportFactory;
}).call(this);
'use strict';

(function () {
	var globals = {};

	if (typeof window !== 'undefined') {
		globals.window = window;
	}

	if (typeof document !== 'undefined') {
		globals.document = document;
	}

	this.wedeploy.globals = globals;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var globals = this.wedeploy.globals;
	var Uri = this.wedeploy.Uri;


	function assertBrowserEnvironment() {
		if (!globals.window) {
			throw new Error('Sign-in type not supported in this environment');
		}
	}

	function assertDefAndNotNull(value, errorMessage) {
		if (!core.isDefAndNotNull(value)) {
			throw new Error(errorMessage);
		}
	}

	function assertNotNull(value, errorMessage) {
		if (core.isNull(value)) {
			throw new Error(errorMessage);
		}
	}

	function assertFunction(value, errorMessage) {
		if (!core.isFunction(value)) {
			throw new Error(errorMessage);
		}
	}

	function assertObject(value, errorMessage) {
		if (!core.isObject(value)) {
			throw new Error(errorMessage);
		}
	}

	function assertResponseSucceeded(response) {
		if (!response.succeeded()) {
			throw response.body();
		}
		return response;
	}

	function assertUserSignedIn(user) {
		if (!core.isDefAndNotNull(user)) {
			throw new Error('You must be signed-in to perform this operation');
		}
	}

	function assertUriWithNoPath(url, message) {
		var uri = new Uri(url);
		if (uri.getPathname().length > 1) {
			throw new Error(message);
		}
	}

	this.wedeployNamed.assertions = this.wedeployNamed.assertions || {};
	this.wedeployNamed.assertions.assertBrowserEnvironment = assertBrowserEnvironment;
	this.wedeployNamed.assertions.assertDefAndNotNull = assertDefAndNotNull;
	this.wedeployNamed.assertions.assertNotNull = assertNotNull;
	this.wedeployNamed.assertions.assertFunction = assertFunction;
	this.wedeployNamed.assertions.assertObject = assertObject;
	this.wedeployNamed.assertions.assertResponseSucceeded = assertResponseSucceeded;
	this.wedeployNamed.assertions.assertUserSignedIn = assertUserSignedIn;
	this.wedeployNamed.assertions.assertUriWithNoPath = assertUriWithNoPath;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var assertDefAndNotNull = this.wedeployNamed.assertions.assertDefAndNotNull;
	var assertObject = this.wedeployNamed.assertions.assertObject;
	var assertResponseSucceeded = this.wedeployNamed.assertions.assertResponseSucceeded;

	/**
  * Class responsible for storing authorization information.
  */

	var Auth = function () {
		/**
   * Constructs an {@link Auth} instance.
   * @param {string} tokenOrEmail Either the authorization token, or
   *   the username.
   * @param {string=} opt_password If a username is given as the first param,
   *   this should be the password.
   * @constructor
   */
		function Auth(tokenOrEmail) {
			var opt_password = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
			babelHelpers.classCallCheck(this, Auth);

			this.token = core.isString(opt_password) ? null : tokenOrEmail;
			this.email = core.isString(opt_password) ? tokenOrEmail : null;
			this.password = opt_password;

			this.createdAt = null;
			this.id = null;
			this.name = null;
			this.photoUrl = null;
			this.wedeployClient = null;
		}

		/**
   * Constructs an {@link Auth} instance.
   * @param {string} tokenOrUsername Either the authorization token, or
   *   the username.
   * @param {string=} opt_password If a username is given as the first param,
   *   this should be the password.
   * @return {!Auth}
   */


		babelHelpers.createClass(Auth, [{
			key: 'getCreatedAt',


			/**
    * Gets the created at date.
    * @return {string}
    */
			value: function getCreatedAt() {
				return this.createdAt;
			}

			/**
    * Gets the email.
    * @return {string}
    */

		}, {
			key: 'getEmail',
			value: function getEmail() {
				return this.email;
			}

			/**
    * Gets the id.
    * @return {string}
    */

		}, {
			key: 'getId',
			value: function getId() {
				return this.id;
			}

			/**
    * Gets the name.
    * @return {string}
    */

		}, {
			key: 'getName',
			value: function getName() {
				return this.name;
			}

			/**
    * Gets the password.
    * @return {string}
    */

		}, {
			key: 'getPassword',
			value: function getPassword() {
				return this.password;
			}

			/**
    * Gets the photo url.
    * @return {string}
    */

		}, {
			key: 'getPhotoUrl',
			value: function getPhotoUrl() {
				return this.photoUrl;
			}

			/**
    * Gets the token.
    * @return {string}
    */

		}, {
			key: 'getToken',
			value: function getToken() {
				return this.token;
			}

			/**
    * Checks if created at is set.
    * @return {boolean}
    */

		}, {
			key: 'hasCreatedAt',
			value: function hasCreatedAt() {
				return core.isDefAndNotNull(this.createdAt);
			}

			/**
    * Checks if the email is set.
    * @return {boolean}
    */

		}, {
			key: 'hasEmail',
			value: function hasEmail() {
				return core.isDefAndNotNull(this.email);
			}

			/**
    * Checks if the id is set.
    * @return {boolean}
    */

		}, {
			key: 'hasId',
			value: function hasId() {
				return core.isDefAndNotNull(this.id);
			}

			/**
    * Checks if the name is set.
    * @return {boolean}
    */

		}, {
			key: 'hasName',
			value: function hasName() {
				return core.isDefAndNotNull(this.name);
			}

			/**
    * Checks if the password is set.
    * @return {boolean}
    */

		}, {
			key: 'hasPassword',
			value: function hasPassword() {
				return core.isDefAndNotNull(this.password);
			}

			/**
    * Checks if the photo url is set.
    * @return {boolean}
    */

		}, {
			key: 'hasPhotoUrl',
			value: function hasPhotoUrl() {
				return core.isDefAndNotNull(this.photoUrl);
			}

			/**
    * Checks if the token is set.
    * @return {boolean}
    */

		}, {
			key: 'hasToken',
			value: function hasToken() {
				return core.isDefAndNotNull(this.token);
			}

			/**
    * Sets created at.
    * @param {string} createdAt
    */

		}, {
			key: 'setCreatedAt',
			value: function setCreatedAt(createdAt) {
				this.createdAt = createdAt;
			}

			/**
    * Sets the email.
    * @param {string} email
    */

		}, {
			key: 'setEmail',
			value: function setEmail(email) {
				this.email = email;
			}

			/**
    * Sets the id.
    * @param {string} id
    */

		}, {
			key: 'setId',
			value: function setId(id) {
				this.id = id;
			}

			/**
    * Sets the name.
    * @param {string} name
    */

		}, {
			key: 'setName',
			value: function setName(name) {
				this.name = name;
			}

			/**
    * Sets the password.
    * @param {string} password
    */

		}, {
			key: 'setPassword',
			value: function setPassword(password) {
				this.password = password;
			}

			/**
    * Sets the photo url.
    * @param {string} photoUrl
    */

		}, {
			key: 'setPhotoUrl',
			value: function setPhotoUrl(photoUrl) {
				this.photoUrl = photoUrl;
			}

			/**
    * Sets the token.
    * @param {string} token
    */

		}, {
			key: 'setToken',
			value: function setToken(token) {
				this.token = token;
			}
		}, {
			key: 'setWedeployClient',
			value: function setWedeployClient(wedeployClient) {
				this.wedeployClient = wedeployClient;
			}

			/**
    * Updates the user.
    * @param {!object} data
    * @return {CompletableFuture}
    */

		}, {
			key: 'updateUser',
			value: function updateUser(data) {
				assertObject(data, 'User data must be specified as object');
				return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users').auth(this).patch(data).then(function (response) {
					return assertResponseSucceeded(response);
				});
			}

			/**
    * Deletes the current user.
    * @return {CompletableFuture}
    */

		}, {
			key: 'deleteUser',
			value: function deleteUser() {
				assertDefAndNotNull(this.id, 'Cannot delete user without id');
				return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users', this.id).auth(this).delete().then(function (response) {
					return assertResponseSucceeded(response);
				});
			}
		}], [{
			key: 'create',
			value: function create(tokenOrUsername, opt_password) {
				return new Auth(tokenOrUsername, opt_password);
			}
		}]);
		return Auth;
	}();

	this.wedeploy.Auth = Auth;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var Uri = this.wedeploy.Uri;

	/**
  * Class responsible for encapsulate provider information.
  */

	var AuthProvider = function () {
		/**
   * Constructs an {@link AuthProvider} instance.
   * @constructor
   */
		function AuthProvider() {
			babelHelpers.classCallCheck(this, AuthProvider);

			this.provider = null;
			this.providerScope = null;
			this.redirectUri = null;
			this.scope = null;
		}

		/**
   * Checks if provider is defined and not null.
   * @return {boolean}
   */


		babelHelpers.createClass(AuthProvider, [{
			key: 'hasProvider',
			value: function hasProvider() {
				return core.isDefAndNotNull(this.provider);
			}

			/**
    * Checks if scope is defined and not null.
    * @return {boolean}
    */

		}, {
			key: 'hasProviderScope',
			value: function hasProviderScope() {
				return core.isDefAndNotNull(this.providerScope);
			}

			/**
    * Checks if redirect uri is defined and not null.
    * @return {boolean}
    */

		}, {
			key: 'hasRedirectUri',
			value: function hasRedirectUri() {
				return core.isDefAndNotNull(this.redirectUri);
			}

			/**
    * Checks if scope is defined and not null.
    * @return {boolean}
    */

		}, {
			key: 'hasScope',
			value: function hasScope() {
				return core.isDefAndNotNull(this.scope);
			}

			/**
    * Makes authorization url.
    * @return {string=} Authorization url.
    */

		}, {
			key: 'makeAuthorizationUrl',
			value: function makeAuthorizationUrl(opt_authUrl) {
				var uri = new Uri(opt_authUrl);

				uri.setPathname('/oauth/authorize');

				if (this.hasProvider()) {
					uri.setParameterValue('provider', this.getProvider());
				}
				if (this.hasProviderScope()) {
					uri.setParameterValue('provider_scope', this.getProviderScope());
				}
				if (this.hasRedirectUri()) {
					uri.setParameterValue('redirect_uri', this.getRedirectUri());
				}
				if (this.hasScope()) {
					uri.setParameterValue('scope', this.getScope());
				}

				return uri.toString();
			}

			/**
    * Gets provider name.
    * @return {string=} Provider name.
    */

		}, {
			key: 'getProvider',
			value: function getProvider() {
				return this.provider;
			}

			/**
    * Gets provider scope.
    * @return {string=} String with scopes.
    */

		}, {
			key: 'getProviderScope',
			value: function getProviderScope() {
				return this.providerScope;
			}

			/**
    * Gets redirect uri.
    * @return {string=}.
    */

		}, {
			key: 'getRedirectUri',
			value: function getRedirectUri() {
				return this.redirectUri;
			}

			/**
    * Gets scope.
    * @return {string=} String with scopes.
    */

		}, {
			key: 'getScope',
			value: function getScope() {
				return this.scope;
			}

			/**
    * Sets provider scope.
    * @param {string=} scope Scope string. Separate by space for multiple
    *   scopes, e.g. "scope1 scope2".
    */

		}, {
			key: 'setProviderScope',
			value: function setProviderScope(providerScope) {
				assertStringIfDefAndNotNull(providerScope, 'Provider scope must be a string');
				this.providerScope = providerScope;
			}

			/**
    * Sets redirect uri.
    * @param {string=} redirectUri.
    */

		}, {
			key: 'setRedirectUri',
			value: function setRedirectUri(redirectUri) {
				assertStringIfDefAndNotNull(redirectUri, 'Redirect uri must be a string');
				this.redirectUri = redirectUri;
			}

			/**
    * Sets scope.
    * @param {string=} scope Scope string. Separate by space for multiple
    *   scopes, e.g. "scope1 scope2".
    */

		}, {
			key: 'setScope',
			value: function setScope(scope) {
				assertStringIfDefAndNotNull(scope, 'Scope must be a string');
				this.scope = scope;
			}
		}]);
		return AuthProvider;
	}();

	function assertStringIfDefAndNotNull(value, errorMessage) {
		if (core.isDefAndNotNull(value) && !core.isString(value)) {
			throw new Error(errorMessage);
		}
	}

	this.wedeploy.AuthProvider = AuthProvider;
}).call(this);
'use strict';

(function () {
	var AuthProvider = this.wedeploy.AuthProvider;

	/**
  * Facebook auth provider implementation.
  */

	var FacebookAuthProvider = function (_AuthProvider) {
		babelHelpers.inherits(FacebookAuthProvider, _AuthProvider);

		/**
   * Constructs an {@link FacebookAuthProvider} instance.
   * @constructor
   */
		function FacebookAuthProvider() {
			babelHelpers.classCallCheck(this, FacebookAuthProvider);

			var _this = babelHelpers.possibleConstructorReturn(this, (FacebookAuthProvider.__proto__ || Object.getPrototypeOf(FacebookAuthProvider)).call(this));

			_this.provider = FacebookAuthProvider.PROVIDER;
			return _this;
		}

		return FacebookAuthProvider;
	}(AuthProvider);

	FacebookAuthProvider.PROVIDER = 'facebook';

	this.wedeploy.FacebookAuthProvider = FacebookAuthProvider;
}).call(this);
'use strict';

(function () {
	var AuthProvider = this.wedeploy.AuthProvider;

	/**
  * Github auth provider implementation.
  */

	var GithubAuthProvider = function (_AuthProvider) {
		babelHelpers.inherits(GithubAuthProvider, _AuthProvider);

		/**
   * Constructs an {@link GithubAuthProvider} instance.
   * @constructor
   */
		function GithubAuthProvider() {
			babelHelpers.classCallCheck(this, GithubAuthProvider);

			var _this = babelHelpers.possibleConstructorReturn(this, (GithubAuthProvider.__proto__ || Object.getPrototypeOf(GithubAuthProvider)).call(this));

			_this.provider = GithubAuthProvider.PROVIDER;
			return _this;
		}

		return GithubAuthProvider;
	}(AuthProvider);

	GithubAuthProvider.PROVIDER = 'github';

	this.wedeploy.GithubAuthProvider = GithubAuthProvider;
}).call(this);
'use strict';

(function () {
	var AuthProvider = this.wedeploy.AuthProvider;

	/**
  * Google auth provider implementation.
  */

	var GoogleAuthProvider = function (_AuthProvider) {
		babelHelpers.inherits(GoogleAuthProvider, _AuthProvider);

		/**
   * Constructs an {@link GoogleAuthProvider} instance.
   * @constructor
   */
		function GoogleAuthProvider() {
			babelHelpers.classCallCheck(this, GoogleAuthProvider);

			var _this = babelHelpers.possibleConstructorReturn(this, (GoogleAuthProvider.__proto__ || Object.getPrototypeOf(GoogleAuthProvider)).call(this));

			_this.provider = GoogleAuthProvider.PROVIDER;
			return _this;
		}

		return GoogleAuthProvider;
	}(AuthProvider);

	GoogleAuthProvider.PROVIDER = 'google';

	this.wedeploy.GoogleAuthProvider = GoogleAuthProvider;
}).call(this);
'use strict';

/* jshint ignore:start */

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */

(function () {
	var StorageMechanism = function () {
		function StorageMechanism() {
			babelHelpers.classCallCheck(this, StorageMechanism);
		}

		babelHelpers.createClass(StorageMechanism, [{
			key: 'clear',

			/**
    * Clear all items from the data storage.
    */
			value: function clear() {
				throw Error('Unimplemented abstract method');
			}

			/**
    * Sets an item in the data storage.
    * @param {string} key The key to set.
    * @param {*} value The value to serialize to a string and save.
    */

		}, {
			key: 'set',
			value: function set(key, value) {
				throw Error('Unimplemented abstract method');
			}

			/**
    * Gets an item from the data storage.
    * @param {string} key The key to get.
    * @return {*} Deserialized value or undefined if not found.
    */

		}, {
			key: 'get',
			value: function get(key) {
				throw Error('Unimplemented abstract method');
			}

			/**
    * Returns the list of keys stored in the Storage object.
    * @param {!Array<string>} keys
    */

		}, {
			key: 'keys',
			value: function keys() {
				throw Error('Unimplemented abstract method');
			}

			/**
    * Removes an item from the data storage.
    * @param {string} key The key to remove.
    */

		}, {
			key: 'remove',
			value: function remove(key) {
				throw Error('Unimplemented abstract method');
			}

			/**
    * Returns the number of data items stored in the Storage object.
    * @return {number}
    */

		}, {
			key: 'size',
			value: function size() {
				throw Error('Unimplemented abstract method');
			}
		}]);
		return StorageMechanism;
	}();

	this.wedeploy.StorageMechanism = StorageMechanism;

	/* jshint ignore:end */
}).call(this);
'use strict';

(function () {
	var core = this.wedeploy.metal;
	var StorageMechanism = this.wedeploy.StorageMechanism;

	var Storage = function () {

		/**
   * Provides a convenient API for data persistence using a selected data
   * storage mechanism.
   * @param {!StorageMechanism} mechanism The underlying storage mechanism.
   * @constructor
   */
		function Storage(mechanism) {
			babelHelpers.classCallCheck(this, Storage);

			assertMechanismDefAndNotNull(mechanism);
			assertMechanismIntanceOf(mechanism);

			/**
    * The mechanism used to persist key-value pairs.
    * @type {StorageMechanism}
    * @protected
    */
			this.mechanism = mechanism;
		}

		/**
   * Clear all items from the data storage.
   */


		babelHelpers.createClass(Storage, [{
			key: 'clear',
			value: function clear() {
				this.mechanism.clear();
			}

			/**
    * Sets an item in the data storage.
    * @param {string} key The key to set.
    * @param {*} value The value to serialize to a string and save.
    */

		}, {
			key: 'set',
			value: function set(key, value) {
				if (!core.isDef(value)) {
					this.mechanism.remove(key);
					return;
				}
				this.mechanism.set(key, JSON.stringify(value));
			}

			/**
    * Gets an item from the data storage.
    * @param {string} key The key to get.
    * @return {*} Deserialized value or undefined if not found.
    */

		}, {
			key: 'get',
			value: function get(key) {
				var json;
				try {
					json = this.mechanism.get(key);
				} catch (e) {
					return undefined;
				}
				if (core.isNull(json)) {
					return undefined;
				}
				try {
					return JSON.parse(json);
				} catch (e) {
					throw Storage.ErrorCode.INVALID_VALUE;
				}
			}

			/**
    * Returns the list of keys stored in the Storage object.
    * @param {!Array<string>} keys
    */

		}, {
			key: 'keys',
			value: function keys() {
				return this.mechanism.keys();
			}

			/**
    * Removes an item from the data storage.
    * @param {string} key The key to remove.
    */

		}, {
			key: 'remove',
			value: function remove(key) {
				this.mechanism.remove(key);
			}

			/**
    * Returns the number of data items stored in the Storage object.
    * @return {number}
    */

		}, {
			key: 'size',
			value: function size() {
				return this.mechanism.size();
			}

			/**
    * Returns the list of values stored in the Storage object.
    * @param {!Array<string>} values
    */

		}, {
			key: 'values',
			value: function values() {
				var _this = this;

				return this.keys().map(function (key) {
					return _this.get(key);
				});
			}
		}]);
		return Storage;
	}();

	/**
  * Errors thrown by the storage.
  * @enum {string}
  */


	Storage.ErrorCode = {
		INVALID_VALUE: 'Storage: Invalid value was encountered'
	};

	function assertMechanismDefAndNotNull(mechanism) {
		if (!core.isDefAndNotNull(mechanism)) {
			throw Error('Storage mechanism is required');
		}
	}

	function assertMechanismIntanceOf(mechanism) {
		if (!(mechanism instanceof StorageMechanism)) {
			throw Error('Storage mechanism must me an implementation of StorageMechanism');
		}
	}

	this.wedeploy.Storage = Storage;
}).call(this);
'use strict';

(function () {
	var StorageMechanism = this.wedeploy.StorageMechanism;

	/**
  * Abstract interface for storing and retrieving data using some persistence
  * mechanism.
  * @constructor
  */

	var LocalStorageMechanism = function (_StorageMechanism) {
		babelHelpers.inherits(LocalStorageMechanism, _StorageMechanism);

		function LocalStorageMechanism() {
			babelHelpers.classCallCheck(this, LocalStorageMechanism);
			return babelHelpers.possibleConstructorReturn(this, (LocalStorageMechanism.__proto__ || Object.getPrototypeOf(LocalStorageMechanism)).apply(this, arguments));
		}

		babelHelpers.createClass(LocalStorageMechanism, [{
			key: 'storage',

			/**
    * Returns reference for global local storage. by default
    */
			value: function storage() {
				return LocalStorageMechanism.globals.localStorage;
			}

			/**
    * @inheritDoc
    */

		}, {
			key: 'clear',
			value: function clear() {
				this.storage().clear();
			}

			/**
    * @inheritDoc
    */

		}, {
			key: 'keys',
			value: function keys() {
				return Object.keys(this.storage());
			}

			/**
    * @inheritDoc
    */

		}, {
			key: 'get',
			value: function get(key) {
				return this.storage().getItem(key);
			}

			/**
    * @inheritDoc
    */

		}, {
			key: 'remove',
			value: function remove(key) {
				this.storage().removeItem(key);
			}

			/**
    * @inheritDoc
    */

		}, {
			key: 'set',
			value: function set(key, value) {
				this.storage().setItem(key, value);
			}

			/**
    * @inheritDoc
    */

		}, {
			key: 'size',
			value: function size() {
				return this.storage().length;
			}
		}]);
		return LocalStorageMechanism;
	}(StorageMechanism);

	LocalStorageMechanism.globals = {
		localStorage: window.localStorage
	};

	this.wedeploy.LocalStorageMechanism = LocalStorageMechanism;
}).call(this);
'use strict';

(function () {
  var Storage = this.wedeploy.Storage;
  var StorageMechanism = this.wedeploy.StorageMechanism;
  var LocalStorageMechanism = this.wedeploy.LocalStorageMechanism;
  this.wedeployNamed.storage = this.wedeployNamed.storage || {};
  this.wedeployNamed.storage.Storage = Storage;
  this.wedeployNamed.storage.StorageMechanism = StorageMechanism;
  this.wedeployNamed.storage.LocalStorageMechanism = LocalStorageMechanism;
}).call(this);
'use strict';

(function () {
	var Auth = this.wedeploy.Auth;
	var FacebookAuthProvider = this.wedeploy.FacebookAuthProvider;
	var GithubAuthProvider = this.wedeploy.GithubAuthProvider;
	var globals = this.wedeploy.globals;
	var GoogleAuthProvider = this.wedeploy.GoogleAuthProvider;
	var Storage = this.wedeployNamed.storage.Storage;
	var LocalStorageMechanism = this.wedeployNamed.storage.LocalStorageMechanism;
	var assertDefAndNotNull = this.wedeployNamed.assertions.assertDefAndNotNull;
	var assertFunction = this.wedeployNamed.assertions.assertFunction;
	var assertObject = this.wedeployNamed.assertions.assertObject;
	var assertUserSignedIn = this.wedeployNamed.assertions.assertUserSignedIn;
	var assertBrowserEnvironment = this.wedeployNamed.assertions.assertBrowserEnvironment;
	var assertResponseSucceeded = this.wedeployNamed.assertions.assertResponseSucceeded;

	/**
  * Class responsible for encapsulate auth api calls.
  */

	var AuthApiHelper = function () {
		/**
   * Constructs an {@link AuthApiHelper} instance.
   * @constructor
   */
		function AuthApiHelper(wedeployClient) {
			babelHelpers.classCallCheck(this, AuthApiHelper);

			assertDefAndNotNull(wedeployClient, 'WeDeploy client reference must be specified');

			this.currentUser = null;
			this.onSignInCallback = null;
			this.onSignOutCallback = null;
			this.wedeployClient = wedeployClient;
			this.storage = new Storage(new LocalStorageMechanism());

			this.processSignIn_();

			this.provider = {
				Facebook: FacebookAuthProvider,
				Google: GoogleAuthProvider,
				Github: GithubAuthProvider
			};
		}

		/**
   * Creates user.
   * @param {!object} data The data to be used to create the user.
   * @return {CancellablePromise}
   */


		babelHelpers.createClass(AuthApiHelper, [{
			key: 'createUser',
			value: function createUser(data) {
				var _this = this;

				assertObject(data, 'User data must be specified as object');
				return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users').post(data).then(function (response) {
					return assertResponseSucceeded(response);
				}).then(function (response) {
					return _this.makeUserAuthFromData(response.body());
				});
			}

			/**
    * Gets the current browser url without the fragment part.
    * @return {!string}
    * @protected
    */

		}, {
			key: 'getHrefWithoutFragment_',
			value: function getHrefWithoutFragment_() {
				var location = globals.window.location;
				return location.protocol + '//' + location.host + location.pathname + (location.search ? location.search : '');
			}

			/**
    * Gets the access token from the url fragment and removes it.
    * @return {?string}
    * @protected
    */

		}, {
			key: 'getRedirectAccessToken_',
			value: function getRedirectAccessToken_() {
				if (globals.window) {
					var fragment = globals.window.location.hash;
					if (fragment.indexOf('#access_token=') === 0) {
						return fragment.substring(14);
					}
				}
				return null;
			}

			/**
    * Gets user by id.
    * @param {!string} userId
    * @return {CancellablePromise}
    */

		}, {
			key: 'getUser',
			value: function getUser(userId) {
				assertDefAndNotNull(userId, 'User userId must be specified');
				assertUserSignedIn(this.currentUser);
				return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users', userId).auth(this.currentUser.token).get().then(function (response) {
					return assertResponseSucceeded(response);
				});
			}

			/**
    * Loads current user. Requires a user token as argument.
    * @param {!string} token
    * @return {CancellablePromise}
    */

		}, {
			key: 'loadCurrentUser',
			value: function loadCurrentUser(token) {
				var _this2 = this;

				assertDefAndNotNull(token, 'User token must be specified');
				return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/user').auth(token).get().then(function (response) {
					var data = response.body();
					data.token = token;
					_this2.currentUser = _this2.makeUserAuthFromData(data);
					_this2.storage.set('currentUser', data);
					return _this2.currentUser;
				});
			}

			/**
    * Makes user Auth from data object.
    * @param {object} data
    * @return {Auth}
    * @protected
    */

		}, {
			key: 'makeUserAuthFromData',
			value: function makeUserAuthFromData(data) {
				var auth = new Auth();
				auth.setWedeployClient(this.wedeployClient);
				auth.setCreatedAt(data.createdAt);
				auth.setEmail(data.email);
				auth.setId(data.id);
				auth.setName(data.name);
				auth.setPhotoUrl(data.photoUrl);
				auth.setToken(data.token);
				return auth;
			}

			/**
    * Calls the on sign in callback if set.
    * @protected
    */

		}, {
			key: 'maybeCallOnSignInCallback_',
			value: function maybeCallOnSignInCallback_() {
				if (this.onSignInCallback) {
					this.onSignInCallback.call(this, this.currentUser);
				}
			}

			/**
    * Calls the on sign out callback if set.
    * @protected
    */

		}, {
			key: 'maybeCallOnSignOutCallback_',
			value: function maybeCallOnSignOutCallback_() {
				if (this.onSignOutCallback) {
					this.onSignOutCallback.call(this, this.currentUser);
				}
			}

			/**
    * Fires passed callback when a user sign-in. Note that it keeps only the
    * last callback passed.
    * @param {!Function} callback
    */

		}, {
			key: 'onSignIn',
			value: function onSignIn(callback) {
				assertFunction(callback, 'Sign-in callback must be a function');
				this.onSignInCallback = callback;
			}

			/**
    * Fires passed callback when a user sign-out. Note that it keeps only the
    * last callback passed.
    * @param {!Function} callback
    */

		}, {
			key: 'onSignOut',
			value: function onSignOut(callback) {
				assertFunction(callback, 'Sign-out callback must be a function');
				this.onSignOutCallback = callback;
			}

			/**
    * Processes sign-in by detecting a presence of a fragment
    * <code>#access_token=</code> in the url or, alternatively, by local
    * storage current user.
    */

		}, {
			key: 'processSignIn_',
			value: function processSignIn_() {
				var _this3 = this;

				var redirectAccessToken = this.getRedirectAccessToken_();
				if (redirectAccessToken) {
					this.removeUrlFragmentCompletely_();
					this.loadCurrentUser(redirectAccessToken).then(function () {
						return _this3.maybeCallOnSignInCallback_();
					});
					return;
				}
				var currentUser = this.storage.get('currentUser');
				if (currentUser) {
					this.currentUser = this.makeUserAuthFromData(currentUser);
				}
			}

			/**
    * Removes fragment from url by performing a push state to the current path.
    * @protected
    */

		}, {
			key: 'removeUrlFragmentCompletely_',
			value: function removeUrlFragmentCompletely_() {
				globals.window.history.pushState({}, document.title, window.location.pathname + window.location.search);
			}

			/**
    * Sends password reset email to the specified email if found in database.
    * For security reasons call do not fail if email not found.
    * @param {!string} email
    * @return {CancellablePromise}
    */

		}, {
			key: 'sendPasswordResetEmail',
			value: function sendPasswordResetEmail(email) {
				assertDefAndNotNull(email, 'Send password reset email must be specified');
				return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/user/recover').param('email', email).post().then(function (response) {
					return assertResponseSucceeded(response);
				});
			}

			/**
    * Signs in using email and password.
    * @param {!string} email
    * @param {!string} password
    * @return {CancellablePromise}
    */

		}, {
			key: 'signInWithEmailAndPassword',
			value: function signInWithEmailAndPassword(email, password) {
				var _this4 = this;

				assertDefAndNotNull(email, 'Sign-in email must be specified');
				assertDefAndNotNull(password, 'Sign-in password must be specified');

				return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/oauth/token').param('grant_type', 'password').param('username', email).param('password', password).get().then(function (response) {
					return assertResponseSucceeded(response);
				}).then(function (response) {
					return _this4.loadCurrentUser(response.body().access_token);
				}).then(function (user) {
					_this4.maybeCallOnSignInCallback_();
					return user;
				});
			}

			/**
    * Signs in with redirect. Some providers and environment may not support
    * this flow.
    * @param {AuthProvider} provider
    */

		}, {
			key: 'signInWithRedirect',
			value: function signInWithRedirect(provider) {
				assertBrowserEnvironment();
				assertDefAndNotNull(provider, 'Sign-in provider must be defined');
				assertSupportedProvider(provider);

				if (!provider.hasRedirectUri()) {
					provider.setRedirectUri(this.getHrefWithoutFragment_());
				}
				globals.window.location.href = provider.makeAuthorizationUrl(this.wedeployClient.authUrl_);
			}

			/**
    * Signs out <code>currentUser</code> and removes from <code>localStorage</code>.
    * @return {[type]} [description]
    */

		}, {
			key: 'signOut',
			value: function signOut() {
				var _this5 = this;

				assertUserSignedIn(this.currentUser);
				return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/oauth/revoke').param('token', this.currentUser.token).get().then(function (response) {
					return assertResponseSucceeded(response);
				}).then(function (response) {
					_this5.maybeCallOnSignOutCallback_();
					_this5.unloadCurrentUser_();
					return response;
				});
			}

			/**
    * Unloads all information for <code>currentUser</code> and removes from
    * <code>localStorage</code> if present.
    * @return {[type]} [description]
    */

		}, {
			key: 'unloadCurrentUser_',
			value: function unloadCurrentUser_() {
				this.currentUser = null;
				this.storage.remove('currentUser');
			}
		}]);
		return AuthApiHelper;
	}();

	function assertSupportedProvider(provider) {
		switch (provider.constructor.PROVIDER) {
			case FacebookAuthProvider.PROVIDER:
			case GithubAuthProvider.PROVIDER:
			case GoogleAuthProvider.PROVIDER:
				break;
			default:
				throw new Error('Sign-in provider not supported');
		}
	}

	this.wedeploy.AuthApiHelper = AuthApiHelper;
}).call(this);
'use strict';

/**
 * Class responsible for storing an object that will be printed as JSON
 * when the `toString` method is called.
 */

(function () {
	var Embodied = function () {
		/**
   * Constructs a Embodied instance.
   * @constructor
   */
		function Embodied() {
			babelHelpers.classCallCheck(this, Embodied);

			this.body_ = {};
		}

		/**
   * Gets the json object that represents this instance.
   * @return {!Object}
   */


		babelHelpers.createClass(Embodied, [{
			key: 'body',
			value: function body() {
				return this.body_;
			}

			/**
    * If the given object is an instance of Embodied, this will
    * return its body content. Otherwise this will return the
    * original object.
    * @param {*} obj
    * @return {*}
    * @static
    */

		}, {
			key: 'toString',


			/**
    * Gets the json string that represents this instance.
    * @return {string}
    */
			value: function toString() {
				return JSON.stringify(this.body());
			}
		}], [{
			key: 'toBody',
			value: function toBody(obj) {
				return obj instanceof Embodied ? obj.body() : obj;
			}
		}]);
		return Embodied;
	}();

	this.wedeploy.Embodied = Embodied;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var Embodied = this.wedeploy.Embodied;

	/**
  * Class responsible for storing and handling the body contents
  * of a Filter instance.
  */

	var FilterBody = function () {
		/**
   * Constructs a {@link FilterBody} instance.
   * @param {string} field The name of the field to filter by.
   * @param {*} operatorOrValue If a third param is given, this should
   *   be the filter's operator (like ">="). Otherwise, this will be
   *   used as the filter's value, and the filter's operator will be "=".
   * @param {*=} opt_value The filter's value.
   * @constructor
   */
		function FilterBody(field, operatorOrValue, opt_value) {
			babelHelpers.classCallCheck(this, FilterBody);

			var obj = {
				operator: core.isDef(opt_value) ? operatorOrValue : '='
			};
			var value = core.isDef(opt_value) ? opt_value : operatorOrValue;
			if (core.isDefAndNotNull(value)) {
				if (value instanceof Embodied) {
					value = value.body();
				}
				obj.value = value;
			}
			this.createBody_(field, obj);
		}

		/**
   * Composes the current filter with the given operator.
   * @param {string} operator
   * @param {Filter=} opt_filter Another filter to compose this filter with,
   *   if the operator is not unary.
   */


		babelHelpers.createClass(FilterBody, [{
			key: 'add',
			value: function add(operator, opt_filter) {
				if (opt_filter) {
					this.addArrayOperator_(operator, opt_filter);
				} else {
					this.createBody_(operator, this.body_);
				}
			}

			/**
    * Composes the current filter with an operator that stores its values in an array.
    * @param {string} operator
    * @param {!Filter} filter
    * @protected
    */

		}, {
			key: 'addArrayOperator_',
			value: function addArrayOperator_(operator, filter) {
				if (!(this.body_[operator] instanceof Array)) {
					this.createBody_(operator, [this.body_]);
				}
				this.body_[operator].push(filter.body());
			}

			/**
    * Adds filters to be composed with this filter body using the given operator.
    * @param {string} operator
    * @param {...*} filters A variable amount of filters to be composed.
    */

		}, {
			key: 'addMany',
			value: function addMany(operator) {
				for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					filters[_key - 1] = arguments[_key];
				}

				for (var i = 0; i < filters.length; i++) {
					this.add(operator, filters[i]);
				}
			}

			/**
    * Creates a new body object, setting the requestd key to the given value.
    * @param {string} key The key to set in the new body object
    * @param {*} value The value the requested key should have in the new body object.
    * @protected
    */

		}, {
			key: 'createBody_',
			value: function createBody_(key, value) {
				this.body_ = {};
				this.body_[key] = value;
			}

			/**
    * Gets the json object that represents this filter's body.
    * @return {!Object}
    */

		}, {
			key: 'getObject',
			value: function getObject() {
				return this.body_;
			}
		}]);
		return FilterBody;
	}();

	this.wedeploy.FilterBody = FilterBody;
}).call(this);
'use strict';

(function () {
	var Embodied = this.wedeploy.Embodied;

	/**
  * Class responsible for building different types of geometric
  * shapes.
  */

	var Geo = function () {
		function Geo() {
			babelHelpers.classCallCheck(this, Geo);
		}

		babelHelpers.createClass(Geo, null, [{
			key: 'boundingBox',

			/**
    * Creates a new {@link BoundingBox} instance.
    * @param {*} upperLeft The upper left point.
    * @param {*} lowerRight The lower right point.
    * @return {!BoundingBox}
    * @static
    */
			value: function boundingBox(upperLeft, lowerRight) {
				return new Geo.BoundingBox(upperLeft, lowerRight);
			}

			/**
    * Creates a new {@link Circle} instance.
    * @param {*} center The circle's center coordinate.
    * @param {string} radius The circle's radius.
    * @return {!Circle}
    * @static
    */

		}, {
			key: 'circle',
			value: function circle(center, radius) {
				return new Geo.Circle(center, radius);
			}

			/**
    * Creates a new {@link Line} instance.
    * @param {...*} points This line's points.
    * @return {!Line}
    * @static
    */

		}, {
			key: 'line',
			value: function line() {
				for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
					points[_key] = arguments[_key];
				}

				return new (Function.prototype.bind.apply(Geo.Line, [null].concat(points)))();
			}

			/**
    * Creates a new {@link Point} instance.
    * @param {number} lat The latitude coordinate
    * @param {number} lon The longitude coordinate
    * @return {!Point}
    * @static
    */

		}, {
			key: 'point',
			value: function point(lat, lon) {
				return new Geo.Point(lat, lon);
			}

			/**
    * Creates a new {@link Polygon} instance.
    * @param {...*} points This polygon's points.
    * @return {!Polygon}
    * @static
    */

		}, {
			key: 'polygon',
			value: function polygon() {
				for (var _len2 = arguments.length, points = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
					points[_key2] = arguments[_key2];
				}

				return new (Function.prototype.bind.apply(Geo.Polygon, [null].concat(points)))();
			}
		}]);
		return Geo;
	}();

	/**
  * Class that represents a point coordinate.
  * @extends {Embodied}
  */


	var Point = function (_Embodied) {
		babelHelpers.inherits(Point, _Embodied);

		/**
   * Constructs a {@link Point} instance.
   * @param {number} lat The latitude coordinate
   * @param {number} lon The longitude coordinate
   * @constructor
   */
		function Point(lat, lon) {
			babelHelpers.classCallCheck(this, Point);

			var _this = babelHelpers.possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this));

			_this.body_ = [lat, lon];
			return _this;
		}

		return Point;
	}(Embodied);

	Geo.Point = Point;

	/**
  * Class that represents a line.
  * @extends {Embodied}
  */

	var Line = function (_Embodied2) {
		babelHelpers.inherits(Line, _Embodied2);

		/**
   * Constructs a {@link Line} instance.
   * @param {...*} points This line's points.
   * @constructor
   */
		function Line() {
			babelHelpers.classCallCheck(this, Line);

			var _this2 = babelHelpers.possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this));

			for (var _len3 = arguments.length, points = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
				points[_key3] = arguments[_key3];
			}

			_this2.body_ = {
				type: 'linestring',
				coordinates: points.map(function (point) {
					return Embodied.toBody(point);
				})
			};
			return _this2;
		}

		return Line;
	}(Embodied);

	Geo.Line = Line;

	/**
  * Class that represents a bounding box.
  * @extends {Embodied}
  */

	var BoundingBox = function (_Embodied3) {
		babelHelpers.inherits(BoundingBox, _Embodied3);

		/**
   * Constructs a {@link BoundingBox} instance.
   * @param {*} upperLeft The upper left point.
   * @param {*} lowerRight The lower right point.
   * @constructor
   */
		function BoundingBox(upperLeft, lowerRight) {
			babelHelpers.classCallCheck(this, BoundingBox);

			var _this3 = babelHelpers.possibleConstructorReturn(this, (BoundingBox.__proto__ || Object.getPrototypeOf(BoundingBox)).call(this));

			_this3.body_ = {
				type: 'envelope',
				coordinates: [Embodied.toBody(upperLeft), Embodied.toBody(lowerRight)]
			};
			return _this3;
		}

		/**
   * Gets this bounding box's points.
   * @return {!Array}
   */


		babelHelpers.createClass(BoundingBox, [{
			key: 'getPoints',
			value: function getPoints() {
				return this.body_.coordinates;
			}
		}]);
		return BoundingBox;
	}(Embodied);

	Geo.BoundingBox = BoundingBox;

	/**
  * Class that represents a circle.
  * @extends {Embodied}
  */

	var Circle = function (_Embodied4) {
		babelHelpers.inherits(Circle, _Embodied4);

		/**
   * Constructs a {@link Circle} instance.
   * @param {*} center The circle's center coordinate.
   * @param {string} radius The circle's radius.
   * @constructor
   */
		function Circle(center, radius) {
			babelHelpers.classCallCheck(this, Circle);

			var _this4 = babelHelpers.possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this));

			_this4.body_ = {
				type: 'circle',
				coordinates: Embodied.toBody(center),
				radius: radius
			};
			return _this4;
		}

		/**
   * Gets this circle's center coordinate.
   * @return {*}
   */


		babelHelpers.createClass(Circle, [{
			key: 'getCenter',
			value: function getCenter() {
				return this.body_.coordinates;
			}

			/**
    * Gets this circle's radius.
    * @return {string}
    */

		}, {
			key: 'getRadius',
			value: function getRadius() {
				return this.body_.radius;
			}
		}]);
		return Circle;
	}(Embodied);

	Geo.Circle = Circle;

	/**
  * Class that represents a polygon.
  * @extends {Embodied}
  */

	var Polygon = function (_Embodied5) {
		babelHelpers.inherits(Polygon, _Embodied5);

		/**
   * Constructs a {@link Polygon} instance.
   * @param {...*} points This polygon's points.
   * @constructor
   */
		function Polygon() {
			babelHelpers.classCallCheck(this, Polygon);

			var _this5 = babelHelpers.possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this));

			_this5.body_ = {
				type: 'polygon',
				coordinates: []
			};
			_this5.addCoordinates_.apply(_this5, arguments);
			return _this5;
		}

		/**
   * Adds the given points as coordinates for this polygon.
   * @param {...*} points
   * @protected
   */


		babelHelpers.createClass(Polygon, [{
			key: 'addCoordinates_',
			value: function addCoordinates_() {
				for (var _len4 = arguments.length, points = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
					points[_key4] = arguments[_key4];
				}

				this.body_.coordinates.push(points.map(function (point) {
					return Embodied.toBody(point);
				}));
			}

			/**
    * Adds the given points as a hole inside this polygon.
    * @param  {...*} points
    * @chainnable
    */

		}, {
			key: 'hole',
			value: function hole() {
				this.addCoordinates_.apply(this, arguments);
				return this;
			}
		}]);
		return Polygon;
	}(Embodied);

	Geo.Polygon = Polygon;

	this.wedeploy.Geo = Geo;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var Embodied = this.wedeploy.Embodied;

	/**
  * Class responsible for building range objects to be used by `Filter`.
  * @extends {Embodied}
  */

	var Range = function (_Embodied) {
		babelHelpers.inherits(Range, _Embodied);

		/**
   * Constructs a {@link Range} instance.
   * @param {*} from
   * @param {*} opt_to
   * @constructor
   */
		function Range(from, opt_to) {
			babelHelpers.classCallCheck(this, Range);

			var _this = babelHelpers.possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this));

			if (core.isDefAndNotNull(from)) {
				_this.body_.from = from;
			}
			if (core.isDefAndNotNull(opt_to)) {
				_this.body_.to = opt_to;
			}
			return _this;
		}

		/**
   * Constructs a {@link Range} instance.
   * @param {*} from
   * @return {!Range}
   * @static
   */


		babelHelpers.createClass(Range, null, [{
			key: 'from',
			value: function from(_from) {
				return new Range(_from);
			}

			/**
    * Constructs a {@link Range} instance.
    * @param {*} from
    * @param {*} to
    * @return {!Range}
    * @static
    */

		}, {
			key: 'range',
			value: function range(from, to) {
				return new Range(from, to);
			}

			/**
    * Constructs a {@link Range} instance.
    * @param {*} to
    * @return {!Range}
    * @static
    */

		}, {
			key: 'to',
			value: function to(_to) {
				return new Range(null, _to);
			}
		}]);
		return Range;
	}(Embodied);

	this.wedeploy.Range = Range;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var Embodied = this.wedeploy.Embodied;
	var FilterBody = this.wedeploy.FilterBody;
	var Geo = this.wedeploy.Geo;
	var Range = this.wedeploy.Range;

	/**
  * Class responsible for building filters.
  * @extends {Embodied}
  */

	var Filter = function (_Embodied) {
		babelHelpers.inherits(Filter, _Embodied);

		/**
   * Constructs a {@link Filter} instance.
   * @param {string} field The name of the field to filter by.
   * @param {*} operatorOrValue If a third param is given, this should
   *   be the filter's operator (like ">="). Otherwise, this will be
   *   used as the filter's value, and the filter's operator will be "=".
   * @param {*=} opt_value The filter's value.
   * @constructor
   */
		function Filter(field, operatorOrValue, opt_value) {
			babelHelpers.classCallCheck(this, Filter);

			var _this = babelHelpers.possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).call(this));

			_this.body_ = new FilterBody(field, operatorOrValue, opt_value);
			return _this;
		}

		/**
   * Adds a filter to be composed with this filter using the given operator.
   * @param {string} operator
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */


		babelHelpers.createClass(Filter, [{
			key: 'add',
			value: function add(operator, fieldOrFilter, opt_operatorOrValue, opt_value) {
				var filter = fieldOrFilter ? Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) : null;
				this.body_.add(operator, filter);
				return this;
			}

			/**
    * Adds filters to be composed with this filter using the given operator.
    * @param {string} operator
    * @param {...*} filters A variable amount of filters to be composed.
    * @chainnable
    */

		}, {
			key: 'addMany',
			value: function addMany(operator) {
				var _body_;

				for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					filters[_key - 1] = arguments[_key];
				}

				(_body_ = this.body_).addMany.apply(_body_, [operator].concat(filters));
				return this;
			}

			/**
    * Adds a filter to be composed with this filter using the "and" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @chainnable
    */

		}, {
			key: 'and',
			value: function and(fieldOrFilter, opt_operatorOrValue, opt_value) {
				return this.add('and', fieldOrFilter, opt_operatorOrValue, opt_value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "any" operator.
    * @param {string} field The name of the field to filter by.
    * @param {!(Array|...*)} values A variable amount of values to be used with
    *   the "none" operator. Can be passed either as a single array or as
    *   separate params.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'body',


			/**
    * Gets the json object that represents this filter.
    * @return {!Object}
    */
			value: function body() {
				return this.body_.getObject();
			}

			/**
    * Returns a {@link Filter} instance that uses the "gd" operator.
    * @param {string} field The field's name.
    * @param {*} locationOrCircle Either a `Geo.Circle` instance or a coordinate.
    * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
    *   the distance value.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'or',


			/**
    * Adds a filter to be composed with this filter using the "or" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @chainnable
    */
			value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
				return this.add('or', fieldOrFilter, opt_operatorOrValue, opt_value);
			}

			/**
    * Converts the given arguments into a {@link Filter} instance.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {!Filter}
    */

		}], [{
			key: 'any',
			value: function any(field) {
				var values = Array.prototype.slice.call(arguments, 1);
				if (values.length === 1 && values[0] instanceof Array) {
					values = values[0];
				}
				return new Filter(field, 'any', values);
			}

			/**
    * Returns a {@link Filter} instance that uses the "gp" operator.
    * This is a special use case of `Filter.polygon` for bounding
    * boxes.
    * @param {string} field The field's name.
    * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or
    *   a bounding box's upper left coordinate.
    * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'boundingBox',
			value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
				if (boxOrUpperLeft instanceof Geo.BoundingBox) {
					return Filter.polygon.apply(Filter, [field].concat(babelHelpers.toConsumableArray(boxOrUpperLeft.getPoints())));
				} else {
					return Filter.polygon(field, boxOrUpperLeft, opt_lowerRight);
				}
			}
		}, {
			key: 'distance',
			value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
				var location = locationOrCircle;
				var range = opt_rangeOrDistance;
				if (locationOrCircle instanceof Geo.Circle) {
					location = locationOrCircle.getCenter();
					range = Range.to(locationOrCircle.getRadius());
				} else if (!(opt_rangeOrDistance instanceof Range)) {
					range = Range.to(opt_rangeOrDistance);
				}
				return Filter.distanceInternal_(field, location, range);
			}

			/**
    * Returns a {@link Filter} instance that uses the "gd" operator. This
    * is just an internal helper used by `Filter.distance`.
    * @param {string} field The field's name.
    * @param {*} location A location coordinate.
    * @param {Range} range A `Range` instance.
    * @return {!Filter}
    * @protected
    * @static
    */

		}, {
			key: 'distanceInternal_',
			value: function distanceInternal_(field, location, range) {
				var value = {
					location: Embodied.toBody(location)
				};
				range = range.body();
				if (range.from) {
					value.min = range.from;
				}
				if (range.to) {
					value.max = range.to;
				}
				return Filter.field(field, 'gd', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
     * @static
    */

		}, {
			key: 'equal',
			value: function equal(field, value) {
				return new Filter(field, '=', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "exists" operator.
    * @param {string} field The field's name.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'exists',
			value: function exists(field) {
				return Filter.field(field, 'exists', null);
			}

			/**
    * Returns a {@link Filter} instance that uses the "fuzzy" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
    *   be the query, otherwise it should be the fuzziness value.
    * @param {number=} opt_fuzziness The fuzziness value.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'fuzzy',
			value: function fuzzy(fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
				return Filter.fuzzyInternal_('fuzzy', fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness);
			}

			/**
    * Returns a {@link Filter} instance that uses the given fuzzy operator. This
    * is an internal implementation used by the `Filter.fuzzy` method.
    * @param {string} operator The fuzzy operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
    *   be the query, otherwise it should be the fuzziness value.
    * @param {number=} opt_fuzziness The fuzziness value.
    * @return {!Filter}
    * @protected
    * @static
    */

		}, {
			key: 'fuzzyInternal_',
			value: function fuzzyInternal_(operator, fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
				var arg2IsString = core.isString(opt_queryOrFuzziness);

				var value = {
					query: arg2IsString ? opt_queryOrFuzziness : fieldOrQuery
				};
				var fuzziness = arg2IsString ? opt_fuzziness : opt_queryOrFuzziness;
				if (fuzziness) {
					value.fuzziness = fuzziness;
				}

				var field = arg2IsString ? fieldOrQuery : Filter.ALL;
				return Filter.field(field, operator, value);
			}

			/**
    * Returns a {@link Filter} instance that uses the ">" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
     * @static
    */

		}, {
			key: 'gt',
			value: function gt(field, value) {
				return new Filter(field, '>', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the ">=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
     * @static
    */

		}, {
			key: 'gte',
			value: function gte(field, value) {
				return new Filter(field, '>=', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "match" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'match',
			value: function match(fieldOrQuery, opt_query) {
				var field = core.isString(opt_query) ? fieldOrQuery : Filter.ALL;
				var query = core.isString(opt_query) ? opt_query : fieldOrQuery;
				return Filter.field(field, 'match', query);
			}

			/**
    * Returns a {@link Filter} instance that uses the "missing" operator.
    * @param {string} field The field's name.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'missing',
			value: function missing(field) {
				return Filter.field(field, 'missing', null);
			}

			/**
    * Returns a {@link Filter} instance that uses the "phrase" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'phrase',
			value: function phrase(fieldOrQuery, opt_query) {
				var field = core.isString(opt_query) ? fieldOrQuery : Filter.ALL;
				var query = core.isString(opt_query) ? opt_query : fieldOrQuery;
				return Filter.field(field, 'phrase', query);
			}

			/**
    * Returns a {@link Filter} instance that uses the "gp" operator.
    * @param {string} field The name of the field.
    * @param {...!Object} points Objects representing points in the polygon.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'polygon',
			value: function polygon(field) {
				for (var _len2 = arguments.length, points = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
					points[_key2 - 1] = arguments[_key2];
				}

				points = points.map(function (point) {
					return Embodied.toBody(point);
				});
				return Filter.field(field, 'gp', points);
			}

			/**
    * Returns a {@link Filter} instance that uses the "prefix" operator.
    * @param {string} fieldOrQuery If no second argument is given, this should
    *   be the query string, in which case all fields will be matched. Otherwise,
    *   this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'prefix',
			value: function prefix(fieldOrQuery, opt_query) {
				var field = opt_query ? fieldOrQuery : Filter.ALL;
				var query = opt_query ? opt_query : fieldOrQuery;
				return Filter.field(field, 'prefix', query);
			}

			/**
    * Returns a {@link Filter} instance that uses the "range" operator.
    * @param {string} field The field's name.
    * @param {*} rangeOrMin Either a `Range` instance or a the range's min value.
    * @param {*=} opt_max The range's max value.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'range',
			value: function range(field, rangeOrMin, opt_max) {
				var range = rangeOrMin;
				if (!(range instanceof Range)) {
					range = Range.range(rangeOrMin, opt_max);
				}
				return Filter.field(field, 'range', range);
			}

			/**
    * Returns a {@link Filter} instance that uses the "~" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
     * @static
    */

		}, {
			key: 'regex',
			value: function regex(field, value) {
				return new Filter(field, '~', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "gs" operator.
    * @param {string} field The field's name.
    * @param {...!Object} shapes Objects representing shapes.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'shape',
			value: function shape(field) {
				for (var _len3 = arguments.length, shapes = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
					shapes[_key3 - 1] = arguments[_key3];
				}

				shapes = shapes.map(function (shape) {
					return Embodied.toBody(shape);
				});
				var value = {
					type: 'geometrycollection',
					geometries: shapes
				};
				return Filter.field(field, 'gs', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "similar" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {?string} query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'similar',
			value: function similar(fieldOrQuery, query) {
				var field = core.isString(query) ? fieldOrQuery : Filter.ALL;
				var value = {
					query: core.isString(query) ? query : fieldOrQuery
				};
				return Filter.field(field, 'similar', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "<" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
     * @static
    */

		}, {
			key: 'lt',
			value: function lt(field, value) {
				return new Filter(field, '<', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "<=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
     * @static
    */

		}, {
			key: 'lte',
			value: function lte(field, value) {
				return new Filter(field, '<=', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "none" operator.
    * @param {string} field The name of the field to filter by.
    * @param {!(Array|...*)} value A variable amount of values to be used with
    *   the "none" operator. Can be passed either as a single array or as
    *   separate params.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'none',
			value: function none(field) {
				var values = Array.prototype.slice.call(arguments, 1);
				if (values.length === 1 && values[0] instanceof Array) {
					values = values[0];
				}
				return new Filter(field, 'none', values);
			}

			/**
    * Returns a {@link Filter} instance that uses the "!=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'notEqual',
			value: function notEqual(field, value) {
				return new Filter(field, '!=', value);
			}

			/**
    * Returns a {@link Filter} instance that uses the "not" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
			key: 'not',
			value: function not(fieldOrFilter, opt_operatorOrValue, opt_value) {
				return Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value).add('not');
			}

			/**
    * Returns a {@link Filter} instance.
    * @param {string} field The name of the field to filter by.
    * @param {*} operatorOrValue If a third param is given, this should
    *   be the filter's operator (like ">="). Otherwise, this will be
    *   used as the filter's value, and the filter's operator will be "=".
    * @param {*=} opt_value The filter's value.
    * @return {!Filter}
     * @static
    */

		}, {
			key: 'field',
			value: function field(_field, operatorOrValue, opt_value) {
				return new Filter(_field, operatorOrValue, opt_value);
			}
		}, {
			key: 'toFilter',
			value: function toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) {
				var filter = fieldOrFilter;
				if (!(filter instanceof Filter)) {
					filter = Filter.field(fieldOrFilter, opt_operatorOrValue, opt_value);
				}
				return filter;
			}
		}]);
		return Filter;
	}(Embodied);

	/**
  * String constant that represents all fields.
  * @type {string}
  * @static
  */


	Filter.ALL = '*';

	this.wedeploy.Filter = Filter;
}).call(this);
'use strict';

(function () {
	var Embodied = this.wedeploy.Embodied;
	var Range = this.wedeploy.Range;

	/**
  * Class that represents a search aggregation.
  */

	var Aggregation = function () {
		/**
   * Constructs an {@link Aggregation} instance.
   * @param {string} field The aggregation field.
   * @param {string} operator The aggregation operator.
   * @param {*=} opt_value The aggregation value.
   * @constructor
   */
		function Aggregation(field, operator, opt_value) {
			babelHelpers.classCallCheck(this, Aggregation);

			this.field_ = field;
			this.operator_ = operator;
			this.value_ = opt_value;
		}

		/**
   * Creates an {@link Aggregation} instance with the "avg" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */


		babelHelpers.createClass(Aggregation, [{
			key: 'getField',


			/**
    * Gets this aggregation's field.
    * @return {string}
    */
			value: function getField() {
				return this.field_;
			}

			/**
    * Gets this aggregation's operator.
    * @return {string}
    */

		}, {
			key: 'getOperator',
			value: function getOperator() {
				return this.operator_;
			}

			/**
    * Gets this aggregation's value.
    * @return {*}
    */

		}, {
			key: 'getValue',
			value: function getValue() {
				return this.value_;
			}

			/**
    * Creates an {@link Aggregation} instance with the "histogram" operator.
    * @param {string} field The aggregation field.
    * @param {number} interval The histogram's interval.
    * @return {!Aggregation}
    * @static
    */

		}], [{
			key: 'avg',
			value: function avg(field) {
				return Aggregation.field(field, 'avg');
			}

			/**
    * Creates an {@link Aggregation} instance with the "count" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
			key: 'count',
			value: function count(field) {
				return Aggregation.field(field, 'count');
			}

			/**
    * Creates an {@link DistanceAggregation} instance with the "geoDistance" operator.
    * @param {string} field The aggregation field.
    * @param {*} location The aggregation location.
    * @param {...!Range} ranges The aggregation ranges.
    * @return {!DistanceAggregation}
    * @static
    */

		}, {
			key: 'distance',
			value: function distance(field, location) {
				for (var _len = arguments.length, ranges = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
					ranges[_key - 2] = arguments[_key];
				}

				return new (Function.prototype.bind.apply(Aggregation.DistanceAggregation, [null].concat([field, location], ranges)))();
			}

			/**
    * Creates an {@link Aggregation} instance with the "extendedStats" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
			key: 'extendedStats',
			value: function extendedStats(field) {
				return Aggregation.field(field, 'extendedStats');
			}
		}, {
			key: 'histogram',
			value: function histogram(field, interval) {
				return new Aggregation(field, 'histogram', interval);
			}

			/**
    * Creates an {@link Aggregation} instance with the "max" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
			key: 'max',
			value: function max(field) {
				return Aggregation.field(field, 'max');
			}

			/**
    * Creates an {@link Aggregation} instance with the "min" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
			key: 'min',
			value: function min(field) {
				return Aggregation.field(field, 'min');
			}

			/**
    * Creates an {@link Aggregation} instance with the "missing" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
			key: 'missing',
			value: function missing(field) {
				return Aggregation.field(field, 'missing');
			}

			/**
    * Creates a new {@link Aggregation} instance.
    * @param {string} field The aggregation field.
    * @param {string} operator The aggregation operator.
    * @return {!Aggregation}
    * @static
    */

		}, {
			key: 'field',
			value: function field(_field, operator) {
				return new Aggregation(_field, operator);
			}

			/**
    * Creates an {@link RangeAggregation} instance with the "range" operator.
    * @param {string} field The aggregation field.
    * @param {...!Range} ranges The aggregation ranges.
    * @return {!RangeAggregation}
    * @static
    */

		}, {
			key: 'range',
			value: function range(field) {
				for (var _len2 = arguments.length, ranges = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
					ranges[_key2 - 1] = arguments[_key2];
				}

				return new (Function.prototype.bind.apply(Aggregation.RangeAggregation, [null].concat([field], ranges)))();
			}

			/**
    * Creates an {@link Aggregation} instance with the "stats" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
			key: 'stats',
			value: function stats(field) {
				return Aggregation.field(field, 'stats');
			}

			/**
    * Creates an {@link Aggregation} instance with the "sum" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
			key: 'sum',
			value: function sum(field) {
				return Aggregation.field(field, 'sum');
			}

			/**
    * Creates an {@link Aggregation} instance with the "terms" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
			key: 'terms',
			value: function terms(field) {
				return Aggregation.field(field, 'terms');
			}
		}]);
		return Aggregation;
	}();

	/**
  * Class that represents a distance aggregation.
  * @extends {Aggregation}
  */


	var DistanceAggregation = function (_Aggregation) {
		babelHelpers.inherits(DistanceAggregation, _Aggregation);

		/**
   * Constructs an {@link DistanceAggregation} instance.
   * @param {string} field The aggregation field.
   * @param {*} location The aggregation location.
   * @param {...!Range} ranges The aggregation ranges.
   * @constructor
   */
		function DistanceAggregation(field, location) {
			babelHelpers.classCallCheck(this, DistanceAggregation);

			var _this = babelHelpers.possibleConstructorReturn(this, (DistanceAggregation.__proto__ || Object.getPrototypeOf(DistanceAggregation)).call(this, field, 'geoDistance', {}));

			_this.value_.location = Embodied.toBody(location);

			for (var _len3 = arguments.length, ranges = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
				ranges[_key3 - 2] = arguments[_key3];
			}

			_this.value_.ranges = ranges.map(function (range) {
				return range.body();
			});
			return _this;
		}

		/**
   * Adds a range to this aggregation.
   * @param {*} rangeOrFrom
   * @param {*=} opt_to
   * @chainnable
   */


		babelHelpers.createClass(DistanceAggregation, [{
			key: 'range',
			value: function range(rangeOrFrom, opt_to) {
				var range = rangeOrFrom;
				if (!(range instanceof Range)) {
					range = Range.range(rangeOrFrom, opt_to);
				}
				this.value_.ranges.push(range.body());
				return this;
			}

			/**
    * Sets this aggregation's unit.
    * @param {string} unit
    * @chainnable
    */

		}, {
			key: 'unit',
			value: function unit(_unit) {
				this.value_.unit = _unit;
				return this;
			}
		}]);
		return DistanceAggregation;
	}(Aggregation);

	Aggregation.DistanceAggregation = DistanceAggregation;

	/**
  * Class that represents a range aggregation.
  * @extends {Aggregation}
  */

	var RangeAggregation = function (_Aggregation2) {
		babelHelpers.inherits(RangeAggregation, _Aggregation2);

		/**
   * Constructs an {@link RangeAggregation} instance.
   * @param {string} field The aggregation field.
   * @param {...!Range} ranges The aggregation ranges.
   * @constructor
   */
		function RangeAggregation(field) {
			babelHelpers.classCallCheck(this, RangeAggregation);

			var _this2 = babelHelpers.possibleConstructorReturn(this, (RangeAggregation.__proto__ || Object.getPrototypeOf(RangeAggregation)).call(this, field, 'range'));

			for (var _len4 = arguments.length, ranges = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
				ranges[_key4 - 1] = arguments[_key4];
			}

			_this2.value_ = ranges.map(function (range) {
				return range.body();
			});
			return _this2;
		}

		/**
   * Adds a range to this aggregation.
   * @param {*} rangeOrFrom
   * @param {*=} opt_to
   * @chainnable
   */


		babelHelpers.createClass(RangeAggregation, [{
			key: 'range',
			value: function range(rangeOrFrom, opt_to) {
				var range = rangeOrFrom;
				if (!(range instanceof Range)) {
					range = Range.range(rangeOrFrom, opt_to);
				}
				this.value_.push(range.body());
				return this;
			}
		}]);
		return RangeAggregation;
	}(Aggregation);

	Aggregation.RangeAggregation = RangeAggregation;

	this.wedeploy.Aggregation = Aggregation;
}).call(this);
'use strict';

(function () {
	var core = this.wedeployNamed.metal.core;
	var Embodied = this.wedeploy.Embodied;
	var Filter = this.wedeploy.Filter;
	var Aggregation = this.wedeploy.Aggregation;

	/**
  * Class responsible for building queries.
  * @extends {Embodied}
  */

	var Query = function (_Embodied) {
		babelHelpers.inherits(Query, _Embodied);

		function Query() {
			babelHelpers.classCallCheck(this, Query);
			return babelHelpers.possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).apply(this, arguments));
		}

		babelHelpers.createClass(Query, [{
			key: 'aggregate',


			/**
    * Adds an aggregation to this {@link Query} instance.
    * @param {string} name The aggregation name.
    * @param {!Aggregation|string} aggregationOrField Either an
    *   {@link Aggregation} instance or the name of the aggregation field.
    * @param {string=} opt_operator The aggregation operator.
    * @chainnable
    */
			value: function aggregate(name, aggregationOrField, opt_operator) {
				var aggregation = aggregationOrField;
				if (!(aggregation instanceof Aggregation)) {
					aggregation = Aggregation.field(aggregationOrField, opt_operator);
				}

				var field = aggregation.getField();
				var value = {};
				value[field] = {
					name: name,
					operator: aggregation.getOperator()
				};
				if (core.isDefAndNotNull(aggregation.getValue())) {
					value[field].value = aggregation.getValue();
				}

				if (!this.body_.aggregation) {
					this.body_.aggregation = [];
				}
				this.body_.aggregation.push(value);
				return this;
			}

			/**
    * Sets this query's type to "count".
    * @chainnable
    */

		}, {
			key: 'count',
			value: function count() {
				return this.type('count');
			}

			/**
    * Sets this query's type to "fetch".
    * @chainnable
    */

		}, {
			key: 'fetch',
			value: function fetch() {
				return this.type('fetch');
			}

			/**
    * Adds a filter to this Query.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @chainnable
    */

		}, {
			key: 'filter',
			value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
				var filter = Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value);
				if (!this.body_.filter) {
					this.body_.filter = [];
				}
				this.body_.filter.push(filter.body());
				return this;
			}

			/**
    * Sets the query offset.
    * @param {number} offset The index of the first entry that should be returned
    *   by this query.
    * @chainnable
    */

		}, {
			key: 'offset',
			value: function offset(_offset2) {
				this.body_.offset = _offset2;
				return this;
			}

			/**
    * Adds a highlight entry to this {@link Query} instance.
    * @param {string} field The field's name.
    * @chainnable
    */

		}, {
			key: 'highlight',
			value: function highlight(field) {
				if (!this.body_.highlight) {
					this.body_.highlight = [];
				}

				this.body_.highlight.push(field);
				return this;
			}

			/**
    * Sets the query limit.
    * @param {number} limit The max amount of entries that this query should return.
    * @chainnable
    */

		}, {
			key: 'limit',
			value: function limit(_limit2) {
				this.body_.limit = _limit2;
				return this;
			}

			/**
    * Adds a search to this {@link Query} instance.
    * @param {!Filter|string} filterOrTextOrField If no other arguments
    *   are passed to this function, this should be either a {@link Filter}
    *   instance or a text to be used in a match filter. In both cases
    *   the filter will be applied to all fields. Another option is to
    *   pass this as a field name instead, together with other arguments
    *   so the filter can be created.
    * @param {string=} opt_textOrOperator Either a text to be used in a
    *   match filter, or the operator that should be used.
    * @param {*=} opt_value The value to be used by the filter. Should
    *   only be passed if an operator was passed as the second argument.
    * @chainnable
    */

		}, {
			key: 'search',
			value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
				var filter = filterOrTextOrField;
				if (opt_value) {
					filter = Filter.field(filterOrTextOrField, opt_textOrOperator, opt_value);
				} else if (opt_textOrOperator) {
					filter = Filter.match(filterOrTextOrField, opt_textOrOperator);
				} else if (!(filter instanceof Filter)) {
					filter = Filter.match(filterOrTextOrField);
				}
				if (!this.body_.search) {
					this.body_.search = [];
				}
				this.body_.search.push(filter.body());
				return this;
			}

			/**
    * Adds a sort entry to this query, specifying the field this query should be
    * sorted by and, optionally, the sort direction.
    * @param {string} field The field that the query should be sorted by.
    * @param {string=} opt_direction The direction the sort operation should use.
    *   If none is given, "asc" is used by default.
    * @chainnable
    */

		}, {
			key: 'sort',
			value: function sort(field, opt_direction) {
				if (!this.body_.sort) {
					this.body_.sort = [];
				}
				var sortEntry = {};
				sortEntry[field] = opt_direction || 'asc';
				this.body_.sort.push(sortEntry);
				return this;
			}

			/**
    * Sets the query type.
    * @param {string} type The query's type. For example: "count", "fetch".
    * @chainnable
    */

		}, {
			key: 'type',
			value: function type(_type2) {
				this.body_.type = _type2;
				return this;
			}
		}], [{
			key: 'aggregate',

			/**
    * Adds an aggregation to this {@link Query} instance.
    * @param {string} name The aggregation name.
    * @param {!Aggregation|string} aggregationOrField Either an
    *   {@link Aggregation} instance or the name of the aggregation field.
    * @param {string=} opt_operator The aggregation operator.
    * @return {!Query}
    * @static
    */
			value: function aggregate(name, aggregationOrField, opt_operator) {
				return new Query().aggregate(name, aggregationOrField, opt_operator);
			}

			/**
    * Sets this query's type to "count".
    * @return {!Query}
    * @static
    */

		}, {
			key: 'count',
			value: function count() {
				return new Query().type('count');
			}

			/**
    * Sets this query's type to "fetch".
    * @return {!Query}
    * @static
    */

		}, {
			key: 'fetch',
			value: function fetch() {
				return new Query().type('fetch');
			}

			/**
    * Adds a filter to this Query.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {!Query}
    * @static
    */

		}, {
			key: 'filter',
			value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
				return new Query().filter(fieldOrFilter, opt_operatorOrValue, opt_value);
			}

			/**
    * Sets the query offset.
    * @param {number} offset The index of the first entry that should be returned
    *   by this query.
    * @return {!Query}
    * @static
    */

		}, {
			key: 'offset',
			value: function offset(_offset) {
				return new Query().offset(_offset);
			}

			/**
    * Adds a highlight entry to this {@link Query} instance.
    * @param {string} field The field's name.
    * @return {!Query}
    * @static
    */

		}, {
			key: 'highlight',
			value: function highlight(field) {
				return new Query().highlight(field);
			}

			/**
    * Sets the query limit.
    * @param {number} limit The max amount of entries that this query should return.
    * @return {!Query}
    * @static
    */

		}, {
			key: 'limit',
			value: function limit(_limit) {
				return new Query().limit(_limit);
			}

			/**
    * Adds a search to this {@link Query} instance.
    * @param {!Filter|string} filterOrTextOrField If no other arguments
    *   are passed to this function, this should be either a {@link Filter}
    *   instance or a text to be used in a match filter. In both cases
    *   the filter will be applied to all fields. Another option is to
    *   pass this as a field name instead, together with other arguments
    *   so the filter can be created.
    * @param {string=} opt_textOrOperator Either a text to be used in a
    *   match filter, or the operator that should be used.
    * @param {*=} opt_value The value to be used by the filter. Should
    *   only be passed if an operator was passed as the second argument.
    * @return {!Query}
    * @static
    */

		}, {
			key: 'search',
			value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
				return new Query().search(filterOrTextOrField, opt_textOrOperator, opt_value);
			}

			/**
    * Adds a sort entry to this query, specifying the field this query should be
    * sorted by and, optionally, the sort direction.
    * @param {string} field The field that the query should be sorted by.
    * @param {string=} opt_direction The direction the sort operation should use.
    *   If none is given, "asc" is used by default.
    * @return {!Query}
    * @static
    */

		}, {
			key: 'sort',
			value: function sort(field, opt_direction) {
				return new Query().sort(field, opt_direction);
			}

			/**
    * Sets the query type.
    * @param {string} type The query's type. For example: "count", "fetch".
    * @return {!Query}
    * @static
    */

		}, {
			key: 'type',
			value: function type(_type) {
				return new Query().type(_type);
			}
		}]);
		return Query;
	}(Embodied);

	this.wedeploy.Query = Query;
}).call(this);
'use strict';

(function () {
	var globals = this.wedeploy.globals;
	var assertNotNull = this.wedeployNamed.assertions.assertNotNull;
	var assertObject = this.wedeployNamed.assertions.assertObject;
	var assertDefAndNotNull = this.wedeployNamed.assertions.assertDefAndNotNull;
	var assertResponseSucceeded = this.wedeployNamed.assertions.assertResponseSucceeded;
	var Query = this.wedeploy.Query;

	/**
  * Class responsible for encapsulate data api calls.
  */

	var DataApiHelper = function () {

		/**
   * Constructs an {@link DataApiHelper} instance.
   * @constructor
   */
		function DataApiHelper(wedeployClient) {
			babelHelpers.classCallCheck(this, DataApiHelper);

			assertDefAndNotNull(wedeployClient, 'WeDeploy client reference must be specified');
			this.wedeployClient = wedeployClient;

			// sandbox
			this.wedeployClientInstance = wedeployClient.url(this.wedeployClient.dataUrl_);
			this.result = null;
		}

		/**
   * Sets the limit for this request's {@link Query}.
   * @param {number} limit The max amount of entries that this request should return.
   * @chainable
   */


		babelHelpers.createClass(DataApiHelper, [{
			key: 'limit',
			value: function limit(_limit) {
				this.wedeployClient.url(this.wedeployClient.dataUrl_).getOrCreateQuery().limit(_limit);

				return this;
			}
		}, {
			key: 'limit',
			value: function limit(_limit2) {
				this.getOrCreateQuery().limit(_limit2);
				return this;
			}

			/**
    * [sandbox]
    * Gets the currently used {@link Query} object. If none exists yet,
    * a new one is created.
    * @return {!Query}
    */

		}, {
			key: 'getOrCreateQuery',
			value: function getOrCreateQuery() {
				if (!this.wedeployClientInstance.query_) {
					this.wedeployClientInstance.query_ = new Query();
				}
				return this.wedeployClientInstance.query_;
			}

			/**
    * Adds a search to this request's {@link Query} instance.
    * @param {!Filter|string} filterOrTextOrField If no other arguments
    *   are passed to this function, this should be either a `Filter`
    *   instance or a text to be used in a match filter. In both cases
    *   the filter will be applied to all fields. Another option is to
    *   pass this as a field name instead, together with other arguments
    *   so the filter can be created.
    * @param {string=} opt_textOrOperator Either a text to be used in a
    *   match filter, or the operator that should be used.
    * @param {*=} opt_value The value to be used by the filter. Should
    *   only be passed if an operator was passed as the second argument.
    * @chainable
    */

		}, {
			key: 'search',
			value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
				this.wedeployClient.url(this.wedeployClient.dataUrl_).getOrCreateQuery().search(filterOrTextOrField, opt_textOrOperator, opt_value);

				return this.wedeployClient;
			}

			/**
    * Sets the offset for this request's {@link Query}.
    * @param {number} offset The index of the first entry that should be returned
    *   by this query.
    * @chainable
    */

		}, {
			key: 'offset',
			value: function offset(_offset) {
				this.wedeployClient.url(this.wedeployClient.authUrl_).getOrCreateQuery().offset(_offset);

				return this.wedeployClient;
			}

			/**
    * Adds a filter to this request's {@link Query}.
    * @param {!Filter|string} fieldOrFilter Either a Filter instance or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @chainable
    */

		}, {
			key: 'where',
			value: function where(fieldOrFilter, opt_operatorOrValue, opt_value) {
				this.wedeployClient.url(this.wedeployClient.authUrl_).getOrCreateQuery().filter(fieldOrFilter, opt_operatorOrValue, opt_value);

				return this.wedeployClient;
			}

			/**
    * Adds a highlight entry to this request's {@link Query} instance.
    * @param {string} field The field's name.
    * @chainable
    */

		}, {
			key: 'highlight',
			value: function highlight(field) {
				this.wedeployClient.url(this.wedeployClient.authUrl_).getOrCreateQuery().highlight(field);

				return this.wedeployClient;
			}

			/**
    * Adds an aggregation to this {@link Query} instance.
    * @param {string} name The aggregation name.
    * @param {!Aggregation|string} aggregationOrField Either an
    *   {@link Aggregation} instance or the name of the aggregation field.
    * @param {string=} opt_operator The aggregation operator.
    * @chainable
    */

		}, {
			key: 'aggregate',
			value: function aggregate(name, aggregationOrField, opt_operator) {
				this.wedeployClient.url(this.wedeployClient.authUrl_).getOrCreateQuery().aggregate(name, aggregationOrField, opt_operator);

				return this.wedeployClient;
			}

			/**
    * Sets this request's query type to "count".
    * @chainnable
    */

		}, {
			key: 'count',
			value: function count() {
				this.wedeployClient.url(this.wedeployClient.authUrl_).getOrCreateQuery().type('count');

				return this.wedeployClient;
			}

			/**
    * Adds a sort query to this request's body.
    * @param {string} field The field that the query should be sorted by.
    * @param {string=} opt_direction The direction the sort operation should use.
    *   If none is given, "asc" is used by default.
    * @chainnable
    */

		}, {
			key: 'orderBy',
			value: function orderBy(field, opt_direction) {
				this.wedeployClient.url(this.wedeployClient.authUrl_).getOrCreateQuery().sort(field, opt_direction);

				return this.wedeployClient;
			}

			/**
    * Insert data.
    * @param {string} collection
    * @param {Object} data
    * @return {!CancellablePromise}
    */

		}, {
			key: 'create',
			value: function create(collection, data) {
				assertNotNull(collection, "Collection key must be specified");
				assertObject(data, "Data can't be empty");

				return this.wedeployClient.url(this.wedeployClient.dataUrl_).path(collection).post(data).then(function (response) {
					return assertResponseSucceeded(response);
				}).then(function (response) {
					return response.body();
				});
			}

			/**
    * Update data.
    * @param {string} collection
    * @param {Object} data
    * @return {!CancellablePromise}
    */

		}, {
			key: 'update',
			value: function update(collection, data) {
				assertNotNull(collection, "Collection key must be specified");
				assertObject(data, "Data must be specified");

				return this.wedeployClient.url(this.wedeployClient.dataUrl_).path(collection).put(data).then(function (response) {
					return assertResponseSucceeded(response);
				}).then(function (response) {
					return response.body();
				});
			}

			/**
    * Delete data
    * @param {string} collection
    * @return {!CancellablePromise}
    */

		}, {
			key: 'delete',
			value: function _delete(collection) {
				assertNotNull(collection, "Collection key must be specified");

				return this.wedeployClient.url(this.wedeployClient.dataUrl_).path(collection).delete();
			}

			/**
    * get/findclear
    * @param  {string} collection [description]
    * @return {!CancellablePromise}            [description]
    */

		}, {
			key: 'get',
			value: function get(collection) {
				assertNotNull(collection, "Collection key must be specified");

				return this.wedeployClient.url(this.wedeployClient.dataUrl_).path(collection).get().then(function (response) {
					return assertResponseSucceeded(response);
				}).then(function (response) {
					return response.body();
				});
			}

			/**
    * TO DO
    * @param  {[type]} collection [description]
    * @return {[type]}            [description]
    */

		}, {
			key: 'all',
			value: function all(collection) {}
		}, {
			key: 'urlInstance',
			value: function urlInstance() {
				if (this.wedeployClient instanceof WeDeploy) {
					return this.wedeployClient;
				} else {
					return this.wedeployClient.url(this.wedeployClient.dataUrl_);
				}
			}

			/**
    * TO DO
    * @return {[type]} [description]
    */

		}, {
			key: 'range',
			value: function range() {}

			/**
    * TO DO
    * @return {[type]} [description]
    */

		}, {
			key: 'first',
			value: function first() {}

			/**
    * TO DO
    * @return {[type]} [description]
    */

		}, {
			key: 'last',
			value: function last() {}
		}]);
		return DataApiHelper;
	}();

	this.wedeploy.DataApiHelper = DataApiHelper;
}).call(this);
'use strict';

/**
 * Abstraction layer for string to base64 conversion
 * reference: https://github.com/nodejs/node/issues/3462
 */

(function () {
	var Base64 = function () {
		function Base64() {
			babelHelpers.classCallCheck(this, Base64);
		}

		babelHelpers.createClass(Base64, null, [{
			key: 'encodeString',

			/**
    * Creates a base-64 encoded ASCII string from a "string" of binary data.
    * @param {string} string to be encoded.
    * @return {string}
    * @static
    */
			value: function encodeString(string) {
				if (typeof btoa === 'function') {
					return btoa(string);
				}

				return new Buffer(string.toString(), 'binary');
			}
		}]);
		return Base64;
	}();

	this.wedeploy.Base64 = Base64;
}).call(this);
'use strict';

(function () {
	var globals = this.wedeploy.globals;
	var core = this.wedeployNamed.metal.core;
	var Auth = this.wedeploy.Auth;
	var AuthApiHelper = this.wedeploy.AuthApiHelper;
	var DataApiHelper = this.wedeploy.DataApiHelper;
	var Base64 = this.wedeploy.Base64;
	var Embodied = this.wedeploy.Embodied;
	var Filter = this.wedeploy.Filter;
	var Query = this.wedeploy.Query;
	var TransportFactory = this.wedeploy.TransportFactory;
	var ClientRequest = this.wedeploy.ClientRequest;
	var MultiMap = this.wedeployNamed.structs.MultiMap;
	var Uri = this.wedeploy.Uri;
	var assertUriWithNoPath = this.wedeployNamed.assertions.assertUriWithNoPath;


	var io;

	// Optimistic initialization of `io` reference from global `globals.window.io`.
	if (typeof globals.window !== 'undefined') {
		io = globals.window.io;
	}

	/**
  * The main class for making api requests. Sending requests returns a promise that is
  * resolved when the response arrives. Usage example:
  * ```javascript
  * WeDeploy
  *   .url('/data/tasks')
  *   .post({desc: 'Buy milkl'})
  *   .then(function(response) {
  *     // Handle response here.
  *     console.log(response.body())
  *   });
  * ```
  */

	var WeDeploy = function () {
		/**
   * WeDeploy constructor function.
   * @param {string} url The base url.
   * @param {...string} paths Any amount of paths to be appended to the base url.
   * @constructor
   */
		function WeDeploy(url) {
			for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				paths[_key - 1] = arguments[_key];
			}

			babelHelpers.classCallCheck(this, WeDeploy);

			if (arguments.length === 0) {
				throw new Error('Invalid arguments, try `new WeDeploy(baseUrl, url)`');
			}

			this.auth_ = null;
			this.body_ = null;
			this.url_ = Uri.joinPaths.apply(Uri, [url || ''].concat(paths));
			this.headers_ = new MultiMap();
			this.params_ = new MultiMap();
			this.withCredentials_ = true;

			this.header('Content-Type', 'application/json');
			this.header('X-Requested-With', 'XMLHttpRequest');
		}

		/**
   * Static factory for creating WeDeploy data for the given url
   * @param  {string=} opt_dataUrl The url that points to the data services.
   * @return @return {data} WeDeploy data instance
   */


		babelHelpers.createClass(WeDeploy, [{
			key: 'auth',


			/**
    * Adds authorization information to this request.
    * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
    *   an authorization token, or the email.
    * @param {string=} opt_password If a email is given as the first param,
    *   this should be the password.
    * @chainable
    */
			value: function auth(authOrTokenOrEmail, opt_password) {
				this.auth_ = authOrTokenOrEmail;
				if (!(this.auth_ instanceof Auth)) {
					this.auth_ = Auth.create(authOrTokenOrEmail, opt_password);
				}
				return this;
			}

			/**
    * Static factory for creating WeDeploy auth for the given url.
    * @param {string=} opt_authUrl The url that points to the auth service.
    */

		}, {
			key: 'body',


			/**
    * Sets the body that will be sent with this request.
    * @param {*} body
    * @chainable
    */
			value: function body(_body) {
				this.body_ = _body;
				return this;
			}

			/**
    * Converts the given body object to query params.
    * @param {!ClientRequest} clientRequest
    * @param {*} body
    * @protected
    */

		}, {
			key: 'convertBodyToParams_',
			value: function convertBodyToParams_(clientRequest, body) {
				if (core.isString(body)) {
					body = {
						body: body
					};
				} else if (body instanceof Embodied) {
					body = body.body();
				}
				Object.keys(body || {}).forEach(function (name) {
					return clientRequest.param(name, body[name]);
				});
			}

			/**
    * Creates client request and encode.
    * @param {string} method
    * @param {*} body
    * @return {!ClientRequest} clientRequest
    * @protected
    */

		}, {
			key: 'createClientRequest_',
			value: function createClientRequest_(method, body) {
				var clientRequest = new ClientRequest();

				clientRequest.body(body || this.body_);

				if (!core.isDefAndNotNull(clientRequest.body())) {
					if (this.query_) {
						clientRequest.body(this.query_.body());
					} else if (this.formData_) {
						clientRequest.body(this.formData_);
					}
				}

				clientRequest.method(method);
				clientRequest.headers(this.headers());
				clientRequest.params(this.params());
				clientRequest.url(this.url());
				clientRequest.withCredentials(this.withCredentials_);

				this.encode(clientRequest);

				return clientRequest;
			}

			/**
    * Decodes clientResponse body, parsing the body for example.
    * @param {!ClientResponse} clientResponse The response object to be decoded.
    * @return {!ClientResponse} The decoded response.
    */

		}, {
			key: 'decode',
			value: function decode(clientResponse) {
				if (WeDeploy.isContentTypeJson(clientResponse)) {
					try {
						clientResponse.body(JSON.parse(clientResponse.body()));
					} catch (err) {}
				}
				return clientResponse;
			}

			/**
    * Sends message with the DELETE http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

		}, {
			key: 'delete',
			value: function _delete(opt_body) {
				return this.sendAsync('DELETE', opt_body);
			}

			/**
    * Encodes the given {@link ClientRequest}, converting its body to an appropriate
    * format for example.
    * @param {!ClientRequest} clientRequest The request object to encode.
    * @return {!ClientRequest} The encoded request.
    */

		}, {
			key: 'encode',
			value: function encode(clientRequest) {
				var body = clientRequest.body();

				if (core.isElement(body)) {
					body = new FormData(body);
					clientRequest.body(body);
				}

				body = this.wrapWithQuery_(body);
				if (clientRequest.method() === 'GET') {
					this.convertBodyToParams_(clientRequest, body);
					clientRequest.removeBody();
					body = null;
				}

				if (typeof FormData !== 'undefined' && body instanceof FormData) {
					clientRequest.headers().remove('content-type');
				} else if (body instanceof Embodied) {
					clientRequest.body(body.toString());
				} else if (WeDeploy.isContentTypeJson(clientRequest)) {
					clientRequest.body(JSON.stringify(clientRequest.body()));
				}

				this.encodeParams_(clientRequest);
				this.resolveAuthentication_(clientRequest);

				return clientRequest;
			}

			/**
    * Encodes the params for the given request, according to their types.
    * @param {!ClientRequest} clientRequest
    * @protected
    */

		}, {
			key: 'encodeParams_',
			value: function encodeParams_(clientRequest) {
				var params = clientRequest.params();
				params.names().forEach(function (name) {
					var values = params.getAll(name);
					values.forEach(function (value, index) {
						if (value instanceof Embodied) {
							value = value.toString();
						} else if (core.isObject(value) || value instanceof Array) {
							value = JSON.stringify(value);
						}
						values[index] = value;
					});
				});
			}

			/**
    * Adds a key/value pair to be sent via the body in a `multipart/form-data` format.
    * If the body is set by other means (for example, through the `body` method), this
    * will be ignored.
    * @param {string} name
    * @param {*} value
    * @chainable
    */

		}, {
			key: 'form',
			value: function form(name, value) {
				if (typeof FormData === 'undefined') {
					throw new Error('form() is only available when FormData API is available.');
				}

				if (!this.formData_) {
					this.formData_ = new FormData();
				}
				this.formData_.append(name, value);
				return this;
			}

			/**
    * Sends message with the GET http verb.
    * @param {*=} opt_params Params to be added to the request url.
    * @return {!CancellablePromise}
    */

		}, {
			key: 'get',
			value: function get(opt_params) {
				return this.sendAsync('GET', opt_params);
			}

			/**
    * Adds a header. If the header with the same name already exists, it will
    * not be overwritten, but new value will be stored. The order is preserved.
    * @param {string} name
    * @param {*} value
    * @chainable
    */

		}, {
			key: 'header',
			value: function header(name, value) {
				if (arguments.length !== 2) {
					throw new Error('Invalid arguments');
				}
				this.headers_.set(name, value);
				return this;
			}

			/**
    * Gets the headers.
    * @return {!MultiMap}
    */

		}, {
			key: 'headers',
			value: function headers() {
				return this.headers_;
			}

			/**
    * Adds a query. If the query with the same name already exists, it will not
    * be overwritten, but new value will be stored. The order is preserved.
    * @param {string} name
    * @param {*} value
    * @chainable
    */

		}, {
			key: 'param',
			value: function param(name, value) {
				if (arguments.length !== 2) {
					throw new Error('Invalid arguments');
				}
				this.params_.set(name, value);
				return this;
			}

			/**
    * Gets the query strings map.
    * @return {!MultiMap}
    */

		}, {
			key: 'params',
			value: function params() {
				return this.params_;
			}

			/**
    * Sends message with the PATCH http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

		}, {
			key: 'patch',
			value: function patch(opt_body) {
				return this.sendAsync('PATCH', opt_body);
			}

			/**
    * Creates a new {@link WeDeploy} instance for handling the url resulting in the
    * union of the current url with the given paths.
    * @param {...string} paths Any number of paths.
    * @return {!WeDeploy} A new {@link WeDeploy} instance for handling the given paths.
    */

		}, {
			key: 'path',
			value: function path() {
				for (var _len2 = arguments.length, paths = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
					paths[_key2] = arguments[_key2];
				}

				return new (Function.prototype.bind.apply(WeDeploy, [null].concat([this.url()], paths)))().use(this.customTransport_);
			}

			/**
    * Sends message with the POST http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

		}, {
			key: 'post',
			value: function post(opt_body) {
				return this.sendAsync('POST', opt_body);
			}

			/**
    * Sends message with the PUT http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

		}, {
			key: 'put',
			value: function put(opt_body) {
				return this.sendAsync('PUT', opt_body);
			}

			/**
    * Adds the authentication information to the request.
    * @param {!ClientRequest} clientRequest
    * @protected
    */

		}, {
			key: 'resolveAuthentication_',
			value: function resolveAuthentication_(clientRequest) {
				if (!this.auth_) {
					return;
				}
				if (this.auth_.hasToken()) {
					clientRequest.header('Authorization', 'Bearer ' + this.auth_.token);
				} else {
					var credentials = this.auth_.email + ':' + this.auth_.password;
					clientRequest.header('Authorization', 'Basic ' + Base64.encodeString(credentials));
				}
			}

			/**
    * Uses transport to send request with given method name and body
    * asynchronously.
    * @param {string} method The HTTP method to be used when sending data.
    * @param {string} body Content to be sent as the request's body.
    * @return {!CancellablePromise} Deferred request.
    */

		}, {
			key: 'sendAsync',
			value: function sendAsync(method, body) {
				var transport = this.customTransport_ || TransportFactory.instance().getDefault();

				var clientRequest = this.createClientRequest_(method, body);

				return transport.send(clientRequest).then(this.decode);
			}

			/**
    * Sets the socket transport
    * @param {Object} socket implementation object.
    */

		}, {
			key: 'url',


			/**
    * Returns the URL used by this client.
    */
			value: function url() {
				return this.url_;
			}

			/**
    * Specifies {@link Transport} implementation.
    * @param {!Transport} transport The transport implementation that should be used.
    */

		}, {
			key: 'use',
			value: function use(transport) {
				this.customTransport_ = transport;
				return this;
			}

			/**
    * Gets the currently used {@link Query} object. If none exists yet,
    * a new one is created.
    * @return {!Query}
    */

		}, {
			key: 'getOrCreateQuery',
			value: function getOrCreateQuery() {
				if (!this.query_) {
					this.query_ = new Query();
				}
				return this.query_;
			}

			/**
    * Creates new socket.io instance. The parameters passed to socket.io
    * constructor will be provided:
    *
    * ```javascript
    * WeDeploy.url('http://domain:8080/path/a').watch({id: 'myId'}, {foo: true});
    * // Equals:
    * io('domain:8080/?url=path%2Fa%3Fid%3DmyId', {foo: true});
    * ```
    *
    * @param {Object=} opt_params Params to be sent with the Socket IO request.
    * @param {Object=} opt_options Object with Socket IO options.
    * @return {!io} Socket IO reference. Server events can be listened on it.
    */

		}, {
			key: 'watch',
			value: function watch(opt_params, opt_options) {
				if (typeof io === 'undefined') {
					throw new Error('Socket.io client not loaded');
				}

				var clientRequest = this.createClientRequest_('GET', opt_params);
				var uri = new Uri(clientRequest.url());
				uri.addParametersFromMultiMap(clientRequest.params());

				opt_options = opt_options || {
					forceNew: true
				};
				opt_options.query = 'url=' + encodeURIComponent(uri.getPathname() + uri.getSearch());
				opt_options.path = opt_options.path || uri.getPathname();

				return io(uri.getHost(), opt_options);
			}

			/**
    * @param {boolean} opt_withCredentials
    */

		}, {
			key: 'withCredentials',
			value: function withCredentials(_withCredentials) {
				this.withCredentials_ = !!_withCredentials;
				return this;
			}

			/**
    * Wraps the given `Embodied` instance with a {@link Query} instance if needed.
    * @param {Embodied} embodied
    * @return {Embodied}
    * @protected
    */

		}, {
			key: 'wrapWithQuery_',
			value: function wrapWithQuery_(embodied) {
				if (embodied instanceof Filter) {
					embodied = Query.filter(embodied);
				}
				return embodied;
			}
		}], [{
			key: 'data',
			value: function data(opt_dataUrl) {
				assertUriWithNoPath(opt_dataUrl, "The data url should not have a path");

				if (core.isString(opt_dataUrl)) {
					WeDeploy.dataUrl_ = opt_dataUrl;
				}
				if (!WeDeploy.data_) {
					WeDeploy.data_ = new DataApiHelper(WeDeploy);
				}
				return WeDeploy.data_;
			}
		}, {
			key: 'auth',
			value: function auth(opt_authUrl) {
				if (core.isString(opt_authUrl)) {
					WeDeploy.authUrl_ = opt_authUrl;
				}
				if (!WeDeploy.auth_) {
					WeDeploy.auth_ = new AuthApiHelper(WeDeploy);
				}
				return WeDeploy.auth_;
			}
		}, {
			key: 'socket',
			value: function socket(_socket) {
				io = _socket;
			}

			/**
    * Static factory for creating WeDeploy client for the given url.
    * @param {string} url The url that the client should use for sending requests.
    */

		}, {
			key: 'url',
			value: function url(_url) {
				return new WeDeploy(_url).use(this.customTransport_);
			}
		}]);
		return WeDeploy;
	}();

	WeDeploy.isContentTypeJson = function (clientMessage) {
		var contentType = clientMessage.headers().get('content-type') || '';
		return contentType.indexOf('application/json') === 0;
	};

	WeDeploy.auth_ = null;
	WeDeploy.authUrl_ = '';
	WeDeploy.data_ = null;
	WeDeploy.dataUrl_ = '';

	this.wedeploy.WeDeploy = WeDeploy;
}).call(this);
'use strict';

(function () {
  var globals = this.wedeploy.globals;
  var Filter = this.wedeploy.Filter;
  var Geo = this.wedeploy.Geo;
  var WeDeploy = this.wedeploy.WeDeploy;
  var Query = this.wedeploy.Query;
  var Range = this.wedeploy.Range;


  globals.window.Filter = Filter;
  globals.window.Geo = Geo;
  globals.window.Query = Query;
  globals.window.Range = Range;
  globals.window.WeDeploy = WeDeploy;
}).call(this);
}).call(this);


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNvY2tldC5pby5qcyIsIi9zb3VyY2UvY29yZS5qcyIsIi9zb3VyY2UvYXJyYXkuanMiLCIvc291cmNlL2FzeW5jLmpzIiwiL3NvdXJjZS9EaXNwb3NhYmxlLmpzIiwiL3NvdXJjZS9vYmplY3QuanMiLCIvc291cmNlL3N0cmluZy5qcyIsIi9zb3VyY2UvbWV0YWwuanMiLCIvc291cmNlL011bHRpTWFwLmpzIiwiL3NvdXJjZS9UcmVlTm9kZS5qcyIsIi9zb3VyY2Uvc3RydWN0cy5qcyIsIi9zb3VyY2UvQ2xpZW50TWVzc2FnZS5qcyIsIi9zb3VyY2UvQ2xpZW50UmVxdWVzdC5qcyIsIi9zb3VyY2UvQ2xpZW50UmVzcG9uc2UuanMiLCIvc291cmNlL1RyYW5zcG9ydC5qcyIsIi9zb3VyY2UvcGFyc2VGcm9tQW5jaG9yLmpzIiwiL3NvdXJjZS9wYXJzZS5qcyIsIi9zb3VyY2UvVXJpLmpzIiwiL3NvdXJjZS9Qcm9taXNlLmpzIiwiL3NvdXJjZS9BamF4LmpzIiwiL3NvdXJjZS9BamF4VHJhbnNwb3J0LmpzIiwiL3NvdXJjZS9UcmFuc3BvcnRGYWN0b3J5LmpzIiwiL3NvdXJjZS9nbG9iYWxzLmpzIiwiL3NvdXJjZS9hc3NlcnRpb25zLmpzIiwiL3NvdXJjZS9BdXRoLmpzIiwiL3NvdXJjZS9BdXRoUHJvdmlkZXIuanMiLCIvc291cmNlL0ZhY2Vib29rQXV0aFByb3ZpZGVyLmpzIiwiL3NvdXJjZS9HaXRodWJBdXRoUHJvdmlkZXIuanMiLCIvc291cmNlL0dvb2dsZUF1dGhQcm92aWRlci5qcyIsIi9zb3VyY2UvU3RvcmFnZU1lY2hhbmlzbS5qcyIsIi9zb3VyY2UvU3RvcmFnZS5qcyIsIi9zb3VyY2UvTG9jYWxTdG9yYWdlTWVjaGFuaXNtLmpzIiwiL3NvdXJjZS9zdG9yYWdlLmpzIiwiL3NvdXJjZS9BdXRoQXBpSGVscGVyLmpzIiwiL3NvdXJjZS9FbWJvZGllZC5qcyIsIi9zb3VyY2UvRmlsdGVyQm9keS5qcyIsIi9zb3VyY2UvR2VvLmpzIiwiL3NvdXJjZS9SYW5nZS5qcyIsIi9zb3VyY2UvRmlsdGVyLmpzIiwiL3NvdXJjZS9BZ2dyZWdhdGlvbi5qcyIsIi9zb3VyY2UvUXVlcnkuanMiLCIvc291cmNlL0RhdGFBcGlIZWxwZXIuanMiLCIvc291cmNlL0Jhc2U2NC5qcyIsIi9zb3VyY2UvV2VEZXBsb3kuanMiLCIvc291cmNlL2Jyb3dzZXIuanMiXSwibmFtZXMiOlsiY29yZSIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJwcm9wZXJ0eU5hbWUiLCJwcm9wZXJ0eVZhbHVlcyIsIl9fcHJvdG9fXyIsImlzUHJvdG90eXBlT2YiLCJGdW5jdGlvbiIsInB1c2giLCJmbiIsIm5hbWUiLCJzdHIiLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsImluZGV4T2YiLCJvcHRfb2JqZWN0Iiwib3B0X25vSW5oZXJpdGFuY2UiLCJpZCIsIlVJRF9QUk9QRVJUWSIsImhhc093blByb3BlcnR5IiwidW5pcXVlSWRDb3VudGVyXyIsIm9wdF9yZXR1cm5WYWx1ZSIsInZhbCIsInVuZGVmaW5lZCIsImlzRGVmIiwiaXNOdWxsIiwibm9kZVR5cGUiLCJ3aW5kb3ciLCJ0eXBlIiwidGhlbiIsIlN0cmluZyIsIm9wdF9tZXJnZUZuIiwibWVyZ2VkTmFtZSIsIm1lcmdlZCIsImNvbGxlY3RTdXBlckNsYXNzZXNQcm9wZXJ0eSIsIk1hdGgiLCJyYW5kb20iLCJhcnJheSIsImFycjEiLCJhcnIyIiwibGVuZ3RoIiwiaSIsImFyciIsIm9wdF9vdXRwdXQiLCJvdXRwdXQiLCJBcnJheSIsImlzQXJyYXkiLCJmbGF0dGVuIiwib2JqIiwicnYiLCJyZW1vdmVBdCIsInByb3RvdHlwZSIsInNwbGljZSIsImNhbGwiLCJzdGFydCIsIm9wdF9lbmQiLCJzbGljZWQiLCJlbmQiLCJhc3luYyIsInRocm93RXhjZXB0aW9uIiwiZXhjZXB0aW9uIiwibmV4dFRpY2siLCJydW4iLCJjYWxsYmFjayIsIm9wdF9jb250ZXh0Iiwid29ya1F1ZXVlU2NoZWR1bGVkXyIsInByb2Nlc3NXb3JrUXVldWUiLCJ3b3JrUXVldWVfIiwiV29ya0l0ZW1fIiwid29ya0l0ZW1zIiwid29ya0l0ZW0iLCJzY29wZSIsImUiLCJjYiIsImJpbmQiLCJ3cmFwQ2FsbGJhY2tfIiwic2V0SW1tZWRpYXRlIiwic2V0SW1tZWRpYXRlXyIsImdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyIsIkNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvc3RNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImlmcmFtZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiZGlzcGxheSIsInNyYyIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwid2luIiwiY29udGVudFdpbmRvdyIsImRvYyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwibWVzc2FnZSIsIm9yaWdpbiIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJob3N0Iiwib25tZXNzYWdlIiwiZGF0YSIsInBvcnQxIiwicG9ydDIiLCJjaGFubmVsIiwiaGVhZCIsInRhaWwiLCJuZXh0Iiwic2NyaXB0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwic2V0VGltZW91dCIsIkRpc3Bvc2FibGUiLCJkaXNwb3NlZF8iLCJkaXNwb3NlSW50ZXJuYWwiLCJvYmplY3QiLCJ0YXJnZXQiLCJrZXkiLCJzb3VyY2UiLCJhcmd1bWVudHMiLCJvcHRfb2JqIiwicGFydHMiLCJzcGxpdCIsInJlZHVjZSIsInBhcnQiLCJtYXBwZWRPYmoiLCJrZXlzIiwiT2JqZWN0Iiwib2JqMSIsIm9iajIiLCJrZXlzMSIsImtleXMyIiwic3RyaW5nIiwicmVwbGFjZSIsIngiLCJmbG9vciIsImFicyIsIkRhdGUiLCJub3ciLCJoYXNoIiwibGVuIiwiY2hhckNvZGVBdCIsInZhbHVlIiwiY3JlYXRlIiwiTXVsdGlNYXAiLCJ2YWx1ZXMiLCJ0b0xvd2VyQ2FzZSIsInNpemUiLCJtYXAiLCJuYW1lcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXQiLCJUcmVlTm9kZSIsInZhbHVlXyIsInBhcmVudF8iLCJjaGlsZHJlbl8iLCJjaGlsZCIsImFzc2VydENoaWxkSGFzTm9QYXJlbnQiLCJzZXRQYXJlbnQiLCJub2RlIiwiY3VycmVudCIsImdldFBhcmVudCIsImFuY2VzdG9ycyIsImluZGV4IiwiZ2V0Q2hpbGRyZW4iLCJFTVBUWV9BUlJBWSIsImRlcHRoIiwicm9vdCIsImdldENoaWxkQ291bnQiLCJyZW1vdmUiLCJwYXJlbnQiLCJvcHRfcHJlb3JkZXJGbiIsIm9wdF9wb3N0b3JkZXJGbiIsImZvckVhY2giLCJ0cmF2ZXJzZSIsIkNsaWVudE1lc3NhZ2UiLCJoZWFkZXJzXyIsIm9wdF9ib2R5IiwiYm9keV8iLCJvcHRfaGVhZGVycyIsIkNsaWVudFJlcXVlc3QiLCJwYXJhbXNfIiwid2l0aENyZWRlbnRpYWxzXyIsIm9wdF93aXRoQ3JlZGVudGlhbHMiLCJvcHRfbWV0aG9kIiwibWV0aG9kXyIsIkRFRkFVTFRfTUVUSE9EIiwib3B0X3BhcmFtcyIsIm9wdF91cmwiLCJ1cmxfIiwiQ2xpZW50UmVzcG9uc2UiLCJjbGllbnRSZXF1ZXN0IiwiY2xpZW50UmVxdWVzdF8iLCJvcHRfc3RhdHVzQ29kZSIsInN0YXR1c0NvZGVfIiwib3B0X3N0YXR1c1RleHQiLCJzdGF0dXNUZXh0XyIsInN0YXR1c0NvZGUiLCJUcmFuc3BvcnQiLCJwYXJzZUZyb21BbmNob3IiLCJvcHRfdXJpIiwibGluayIsImhyZWYiLCJob3N0bmFtZSIsInBhc3N3b3JkIiwicGF0aG5hbWUiLCJwb3J0Iiwic2VhcmNoIiwidXNlcm5hbWUiLCJwYXJzZSIsImlzRnVuY3Rpb24iLCJVUkwiLCJwYXJzZUZuXyIsIlVyaSIsInVybCIsIm1heWJlQWRkUHJvdG9jb2xBbmRIb3N0bmFtZV8iLCJtdWx0aW1hcCIsImdldEFsbCIsImFkZFBhcmFtZXRlclZhbHVlIiwiZW5zdXJlUXVlcnlJbml0aWFsaXplZF8iLCJxdWVyeSIsImFkZCIsInBhcmFtIiwidXJsRGVjb2RlIiwiZ2V0SG9zdG5hbWUiLCJnZXRQb3J0IiwiSE9TVE5BTUVfUExBQ0VIT0xERVIiLCJnZXRIb3N0IiwiZ2V0UHJvdG9jb2wiLCJnZXQiLCJxdWVyeXN0cmluZyIsImdldFBhcmFtZXRlck5hbWVzIiwiZ2V0UGFyYW1ldGVyVmFsdWVzIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2xpY2UiLCJjb250YWlucyIsInNldFBhcmFtZXRlclZhbHVlIiwiUkFORE9NX1BBUkFNIiwiZ2V0UmFuZG9tU3RyaW5nIiwiREVGQVVMVF9QUk9UT0NPTCIsImNoYXJBdCIsInJlbW92ZVBhcmFtZXRlciIsImdldFBhdGhuYW1lIiwiZ2V0U2VhcmNoIiwiZ2V0SGFzaCIsInBhcnNlZCIsInN1YnN0ciIsIm5vcm1hbGl6ZU9iamVjdCIsInBhcnNlRm4iLCJiYXNlUGF0aCIsInBhdGhzIiwicGF0aCIsImNvbmNhdCIsImpvaW4iLCJkZWNvZGVVUklDb21wb25lbnQiLCJUaGVuYWJsZSIsIklNUExFTUVOVEVEX0JZX1BST1AiLCJhZGRJbXBsZW1lbnRhdGlvbiIsImN0b3IiLCIkZ29vZ19UaGVuYWJsZSIsImlzSW1wbGVtZW50ZWRCeSIsInBhcnRpYWwiLCJhcmdzIiwibmV3QXJncyIsImFwcGx5IiwiQ2FuY2VsbGFibGVQcm9taXNlIiwicmVzb2x2ZXIiLCJzdGF0ZV8iLCJTdGF0ZV8iLCJQRU5ESU5HIiwicmVzdWx0XyIsImNhbGxiYWNrRW50cmllc18iLCJleGVjdXRpbmdfIiwiVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSIsInVuaGFuZGxlZFJlamVjdGlvbklkXyIsImhhZFVuaGFuZGxlZFJlamVjdGlvbl8iLCJzZWxmIiwicmVzb2x2ZV8iLCJGVUxGSUxMRUQiLCJyZWFzb24iLCJSRUpFQ1RFRCIsIkJMT0NLRUQiLCJDYWxsYmFja0VudHJ5XyIsInJlc29sdmUiLCJvcHRfdmFsdWUiLCJyZWplY3QiLCJvcHRfcmVhc29uIiwicmFjZSIsInByb21pc2VzIiwicHJvbWlzZSIsImFsbCIsInRvRnVsZmlsbCIsIm9uRnVsZmlsbCIsIm9uUmVqZWN0IiwiZmlyc3RGdWxmaWxsZWQiLCJ0b1JlamVjdCIsInJlYXNvbnMiLCJvcHRfb25GdWxmaWxsZWQiLCJvcHRfb25SZWplY3RlZCIsImFkZENoaWxkUHJvbWlzZV8iLCJ0aGVuQWx3YXlzIiwib25SZXNvbHZlZCIsImVyciIsImhhbmRsZVJlamVjdGlvbl8iLCJhZGRDYWxsYmFja0VudHJ5XyIsIm9uUmVqZWN0ZWQiLCJvbkZ1bGZpbGxlZCIsInRoZW5DYXRjaCIsImNhdGNoIiwiY2FuY2VsIiwib3B0X21lc3NhZ2UiLCJDYW5jZWxsYXRpb25FcnJvciIsIklTX0NBTkNFTExBVElPTl9FUlJPUiIsImNhbmNlbEludGVybmFsXyIsImNhbmNlbENoaWxkXyIsImNoaWxkUHJvbWlzZSIsImNoaWxkQ291bnQiLCJjaGlsZEluZGV4IiwiZW50cnkiLCJjYWxsYmFja0VudHJ5IiwiZXhlY3V0ZUNhbGxiYWNrXyIsInNjaGVkdWxlQ2FsbGJhY2tzXyIsInJlc3VsdCIsInVuYmxvY2tBbmRGdWxmaWxsXyIsInVuYmxvY2tBbmRSZWplY3RfIiwic3RhdGUiLCJUeXBlRXJyb3IiLCJpc09iamVjdCIsInRyeVRoZW5fIiwiYWRkVW5oYW5kbGVkUmVqZWN0aW9uXyIsInRoZW5hYmxlIiwiY2FsbGVkIiwiZXhlY3V0ZUNhbGxiYWNrc18iLCJlbnRyaWVzIiwicmVtb3ZlVW5oYW5kbGVkUmVqZWN0aW9uXyIsInAiLCJjbGVhclRpbWVvdXQiLCJzZXRVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVyIiwiaGFuZGxlciIsIlByb21pc2UiLCJBamF4IiwiYWxsSGVhZGVycyIsImhlYWRlcnMiLCJwYWlycyIsIm1ldGhvZCIsImJvZHkiLCJvcHRfdGltZW91dCIsIm9wdF9zeW5jIiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0Iiwib25sb2FkIiwiYWJvcnRlZCIsIm9uZXJyb3IiLCJlcnJvciIsImFib3J0IiwidGltZW91dCIsImFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAiLCJ3aXRoQ3JlZGVudGlhbHMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwic2VuZCIsImlzRGVmQW5kTm90TnVsbCIsIkFqYXhUcmFuc3BvcnQiLCJkZWZlcnJlZCIsInBhcmFtcyIsInJlc3BvbnNlIiwiY2xpZW50UmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwicGFyc2VSZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJoZWFkZXIiLCJUcmFuc3BvcnRGYWN0b3J5IiwidHJhbnNwb3J0cyIsIkRFRkFVTFRfVFJBTlNQT1JUX05BTUUiLCJpbXBsZW1lbnRhdGlvbk5hbWUiLCJUcmFuc3BvcnRDbGFzcyIsImluc3RhbmNlXyIsImdsb2JhbHMiLCJhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQiLCJhc3NlcnREZWZBbmROb3ROdWxsIiwiZXJyb3JNZXNzYWdlIiwiYXNzZXJ0Tm90TnVsbCIsImFzc2VydEZ1bmN0aW9uIiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQiLCJzdWNjZWVkZWQiLCJhc3NlcnRVc2VyU2lnbmVkSW4iLCJ1c2VyIiwiYXNzZXJ0VXJpV2l0aE5vUGF0aCIsInVyaSIsIkF1dGgiLCJ0b2tlbk9yRW1haWwiLCJvcHRfcGFzc3dvcmQiLCJ0b2tlbiIsImlzU3RyaW5nIiwiZW1haWwiLCJjcmVhdGVkQXQiLCJwaG90b1VybCIsIndlZGVwbG95Q2xpZW50IiwiYXV0aFVybF8iLCJhdXRoIiwicGF0Y2giLCJkZWxldGUiLCJ0b2tlbk9yVXNlcm5hbWUiLCJBdXRoUHJvdmlkZXIiLCJwcm92aWRlciIsInByb3ZpZGVyU2NvcGUiLCJyZWRpcmVjdFVyaSIsIm9wdF9hdXRoVXJsIiwic2V0UGF0aG5hbWUiLCJoYXNQcm92aWRlciIsImdldFByb3ZpZGVyIiwiaGFzUHJvdmlkZXJTY29wZSIsImdldFByb3ZpZGVyU2NvcGUiLCJoYXNSZWRpcmVjdFVyaSIsImdldFJlZGlyZWN0VXJpIiwiaGFzU2NvcGUiLCJnZXRTY29wZSIsImFzc2VydFN0cmluZ0lmRGVmQW5kTm90TnVsbCIsIkZhY2Vib29rQXV0aFByb3ZpZGVyIiwiUFJPVklERVIiLCJHaXRodWJBdXRoUHJvdmlkZXIiLCJHb29nbGVBdXRoUHJvdmlkZXIiLCJTdG9yYWdlTWVjaGFuaXNtIiwiU3RvcmFnZSIsIm1lY2hhbmlzbSIsImFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwiLCJhc3NlcnRNZWNoYW5pc21JbnRhbmNlT2YiLCJjbGVhciIsImpzb24iLCJFcnJvckNvZGUiLCJJTlZBTElEX1ZBTFVFIiwiTG9jYWxTdG9yYWdlTWVjaGFuaXNtIiwibG9jYWxTdG9yYWdlIiwic3RvcmFnZSIsImdldEl0ZW0iLCJyZW1vdmVJdGVtIiwic2V0SXRlbSIsIkF1dGhBcGlIZWxwZXIiLCJjdXJyZW50VXNlciIsIm9uU2lnbkluQ2FsbGJhY2siLCJvblNpZ25PdXRDYWxsYmFjayIsInByb2Nlc3NTaWduSW5fIiwiRmFjZWJvb2siLCJHb29nbGUiLCJHaXRodWIiLCJwb3N0IiwibWFrZVVzZXJBdXRoRnJvbURhdGEiLCJmcmFnbWVudCIsInVzZXJJZCIsInNldFdlZGVwbG95Q2xpZW50Iiwic2V0Q3JlYXRlZEF0Iiwic2V0RW1haWwiLCJzZXRJZCIsInNldE5hbWUiLCJzZXRQaG90b1VybCIsInNldFRva2VuIiwicmVkaXJlY3RBY2Nlc3NUb2tlbiIsImdldFJlZGlyZWN0QWNjZXNzVG9rZW5fIiwicmVtb3ZlVXJsRnJhZ21lbnRDb21wbGV0ZWx5XyIsImxvYWRDdXJyZW50VXNlciIsIm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfIiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsInRpdGxlIiwiYWNjZXNzX3Rva2VuIiwiYXNzZXJ0U3VwcG9ydGVkUHJvdmlkZXIiLCJzZXRSZWRpcmVjdFVyaSIsImdldEhyZWZXaXRob3V0RnJhZ21lbnRfIiwibWFrZUF1dGhvcml6YXRpb25VcmwiLCJtYXliZUNhbGxPblNpZ25PdXRDYWxsYmFja18iLCJ1bmxvYWRDdXJyZW50VXNlcl8iLCJFbWJvZGllZCIsIkZpbHRlckJvZHkiLCJmaWVsZCIsIm9wZXJhdG9yT3JWYWx1ZSIsIm9wZXJhdG9yIiwiY3JlYXRlQm9keV8iLCJvcHRfZmlsdGVyIiwiYWRkQXJyYXlPcGVyYXRvcl8iLCJmaWx0ZXIiLCJmaWx0ZXJzIiwiR2VvIiwidXBwZXJMZWZ0IiwibG93ZXJSaWdodCIsIkJvdW5kaW5nQm94IiwiY2VudGVyIiwicmFkaXVzIiwiQ2lyY2xlIiwicG9pbnRzIiwiTGluZSIsImxhdCIsImxvbiIsIlBvaW50IiwiUG9seWdvbiIsImNvb3JkaW5hdGVzIiwidG9Cb2R5IiwicG9pbnQiLCJhZGRDb29yZGluYXRlc18iLCJSYW5nZSIsImZyb20iLCJvcHRfdG8iLCJ0byIsIkZpbHRlciIsImZpZWxkT3JGaWx0ZXIiLCJvcHRfb3BlcmF0b3JPclZhbHVlIiwidG9GaWx0ZXIiLCJhZGRNYW55IiwiZ2V0T2JqZWN0IiwiYm94T3JVcHBlckxlZnQiLCJvcHRfbG93ZXJSaWdodCIsInBvbHlnb24iLCJnZXRQb2ludHMiLCJsb2NhdGlvbk9yQ2lyY2xlIiwib3B0X3JhbmdlT3JEaXN0YW5jZSIsInJhbmdlIiwiZ2V0Q2VudGVyIiwiZ2V0UmFkaXVzIiwiZGlzdGFuY2VJbnRlcm5hbF8iLCJtaW4iLCJtYXgiLCJmaWVsZE9yUXVlcnkiLCJvcHRfcXVlcnlPckZ1enppbmVzcyIsIm9wdF9mdXp6aW5lc3MiLCJmdXp6eUludGVybmFsXyIsImFyZzJJc1N0cmluZyIsImZ1enppbmVzcyIsIkFMTCIsIm9wdF9xdWVyeSIsInJhbmdlT3JNaW4iLCJvcHRfbWF4Iiwic2hhcGVzIiwic2hhcGUiLCJnZW9tZXRyaWVzIiwiQWdncmVnYXRpb24iLCJmaWVsZF8iLCJvcGVyYXRvcl8iLCJyYW5nZXMiLCJEaXN0YW5jZUFnZ3JlZ2F0aW9uIiwiaW50ZXJ2YWwiLCJSYW5nZUFnZ3JlZ2F0aW9uIiwicmFuZ2VPckZyb20iLCJ1bml0IiwiUXVlcnkiLCJhZ2dyZWdhdGlvbk9yRmllbGQiLCJvcHRfb3BlcmF0b3IiLCJhZ2dyZWdhdGlvbiIsImdldEZpZWxkIiwiZ2V0T3BlcmF0b3IiLCJnZXRWYWx1ZSIsIm9mZnNldCIsImhpZ2hsaWdodCIsImxpbWl0IiwiZmlsdGVyT3JUZXh0T3JGaWVsZCIsIm9wdF90ZXh0T3JPcGVyYXRvciIsIm1hdGNoIiwib3B0X2RpcmVjdGlvbiIsInNvcnQiLCJzb3J0RW50cnkiLCJhZ2dyZWdhdGUiLCJEYXRhQXBpSGVscGVyIiwid2VkZXBsb3lDbGllbnRJbnN0YW5jZSIsImRhdGFVcmxfIiwiZ2V0T3JDcmVhdGVRdWVyeSIsInF1ZXJ5XyIsImNvbGxlY3Rpb24iLCJwdXQiLCJXZURlcGxveSIsIkJhc2U2NCIsImJ0b2EiLCJCdWZmZXIiLCJpbyIsImF1dGhfIiwiam9pblBhdGhzIiwiYXV0aE9yVG9rZW5PckVtYWlsIiwiZm9ybURhdGFfIiwiZW5jb2RlIiwiaXNDb250ZW50VHlwZUpzb24iLCJzZW5kQXN5bmMiLCJpc0VsZW1lbnQiLCJGb3JtRGF0YSIsIndyYXBXaXRoUXVlcnlfIiwiY29udmVydEJvZHlUb1BhcmFtc18iLCJyZW1vdmVCb2R5IiwiZW5jb2RlUGFyYW1zXyIsInJlc29sdmVBdXRoZW50aWNhdGlvbl8iLCJhcHBlbmQiLCJ1c2UiLCJjdXN0b21UcmFuc3BvcnRfIiwiaGFzVG9rZW4iLCJjcmVkZW50aWFscyIsImVuY29kZVN0cmluZyIsInRyYW5zcG9ydCIsImluc3RhbmNlIiwiZ2V0RGVmYXVsdCIsImNyZWF0ZUNsaWVudFJlcXVlc3RfIiwiZGVjb2RlIiwib3B0X29wdGlvbnMiLCJmb3JjZU5ldyIsImVtYm9kaWVkIiwib3B0X2RhdGFVcmwiLCJkYXRhXyIsInNvY2tldCIsImNsaWVudE1lc3NhZ2UiLCJjb250ZW50VHlwZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QjtBQUNwQkwsY0FBU0ssS0FBVCxHQUFpQixJQUFJdEksYUFBSixDQUFrQmlJLFFBQWxCLENBQWpCO0FBQ0E7QUFDRCxXQUFPQSxTQUFTSyxLQUFoQjtBQUNBOzs7MEJBOFJhOEIsU0FBUTtBQUNyQi9CLFNBQUsrQixPQUFMO0FBQ0E7O0FBRUQ7Ozs7Ozs7dUJBSVdyWSxNQUFLO0FBQ2YsV0FBTyxJQUFJa1csUUFBSixDQUFhbFcsSUFBYixFQUFrQnNYLEdBQWxCLENBQXNCLEtBQUtDLGdCQUEzQixDQUFQO0FBQ0E7Ozs7O0FBb0ZGckIsVUFBU1UsaUJBQVQsR0FBNkIsVUFBUzBCLGFBQVQsRUFBd0I7QUFDcEQsTUFBSUMsY0FBY0QsY0FBY3RRLE9BQWQsR0FBd0JqSCxHQUF4QixDQUE0QixjQUE1QixLQUErQyxFQUFqRTtBQUNBLFNBQU93WCxZQUFZbmxCLE9BQVosQ0FBb0Isa0JBQXBCLE1BQTRDLENBQW5EO0FBQ0EsRUFIRDs7QUFLQThpQixVQUFTSyxLQUFULEdBQWlCLElBQWpCO0FBQ0FMLFVBQVN4SyxRQUFULEdBQW9CLEVBQXBCO0FBQ0F3SyxVQUFTa0MsS0FBVCxHQUFpQixJQUFqQjtBQUNBbEMsVUFBU0wsUUFBVCxHQUFvQixFQUFwQjs7MEJBRWVLOztBQ2hmZjs7O01BRU85TDtNQUNBOEg7TUFDQXJCO01BQ0FxRjtNQUNBeEI7TUFDQTVDOzs7QUFFUDFILFVBQVFuVyxNQUFSLENBQWVpZSxNQUFmLEdBQXdCQSxNQUF4QjtBQUNBOUgsVUFBUW5XLE1BQVIsQ0FBZTRjLEdBQWYsR0FBcUJBLEdBQXJCO0FBQ0F6RyxVQUFRblcsTUFBUixDQUFleWdCLEtBQWYsR0FBdUJBLEtBQXZCO0FBQ0F0SyxVQUFRblcsTUFBUixDQUFlNmQsS0FBZixHQUF1QkEsS0FBdkI7QUFDQTFILFVBQVFuVyxNQUFSLENBQWVpaUIsUUFBZixHQUEwQkEsUUFBMUIiLCJmaWxlIjoiYXBpLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuaW8gPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gX2RlcmVxXygnLi91cmwnKTtcbnZhciBwYXJzZXIgPSBfZGVyZXFfKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IF9kZXJlcV8oJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cblxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IF9kZXJlcV8oJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSBfZGVyZXFfKCcuL3NvY2tldCcpO1xuXG59LHtcIi4vbWFuYWdlclwiOjIsXCIuL3NvY2tldFwiOjQsXCIuL3VybFwiOjUsXCJkZWJ1Z1wiOjE0LFwic29ja2V0LmlvLXBhcnNlclwiOjQwfV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gX2RlcmVxXygnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IF9kZXJlcV8oJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gX2RlcmVxXygnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gX2RlcmVxXygnLi9vbicpO1xudmFyIGJpbmQgPSBfZGVyZXFfKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IF9kZXJlcV8oJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gX2RlcmVxXygnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlcih1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IHBhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBwYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24oKXtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5lbmdpbmUuaWQ7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZm4pe1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlO1xuICB0aGlzLmVtaXRBbGwoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25wb25nID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUgLSB0aGlzLmxhc3RQaW5nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uKG5zcCl7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKXtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZW5naW5lLmlkO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2bmV0IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcbiAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZygpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKHNvY2tldCl7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbihlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMucGFja2V0KHBhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWI7XG4gIHdoaWxlIChzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKSkgc3ViLmRlc3Ryb3koKTtcblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ2Rpc2Nvbm5lY3QnKTtcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdvbmNsb3NlJyk7XG5cbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG5cbiAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uKGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcblxufSx7XCIuL29uXCI6MyxcIi4vc29ja2V0XCI6NCxcImJhY2tvMlwiOjgsXCJjb21wb25lbnQtYmluZFwiOjExLFwiY29tcG9uZW50LWVtaXR0ZXJcIjoxMixcImRlYnVnXCI6MTQsXCJlbmdpbmUuaW8tY2xpZW50XCI6MTYsXCJpbmRleG9mXCI6MzIsXCJzb2NrZXQuaW8tcGFyc2VyXCI6NDB9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IF9kZXJlcV8oJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gX2RlcmVxXygndG8tYXJyYXknKTtcbnZhciBvbiA9IF9kZXJlcV8oJy4vb24nKTtcbnZhciBiaW5kID0gX2RlcmVxXygnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gX2RlcmVxXygnaGFzLWJpbmFyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldChpbywgbnNwKXtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldil7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYXJzZXJUeXBlID0gcGFyc2VyLkVWRU5UOyAvLyBkZWZhdWx0XG4gIGlmIChoYXNCaW4oYXJncykpIHsgcGFyc2VyVHlwZSA9IHBhcnNlci5CSU5BUllfRVZFTlQ7IH0gLy8gYmluYXJ5XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9IHRoaXMubnNwKSB7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGlmIChwYWNrZXQubnNwICE9IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbihpZCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbihjb21wcmVzcyl7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxufSx7XCIuL29uXCI6MyxcImNvbXBvbmVudC1iaW5kXCI6MTEsXCJjb21wb25lbnQtZW1pdHRlclwiOjEyLFwiZGVidWdcIjoxNCxcImhhcy1iaW5hcnlcIjozMCxcInNvY2tldC5pby1wYXJzZXJcIjo0MCxcInRvLWFycmF5XCI6NDN9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IF9kZXJlcV8oJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwodXJpLCBsb2Mpe1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIHZhciBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9XG4gICAgZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCJkZWJ1Z1wiOjE0LFwicGFyc2V1cmlcIjozOH1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbn0se31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcblxufSx7fV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cblxufSx7fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbiAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsxKV07XG4gICAgICBlbmNvZGVkMyA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzIpXTtcbiAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMyldO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKCk7XG5cbn0se31dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se31dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICBmdW5jdGlvbiBvbigpIHtcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG5cbn0se31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07XG59LHt9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbn0se1wiLi9kZWJ1Z1wiOjE1fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IF9kZXJlcV8oJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cbn0se1wibXNcIjozNX1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxubW9kdWxlLmV4cG9ydHMgPSAgX2RlcmVxXygnLi9saWIvJyk7XG5cbn0se1wiLi9saWIvXCI6MTd9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbn0se1wiLi9zb2NrZXRcIjoxOCxcImVuZ2luZS5pby1wYXJzZXJcIjoyN31dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IF9kZXJlcV8oJy4vdHJhbnNwb3J0cycpO1xudmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IF9kZXJlcV8oJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSBfZGVyZXFfKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlanNvbiA9IF9kZXJlcV8oJ3BhcnNlanNvbicpO1xudmFyIHBhcnNlcXMgPSBfZGVyZXFfKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogTm9vcCBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fVxuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDpcbiAgICAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKGdsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0ID9cbiAgICAgICBsb2NhdGlvbi5wb3J0IDpcbiAgICAgICAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG4gIH1cblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSBfZGVyZXFfKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSBfZGVyZXFfKCcuL3RyYW5zcG9ydHMnKTtcblNvY2tldC5wYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KXtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24ocGFja2V0KXtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KVxuICAgICwgZmFpbGVkID0gZmFsc2VcbiAgICAsIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKXtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy9IYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtcbiAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKXtcbiAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlKHRvKXtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCgpe1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBmbikge1xuICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBvcHRpb25zLCBmbikge1xuICBpZignZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICgnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcbiAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL3RyYW5zcG9ydFwiOjE5LFwiLi90cmFuc3BvcnRzXCI6MjAsXCJjb21wb25lbnQtZW1pdHRlclwiOjI2LFwiZGVidWdcIjoxNCxcImVuZ2luZS5pby1wYXJzZXJcIjoyNyxcImluZGV4b2ZcIjozMixcInBhcnNlanNvblwiOjM2LFwicGFyc2Vxc1wiOjM3LFwicGFyc2V1cmlcIjozOH1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG59LHtcImNvbXBvbmVudC1lbWl0dGVyXCI6MjYsXCJlbmdpbmUuaW8tcGFyc2VyXCI6Mjd9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSBfZGVyZXFfKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSBfZGVyZXFfKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSBfZGVyZXFfKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSBfZGVyZXFfKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL3BvbGxpbmctanNvbnBcIjoyMSxcIi4vcG9sbGluZy14aHJcIjoyMixcIi4vd2Vic29ja2V0XCI6MjQsXCJ4bWxodHRwcmVxdWVzdC1zc2xcIjoyNX1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gX2RlcmVxXygnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBDYWxsYmFja3MgY291bnQuXG4gKi9cblxudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBcbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInKyBzZWxmLmlmcmFtZUlkICsnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se1wiLi9wb2xsaW5nXCI6MjMsXCJjb21wb25lbnQtaW5oZXJpdFwiOjEzfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IF9kZXJlcV8oJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFBvbGxpbmcgPSBfZGVyZXFfKCcuL3BvbGxpbmcnKTtcbnZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpbmhlcml0ID0gX2RlcmVxXygnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkoKXt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSKG9wdHMpe1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuICAgICAgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZm4pe1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChvcHRzKXtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy54cyA9ICEhb3B0cy54cztcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG4gIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2YXIgdWk4QXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpO1xuICAgICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSB1aThBcnIubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh1aThBcnJbaWR4XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuICBSZXF1ZXN0LnJlcXVlc3RzID0ge307XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL3BvbGxpbmdcIjoyMyxcImNvbXBvbmVudC1lbWl0dGVyXCI6MjYsXCJjb21wb25lbnQtaW5oZXJpdFwiOjEzLFwiZGVidWdcIjoxNCxcInhtbGh0dHByZXF1ZXN0LXNzbFwiOjI1fV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSBfZGVyZXFfKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gX2RlcmVxXygncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gX2RlcmVxXygnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IF9kZXJlcV8oJ3llYXN0Jyk7XG52YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IF9kZXJlcV8oJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24ob25QYXVzZSl7XG4gIHZhciBwZW5kaW5nID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSgpe1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSgpe1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG59LHtcIi4uL3RyYW5zcG9ydFwiOjE5LFwiY29tcG9uZW50LWluaGVyaXRcIjoxMyxcImRlYnVnXCI6MTQsXCJlbmdpbmUuaW8tcGFyc2VyXCI6MjcsXCJwYXJzZXFzXCI6MzcsXCJ4bWxodHRwcmVxdWVzdC1zc2xcIjoyNSxcInllYXN0XCI6NDV9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IF9kZXJlcV8oJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gX2RlcmVxXygncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSBfZGVyZXFfKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gX2RlcmVxXygneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG52YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxuLyoqXG4gKiBHZXQgZWl0aGVyIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG4gKiBpbiB0aGUgYnJvd3NlciBvciB0cnkgdG8gcmVzb2x2ZSBXZWJTb2NrZXQtY29tcGF0aWJsZVxuICogaW50ZXJmYWNlIGV4cG9zZWQgYnkgYHdzYCBmb3IgTm9kZS1saWtlIGVudmlyb25tZW50LlxuICovXG5cbnZhciBXZWJTb2NrZXQgPSBCcm93c2VyV2ViU29ja2V0O1xuaWYgKCFXZWJTb2NrZXQgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHJ5IHtcbiAgICBXZWJTb2NrZXQgPSBfZGVyZXFfKCd3cycpO1xuICB9IGNhdGNoIChlKSB7IH1cbn1cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gV1Mob3B0cyl7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHZvaWQoMCk7XG4gIHZhciBvcHRzID0ge1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlXG4gIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICBvcHRzLmhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcbiAgfVxuXG4gIHRoaXMud3MgPSBCcm93c2VyV2ViU29ja2V0ID8gbmV3IFdlYlNvY2tldCh1cmkpIDogbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG5cbiAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMud3Muc3VwcG9ydHMgJiYgdGhpcy53cy5zdXBwb3J0cy5iaW5hcnkpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uT3BlbigpO1xuICB9O1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2KXtcbiAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYG9uRGF0YWAgdG8gdXNlIGEgdGltZXIgb24gaU9TLlxuICogU2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tbG91Z2hyYW4vMjA1MjAwNlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yXG4gICYmIC9pUGFkfGlQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICBXUy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhLmNhbGwoc2VsZiwgZGF0YSk7XG4gICAgfSwgMCk7XG4gIH07XG59XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbihwYWNrZXQpIHtcbiAgICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCBzZWxmLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09IHR5cGVvZiBkYXRhID8gZ2xvYmFsLkJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgICAvL2hhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvL3Rocm93IGFuIGVycm9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKEJyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIC8vIFR5cGVFcnJvciBpcyB0aHJvd24gd2hlbiBwYXNzaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgb24gU2FmYXJpXG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhLCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSgpe1xuICAgIHNlbGYuZW1pdCgnZmx1c2gnKTtcblxuICAgIC8vIGZha2UgZHJhaW5cbiAgICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24oKXtcbiAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKVxuICAgIHx8ICgnd3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se1wiLi4vdHJhbnNwb3J0XCI6MTksXCJjb21wb25lbnQtaW5oZXJpdFwiOjEzLFwiZGVidWdcIjoxNCxcImVuZ2luZS5pby1wYXJzZXJcIjoyNyxcInBhcnNlcXNcIjozNyxcIndzXCI6dW5kZWZpbmVkLFwieWVhc3RcIjo0NX1dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG52YXIgaGFzQ09SUyA9IF9kZXJlcV8oJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaChlKSB7IH1cbiAgfVxufVxuXG59LHtcImhhcy1jb3JzXCI6MzF9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG5cbn0se31dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IF9kZXJlcV8oJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IF9kZXJlcV8oJ2hhcy1iaW5hcnknKTtcbnZhciBzbGljZUJ1ZmZlciA9IF9kZXJlcV8oJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYmFzZTY0ZW5jb2RlciA9IF9kZXJlcV8oJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xudmFyIGFmdGVyID0gX2RlcmVxXygnYWZ0ZXInKTtcbnZhciB1dGY4ID0gX2RlcmVxXygndXRmOCcpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IF9kZXJlcV8oJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnXG4gICAgLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmICgnOicgIT0gY2hyKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJycgPT0gbGVuZ3RoIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGVyci50eXBlID09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgaSArPSBuO1xuICAgICAgbGVuZ3RoID0gJyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCAhPSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHZhciBudW1iZXJUb29Mb25nID0gZmFsc2U7XG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT0gMjU1KSBicmVhaztcblxuICAgICAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgbnVtYmVyVG9vTG9uZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGlmKG51bWJlclRvb0xvbmcpIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcbiAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcbiAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL2tleXNcIjoyOCxcImFmdGVyXCI6NixcImFycmF5YnVmZmVyLnNsaWNlXCI6NyxcImJhc2U2NC1hcnJheWJ1ZmZlclwiOjksXCJibG9iXCI6MTAsXCJoYXMtYmluYXJ5XCI6MjksXCJ1dGY4XCI6NDR9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG59LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5cbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcImlzYXJyYXlcIjozM31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgICAgIGlmIChvYmoudG9KU09OICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcImlzYXJyYXlcIjozM31dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuXG59LHt9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG59LHt9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbn0se31dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHt9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9ICcnICsgc3RyO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cbn0se31dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogSlNPTiBwYXJzZS5cbiAqXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcbnZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG52YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XG5cbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cblxuICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xuICB9XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHt9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcbiAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xuICB2YXIgcXJ5ID0ge307XG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICB9XG4gIHJldHVybiBxcnk7XG59O1xuXG59LHt9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgICB2YXIgc3JjID0gc3RyLFxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICAgIHVyaSA9IHt9LFxuICAgICAgICBpID0gMTQ7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICAgIH1cblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaTtcbn07XG5cbn0se31dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpO1xudmFyIGlzQnVmID0gX2RlcmVxXygnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG5cbiAgZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gICAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICB2YXIgY3VyUGxhY2VIb2xkZXIgPSAwO1xuXG4gIGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBidWYgPSBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmogJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL2lzLWJ1ZmZlclwiOjQxLFwiaXNhcnJheVwiOjMzfV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIGpzb24gPSBfZGVyZXFfKCdqc29uMycpO1xudmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG52YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gX2RlcmVxXygnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IF9kZXJlcV8oJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBuc3AgPSBmYWxzZTtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHN0ciArPSBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHM7XG4gICAgc3RyICs9ICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPSBvYmoubnNwKSB7XG4gICAgbnNwID0gdHJ1ZTtcbiAgICBzdHIgKz0gb2JqLm5zcDtcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBpZiAobnNwKSB7XG4gICAgICBzdHIgKz0gJywnO1xuICAgICAgbnNwID0gZmFsc2U7XG4gICAgfVxuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBpZiAobnNwKSBzdHIgKz0gJywnO1xuICAgIHN0ciArPSBqc29uLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIHAgPSB7fTtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGxvb2sgdXAgdHlwZVxuICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHRyeSB7XG4gICAgICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoZGF0YSl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuXG59LHtcIi4vYmluYXJ5XCI6MzksXCIuL2lzLWJ1ZmZlclwiOjQxLFwiY29tcG9uZW50LWVtaXR0ZXJcIjo0MixcImRlYnVnXCI6MTQsXCJpc2FycmF5XCI6MzMsXCJqc29uM1wiOjM0fV0sNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHt9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5hcmd1bWVudHNbNF1bMjZdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxufSx7XCJkdXBcIjoyNn1dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG5cbn0se31dLDQ0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0cmV0dXJuIHN5bWJvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0dmFyIGJ5dGUxO1xuXHRcdHZhciBieXRlMjtcblx0XHR2YXIgYnl0ZTM7XG5cdFx0dmFyIGJ5dGU0O1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cblx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gYnl0ZTE7XG5cdFx0fVxuXG5cdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRcdHZhciBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHt9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJylcbiAgLCBsZW5ndGggPSA2NFxuICAsIG1hcCA9IHt9XG4gICwgc2VlZCA9IDBcbiAgLCBpID0gMFxuICAsIHByZXY7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgdmFyIGVuY29kZWQgPSAnJztcblxuICBkbyB7XG4gICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdmFyIGRlY29kZWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cbiAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xufVxuXG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG55ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG55ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuXG59LHt9XX0se30sWzFdKSgxKVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNvcmUgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAY29uc3RcbiAqL1xuY2xhc3MgY29yZSB7XG5cdC8qKlxuXHQgKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuXHQgKiBGb28ucHJvdG90eXBlLmJhciA9IGNvcmUuYWJzdHJhY3RNZXRob2Rcblx0ICpcblx0ICogTm93IGlmIGEgc3ViY2xhc3Mgb2YgRm9vIGZhaWxzIHRvIG92ZXJyaWRlIGJhcigpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuXHQgKiB3aGVuIGJhcigpIGlzIGludm9rZWQuXG5cdCAqXG5cdCAqIEB0eXBlIHshRnVuY3Rpb259XG5cdCAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cblx0ICovXG5cdHN0YXRpYyBhYnN0cmFjdE1ldGhvZCgpIHtcblx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMb29wcyBjb25zdHJ1Y3RvciBzdXBlciBjbGFzc2VzIGNvbGxlY3RpbmcgaXRzIHByb3BlcnRpZXMgdmFsdWVzLiBJZlxuXHQgKiBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzdXBlciBjbGFzcyBgdW5kZWZpbmVkYCB3aWxsIGJlXG5cdCAqIGNvbGxlY3RlZCBhcyB2YWx1ZSBmb3IgdGhlIGNsYXNzIGhpZXJhcmNoeSBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY29uc3RydWN0b3IgQ2xhc3MgY29uc3RydWN0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBjb2xsZWN0ZWQuXG5cdCAqIEByZXR1cm4ge0FycmF5LjwqPn0gQXJyYXkgb2YgY29sbGVjdGVkIHZhbHVlcy5cblx0ICogVE9ETygqKTogUmV0aGluayBzdXBlcmNsYXNzIGxvb3AuXG5cdCAqL1xuXHRzdGF0aWMgY29sbGVjdFN1cGVyQ2xhc3Nlc1Byb3BlcnR5KGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUpIHtcblx0XHR2YXIgcHJvcGVydHlWYWx1ZXMgPSBbY29uc3RydWN0b3JbcHJvcGVydHlOYW1lXV07XG5cdFx0d2hpbGUgKGNvbnN0cnVjdG9yLl9fcHJvdG9fXyAmJiAhY29uc3RydWN0b3IuX19wcm90b19fLmlzUHJvdG90eXBlT2YoRnVuY3Rpb24pKSB7XG5cdFx0XHRjb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yLl9fcHJvdG9fXztcblx0XHRcdHByb3BlcnR5VmFsdWVzLnB1c2goY29uc3RydWN0b3JbcHJvcGVydHlOYW1lXSk7XG5cdFx0fVxuXHRcdHJldHVybiBwcm9wZXJ0eVZhbHVlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBmdW5jdGlvbi4gSWYgdGhlIGN1cnJlbnQgYnJvd3NlciBkb2Vzbid0XG5cdCAqIHN1cHBvcnQgdGhlIGBuYW1lYCBwcm9wZXJ0eSwgdGhpcyB3aWxsIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBmdW5jdGlvbidzXG5cdCAqIGNvbnRlbnQgc3RyaW5nLlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBmblxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRzdGF0aWMgZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG5cdFx0aWYgKCFmbi5uYW1lKSB7XG5cdFx0XHR2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcblx0XHRcdGZuLm5hbWUgPSBzdHIuc3Vic3RyaW5nKDksIHN0ci5pbmRleE9mKCcoJykpO1xuXHRcdH1cblx0XHRyZXR1cm4gZm4ubmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFuIHVuaXF1ZSBpZC4gSWYgYG9wdF9vYmplY3RgIGFyZ3VtZW50IGlzIHBhc3NlZCwgdGhlIG9iamVjdCBpc1xuXHQgKiBtdXRhdGVkIHdpdGggYW4gdW5pcXVlIGlkLiBDb25zZWN1dGl2ZSBjYWxscyB3aXRoIHRoZSBzYW1lIG9iamVjdFxuXHQgKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuXHQgKiByZXR1cm5zLiBTZWUge0BsaW5rIGNvcmUuVUlEX1BST1BFUlRZfS5cblx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0IE9wdGlvbmFsIG9iamVjdCB0byBiZSBtdXRhdGVkIHdpdGggdGhlIHVpZC4gSWZcblx0ICogICAgIG5vdCBzcGVjaWZpZWQgdGhpcyBtZXRob2Qgb25seSByZXR1cm5zIHRoZSB1aWQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9ub0luaGVyaXRhbmNlIE9wdGlvbmFsIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzXG5cdCAqICAgICBvYmplY3QncyB1aWQgcHJvcGVydHkgY2FuIGJlIGluaGVyaXRlZCBmcm9tIHBhcmVudHMgb3Igbm90LlxuXHQgKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG5cdCAqL1xuXHRzdGF0aWMgZ2V0VWlkKG9wdF9vYmplY3QsIG9wdF9ub0luaGVyaXRhbmNlKSB7XG5cdFx0aWYgKG9wdF9vYmplY3QpIHtcblx0XHRcdHZhciBpZCA9IG9wdF9vYmplY3RbY29yZS5VSURfUFJPUEVSVFldO1xuXHRcdFx0aWYgKG9wdF9ub0luaGVyaXRhbmNlICYmICFvcHRfb2JqZWN0Lmhhc093blByb3BlcnR5KGNvcmUuVUlEX1BST1BFUlRZKSkge1xuXHRcdFx0XHRpZCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaWQgfHwgKG9wdF9vYmplY3RbY29yZS5VSURfUFJPUEVSVFldID0gY29yZS51bmlxdWVJZENvdW50ZXJfKyspO1xuXHRcdH1cblx0XHRyZXR1cm4gY29yZS51bmlxdWVJZENvdW50ZXJfKys7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLiBSZXR1cm5zIGl0cyBmaXJzdCBhcmd1bWVudC5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3JldHVyblZhbHVlIFRoZSBzaW5nbGUgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHs/fSBUaGUgZmlyc3QgYXJndW1lbnQuXG5cdCAqL1xuXHRzdGF0aWMgaWRlbnRpdHlGdW5jdGlvbihvcHRfcmV0dXJuVmFsdWUpIHtcblx0XHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgYm9vbGVhbi5cblx0ICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBib29sZWFuLlxuXHQgKi9cblx0c3RhdGljIGlzQm9vbGVhbih2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG5cdCAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgZGVmaW5lZC5cblx0ICovXG5cdHN0YXRpYyBpc0RlZih2YWwpIHtcblx0XHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbC5cblx0ICogQHBhcmFtIHsqfSB2YWxcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc0RlZkFuZE5vdE51bGwodmFsKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWYodmFsKSAmJiAhY29yZS5pc051bGwodmFsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC5cblx0ICogQHBhcmFtIHsqfSB2YWxcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc0RvY3VtZW50KHZhbCkge1xuXHRcdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSA5O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvbSBlbGVtZW50LlxuXHQgKiBAcGFyYW0geyp9IHZhbFxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzRWxlbWVudCh2YWwpIHtcblx0XHRyZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24uXG5cdCAqL1xuXHRzdGF0aWMgaXNGdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbnVsbC5cblx0ICogQHBhcmFtIHsqfSB2YWxcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc051bGwodmFsKSB7XG5cdFx0cmV0dXJuIHZhbCA9PT0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG51bWJlci5cblx0ICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cblx0ICovXG5cdHN0YXRpYyBpc051bWJlcih2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuXHQgKiBAcGFyYW0geyp9IHZhbFxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzV2luZG93KHZhbCkge1xuXHRcdHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsID09PSB2YWwud2luZG93O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBhcnJheXNcblx0ICogYW5kIGZ1bmN0aW9ucy5cblx0ICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBvYmplY3QuXG5cdCAqL1xuXHRzdGF0aWMgaXNPYmplY3QodmFsKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuXHRcdHJldHVybiB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBQcm9taXNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbFxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzUHJvbWlzZSh2YWwpIHtcblx0XHRyZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNTdHJpbmcodmFsKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZztcblx0fVxuXG5cdC8qKlxuXHQgKiBNZXJnZXMgdGhlIHZhbHVlcyBvZiBhIHN0YXRpYyBwcm9wZXJ0eSBhIGNsYXNzIHdpdGggdGhlIHZhbHVlcyBvZiB0aGF0XG5cdCAqIHByb3BlcnR5IGZvciBhbGwgaXRzIHN1cGVyIGNsYXNzZXMsIGFuZCBzdG9yZXMgaXQgYXMgYSBuZXcgc3RhdGljXG5cdCAqIHByb3BlcnR5IG9mIHRoYXQgY2xhc3MuIElmIHRoZSBzdGF0aWMgcHJvcGVydHkgYWxyZWFkeSBleGlzdGVkLCBpdCB3b24ndFxuXHQgKiBiZSByZWNhbGN1bGF0ZWQuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGNvbnN0cnVjdG9yIENsYXNzIGNvbnN0cnVjdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgY29sbGVjdGVkLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOio9fSBvcHRfbWVyZ2VGbiBGdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGFuIGFycmF5IGZpbGxlZFxuXHQgKiAgIHdpdGggdGhlIHZhbHVlcyBvZiB0aGUgcHJvcGVydHkgZm9yIHRoZSBjdXJyZW50IGNsYXNzIGFuZCBhbGwgaXRzIHN1cGVyIGNsYXNzZXMuXG5cdCAqICAgU2hvdWxkIHJldHVybiB0aGUgbWVyZ2VkIHZhbHVlIHRvIGJlIHN0b3JlZCBvbiB0aGUgY3VycmVudCBjbGFzcy5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIG1lcmdlIGhhcHBlbnMsIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG5cdHN0YXRpYyBtZXJnZVN1cGVyQ2xhc3Nlc1Byb3BlcnR5KGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUsIG9wdF9tZXJnZUZuKSB7XG5cdFx0dmFyIG1lcmdlZE5hbWUgPSBwcm9wZXJ0eU5hbWUgKyAnX01FUkdFRCc7XG5cdFx0aWYgKGNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KG1lcmdlZE5hbWUpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIG1lcmdlZCA9IGNvcmUuY29sbGVjdFN1cGVyQ2xhc3Nlc1Byb3BlcnR5KGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUpO1xuXHRcdGlmIChvcHRfbWVyZ2VGbikge1xuXHRcdFx0bWVyZ2VkID0gb3B0X21lcmdlRm4obWVyZ2VkKTtcblx0XHR9XG5cdFx0Y29uc3RydWN0b3JbbWVyZ2VkTmFtZV0gPSBtZXJnZWQ7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogTnVsbCBmdW5jdGlvbiB1c2VkIGZvciBkZWZhdWx0IHZhbHVlcyBvZiBjYWxsYmFja3MsIGV0Yy5cblx0ICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cblx0ICovXG5cdHN0YXRpYyBudWxsRnVuY3Rpb24oKSB7fVxufVxuXG4vKipcbiAqIFVuaXF1ZSBpZCBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHByb3RlY3RlZFxuICovXG5jb3JlLlVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKTtcblxuLyoqXG4gKiBDb3VudGVyIGZvciB1bmlxdWUgaWQuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuY29yZS51bmlxdWVJZENvdW50ZXJfID0gMTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnLi4vY29yZSc7XG5cbmNsYXNzIGFycmF5IHtcblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudC5cblx0ICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjFcblx0ICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjJcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBlcXVhbChhcnIxLCBhcnIyKSB7XG5cdFx0aWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgaXNuJ3QgdW5kZWZpbmVkLlxuXHQgKiBAcGFyYW0geyFBcnJheX0gYXJyXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRzdGF0aWMgZmlyc3REZWZpbmVkVmFsdWUoYXJyKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhcnJbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gYXJyW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dCBuZXN0ZWQgYXJyYXkgdG8gYmVjb21lIGZsYXQuXG5cdCAqIEBwYXJhbSB7QXJyYXkuPCp8QXJyYXkuPCo+Pn0gYXJyIE5lc3RlZCBhcnJheSB0byBmbGF0dGVuLlxuXHQgKiBAcGFyYW0ge0FycmF5LjwqPn0gb3B0X291dHB1dCBPcHRpb25hbCBvdXRwdXQgYXJyYXkuXG5cdCAqIEByZXR1cm4ge0FycmF5LjwqPn0gRmxhdCBhcnJheS5cblx0ICovXG5cdHN0YXRpYyBmbGF0dGVuKGFyciwgb3B0X291dHB1dCkge1xuXHRcdHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0IHx8IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcnJbaV0pKSB7XG5cdFx0XHRcdGFycmF5LmZsYXR0ZW4oYXJyW2ldLCBvdXRwdXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goYXJyW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgcGFydGljdWxhciB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuXHQgKiBAcGFyYW0ge0FycmF5LjxUPn0gYXJyIEFycmF5IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuXHQgKiBAcGFyYW0ge1R9IG9iaiBPYmplY3QgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRzdGF0aWMgcmVtb3ZlKGFyciwgb2JqKSB7XG5cdFx0dmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuXHRcdHZhciBydjtcblx0XHRpZiAoIChydiA9IGkgPj0gMCkgKSB7XG5cdFx0XHRhcnJheS5yZW1vdmVBdChhcnIsIGkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcnY7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBmcm9tIGFuIGFycmF5IHRoZSBlbGVtZW50IGF0IGluZGV4IGlcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyIEFycmF5IG9yIGFycmF5IGxpa2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXggdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG5cdCAqL1xuXHRzdGF0aWMgcmVtb3ZlQXQoYXJyLCBpKSB7XG5cdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcnIsIGksIDEpLmxlbmd0aCA9PT0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTbGljZXMgdGhlIGdpdmVuIGFycmF5LCBqdXN0IGxpa2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgdGhpc1xuXHQgKiBpcyBmYXN0ZXIgYW5kIHdvcmtpbmcgb24gYWxsIGFycmF5LWxpa2Ugb2JqZWN0cyAobGlrZSBhcmd1bWVudHMpLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IGFyciBBcnJheS1saWtlIG9iamVjdCB0byBzbGljZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCB0aGF0IHNob3VsZCBzdGFydCB0aGUgc2xpY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2VuZCBUaGUgaW5kZXggd2hlcmUgdGhlIHNsaWNlIHNob3VsZCBlbmQsIG5vdFxuXHQgKiAgIGluY2x1ZGVkIGluIHRoZSBmaW5hbCBhcnJheS4gSWYgbm90IGdpdmVuLCBhbGwgZWxlbWVudHMgYWZ0ZXIgdGhlXG5cdCAqICAgc3RhcnQgaW5kZXggd2lsbCBiZSBpbmNsdWRlZC5cblx0ICogQHJldHVybiB7IUFycmF5fVxuXHQgKi9cblx0c3RhdGljIHNsaWNlKGFyciwgc3RhcnQsIG9wdF9lbmQpIHtcblx0XHR2YXIgc2xpY2VkID0gW107XG5cdFx0dmFyIGVuZCA9IGNvcmUuaXNEZWYob3B0X2VuZCkgPyBvcHRfZW5kIDogYXJyLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0c2xpY2VkLnB1c2goYXJyW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHNsaWNlZDtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheTtcbiIsIi8qIVxuICogUG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKiBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXN5bmMgPSB7fTtcblxuXG4vKipcbiAqIFRocm93IGFuIGl0ZW0gd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICBGb3JcbiAqIGV4YW1wbGUsIGlmIHByb2Nlc3NpbmcgYSBncm91cCBvZiBpdGVtcyBpbiBhIGxvb3AsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAqIHRvIHJlcG9ydCBhbiBlcnJvciB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgcmVzdCBvZiB0aGUgYmF0Y2ggdG8gYmVcbiAqIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7Kn0gZXhjZXB0aW9uXG4gKi9cbmFzeW5jLnRocm93RXhjZXB0aW9uID0gZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG5cdC8vIEVhY2ggdGhyb3cgbmVlZHMgdG8gYmUgaW4gaXRzIG93biBjb250ZXh0LlxuXHRhc3luYy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBleGNlcHRpb247XG5cdH0pO1xufTtcblxuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBjYWxsc3RhY2sgdW53aW5kcywgb3IgYXNcbiAqIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyl9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBPYmplY3QgdG8gdXNlIGFzIHRoZSBcInRoaXMgdmFsdWVcIiB3aGVuIGNhbGxpbmdcbiAqICAgICB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5hc3luYy5ydW4gPSBmdW5jdGlvbihjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0aWYgKCFhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXykge1xuXHRcdC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHNjaGVkdWxlZCwgc2NoZWR1bGUgaXQgbm93LlxuXHRcdGFzeW5jLm5leHRUaWNrKGFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlKTtcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IHRydWU7XG5cdH1cblxuXHRhc3luYy5ydW4ud29ya1F1ZXVlXy5wdXNoKFxuXHRcdG5ldyBhc3luYy5ydW4uV29ya0l0ZW1fKGNhbGxiYWNrLCBvcHRfY29udGV4dCkpO1xufTtcblxuXG4vKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xuXG5cbi8qKiBAcHJpdmF0ZSB7IUFycmF5LjwhYXN5bmMucnVuLldvcmtJdGVtXz59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXG4vKipcbiAqIFJ1biBhbnkgcGVuZGluZyBhc3luYy5ydW4gd29yayBpdGVtcy4gVGhpcyBmdW5jdGlvbiBpcyBub3QgaW50ZW5kZWRcbiAqIGZvciBnZW5lcmFsIHVzZSwgYnV0IGZvciB1c2UgYnkgZW50cnkgcG9pbnQgaGFuZGxlcnMgdG8gcnVuIGl0ZW1zIGFoZWFkIG9mXG4gKiBhc3luYy5uZXh0VGljay5cbiAqL1xuYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUgPSBmdW5jdGlvbigpIHtcblx0Ly8gTk9URTogYWRkaXRpb25hbCB3b3JrIHF1ZXVlIGl0ZW1zIG1heSBiZSBwdXNoZWQgd2hpbGUgcHJvY2Vzc2luZy5cblx0d2hpbGUgKGFzeW5jLnJ1bi53b3JrUXVldWVfLmxlbmd0aCkge1xuXHRcdC8vIERvbid0IGxldCB0aGUgd29yayBxdWV1ZSBncm93IGluZGVmaW5pdGVseS5cblx0XHR2YXIgd29ya0l0ZW1zID0gYXN5bmMucnVuLndvcmtRdWV1ZV87XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHdvcmtJdGVtID0gd29ya0l0ZW1zW2ldO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d29ya0l0ZW0uZm4uY2FsbCh3b3JrSXRlbS5zY29wZSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGFzeW5jLnRocm93RXhjZXB0aW9uKGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoZXJlIGFyZSBubyBtb3JlIHdvcmsgaXRlbXMsIHJlc2V0IHRoZSB3b3JrIHF1ZXVlLlxuXHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzY29wZVxuICovXG5hc3luYy5ydW4uV29ya0l0ZW1fID0gZnVuY3Rpb24oZm4sIHNjb3BlKSB7XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5mbiA9IGZuO1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn07XG5cblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlNcbiAqIGV4ZWN1dGlvbiBjb250ZXh0LiBzZXRUaW1lb3V0KOKApiwgMCkgYWx3YXlzIHRha2VzIGF0IGxlYXN0IDVtcyBmb3IgbGVnYWN5XG4gKiByZWFzb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlNDT1BFKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzXG4gKiAgICAgcG9zc2libGUuXG4gKiBAcGFyYW0ge1NDT1BFPX0gb3B0X2NvbnRleHQgT2JqZWN0IGluIHdob3NlIHNjb3BlIHRvIGNhbGwgdGhlIGxpc3RlbmVyLlxuICogQHRlbXBsYXRlIFNDT1BFXG4gKi9cbmFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdHZhciBjYiA9IGNhbGxiYWNrO1xuXHRpZiAob3B0X2NvbnRleHQpIHtcblx0XHRjYiA9IGNhbGxiYWNrLmJpbmQob3B0X2NvbnRleHQpO1xuXHR9XG5cdGNiID0gYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyhjYik7XG5cdC8vIEludHJvZHVjZWQgYW5kIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBJRTEwLlxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHNldEltbWVkaWF0ZShjYik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIExvb2sgZm9yIGFuZCBjYWNoZSB0aGUgY3VzdG9tIGZhbGxiYWNrIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLlxuXHRpZiAoIWFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8pIHtcblx0XHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfKCk7XG5cdH1cblx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyhjYik7XG59O1xuXG5cbi8qKlxuICogQ2FjaGUgZm9yIHRoZSBzZXRJbW1lZGlhdGUgaW1wbGVtZW50YXRpb24uXG4gKiBAdHlwZSB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9XG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gbnVsbDtcblxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3QgcG9zc2libGUgaW1wbGVtZW50YXRpb24gdG8gcnVuIGEgZnVuY3Rpb24gYXMgc29vbiBhc1xuICogdGhlIEpTIGV2ZW50IGxvb3AgaXMgaWRsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfSBUaGUgXCJzZXRJbW1lZGlhdGVcIiBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyA9IGZ1bmN0aW9uKCkge1xuXHQvLyBDcmVhdGUgYSBwcml2YXRlIG1lc3NhZ2UgY2hhbm5lbCBhbmQgdXNlIGl0IHRvIHBvc3RNZXNzYWdlIGVtcHR5IG1lc3NhZ2VzXG5cdC8vIHRvIG91cnNlbHZlcy5cblx0dmFyIENoYW5uZWw7XG5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdENoYW5uZWwgPSBNZXNzYWdlQ2hhbm5lbDtcblx0fVxuXG5cdC8vIElmIE1lc3NhZ2VDaGFubmVsIGlzIG5vdCBhdmFpbGFibGUgYW5kIHdlIGFyZSBpbiBhIGJyb3dzZXIsIGltcGxlbWVudFxuXHQvLyBhbiBpZnJhbWUgYmFzZWQgcG9seWZpbGwgaW4gYnJvd3NlcnMgdGhhdCBoYXZlIHBvc3RNZXNzYWdlIGFuZFxuXHQvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLiBUaGUgbGF0dGVyIGV4Y2x1ZGVzIElFOCBiZWNhdXNlIGl0IGhhcyBhXG5cdC8vIHN5bmNocm9ub3VzIHBvc3RNZXNzYWdlIGltcGxlbWVudGF0aW9uLlxuXHRpZiAodHlwZW9mIENoYW5uZWwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0d2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRcdENoYW5uZWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdC8vIE1ha2UgYW4gZW1wdHksIGludmlzaWJsZSBpZnJhbWUuXG5cdFx0XHR2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdGlmcmFtZS5zcmMgPSAnJztcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdFx0dmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuXHRcdFx0dmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcblx0XHRcdGRvYy5vcGVuKCk7XG5cdFx0XHRkb2Mud3JpdGUoJycpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cdFx0XHR2YXIgbWVzc2FnZSA9ICdjYWxsSW1tZWRpYXRlJyArIE1hdGgucmFuZG9tKCk7XG5cdFx0XHR2YXIgb3JpZ2luID0gd2luLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbi5sb2NhdGlvbi5ob3N0O1xuXHRcdFx0dmFyIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgb3JpZ2luIGFuZCBtZXNzYWdlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgbWVzc2FnZSB3YXNcblx0XHRcdFx0Ly8gaW50ZW5kZWQgZm9yIHVzLlxuXHRcdFx0XHRpZiAoZS5vcmlnaW4gIT09IG9yaWdpbiAmJiBlLmRhdGEgIT09IG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wb3J0MS5vbm1lc3NhZ2UoKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnBvcnQxID0ge307XG5cdFx0XHR0aGlzLnBvcnQyID0ge1xuXHRcdFx0XHRwb3N0TWVzc2FnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0d2luLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZW9mIENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuXHRcdC8vIFVzZSBhIGZpZm8gbGlua2VkIGxpc3QgdG8gY2FsbCBjYWxsYmFja3MgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdHZhciBoZWFkID0ge307XG5cdFx0dmFyIHRhaWwgPSBoZWFkO1xuXHRcdGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWFkID0gaGVhZC5uZXh0O1xuXHRcdFx0dmFyIGNiID0gaGVhZC5jYjtcblx0XHRcdGhlYWQuY2IgPSBudWxsO1xuXHRcdFx0Y2IoKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbihjYikge1xuXHRcdFx0dGFpbC5uZXh0ID0ge1xuXHRcdFx0XHRjYjogY2Jcblx0XHRcdH07XG5cdFx0XHR0YWlsID0gdGFpbC5uZXh0O1xuXHRcdFx0Y2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcblx0XHR9O1xuXHR9XG5cdC8vIEltcGxlbWVudGF0aW9uIGZvciBJRTYtODogU2NyaXB0IGVsZW1lbnRzIGZpcmUgYW4gYXN5bmNocm9ub3VzXG5cdC8vIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aGVuIGluc2VydGVkIGludG8gdGhlIERPTS5cblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW5cblx0XHRkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXHRcdHJldHVybiBmdW5jdGlvbihjYikge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBDbGVhbiB1cCBhbmQgY2FsbCB0aGUgY2FsbGJhY2suXG5cdFx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0XHRjYiA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fTtcblx0fVxuXHQvLyBGYWxsIGJhY2sgdG8gc2V0VGltZW91dCB3aXRoIDAuIEluIGJyb3dzZXJzIHRoaXMgY3JlYXRlcyBhIGRlbGF5IG9mIDVtc1xuXHQvLyBvciBtb3JlLlxuXHRyZXR1cm4gZnVuY3Rpb24oY2IpIHtcblx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0fTtcbn07XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpcyBvdmVycmlkZWQgdG8gcHJvdGVjdCBjYWxsYmFja3Mgd2l0aCBlbnRyeSBwb2ludFxuICogbW9uaXRvciBpZiB0aGUgYXBwbGljYXRpb24gbW9uaXRvcnMgZW50cnkgcG9pbnRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXMgcG9zc2libGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBUaGUgd3JhcHBlZCBjYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18gPSBmdW5jdGlvbihvcHRfcmV0dXJuVmFsdWUpIHtcblx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpc3Bvc2FibGUgdXRpbGl0eS4gV2hlbiBpbmhlcml0ZWQgcHJvdmlkZXMgdGhlIGBkaXNwb3NlYCBmdW5jdGlvbiB0byBpdHNcbiAqIHN1YmNsYXNzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIGFueSBvYmplY3QgcmVmZXJlbmNlc1xuICogd2hlbiBhbiBpbnN0YW5jZSB3b24ndCBiZSB1c2VkIGFueW1vcmUuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG4gKiBgZGlzcG9zZUludGVybmFsYCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljIGRpc3Bvc2luZyBsb2dpYy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBEaXNwb3NhYmxlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0LyoqXG5cdFx0ICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuIENhbGxzIGBkaXNwb3NlSW50ZXJuYWxgLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblx0XHRpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG5cdFx0XHR0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdFx0dGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljXG5cdCAqIGRpc3Bvc2luZyBsb2dpYyAobGlrZSBjbGVhcmluZyByZWZlcmVuY2VzIGFuZCBjYWxsaW5nIGBkaXNwb3NlYCBvbiBvdGhlclxuXHQgKiBkaXNwb3NhYmxlcykuXG5cdCAqL1xuXHRkaXNwb3NlSW50ZXJuYWwoKSB7fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNEaXNwb3NlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXNwb3NlZF87XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlzcG9zYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3Mgb2JqZWN0IHtcblx0LyoqXG5cdCAqIENvcGllcyBhbGwgdGhlIG1lbWJlcnMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0LlxuXHQgKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgVGhlIG9iamVjdHMgZnJvbSB3aGljaCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2UuXG5cdCAqL1xuXHRzdGF0aWMgbWl4aW4odGFyZ2V0KSB7XG5cdFx0dmFyIGtleSwgc291cmNlO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgZnVsbHkgcXVhbGlmaWVkIGV4dGVybmFsIG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZS5cblx0ICogQHBhcmFtIHtvYmplY3Q9fSBvcHRfb2JqIFRoZSBvYmplY3Qgd2l0aGluIHdoaWNoIHRvIGxvb2s7IGRlZmF1bHQgaXNcblx0ICogICAgIDxjb2RlPndpbmRvdzwvY29kZT4uXG5cdCAqIEByZXR1cm4gez99IFRoZSB2YWx1ZSAob2JqZWN0IG9yIHByaW1pdGl2ZSkgb3IsIGlmIG5vdCBmb3VuZCwgdW5kZWZpbmVkLlxuXHQgKi9cblx0c3RhdGljIGdldE9iamVjdEJ5TmFtZShuYW1lLCBvcHRfb2JqKSB7XG5cdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcdHJldHVybiBwYXJ0cy5yZWR1Y2UoKHBhcnQsIGtleSkgPT4gcGFydFtrZXldLCBzY29wZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG5cdCAqIHRoZWlyIHZhbHVlcyBzZXQgdG8gdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBvYmpcblx0ICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICovXG5cdHN0YXRpYyBtYXAob2JqLCBmbikge1xuXHRcdHZhciBtYXBwZWRPYmogPSB7fTtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXBwZWRPYmpba2V5c1tpXV0gPSBmbihrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFwcGVkT2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgdHdvIGdpdmVuIG9iamVjdHMgYXJlIGVxdWFsLiBUaGlzIGlzIGRvbmUgdmlhIGEgc2hhbGxvd1xuXHQgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgc2hhbGxvd0VxdWFsKG9iajEsIG9iajIpIHtcblx0XHRpZiAob2JqMSA9PT0gb2JqMikge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dmFyIGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG5cdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0aWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3Mgc3RyaW5nIHtcblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGJyZWFraW5nIHNwYWNlcyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc3RyaW5nIGFuZFxuXHQgKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG5cdCAqIFRoZSBvcmlnaW5hbCBhbmQgdGhlIHJlc3VsdCBzdHJpbmdzIHJlbmRlciB0aGUgc2FtZSB3YXkgaW4gSFRNTC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBpbiB3aGljaCB0byBjb2xsYXBzZSBzcGFjZXMuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG5cdCAqL1xuXHRzdGF0aWMgY29sbGFwc2VCcmVha2luZ1NwYWNlcyhzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHRcXHJcXG4gXSsvZywgJyAnKS5yZXBsYWNlKC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG5cdH1cblxuXHQvKipcblx0KiBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0aGF0IGFyZSBub3Qgc2FmZSB0byB1c2UgaW4gYSBSZWdFeHAuXG5cdCogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBlc2NhcGUuIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZSBjYXN0ZWRcblx0KiAgICAgdG8gb25lLlxuXHQqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cblx0Ki9cblx0c3RhdGljIGVzY2FwZVJlZ2V4KHN0cikge1xuXHRcdHJldHVybiBTdHJpbmcoc3RyKVxuXHRcdFx0LnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJylcblx0XHRcdC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXHgwOCcpO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyBhIHN0cmluZyB3aXRoIGF0IGxlYXN0IDY0LWJpdHMgb2YgcmFuZG9tbmVzcy5cblx0KiBAcmV0dXJuIHtzdHJpbmd9IEEgcmFuZG9tIHN0cmluZywgZS5nLiBzbjFzN3ZiNGdjaWMuXG5cdCovXG5cdHN0YXRpYyBnZXRSYW5kb21TdHJpbmcoKSB7XG5cdFx0dmFyIHggPSAyMTQ3NDgzNjQ4O1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KS50b1N0cmluZygzNikgK1xuXHRcdFx0TWF0aC5hYnMoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkgXiBEYXRlLm5vdygpKS50b1N0cmluZygzNik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgaGFzaGNvZGUgZm9yIGEgc3RyaW5nLiBUaGUgaGFzaGNvZGUgdmFsdWUgaXMgY29tcHV0ZWQgYnlcblx0ICogdGhlIHN1bSBhbGdvcml0aG06IHNbMF0qMzFeKG4tMSkgKyBzWzFdKjMxXihuLTIpICsgLi4uICsgc1tuLTFdLiBBIG5pY2Vcblx0ICogcHJvcGVydHkgb2YgdXNpbmcgMzEgcHJpbWUgaXMgdGhhdCB0aGUgbXVsdGlwbGljYXRpb24gY2FuIGJlIHJlcGxhY2VkIGJ5XG5cdCAqIGEgc2hpZnQgYW5kIGEgc3VidHJhY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZTogMzEqaSA9PSAoaTw8NSktaS5cblx0ICogTW9kZXJuIFZNcyBkbyB0aGlzIHNvcnQgb2Ygb3B0aW1pemF0aW9uIGF1dG9tYXRpY2FsbHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGFyZ2V0IHN0cmluZy5cblx0ICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgaGFzaGNvZGUuXG5cdCAqL1xuXHRzdGF0aWMgaGFzaENvZGUodmFsKSB7XG5cdFx0dmFyIGhhc2ggPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGhhc2ggPSAzMSAqIGhhc2ggKyB2YWwuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggJT0gMHgxMDAwMDAwMDA7XG5cdFx0fVxuXHRcdHJldHVybiBoYXNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIGludGVydmFsIGludG8gdGhlIHN0cmluZyB3aXRoIHNwZWNpZmllZCB2YWx1ZSwgZS5nLlxuXHQgKiBgcmVwbGFjZUludGVydmFsKFwiYWJjZGVcIiwgMSwgNCwgXCJcIilgIHJldHVybnMgXCJhZVwiLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbnB1dCBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCByZXBsYWNlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRzdGF0aWMgcmVwbGFjZUludGVydmFsKHN0ciwgc3RhcnQsIGVuZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdGFydCkgKyB2YWx1ZSArIHN0ci5zdWJzdHJpbmcoZW5kKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBjb3JlIGZyb20gJy4vY29yZSc7XG5pbXBvcnQgYXJyYXkgZnJvbSAnLi9hcnJheS9hcnJheSc7XG5pbXBvcnQgYXN5bmMgZnJvbSAnLi9hc3luYy9hc3luYyc7XG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZSc7XG5pbXBvcnQgb2JqZWN0IGZyb20gJy4vb2JqZWN0L29iamVjdCc7XG5pbXBvcnQgc3RyaW5nIGZyb20gJy4vc3RyaW5nL3N0cmluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmU7XG5leHBvcnQgeyBjb3JlLCBhcnJheSwgYXN5bmMsIERpc3Bvc2FibGUsIG9iamVjdCwgc3RyaW5nIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogQSBjYWNoZWQgcmVmZXJlbmNlIHRvIHRoZSBjcmVhdGUgZnVuY3Rpb24uXG4gKi9cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIENhc2UgaW5zZW5zaXRpdmUgc3RyaW5nIE11bHRpbWFwIGltcGxlbWVudGF0aW9uLiBBbGxvd3MgbXVsdGlwbGUgdmFsdWVzIGZvclxuICogdGhlIHNhbWUga2V5IG5hbWUuXG4gKiBAZXh0ZW5kcyB7RGlzcG9zYWJsZX1cbiAqL1xuY2xhc3MgTXVsdGlNYXAgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmtleXMgPSBjcmVhdGUobnVsbCk7XG5cdFx0dGhpcy52YWx1ZXMgPSBjcmVhdGUobnVsbCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB2YWx1ZSB0byBhIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMua2V5c1tuYW1lLnRvTG93ZXJDYXNlKCldID0gbmFtZTtcblx0XHR0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBbXTtcblx0XHR0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldLnB1c2godmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyBtYXAgbmFtZXMgYW5kIHZhbHVlcy5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5rZXlzID0gY3JlYXRlKG51bGwpO1xuXHRcdHRoaXMudmFsdWVzID0gY3JlYXRlKG51bGwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBtYXAgY29udGFpbnMgYSB2YWx1ZSB0byB0aGUga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGNvbnRhaW5zKG5hbWUpIHtcblx0XHRyZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpIGluIHRoaXMudmFsdWVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRkaXNwb3NlSW50ZXJuYWwoKSB7XG5cdFx0dGhpcy52YWx1ZXMgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBgTXVsdGlNYXBgIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIG9iamVjdC5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBvYmpcblx0ICogQHJldHVybiB7IU11bHRpTWFwfVxuXHQgKi9cblx0c3RhdGljIGZyb21PYmplY3Qob2JqKSB7XG5cdFx0dmFyIG1hcCA9IG5ldyBNdWx0aU1hcCgpO1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1hcC5zZXQoa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBmaXJzdCBhZGRlZCB2YWx1ZSBmcm9tIGEga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGdldChuYW1lKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0cmV0dXJuIHZhbHVlc1swXTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbGwgdmFsdWVzIGZyb20gYSBrZXkgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7QXJyYXkuPCo+fVxuXHQgKi9cblx0Z2V0QWxsKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1hcCBpcyBlbXB0eSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNFbXB0eSgpIHtcblx0XHRyZXR1cm4gdGhpcy5zaXplKCkgPT09IDA7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhcnJheSBvZiBrZXkgbmFtZXMuXG5cdCAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuXHQgKi9cblx0bmFtZXMoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKS5tYXAoKGtleSkgPT4gdGhpcy5rZXlzW2tleV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIHZhbHVlcyBmcm9tIGEga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHJlbW92ZShuYW1lKSB7XG5cdFx0ZGVsZXRlIHRoaXMua2V5c1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHRcdGRlbGV0ZSB0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlIG9mIGEga2V5IG5hbWUuIFJlbGV2YW50IHRvIHJlcGxhY2UgdGhlIGN1cnJlbnQgdmFsdWVzIHdpdGhcblx0ICogYSBuZXcgb25lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMua2V5c1tuYW1lLnRvTG93ZXJDYXNlKCldID0gbmFtZTtcblx0XHR0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gW3ZhbHVlXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzaXplIG9mIHRoZSBtYXAga2V5IG5hbWVzLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLm5hbWVzKCkubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBhcnNlZCB2YWx1ZXMgYXMgYSBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlcyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTXVsdGlNYXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGFycmF5IH0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIEdlbmVyaWMgdHJlZSBub2RlIGRhdGEgc3RydWN0dXJlIHdpdGggYXJiaXRyYXJ5IG51bWJlciBvZiBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSB7Vn0gdmFsdWUgVmFsdWUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVHJlZU5vZGUge1xuXG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHZhbHVlLlxuXHRcdCAqIEBwcml2YXRlIHtWfVxuXHRcdCAqL1xuXHRcdHRoaXMudmFsdWVfID0gdmFsdWU7XG5cblx0XHQvKipcblx0XHQgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBub2RlIG9yIG51bGwgaWYgaXQgaGFzIG5vIHBhcmVudC5cblx0XHQgKiBAcHJpdmF0ZSB7VHJlZU5vZGV9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJlbnRfID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIENoaWxkIG5vZGVzIG9yIG51bGwgaW4gY2FzZSBvZiBsZWFmIG5vZGUuXG5cdFx0ICogQHByaXZhdGUge0FycmF5PCFUcmVlTm9kZT59XG5cdFx0ICovXG5cdFx0dGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgYSBjaGlsZCBub2RlIHRvIHRoaXMgbm9kZS5cblx0ICogQHBhcmFtIHshVHJlZU5vZGV9IGNoaWxkIE9ycGhhbiBjaGlsZCBub2RlLlxuXHQgKi9cblx0YWRkQ2hpbGQoY2hpbGQpIHtcblx0XHRhc3NlcnRDaGlsZEhhc05vUGFyZW50KGNoaWxkKTtcblx0XHRjaGlsZC5zZXRQYXJlbnQodGhpcyk7XG5cdFx0dGhpcy5jaGlsZHJlbl8gPSB0aGlzLmNoaWxkcmVuXyB8fCBbXTtcblx0XHR0aGlzLmNoaWxkcmVuXy5wdXNoKGNoaWxkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZWxscyB3aGV0aGVyIHRoaXMgbm9kZSBpcyB0aGUgYW5jZXN0b3Igb2YgdGhlIGdpdmVuIG5vZGUuXG5cdCAqIEBwYXJhbSB7IVRyZWVOb2RlfSBub2RlIEEgbm9kZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG5vZGUgaXMgdGhlIGFuY2VzdG9yIG9mIHtAY29kZSBub2RlfS5cblx0ICovXG5cdGNvbnRhaW5zKG5vZGUpIHtcblx0XHRsZXQgY3VycmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cdFx0d2hpbGUgKGN1cnJlbnQpIHtcblx0XHRcdGlmIChjdXJyZW50ID09PSB0aGlzKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGN1cnJlbnQuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHshQXJyYXk8VHJlZU5vZGU+fSBBbGwgYW5jZXN0b3Igbm9kZXMgaW4gYm90dG9tLXVwIG9yZGVyLlxuXHQgKi9cblx0Z2V0QW5jZXN0b3JzKCkge1xuXHRcdGxldCBhbmNlc3RvcnMgPSBbXTtcblx0XHRsZXQgbm9kZSA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cdFx0d2hpbGUgKG5vZGUpIHtcblx0XHRcdGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuXHRcdFx0bm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiBhbmNlc3RvcnM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY2hpbGQgbm9kZSBvZiB0aGlzIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQ2hpbGQgaW5kZXguXG5cdCAqIEByZXR1cm4gez9UcmVlTm9kZX0gVGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuXHQgKi9cblx0Z2V0Q2hpbGRBdChpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmdldENoaWxkcmVuKClbaW5kZXhdIHx8IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7P0FycmF5PCFUcmVlTm9kZT59IENoaWxkIG5vZGVzIG9yIG51bGwgaW4gY2FzZSBvZiBsZWFmIG5vZGUuXG5cdCAqL1xuXHRnZXRDaGlsZHJlbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbl8gfHwgVHJlZU5vZGUuRU1QVFlfQVJSQVk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuXHQgKi9cblx0Z2V0Q2hpbGRDb3VudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgYW5jZXN0b3JzIG9mIHRoZSBub2RlLlxuXHQgKi9cblx0Z2V0RGVwdGgoKSB7XG5cdFx0bGV0IGRlcHRoID0gMDtcblx0XHRsZXQgbm9kZSA9IHRoaXM7XG5cdFx0d2hpbGUgKG5vZGUuZ2V0UGFyZW50KCkpIHtcblx0XHRcdGRlcHRoKys7XG5cdFx0XHRub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRlcHRoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4gez9UcmVlTm9kZX0gUGFyZW50IG5vZGUgb3IgbnVsbCBpZiBpdCBoYXMgbm8gcGFyZW50LlxuXHQgKi9cblx0Z2V0UGFyZW50KCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudF87XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7IVRyZWVOb2RlfSBUaGUgcm9vdCBvZiB0aGUgdHJlZSBzdHJ1Y3R1cmUsIGkuZS4gdGhlIGZhcnRoZXN0XG5cdCAqIGFuY2VzdG9yIG9mIHRoZSBub2RlIG9yIHRoZSBub2RlIGl0c2VsZiBpZiBpdCBoYXMgbm8gcGFyZW50cy5cblx0ICovXG5cdGdldFJvb3QoKSB7XG5cdFx0bGV0IHJvb3QgPSB0aGlzO1xuXHRcdHdoaWxlIChyb290LmdldFBhcmVudCgpKSB7XG5cdFx0XHRyb290ID0gcm9vdC5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJvb3Q7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmFsdWUuXG5cdCAqIEByZXR1cm4ge1Z9IFRoZSB2YWx1ZS5cblx0ICovXG5cdGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlXztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBub2RlIGlzIGEgbGVhZiBub2RlLlxuXHQgKi9cblx0aXNMZWFmKCkge1xuXHRcdHJldHVybiAhdGhpcy5nZXRDaGlsZENvdW50KCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZ2l2ZW4gY2hpbGQgbm9kZSBvZiB0aGlzIG5vZGUuXG5cdCAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkIFRoZSBub2RlIHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7VHJlZU5vZGV9IFRoZSByZW1vdmVkIG5vZGUgaWYgYW55LCBudWxsIG90aGVyd2lzZS5cblx0ICovXG5cdHJlbW92ZUNoaWxkKGNoaWxkKSB7XG5cdFx0aWYgKGFycmF5LnJlbW92ZSh0aGlzLmdldENoaWxkcmVuKCksIGNoaWxkKSkge1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGlzIG5vZGUuIFRoZSBjYWxsZXJzIG11c3QgZW5zdXJlIHRoYXQgdGhlXG5cdCAqIHBhcmVudCBub2RlIGFuZCBvbmx5IHRoYXQgaGFzIHRoaXMgbm9kZSBhbW9uZyBpdHMgY2hpbGRyZW4uXG5cdCAqIEBwYXJhbSB7VHJlZU5vZGV9IHBhcmVudCBUaGUgcGFyZW50IHRvIHNldC4gSWYgbnVsbCwgdGhlIG5vZGUgd2lsbCBiZVxuXHQgKiBkZXRhY2hlZCBmcm9tIHRoZSB0cmVlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRQYXJlbnQocGFyZW50KSB7XG5cdFx0dGhpcy5wYXJlbnRfID0gcGFyZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyYXZlcnNlcyB0aGUgc3VidHJlZS4gVGhlIGZpcnN0IGNhbGxiYWNrIHN0YXJ0cyB3aXRoIHRoaXMgbm9kZSxcblx0ICogYW5kIHZpc2l0cyB0aGUgZGVzY2VuZGFudCBub2RlcyBkZXB0aC1maXJzdCwgaW4gcHJlb3JkZXIuXG5cdCAqIFRoZSBzZWNvbmQgY2FsbGJhY2ssIHN0YXJ0cyB3aXRoIGRlZXBlc3QgY2hpbGQgdGhlbiB2aXNpdHNcblx0ICogdGhlIGFuY2VzdG9yIG5vZGVzIGRlcHRoLWZpcnN0LCBpbiBwb3N0b3JkZXIuIEUuZy5cblx0ICpcblx0ICogIFx0IEFcblx0ICogICAgLyBcXFxuXHQgKiAgIEIgICBDXG5cdCAqICAvICAgLyBcXFxuXHQgKiBEICAgRSAgIEZcblx0ICpcblx0ICogcHJlb3JkZXIgLT4gWydBJywgJ0InLCAnRCcsICdDJywgJ0UnLCAnRiddXG5cdCAqIHBvc3RvcmRlciAtPiBbJ0QnLCAnQicsICdFJywgJ0YnLCAnQycsICdBJ11cblx0ICpcblx0ICogQHBhcmFtIHtmdW5jdGlvbj19IG9wdF9wcmVvcmRlckZuIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdmlzaXRpbmcgYSBub2RlLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb3B0X3Bvc3RvcmRlckZuIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSBsZWF2aW5nIGEgbm9kZS5cblx0ICovXG5cdHRyYXZlcnNlKG9wdF9wcmVvcmRlckZuLCBvcHRfcG9zdG9yZGVyRm4pIHtcblx0XHRpZiAob3B0X3ByZW9yZGVyRm4pIHtcblx0XHRcdG9wdF9wcmVvcmRlckZuKHRoaXMpO1xuXHRcdH1cblx0XHR0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnRyYXZlcnNlKG9wdF9wcmVvcmRlckZuLCBvcHRfcG9zdG9yZGVyRm4pKTtcblx0XHRpZiAob3B0X3Bvc3RvcmRlckZuKSB7XG5cdFx0XHRvcHRfcG9zdG9yZGVyRm4odGhpcyk7XG5cdFx0fVxuXHR9XG5cbn1cblxuLyoqXG4gKiBDb25zdGFudCBmb3IgZW1wdHkgYXJyYXkgdG8gYXZvaWQgdW5uZWNlc3NhcnkgYWxsb2NhdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5UcmVlTm9kZS5FTVBUWV9BUlJBWSA9IFtdO1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCBjaGlsZCBoYXMgbm8gcGFyZW50LlxuICogQHBhcmFtIHtUcmVlTm9kZX0gY2hpbGQgQSBjaGlsZC5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFzc2VydENoaWxkSGFzTm9QYXJlbnQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRpZiAoY2hpbGQuZ2V0UGFyZW50KCkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgY2hpbGQgd2l0aCBwYXJlbnQuJyk7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRyZWVOb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgTXVsdGlNYXAgZnJvbSAnLi4vTXVsdGlNYXAnO1xuaW1wb3J0IFRyZWVOb2RlIGZyb20gJy4uL1RyZWVOb2RlJztcblxuZXhwb3J0IHsgTXVsdGlNYXAsIFRyZWVOb2RlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGllbnQgbWVzc2FnZSAoZS5nLiBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZSkuXG4gKi9cbmNsYXNzIENsaWVudE1lc3NhZ2Uge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IGJvZHkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9ib2R5IFJlcXVlc3QgYm9keSB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGJvZHkgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7Kn0gUmV0dXJucyByZXF1ZXN0IGJvZHkgaWYgbm8gYm9keSB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZVxuXHQgKiAgIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdGJvZHkob3B0X2JvZHkpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfYm9keSkpIHtcblx0XHRcdHRoaXMuYm9keV8gPSBvcHRfYm9keTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5ib2R5Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiBhIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90IGJlXG5cdCAqIG92ZXJ3cml0dGVuLCBidXQgdGhlIG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBhcyB3ZWxsLiBUaGUgb3JkZXIgaXMgcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0aGVhZGVyKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcblx0XHR9XG5cdFx0dGhpcy5oZWFkZXJzXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCBoZWFkZXJzLlxuXHQgKiBAcGFyYW0ge011bHRpTWFwfE9iamVjdD19IG9wdF9oZWFkZXJzIFJlcXVlc3QgaGVhZGVycyBsaXN0IHRvXG5cdCAqICAgYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBoZWFkZXJzIHdpbGxcblx0ICogICBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IU11bHRpTWFwfENsaWVudE1lc3NhZ2V9IFJldHVybnMgbWFwIG9mIHJlcXVlc3QgaGVhZGVyc1xuXHQgKiAgIGlmIG5vIG5ldyB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX1cblx0ICogICBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdGhlYWRlcnMob3B0X2hlYWRlcnMpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfaGVhZGVycykpIHtcblx0XHRcdGlmIChvcHRfaGVhZGVycyBpbnN0YW5jZW9mIE11bHRpTWFwKSB7XG5cdFx0XHRcdHRoaXMuaGVhZGVyc18gPSBvcHRfaGVhZGVycztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuaGVhZGVyc18udmFsdWVzID0gb3B0X2hlYWRlcnM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3B0X2hlYWRlcnM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmhlYWRlcnNfO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGJvZHkuXG5cdCAqL1xuXHRyZW1vdmVCb2R5KCkge1xuXHRcdHRoaXMuYm9keV8gPSB1bmRlZmluZWQ7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50TWVzc2FnZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBDbGllbnRNZXNzYWdlIGZyb20gJy4vQ2xpZW50TWVzc2FnZSc7XG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGllbnQgcmVxdWVzdCBvYmplY3QuXG4gKiBAZXh0ZW5kcyB7Q2xpZW50TWVzc2FnZX1cbiAqL1xuY2xhc3MgQ2xpZW50UmVxdWVzdCBleHRlbmRzIENsaWVudE1lc3NhZ2Uge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMucGFyYW1zXyA9IG5ldyBNdWx0aU1hcCgpO1xuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzXyA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciB3aXRoIGNyZWRlbnRpYWxzIG9wdGlvbi5cblx0ICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dpdGhDcmVkZW50aWFsc1xuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0d2l0aENyZWRlbnRpYWxzKG9wdF93aXRoQ3JlZGVudGlhbHMpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfd2l0aENyZWRlbnRpYWxzKSkge1xuXHRcdFx0dGhpcy53aXRoQ3JlZGVudGlhbHNfID0gISFvcHRfd2l0aENyZWRlbnRpYWxzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLndpdGhDcmVkZW50aWFsc187XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWV0aG9kIFJlcXVlc3QgbWV0aG9kIHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCBtZXRob2QgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8c3RyaW5nfSBSZXR1cm5zIHJlcXVlc3QgbWV0aG9kIGlmIG5vIG5ldyB2YWx1ZSB3YXNcblx0ICogICBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0bWV0aG9kKG9wdF9tZXRob2QpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfbWV0aG9kKSkge1xuXHRcdFx0dGhpcy5tZXRob2RfID0gb3B0X21ldGhvZDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5tZXRob2RfIHx8IENsaWVudFJlcXVlc3QuREVGQVVMVF9NRVRIT0Q7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHF1ZXJ5LiBJZiBhIHF1ZXJ5IHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBub3Rcblx0ICogYmUgb3ZlcndyaXR0ZW4sIGJ1dCBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQgYXMgd2VsbC4gVGhlIG9yZGVyIGlzIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHBhcmFtKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcblx0XHR9XG5cdFx0dGhpcy5wYXJhbXNfLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IHF1ZXJ5c3RyaW5nLlxuXHQgKiBAcGFyYW0ge011bHRpTWFwfE9iamVjdD19IG9wdF9wYXJhbXMgUmVxdWVzdCBxdWVyeXN0cmluZyBtYXAgdG8gYmUgc2V0LlxuXHQgKiAgIElmIG5vbmUgaXMgZ2l2ZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhcmFtcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB8Q2xpZW50TWVzc2FnZX0gUmV0dXJucyBtYXAgb2YgcmVxdWVzdCBxdWVyeXN0cmluZyBpZlxuXHQgKiAgIG5vIG5ldyB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX1cblx0ICogICBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICovXG5cdHBhcmFtcyhvcHRfcGFyYW1zKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X3BhcmFtcykpIHtcblx0XHRcdGlmIChvcHRfcGFyYW1zIGluc3RhbmNlb2YgTXVsdGlNYXApIHtcblx0XHRcdFx0dGhpcy5wYXJhbXNfID0gb3B0X3BhcmFtcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucGFyYW1zXy52YWx1ZXMgPSBvcHRfcGFyYW1zO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wdF9wYXJhbXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnBhcmFtc187XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdXJsIFJlcXVlc3QgdXJsIHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgdXJsIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfHN0cmluZ30gUmV0dXJucyByZXF1ZXN0IHVybCBpZiBubyBuZXcgdmFsdWUgd2FzIGdpdmVuLlxuXHQgKiAgIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdHVybChvcHRfdXJsKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X3VybCkpIHtcblx0XHRcdHRoaXMudXJsXyA9IG9wdF91cmw7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMudXJsXztcblx0fVxuXG59XG5cbkNsaWVudFJlcXVlc3QuREVGQVVMVF9NRVRIT0QgPSAnR0VUJztcblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50UmVxdWVzdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBDbGllbnRNZXNzYWdlIGZyb20gJy4vQ2xpZW50TWVzc2FnZSc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsaWVudCByZXNwb25zZSBvYmplY3QuXG4gKiBAZXh0ZW5kcyB7Q2xpZW50TWVzc2FnZX1cbiAqL1xuY2xhc3MgQ2xpZW50UmVzcG9uc2UgZXh0ZW5kcyBDbGllbnRNZXNzYWdlIHtcblx0Y29uc3RydWN0b3IoY2xpZW50UmVxdWVzdCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0aWYgKCFjbGllbnRSZXF1ZXN0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY3JlYXRlIHJlc3BvbnNlIHdpdGhvdXQgcmVxdWVzdCcpO1xuXHRcdH1cblx0XHR0aGlzLmNsaWVudFJlcXVlc3RfID0gY2xpZW50UmVxdWVzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJlcXVlc3QgdGhhdCBjcmVhdGVkIHRoaXMgcmVzcG9uc2UuXG5cdCAqIEByZXR1cm4geyFDbGllbnRSZXF1ZXN0fVxuXHQgKi9cblx0cmVxdWVzdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGllbnRSZXF1ZXN0Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9zdGF0dXNDb2RlIFJlcXVlc3Qgc3RhdHVzIGNvZGUgdG8gYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuLFxuXHQgKiAgIHRoZSBjdXJyZW50IHN0YXR1cyBjb2RlIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfG51bWJlcn0gUmV0dXJucyByZXNwb25zZSBzdGF0dXMgY29kZSBpZiBubyBuZXcgdmFsdWUgd2FzXG5cdCAqICAgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuXG5cdCAqICAgYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdHN0YXR1c0NvZGUob3B0X3N0YXR1c0NvZGUpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfc3RhdHVzQ29kZSkpIHtcblx0XHRcdHRoaXMuc3RhdHVzQ29kZV8gPSBvcHRfc3RhdHVzQ29kZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdGF0dXNDb2RlXztcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlc3BvbnNlIHN0YXR1cyB0ZXh0LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zdGF0dXNUZXh0IFJlcXVlc3Qgc3RhdHVzIHRleHQgdG8gYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuLFxuXHQgKiAgIHRoZSBjdXJyZW50IHN0YXR1cyB0ZXh0IHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfG51bWJlcn0gUmV0dXJucyByZXNwb25zZSBzdGF0dXMgdGV4dCBpZiBubyBuZXcgdmFsdWUgd2FzXG5cdCAqICAgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuXG5cdCAqICAgYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdHN0YXR1c1RleHQob3B0X3N0YXR1c1RleHQpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfc3RhdHVzVGV4dCkpIHtcblx0XHRcdHRoaXMuc3RhdHVzVGV4dF8gPSBvcHRfc3RhdHVzVGV4dDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdGF0dXNUZXh0Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcmVzcG9uc2Ugc3VjY2VlZGVkLiBBbnkgc3RhdHVzIGNvZGUgMnh4IG9yIDN4eCBpcyBjb25zaWRlcmVkIHZhbGlkLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3VjY2VlZGVkKCkge1xuXHRcdHJldHVybiB0aGlzLnN0YXR1c0NvZGUoKSA+PSAyMDAgJiYgdGhpcy5zdGF0dXNDb2RlKCkgPD0gMzk5O1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50UmVzcG9uc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBjb252ZW5pZW50IGludGVyZmFjZSBmb3IgZGF0YSB0cmFuc3BvcnQuXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFRyYW5zcG9ydCB7XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgbWVzc2FnZSBmb3IgdGhlIHNwZWNpZmllZCBjbGllbnQuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3Rcblx0ICogQHJldHVybiB7IVByb21pc2V9IERlZmVycmVkIHJlcXVlc3QuXG5cdCAqL1xuXHRzZW5kKCkge31cblxufVxuXG5leHBvcnQgZGVmYXVsdCBUcmFuc3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB1cmkgc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuICogQHBhcmFtIHsqPX0gb3B0X3VyaSBPcHRpb25hbCBzdHJpbmcgVVJJIHRvIHBhcnNlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRnJvbUFuY2hvcihvcHRfdXJpKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRsaW5rLmhyZWYgPSBvcHRfdXJpO1xuXHRyZXR1cm4ge1xuXHRcdGhhc2g6IGxpbmsuaGFzaCxcblx0XHRob3N0bmFtZTogbGluay5ob3N0bmFtZSxcblx0XHRwYXNzd29yZDogbGluay5wYXNzd29yZCxcblx0XHRwYXRobmFtZTogbGluay5wYXRobmFtZVswXSA9PT0gJy8nID8gbGluay5wYXRobmFtZSA6ICcvJyArIGxpbmsucGF0aG5hbWUsXG5cdFx0cG9ydDogbGluay5wb3J0LFxuXHRcdHByb3RvY29sOiBsaW5rLnByb3RvY29sLFxuXHRcdHNlYXJjaDogbGluay5zZWFyY2gsXG5cdFx0dXNlcm5hbWU6IGxpbmsudXNlcm5hbWVcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2VGcm9tQW5jaG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHBhcnNlRnJvbUFuY2hvciBmcm9tICcuL3BhcnNlRnJvbUFuY2hvcic7XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB1cmkgc3RyaW5nIGludG8gYW4gb2JqZWN0LiBUaGUgVVJMIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZFxuICogd2hlbiBwcmVzZW50LCBvdGhlcndpc2Ugd2UnbGwgZmFsbCBiYWNrIHRvIHRoZSBhbmNob3Igbm9kZSBlbGVtZW50LlxuICogQHBhcmFtIHsqPX0gb3B0X3VyaSBPcHRpb25hbCBzdHJpbmcgVVJJIHRvIHBhcnNlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKG9wdF91cmkpIHtcblx0aWYgKGNvcmUuaXNGdW5jdGlvbihVUkwpICYmIFVSTC5sZW5ndGgpIHtcblx0XHRyZXR1cm4gbmV3IFVSTChvcHRfdXJpKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gcGFyc2VGcm9tQW5jaG9yKG9wdF91cmkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlLCBzdHJpbmcgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZSc7XG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuXG52YXIgcGFyc2VGbl8gPSBwYXJzZTtcblxuY2xhc3MgVXJpIHtcblxuXHQvKipcblx0ICogVGhpcyBjbGFzcyBjb250YWlucyBzZXR0ZXJzIGFuZCBnZXR0ZXJzIGZvciB0aGUgcGFydHMgb2YgdGhlIFVSSS5cblx0ICogVGhlIGZvbGxvd2luZyBmaWd1cmUgZGlzcGxheXMgYW4gZXhhbXBsZSBVUklzIGFuZCB0aGVpciBjb21wb25lbnQgcGFydHMuXG5cdCAqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhcblx0ICpcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSQXG5cdCAqXHQgIGFiYzovL2V4YW1wbGUuY29tOjEyMy9wYXRoL2RhdGE/a2V5PXZhbHVlI2ZyYWdpZDFcblx0ICpcdCAg4pSU4pSs4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSYIOKUlOKUrOKUmCAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSYIOKUlOKUgOKUgOKUrOKUgOKUgOKUmFxuXHQgKiBwcm90b2NvbCAgaG9zdG5hbWUgIHBvcnQgICAgICAgICAgICBzZWFyY2ggICAgaGFzaFxuXHQgKiAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilJhcblx0ICogICAgICAgICAgICAgICAgaG9zdFxuXHQgKlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdXJpIE9wdGlvbmFsIHN0cmluZyBVUkkgdG8gcGFyc2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRfdXJpID0gJycpIHtcblx0XHR0aGlzLnVybCA9IFVyaS5wYXJzZSh0aGlzLm1heWJlQWRkUHJvdG9jb2xBbmRIb3N0bmFtZV8ob3B0X3VyaSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgcGFyYW1ldGVycyB0byB1cmkgZnJvbSBhIDxjb2RlPk11bHRpTWFwPC9jb2RlPiBhcyBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXB9IG11bHRpbWFwIFRoZSA8Y29kZT5NdWx0aU1hcDwvY29kZT4gY29udGFpbmluZyB0aGVcblx0ICogICBwYXJhbWV0ZXJzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAobXVsdGltYXApIHtcblx0XHRtdWx0aW1hcC5uYW1lcygpLmZvckVhY2goKG5hbWUpID0+IHtcblx0XHRcdG11bHRpbWFwLmdldEFsbChuYW1lKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuXHRcdFx0XHR0aGlzLmFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuIFdpbGwgYmUgZXhwbGljaXRseSBjYXN0ZWQgdG8gU3RyaW5nLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRpZiAoY29yZS5pc0RlZih2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblx0XHR9XG5cdFx0dGhpcy5xdWVyeS5hZGQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHZhbHVlcyBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFBhcmFtZXRlclZhbHVlcyhuYW1lLCB2YWx1ZXMpIHtcblx0XHR2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFbnN1cmVzIHF1ZXJ5IGludGVybmFsIG1hcCBpcyBpbml0aWFsaXplZCBhbmQgc3luY2VkIHdpdGggaW5pdGlhbCB2YWx1ZVxuXHQgKiBleHRyYWN0ZWQgZnJvbSBVUkkgc2VhcmNoIHBhcnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCkge1xuXHRcdGlmICh0aGlzLnF1ZXJ5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMucXVlcnkgPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR2YXIgc2VhcmNoID0gdGhpcy51cmwuc2VhcmNoO1xuXHRcdGlmIChzZWFyY2gpIHtcblx0XHRcdHNlYXJjaC5zdWJzdHJpbmcoMSkuc3BsaXQoJyYnKS5mb3JFYWNoKChwYXJhbSkgPT4ge1xuXHRcdFx0XHR2YXIgW2tleSwgdmFsdWVdID0gcGFyYW0uc3BsaXQoJz0nKTtcblx0XHRcdFx0aWYgKGNvcmUuaXNEZWYodmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBVcmkudXJsRGVjb2RlKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZFBhcmFtZXRlclZhbHVlKGtleSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhhc2ggcGFydCBvZiB1cmkuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEhhc2goKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsLmhhc2ggfHwgJyc7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaG9zdCBwYXJ0IG9mIHVyaS4gRS5nLiA8Y29kZT5baG9zdG5hbWVdOltwb3J0XTwvY29kZT4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEhvc3QoKSB7XG5cdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3RuYW1lKCk7XG5cdFx0aWYgKGhvc3QpIHtcblx0XHRcdHZhciBwb3J0ID0gdGhpcy5nZXRQb3J0KCk7XG5cdFx0XHRpZiAocG9ydCAmJiBwb3J0ICE9PSAnODAnKSB7XG5cdFx0XHRcdGhvc3QgKz0gJzonICsgcG9ydDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGhvc3Q7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaG9zdG5hbWUgcGFydCBvZiB1cmkgd2l0aG91dCBwcm90b2NvbCBhbmQgcG9ydC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0SG9zdG5hbWUoKSB7XG5cdFx0dmFyIGhvc3RuYW1lID0gdGhpcy51cmwuaG9zdG5hbWU7XG5cdFx0aWYgKGhvc3RuYW1lID09PSBVcmkuSE9TVE5BTUVfUExBQ0VIT0xERVIpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0cmV0dXJuIGhvc3RuYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG9yaWdpbiBwYXJ0IG9mIHVyaS4gRS5nLiA8Y29kZT5odHRwOi8vW2hvc3RuYW1lXTpbcG9ydF08L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRPcmlnaW4oKSB7XG5cdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3QoKTtcblx0XHRpZiAoaG9zdCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UHJvdG9jb2woKSArICcvLycgKyBob3N0O1xuXHRcdH1cblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIG9yIHVuZGVmaW5lZCBpZiB0aGUgZ2l2ZW5cblx0ICogcGFyYW1ldGVyIG5hbWUgZG9lcyBub3QgYXBwZWFyIGluIHRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWUgVW5lc2NhcGVkIHBhcmFtZXRlciBuYW1lLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgZmlyc3QgdmFsdWUgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIG9yXG5cdCAqICAgdW5kZWZpbmVkIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZSBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHF1ZXJ5XG5cdCAqICAgc3RyaW5nLlxuXHQgKi9cblx0Z2V0UGFyYW1ldGVyVmFsdWUobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5nZXQobmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWU8Yj5zPC9iPiBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgYXMgYSBsaXN0IG9mIGRlY29kZWRcblx0ICogcXVlcnkgcGFyYW1ldGVyIHZhbHVlcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHBhcmFtZXRlciB0byBnZXQgdmFsdWVzIGZvci5cblx0ICogQHJldHVybiB7IUFycmF5PD8+fSBUaGUgdmFsdWVzIGZvciBhIGdpdmVuIHBhcmFtZXRlciBhcyBhIGxpc3Qgb2YgZGVjb2RlZFxuXHQgKiAgIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZXMuXG5cdCAqL1xuXHRnZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5nZXRBbGwobmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZTxiPnM8L2I+IG9mIHRoZSBwYXJhbWV0ZXJzLlxuXHQgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn0gVGhlIG5hbWVzIGZvciB0aGUgcGFyYW1ldGVycyBhcyBhIGxpc3Qgb2Zcblx0ICogICBzdHJpbmdzLlxuXHQgKi9cblx0Z2V0UGFyYW1ldGVyTmFtZXMoKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdHJldHVybiB0aGlzLnF1ZXJ5Lm5hbWVzKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZnVuY3Rpb24gY3VycmVudGx5IGJlaW5nIHVzZWQgdG8gcGFyc2UgVVJJcy5cblx0ICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG5cdCAqL1xuXHRzdGF0aWMgZ2V0UGFyc2VGbigpIHtcblx0XHRyZXR1cm4gcGFyc2VGbl87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcGF0aG5hbWUgcGFydCBvZiB1cmkuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBhdGhuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLnVybC5wYXRobmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3J0IG51bWJlciBwYXJ0IG9mIHVyaSBhcyBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBvcnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsLnBvcnQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcHJvdG9jb2wgcGFydCBvZiB1cmkuIEUuZy4gPGNvZGU+aHR0cDo8L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRQcm90b2NvbCgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmwucHJvdG9jb2w7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc2VhcmNoIHBhcnQgb2YgdXJpLiBTZWFyY2ggdmFsdWUgaXMgcmV0cmlldmVkIGZyb20gcXVlcnlcblx0ICogcGFyYW1ldGVycy5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0U2VhcmNoKCkge1xuXHRcdHZhciBzZWFyY2ggPSAnJztcblx0XHR2YXIgcXVlcnlzdHJpbmcgPSAnJztcblx0XHR0aGlzLmdldFBhcmFtZXRlck5hbWVzKCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdFx0dGhpcy5nZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSkuZm9yRWFjaCgodmFsdWUpID0+IHtcblx0XHRcdFx0cXVlcnlzdHJpbmcgKz0gbmFtZTtcblx0XHRcdFx0aWYgKGNvcmUuaXNEZWYodmFsdWUpKSB7XG5cdFx0XHRcdFx0cXVlcnlzdHJpbmcgKz0gJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRxdWVyeXN0cmluZyArPSAnJic7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRxdWVyeXN0cmluZyA9IHF1ZXJ5c3RyaW5nLnNsaWNlKDAsIC0xKTtcblx0XHRpZiAocXVlcnlzdHJpbmcpIHtcblx0XHRcdHNlYXJjaCArPSAnPycgKyBxdWVyeXN0cmluZztcblx0XHR9XG5cdFx0cmV0dXJuIHNlYXJjaDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdXJpIGNvbnRhaW5zIHRoZSBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNQYXJhbWV0ZXIobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5jb250YWlucyhuYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlcyB0aGlzIFVSTCB1bmlxdWUgYnkgYWRkaW5nIGEgcmFuZG9tIHBhcmFtIHRvIGl0LiBVc2VmdWwgZm9yIGF2b2lkaW5nXG5cdCAqIGNhY2hlLlxuXHQgKi9cblx0bWFrZVVuaXF1ZSgpIHtcblx0XHR0aGlzLnNldFBhcmFtZXRlclZhbHVlKFVyaS5SQU5ET01fUEFSQU0sIHN0cmluZy5nZXRSYW5kb21TdHJpbmcoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogTWF5YmUgYWRkcyBwcm90b2NvbCBhbmQgYSBob3N0bmFtZSBwbGFjZWhvbGRlciBvbiBhIHBhcmlhbCBVUkkgaWYgbmVlZGVkLlxuXHQgKiBSZWxldmVudCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDxjb2RlPlVSTDwvY29kZT4gbmF0aXZlIG9iamVjdC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdXJpXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gVVJJIHdpdGggcHJvdG9jb2wgYW5kIGhvc3RuYW1lIHBsYWNlaG9sZGVyLlxuXHQgKi9cblx0bWF5YmVBZGRQcm90b2NvbEFuZEhvc3RuYW1lXyhvcHRfdXJpKSB7XG5cdFx0dmFyIHVybCA9IG9wdF91cmk7XG5cdFx0aWYgKG9wdF91cmkuaW5kZXhPZignOi8vJykgPT09IC0xICYmXG5cdFx0XHRvcHRfdXJpLmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgIT09IDApIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cblx0XHRcdHVybCA9IFVyaS5ERUZBVUxUX1BST1RPQ09MO1xuXHRcdFx0aWYgKG9wdF91cmlbMF0gIT09ICcvJyB8fCBvcHRfdXJpWzFdICE9PSAnLycpIHtcblx0XHRcdFx0dXJsICs9ICcvLyc7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAob3B0X3VyaS5jaGFyQXQoMCkpIHtcblx0XHRcdFx0Y2FzZSAnLic6XG5cdFx0XHRcdGNhc2UgJz8nOlxuXHRcdFx0XHRjYXNlICcjJzpcblx0XHRcdFx0XHR1cmwgKz0gVXJpLkhPU1ROQU1FX1BMQUNFSE9MREVSO1xuXHRcdFx0XHRcdHVybCArPSAnLyc7XG5cdFx0XHRcdFx0dXJsICs9IG9wdF91cmk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJyc6XG5cdFx0XHRcdGNhc2UgJy8nOlxuXHRcdFx0XHRcdGlmIChvcHRfdXJpWzFdICE9PSAnLycpIHtcblx0XHRcdFx0XHRcdHVybCArPSBVcmkuSE9TVE5BTUVfUExBQ0VIT0xERVI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHVybCArPSBvcHRfdXJpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHVybCArPSBvcHRfdXJpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXJsO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5vcm1hbGl6ZXMgdGhlIHBhcnNlZCBvYmplY3QgdG8gYmUgaW4gdGhlIGV4cGVjdGVkIHN0YW5kYXJkLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9XG5cdCAqL1xuXHRzdGF0aWMgbm9ybWFsaXplT2JqZWN0KHBhcnNlZCkge1xuXHRcdHZhciBsZW5ndGggPSBwYXJzZWQucGF0aG5hbWUgPyBwYXJzZWQucGF0aG5hbWUubGVuZ3RoIDogMDtcblx0XHRpZiAobGVuZ3RoID4gMSAmJiBwYXJzZWQucGF0aG5hbWVbbGVuZ3RoIC0gMV0gPT09ICcvJykge1xuXHRcdFx0cGFyc2VkLnBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lLnN1YnN0cigwLCBsZW5ndGggLSAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGdpdmVuIHVyaSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuXHQgKi9cblx0c3RhdGljIHBhcnNlKG9wdF91cmkpIHtcblx0XHRyZXR1cm4gVXJpLm5vcm1hbGl6ZU9iamVjdChwYXJzZUZuXyhvcHRfdXJpKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcGFyYW1ldGVyIHRvIHJlbW92ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cmVtb3ZlUGFyYW1ldGVyKG5hbWUpIHtcblx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0dGhpcy5xdWVyeS5yZW1vdmUobmFtZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB1bmlxdWVuZXNzIHBhcmFtZXRlciBvZiB0aGUgdXJpLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRyZW1vdmVVbmlxdWUoKSB7XG5cdFx0dGhpcy5yZW1vdmVQYXJhbWV0ZXIoVXJpLlJBTkRPTV9QQVJBTSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgaGFzaC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0SGFzaChoYXNoKSB7XG5cdFx0dGhpcy51cmwuaGFzaCA9IGhhc2g7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgaG9zdG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRIb3N0bmFtZShob3N0bmFtZSkge1xuXHRcdHRoaXMudXJsLmhvc3RuYW1lID0gaG9zdG5hbWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMsIGNsZWFyaW5nIHByZXZpb3VzIHZhbHVlc1xuXHQgKiBmb3IgdGhhdCBrZXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLnJlbW92ZVBhcmFtZXRlcihuYW1lKTtcblx0XHR0aGlzLmFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMsIGNsZWFyaW5nIHByZXZpb3VzIHZhbHVlc1xuXHQgKiBmb3IgdGhhdCBrZXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UGFyYW1ldGVyVmFsdWVzKG5hbWUsIHZhbHVlcykge1xuXHRcdHRoaXMucmVtb3ZlUGFyYW1ldGVyKG5hbWUpO1xuXHRcdHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4gdGhpcy5hZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBhdGhuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UGF0aG5hbWUocGF0aG5hbWUpIHtcblx0XHR0aGlzLnVybC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBvcnQgbnVtYmVyLlxuXHQgKiBAcGFyYW0geyp9IHBvcnQgUG9ydCBudW1iZXIuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldFBvcnQocG9ydCkge1xuXHRcdHRoaXMudXJsLnBvcnQgPSBwb3J0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBwYXJzaW5nIHRoZSBvcmlnaW5hbCBzdHJpbmcgdXJpXG5cdCAqIGludG8gYW4gb2JqZWN0LlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBwYXJzZUZuXG5cdCAqL1xuXHRzdGF0aWMgc2V0UGFyc2VGbihwYXJzZUZuKSB7XG5cdFx0cGFyc2VGbl8gPSBwYXJzZUZuO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHByb3RvY29sLiBJZiBtaXNzaW5nIDxjb2RlPmh0dHA6PC9jb2RlPiBpcyB1c2VkIGFzIGRlZmF1bHQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQcm90b2NvbChwcm90b2NvbCkge1xuXHRcdHRoaXMudXJsLnByb3RvY29sID0gcHJvdG9jb2w7XG5cdFx0aWYgKHRoaXMudXJsLnByb3RvY29sW3RoaXMudXJsLnByb3RvY29sLmxlbmd0aCAtIDFdICE9PSAnOicpIHtcblx0XHRcdHRoaXMudXJsLnByb3RvY29sICs9ICc6Jztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIGZvcm0gb2YgdGhlIHVybC5cblx0ICogQG92ZXJyaWRlXG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHR2YXIgaHJlZiA9ICcnO1xuXHRcdHZhciBob3N0ID0gdGhpcy5nZXRIb3N0KCk7XG5cdFx0aWYgKGhvc3QpIHtcblx0XHRcdGhyZWYgKz0gdGhpcy5nZXRQcm90b2NvbCgpICsgJy8vJztcblx0XHR9XG5cdFx0aHJlZiArPSBob3N0ICsgdGhpcy5nZXRQYXRobmFtZSgpICsgdGhpcy5nZXRTZWFyY2goKSArIHRoaXMuZ2V0SGFzaCgpO1xuXHRcdHJldHVybiBocmVmO1xuXHR9XG5cblx0LyoqXG5cdCAqIEpvaW5zIHRoZSBnaXZlbiBwYXRocy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoXG5cdCAqIEBwYXJhbSB7Li4uc3RyaW5nfSAuLi5wYXRocyBBbnkgbnVtYmVyIG9mIHBhdGhzIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSBiYXNlIHVybC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGpvaW5QYXRocyhiYXNlUGF0aCwgLi4ucGF0aHMpIHtcblx0XHRpZiAoYmFzZVBhdGguY2hhckF0KGJhc2VQYXRoLmxlbmd0aCAtIDEpID09PSAnLycpIHtcblx0XHRcdGJhc2VQYXRoID0gYmFzZVBhdGguc3Vic3RyaW5nKDAsIGJhc2VQYXRoLmxlbmd0aCAtIDEpO1xuXHRcdH1cblx0XHRwYXRocyA9IHBhdGhzLm1hcChwYXRoID0+IHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGgpO1xuXHRcdHJldHVybiBbYmFzZVBhdGhdLmNvbmNhdChwYXRocykuam9pbignLycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdH1cblxuXHQvKipcblx0ICogVVJMLWRlY29kZXMgdGhlIHN0cmluZy4gV2UgbmVlZCB0byBzcGVjaWFsbHkgaGFuZGxlICcrJ3MgYmVjYXVzZVxuXHQgKiB0aGUgamF2YXNjcmlwdCBsaWJyYXJ5IGRvZXNuJ3QgY29udmVydCB0aGVtIHRvIHNwYWNlcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHVybCBkZWNvZGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRlY29kZWQge0Bjb2RlIHN0cn0uXG5cdCAqL1xuXHRzdGF0aWMgdXJsRGVjb2RlKHN0cikge1xuXHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcblx0fVxuXG59XG5cbi8qKlxuICogRGVmYXVsdCBwcm90b2NvbCB2YWx1ZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZGVmYXVsdCBodHRwOlxuICogQHN0YXRpY1xuICovXG5VcmkuREVGQVVMVF9QUk9UT0NPTCA9ICdodHRwOic7XG5cbi8qKlxuICogSG9zdG5hbWUgcGxhY2Vob2xkZXIuIFJlbGV2YW50IHRvIGludGVybmFsIHVzYWdlIG9ubHkuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHN0YXRpY1xuICovXG5VcmkuSE9TVE5BTUVfUExBQ0VIT0xERVIgPSAnaG9zdG5hbWUnICsgRGF0ZS5ub3coKTtcblxuLyoqXG4gKiBOYW1lIHVzZWQgYnkgdGhlIHBhcmFtIGdlbmVyYXRlZCBieSBgbWFrZVVuaXF1ZWAuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHN0YXRpY1xuICovXG5VcmkuUkFORE9NX1BBUkFNID0gJ3p4JztcblxuZXhwb3J0IGRlZmF1bHQgVXJpO1xuIiwiLyohXG4gKiBQcm9taXNlcyBwb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqXG4gKiAgICAgIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RFKGVkdWFyZG8pOiBQcm9taXNlIHN1cHBvcnQgaXMgbm90IHJlYWR5IG9uIGFsbCBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4gKiB0aGVyZWZvcmUgY29yZS5qcyBpcyB0ZW1wb3JhcmlseSB1c2luZyBHb29nbGUncyBwcm9taXNlcyBhcyBwb2x5ZmlsbC4gSXRcbiAqIHN1cHBvcnRzIGNhbmNlbGxhYmxlIHByb21pc2VzIGFuZCBoYXMgY2xlYW4gYW5kIGZhc3QgaW1wbGVtZW50YXRpb24uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHsgYXN5bmMgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBtb3JlIHN0cmljdCBpbnRlcmZhY2UgZm9yIFRoZW5hYmxlcyBpbiB0ZXJtcyBvZlxuICogaHR0cDovL3Byb21pc2VzYXBsdXMuY29tIGZvciBpbnRlcm9wIHdpdGgge0BzZWUgQ2FuY2VsbGFibGVQcm9taXNlfS5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyB7SVRoZW5hYmxlLjxUWVBFPn1cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbnZhciBUaGVuYWJsZSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQWRkcyBjYWxsYmFja3MgdGhhdCB3aWxsIG9wZXJhdGUgb24gdGhlIHJlc3VsdCBvZiB0aGUgVGhlbmFibGUsIHJldHVybmluZyBhXG4gKiBuZXcgY2hpbGQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgVGhlbmFibGUgaXMgZnVsZmlsbGVkLCB0aGUge0Bjb2RlIG9uRnVsZmlsbGVkfSBjYWxsYmFjayB3aWxsIGJlXG4gKiBpbnZva2VkIHdpdGggdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbFxuICogYmUgZnVsZmlsbGVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2suIElmIHRoZSBjYWxsYmFjayB0aHJvd3NcbiAqIGFuIGV4Y2VwdGlvbiwgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSB0aHJvd24gdmFsdWVcbiAqIGluc3RlYWQuXG4gKlxuICogSWYgdGhlIFRoZW5hYmxlIGlzIHJlamVjdGVkLCB0aGUge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWRcbiAqIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2sgb3IgdGhyb3duIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7PyhmdW5jdGlvbih0aGlzOlRISVMsIFRZUEUpOlxuICogICAgICAgICAgICAgKFJFU1VMVHxJVGhlbmFibGUuPFJFU1VMVD58VGhlbmFibGUpKT19IG9wdF9vbkZ1bGZpbGxlZCBBXG4gKiAgICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaWYgdGhlIFByb21pc2VcbiAqICAgICBpcyBmdWxsZmlsbGVkLlxuICogQHBhcmFtIHs/KGZ1bmN0aW9uKCopOiAqKT19IG9wdF9vblJlamVjdGVkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAqICAgICB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZVxuICogICAgIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLiBCeSBkZWZhdWx0LCBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkXG4gKiAgICAgd2l0aCB0aGUgZGVmYXVsdCB0aGlzLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48UkVTVUxUPn0gQSBuZXcgUHJvbWlzZSB0aGF0IHdpbGwgcmVjZWl2ZSB0aGVcbiAqICAgICByZXN1bHQgb2YgdGhlIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBjYWxsYmFjay5cbiAqIEB0ZW1wbGF0ZSBSRVNVTFQsVEhJU1xuICovXG5UaGVuYWJsZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBBbiBleHBhbmRvIHByb3BlcnR5IHRvIGluZGljYXRlIHRoYXQgYW4gb2JqZWN0IGltcGxlbWVudHNcbiAqIHtAY29kZSBUaGVuYWJsZX0uXG4gKlxuICoge0BzZWUgYWRkSW1wbGVtZW50YXRpb259LlxuICpcbiAqIEBjb25zdFxuICovXG5UaGVuYWJsZS5JTVBMRU1FTlRFRF9CWV9QUk9QID0gJyRnb29nX1RoZW5hYmxlJztcblxuXG4vKipcbiAqIE1hcmtzIGEgZ2l2ZW4gY2xhc3MgKGNvbnN0cnVjdG9yKSBhcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBUaGVuYWJsZSwgc29cbiAqIHRoYXQgd2UgY2FuIHF1ZXJ5IHRoYXQgZmFjdCBhdCBydW50aW1lLiBUaGUgY2xhc3MgbXVzdCBoYXZlIGFscmVhZHlcbiAqIGltcGxlbWVudGVkIHRoZSBpbnRlcmZhY2UuXG4gKiBFeHBvcnRzIGEgJ3RoZW4nIG1ldGhvZCBvbiB0aGUgY29uc3RydWN0b3IgcHJvdG90eXBlLCBzbyB0aGF0IHRoZSBvYmplY3RzXG4gKiBhbHNvIGltcGxlbWVudCB0aGUgZXh0ZXJuIHtAc2VlIFRoZW5hYmxlfSBpbnRlcmZhY2UgZm9yIGludGVyb3Agd2l0aFxuICogb3RoZXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpUaGVuYWJsZSwuLi5bP10pfSBjdG9yIFRoZSBjbGFzcyBjb25zdHJ1Y3Rvci4gVGhlXG4gKiAgICAgY29ycmVzcG9uZGluZyBjbGFzcyBtdXN0IGhhdmUgYWxyZWFkeSBpbXBsZW1lbnRlZCB0aGUgaW50ZXJmYWNlLlxuICovXG5UaGVuYWJsZS5hZGRJbXBsZW1lbnRhdGlvbiA9IGZ1bmN0aW9uKGN0b3IpIHtcbiAgY3Rvci5wcm90b3R5cGUudGhlbiA9IGN0b3IucHJvdG90eXBlLnRoZW47XG4gIGN0b3IucHJvdG90eXBlLiRnb29nX1RoZW5hYmxlID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBhIGdpdmVuIGluc3RhbmNlIGltcGxlbWVudHMge0Bjb2RlIFRoZW5hYmxlfS5cbiAqICAgICBUaGUgY2xhc3Mvc3VwZXJjbGFzcyBvZiB0aGUgaW5zdGFuY2UgbXVzdCBjYWxsIHtAY29kZSBhZGRJbXBsZW1lbnRhdGlvbn0uXG4gKi9cblRoZW5hYmxlLmlzSW1wbGVtZW50ZWRCeSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiAhIW9iamVjdC4kZ29vZ19UaGVuYWJsZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFByb3BlcnR5IGFjY2VzcyBzZWVtcyB0byBiZSBmb3JiaWRkZW4uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbi8qKlxuICogTGlrZSBiaW5kKCksIGV4Y2VwdCB0aGF0IGEgJ3RoaXMgb2JqZWN0JyBpcyBub3QgcmVxdWlyZWQuIFVzZWZ1bCB3aGVuIHRoZVxuICogdGFyZ2V0IGZ1bmN0aW9uIGlzIGFscmVhZHkgYm91bmQuXG4gKlxuICogVXNhZ2U6XG4gKiB2YXIgZyA9IHBhcnRpYWwoZiwgYXJnMSwgYXJnMik7XG4gKiBnKGFyZzMsIGFyZzQpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXJ0aWFsbHkgYXBwbGllZCB0byBmbi5cbiAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBiaW5kKCkgd2FzXG4gKiAgICAgaW52b2tlZCBhcyBhIG1ldGhvZCBvZi5cbiAqL1xudmFyIHBhcnRpYWwgPSBmdW5jdGlvbihmbikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgKHdpdGggc2xpY2UoKSkgYW5kIGFwcGVuZCBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgIC8vIHRvIHRoZSBleGlzdGluZyBhcmd1bWVudHMuXG4gICAgdmFyIG5ld0FyZ3MgPSBhcmdzLnNsaWNlKCk7XG4gICAgbmV3QXJncy5wdXNoLmFwcGx5KG5ld0FyZ3MsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICB9O1xufTtcblxuLyoqXG4gKiBQcm9taXNlcyBwcm92aWRlIGEgcmVzdWx0IHRoYXQgbWF5IGJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5LiBBIFByb21pc2UgbWF5XG4gKiBiZSByZXNvbHZlZCBieSBiZWluZyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCB3aWxsIGJlIGtub3duXG4gKiBhcyB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgb3IgdGhlIHJlamVjdGlvbiByZWFzb24uIFdoZXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZCwgdGhlIFByb21pc2UgcmVzdWx0IGlzIGltbXV0YWJsZSBvbmNlIGl0IGlzIHNldC5cbiAqXG4gKiBQcm9taXNlcyBtYXkgcmVwcmVzZW50IHJlc3VsdHMgb2YgYW55IHR5cGUsIGluY2x1ZGluZyB1bmRlZmluZWQuIFJlamVjdGlvblxuICogcmVhc29ucyBhcmUgdHlwaWNhbGx5IEVycm9ycywgYnV0IG1heSBhbHNvIGJlIG9mIGFueSB0eXBlLiBDbG9zdXJlIFByb21pc2VzXG4gKiBhbGxvdyBmb3Igb3B0aW9uYWwgdHlwZSBhbm5vdGF0aW9ucyB0aGF0IGVuZm9yY2UgdGhhdCBmdWxmaWxsbWVudCB2YWx1ZXMgYXJlXG4gKiBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZXMgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIFRoZSByZXN1bHQgb2YgYSBQcm9taXNlIGlzIGFjY2Vzc2libGUgYnkgY2FsbGluZyB7QGNvZGUgdGhlbn0gYW5kIHJlZ2lzdGVyaW5nXG4gKiB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzLiBPbmNlIHRoZSBQcm9taXNlXG4gKiByZXNvbHZlcywgdGhlIHJlbGV2YW50IGNhbGxiYWNrcyBhcmUgaW52b2tlZCB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBvclxuICogcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudC4gQ2FsbGJhY2tzIGFyZSBhbHdheXMgaW52b2tlZCBpbiB0aGUgb3JkZXIgdGhleVxuICogd2VyZSByZWdpc3RlcmVkLCBldmVuIHdoZW4gYWRkaXRpb25hbCB7QGNvZGUgdGhlbn0gY2FsbHMgYXJlIG1hZGUgZnJvbSBpbnNpZGVcbiAqIGFub3RoZXIgY2FsbGJhY2suIEEgY2FsbGJhY2sgaXMgYWx3YXlzIHJ1biBhc3luY2hyb25vdXNseSBzb21ldGltZSBhZnRlciB0aGVcbiAqIHNjb3BlIGNvbnRhaW5pbmcgdGhlIHJlZ2lzdGVyaW5nIHtAY29kZSB0aGVufSBpbnZvY2F0aW9uIGhhcyByZXR1cm5lZC5cbiAqXG4gKiBJZiBhIFByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBhbm90aGVyIFByb21pc2UsIHRoZSBmaXJzdCBQcm9taXNlIHdpbGwgYmxvY2tcbiAqIHVudGlsIHRoZSBzZWNvbmQgaXMgcmVzb2x2ZWQsIGFuZCB0aGVuIGFzc3VtZXMgdGhlIHNhbWUgcmVzdWx0IGFzIHRoZSBzZWNvbmRcbiAqIFByb21pc2UuIFRoaXMgYWxsb3dzIFByb21pc2VzIHRvIGRlcGVuZCBvbiB0aGUgcmVzdWx0cyBvZiBvdGhlciBQcm9taXNlcyxcbiAqIGxpbmtpbmcgdG9nZXRoZXIgbXVsdGlwbGUgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBjb21wYXRpYmxlIHdpdGggdGhlIFByb21pc2VzL0ErIHNwZWNpZmljYXRpb24gYW5kXG4gKiBwYXNzZXMgdGhhdCBzcGVjaWZpY2F0aW9uJ3MgY29uZm9ybWFuY2UgdGVzdCBzdWl0ZS4gQSBDbG9zdXJlIFByb21pc2UgbWF5IGJlXG4gKiByZXNvbHZlZCB3aXRoIGEgUHJvbWlzZSBpbnN0YW5jZSAob3Igc3VmZmljaWVudGx5IGNvbXBhdGlibGUgUHJvbWlzZS1saWtlXG4gKiBvYmplY3QpIGNyZWF0ZWQgYnkgb3RoZXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMuIEZyb20gdGhlIHNwZWNpZmljYXRpb24sXG4gKiBQcm9taXNlLWxpa2Ugb2JqZWN0cyBhcmUga25vd24gYXMgXCJUaGVuYWJsZXNcIi5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS9cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFxuICogICAgICAgICAgICAgdGhpczpSRVNPTFZFUl9DT05URVhULFxuICogICAgICAgICAgICAgZnVuY3Rpb24oKFRZUEV8SVRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSkpLFxuICogICAgICAgICAgICAgZnVuY3Rpb24oKikpOiB2b2lkfSByZXNvbHZlclxuICogICAgIEluaXRpYWxpemF0aW9uIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseSB3aXRoIHtAY29kZSByZXNvbHZlfVxuICogICAgIGFuZCB7QGNvZGUgcmVqZWN0fSBmdW5jdGlvbnMgYXMgYXJndW1lbnRzLiBUaGUgUHJvbWlzZSBpcyByZXNvbHZlZCBvclxuICogICAgIHJlamVjdGVkIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBlaXRoZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1JFU09MVkVSX0NPTlRFWFQ9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IGZvciBleGVjdXRpbmcgdGhlXG4gKiAgICAgcmVzb2x2ZXIgZnVuY3Rpb24uIElmIHVuc3BlY2lmaWVkLCB0aGUgcmVzb2x2ZXIgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZFxuICogICAgIGluIHRoZSBkZWZhdWx0IHNjb3BlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAZmluYWxcbiAqIEBpbXBsZW1lbnRzIHtUaGVuYWJsZS48VFlQRT59XG4gKiBAdGVtcGxhdGUgVFlQRSxSRVNPTFZFUl9DT05URVhUXG4gKi9cbnZhciBDYW5jZWxsYWJsZVByb21pc2UgPSBmdW5jdGlvbihyZXNvbHZlciwgb3B0X2NvbnRleHQpIHtcbiAgLyoqXG4gICAqIFRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGlzIFByb21pc2UuIEVpdGhlciBQRU5ESU5HLCBGVUxGSUxMRUQsIFJFSkVDVEVELCBvclxuICAgKiBCTE9DS0VELlxuICAgKiBAcHJpdmF0ZSB7Q2FuY2VsbGFibGVQcm9taXNlLlN0YXRlX31cbiAgICovXG4gIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgcmVzdWx0IG9mIHRoZSBQcm9taXNlLiBJbW11dGFibGUgb25jZSBzZXQgd2l0aCBlaXRoZXIgYVxuICAgKiBmdWxmaWxsbWVudCB2YWx1ZSBvciByZWplY3Rpb24gcmVhc29uLlxuICAgKiBAcHJpdmF0ZSB7Kn1cbiAgICovXG4gIHRoaXMucmVzdWx0XyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRm9yIFByb21pc2VzIGNyZWF0ZWQgYnkgY2FsbGluZyB7QGNvZGUgdGhlbigpfSwgdGhlIG9yaWdpbmF0aW5nIHBhcmVudC5cbiAgICogQHByaXZhdGUge0NhbmNlbGxhYmxlUHJvbWlzZX1cbiAgICovXG4gIHRoaXMucGFyZW50XyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHtAY29kZSBvbkZ1bGZpbGxlZH0gYW5kIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgYWRkZWQgdG9cbiAgICogdGhpcyBQcm9taXNlIGJ5IGNhbGxzIHRvIHtAY29kZSB0aGVuKCl9LlxuICAgKiBAcHJpdmF0ZSB7QXJyYXkuPENhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5Xz59XG4gICAqL1xuICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBQcm9taXNlIGlzIGluIHRoZSBxdWV1ZSBvZiBQcm9taXNlcyB0byBleGVjdXRlLlxuICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuZXhlY3V0aW5nXyA9IGZhbHNlO1xuXG4gIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA+IDApIHtcbiAgICAvKipcbiAgICAgKiBBIHRpbWVvdXQgSUQgdXNlZCB3aGVuIHRoZSB7QGNvZGUgVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWX0gaXMgZ3JlYXRlclxuICAgICAqIHRoYW4gMCBtaWxsaXNlY29uZHMuIFRoZSBJRCBpcyBzZXQgd2hlbiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgYW5kXG4gICAgICogY2xlYXJlZCBvbmx5IGlmIGFuIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBpcyBpbnZva2VkIGZvciB0aGVcbiAgICAgKiBQcm9taXNlIChvciBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzKSBiZWZvcmUgdGhlIGRlbGF5IGlzIGV4Y2VlZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIHJlamVjdGlvbiBpcyBub3QgaGFuZGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQgY29tcGxldGVzLCB0aGVcbiAgICAgKiByZWplY3Rpb24gcmVhc29uIGlzIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25JZF8gPSAwO1xuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUge0Bjb2RlIFVOSEFORExFRF9SRUpFQ1RJT05fREVMQVl9IGlzIHNldCB0byAwIG1pbGxpc2Vjb25kcywgYVxuICAgICAqIGJvb2xlYW4gdGhhdCBpcyBzZXQgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGFuZCByZXNldCB0byBmYWxzZSBpZiBhblxuICAgICAqIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBpcyBpbnZva2VkIGZvciB0aGUgUHJvbWlzZSAob3Igb25lIG9mIGl0c1xuICAgICAqIGRlc2NlbmRhbnRzKS4gSWYgdGhlIHJlamVjdGlvbiBpcyBub3QgaGFuZGxlZCBiZWZvcmUgdGhlIG5leHQgdGltZXN0ZXAsXG4gICAgICogdGhlIHJlamVjdGlvbiByZWFzb24gaXMgcGFzc2VkIHRvIHRoZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGhhbmRsZXIuXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXNvbHZlci5jYWxsKFxuICAgICAgb3B0X2NvbnRleHQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHNlbGYucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQsIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBzZWxmLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIHJlYXNvbik7XG4gICAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgZSk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgYSByZWplY3RlZCBQcm9taXNlJ3MgcmVhc29uIGlzIHBhc3NlZCB0b1xuICogdGhlIHJlamVjdGlvbiBoYW5kbGVyLiBCeSBkZWZhdWx0LCB0aGUgcmVqZWN0aW9uIGhhbmRsZXIgcmV0aHJvd3MgdGhlXG4gKiByZWplY3Rpb24gcmVhc29uIHNvIHRoYXQgaXQgYXBwZWFycyBpbiB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUgb3JcbiAqIHtAY29kZSB3aW5kb3cub25lcnJvcn0gaGFuZGxlci5cbiAqIFJlamVjdGlvbnMgYXJlIHJldGhyb3duIGFzIHF1aWNrbHkgYXMgcG9zc2libGUgYnkgZGVmYXVsdC4gQSBuZWdhdGl2ZSB2YWx1ZVxuICogZGlzYWJsZXMgcmVqZWN0aW9uIGhhbmRsaW5nIGVudGlyZWx5LlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPSAwO1xuXG5cbi8qKlxuICogVGhlIHBvc3NpYmxlIGludGVybmFsIHN0YXRlcyBmb3IgYSBQcm9taXNlLiBUaGVzZSBzdGF0ZXMgYXJlIG5vdCBkaXJlY3RseVxuICogb2JzZXJ2YWJsZSB0byBleHRlcm5hbCBjYWxsZXJzLlxuICogQGVudW0ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8gPSB7XG4gIC8qKiBUaGUgUHJvbWlzZSBpcyB3YWl0aW5nIGZvciByZXNvbHV0aW9uLiAqL1xuICBQRU5ESU5HOiAwLFxuXG4gIC8qKiBUaGUgUHJvbWlzZSBpcyBibG9ja2VkIHdhaXRpbmcgZm9yIHRoZSByZXN1bHQgb2YgYW5vdGhlciBUaGVuYWJsZS4gKi9cbiAgQkxPQ0tFRDogMSxcblxuICAvKiogVGhlIFByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWQgd2l0aCBhIGZ1bGZpbGxtZW50IHZhbHVlLiAqL1xuICBGVUxGSUxMRUQ6IDIsXG5cbiAgLyoqIFRoZSBQcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggYSByZWplY3Rpb24gcmVhc29uLiAqL1xuICBSRUpFQ1RFRDogM1xufTtcblxuXG4vKipcbiAqIFR5cGVkZWYgZm9yIGVudHJpZXMgaW4gdGhlIGNhbGxiYWNrIGNoYWluLiBFYWNoIGNhbGwgdG8ge0Bjb2RlIHRoZW59LFxuICoge0Bjb2RlIHRoZW5DYXRjaH0sIG9yIHtAY29kZSB0aGVuQWx3YXlzfSBjcmVhdGVzIGFuIGVudHJ5IGNvbnRhaW5pbmcgdGhlXG4gKiBmdW5jdGlvbnMgdGhhdCBtYXkgYmUgaW52b2tlZCBvbmNlIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkLlxuICpcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGNoaWxkOiBDYW5jZWxsYWJsZVByb21pc2UsXG4gKiAgIG9uRnVsZmlsbGVkOiBmdW5jdGlvbigqKSxcbiAqICAgb25SZWplY3RlZDogZnVuY3Rpb24oKilcbiAqIH19XG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV8gPSBudWxsO1xuXG5cbi8qKlxuICogQHBhcmFtIHsoVFlQRXxUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPX0gb3B0X3ZhbHVlXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxUWVBFPn0gQSBuZXcgUHJvbWlzZSB0aGF0IGlzIGltbWVkaWF0ZWx5IHJlc29sdmVkXG4gKiAgICAgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKG9wdF92YWx1ZSkge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKG9wdF92YWx1ZSk7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHsqPX0gb3B0X3JlYXNvblxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gQSBuZXcgUHJvbWlzZSB0aGF0IGlzIGltbWVkaWF0ZWx5IHJlamVjdGVkIHdpdGggdGhlXG4gKiAgICAgZ2l2ZW4gcmVhc29uLlxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24ob3B0X3JlYXNvbikge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlamVjdChvcHRfcmVhc29uKTtcbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheS48IShUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPn0gcHJvbWlzZXNcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBBIFByb21pc2UgdGhhdCByZWNlaXZlcyB0aGUgcmVzdWx0IG9mIHRoZVxuICogICAgIGZpcnN0IFByb21pc2UgKG9yIFByb21pc2UtbGlrZSkgaW5wdXQgdG8gY29tcGxldGUuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmFjZSA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKCFwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IChwcm9taXNlID0gcHJvbWlzZXNbaV0pOyBpKyspIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshQXJyYXkuPCEoVGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT59IHByb21pc2VzXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjwhQXJyYXkuPFRZUEU+Pn0gQSBQcm9taXNlIHRoYXQgcmVjZWl2ZXMgYSBsaXN0IG9mXG4gKiAgICAgZXZlcnkgZnVsZmlsbGVkIHZhbHVlIG9uY2UgZXZlcnkgaW5wdXQgUHJvbWlzZSAob3IgUHJvbWlzZS1saWtlKSBpc1xuICogICAgIHN1Y2Nlc3NmdWxseSBmdWxmaWxsZWQsIG9yIGlzIHJlamVjdGVkIGJ5IHRoZSBmaXJzdCByZWplY3Rpb24gcmVzdWx0LlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLmFsbCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHRvRnVsZmlsbCA9IHByb21pc2VzLmxlbmd0aDtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgICAgaWYgKCF0b0Z1bGZpbGwpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvbkZ1bGZpbGwgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdG9GdWxmaWxsLS07XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRvRnVsZmlsbCA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG9uUmVqZWN0ID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IChwcm9taXNlID0gcHJvbWlzZXNbaV0pOyBpKyspIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKHBhcnRpYWwob25GdWxmaWxsLCBpKSwgb25SZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjwhKFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk+fSBwcm9taXNlc1xuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IEEgUHJvbWlzZSB0aGF0IHJlY2VpdmVzIHRoZSB2YWx1ZSBvZlxuICogICAgIHRoZSBmaXJzdCBpbnB1dCB0byBiZSBmdWxmaWxsZWQsIG9yIGlzIHJlamVjdGVkIHdpdGggYSBsaXN0IG9mIGV2ZXJ5XG4gKiAgICAgcmVqZWN0aW9uIHJlYXNvbiBpZiBhbGwgaW5wdXRzIGFyZSByZWplY3RlZC5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5maXJzdEZ1bGZpbGxlZCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHRvUmVqZWN0ID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgdmFyIHJlYXNvbnMgPSBbXTtcblxuICAgICAgaWYgKCF0b1JlamVjdCkge1xuICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9uRnVsZmlsbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9uUmVqZWN0ID0gZnVuY3Rpb24oaW5kZXgsIHJlYXNvbikge1xuICAgICAgICB0b1JlamVjdC0tO1xuICAgICAgICByZWFzb25zW2luZGV4XSA9IHJlYXNvbjtcbiAgICAgICAgaWYgKHRvUmVqZWN0ID09PSAwKSB7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgcHJvbWlzZTsgKHByb21pc2UgPSBwcm9taXNlc1tpXSk7IGkrKykge1xuICAgICAgICBwcm9taXNlLnRoZW4ob25GdWxmaWxsLCBwYXJ0aWFsKG9uUmVqZWN0LCBpKSk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQWRkcyBjYWxsYmFja3MgdGhhdCB3aWxsIG9wZXJhdGUgb24gdGhlIHJlc3VsdCBvZiB0aGUgUHJvbWlzZSwgcmV0dXJuaW5nIGFcbiAqIG5ldyBjaGlsZCBQcm9taXNlLlxuICpcbiAqIElmIHRoZSBQcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHtAY29kZSBvbkZ1bGZpbGxlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmVcbiAqIGZ1bGZpbGxlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrLiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzIGFuXG4gKiBleGNlcHRpb24sIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlIGluc3RlYWQuXG4gKlxuICogSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIHRoZSB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZFxuICogd2l0aCB0aGUgcmV0dXJuIHZhbHVlIChvciB0aHJvd24gdmFsdWUpIG9mIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob3B0X29uRnVsZmlsbGVkLCBvcHRfb25SZWplY3RlZCwgb3B0X2NvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuYWRkQ2hpbGRQcm9taXNlXyhcbiAgICBjb3JlLmlzRnVuY3Rpb24ob3B0X29uRnVsZmlsbGVkKSA/IG9wdF9vbkZ1bGZpbGxlZCA6IG51bGwsXG4gICAgY29yZS5pc0Z1bmN0aW9uKG9wdF9vblJlamVjdGVkKSA/IG9wdF9vblJlamVjdGVkIDogbnVsbCxcbiAgICBvcHRfY29udGV4dCk7XG59O1xuVGhlbmFibGUuYWRkSW1wbGVtZW50YXRpb24oQ2FuY2VsbGFibGVQcm9taXNlKTtcblxuXG4vKipcbiAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGV0aGVyIHRoZSBQcm9taXNlIGlzIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQuIFRoZSBjYWxsYmFjayByZWNlaXZlcyBubyBhcmd1bWVudCwgYW5kIG5vIG5ldyBjaGlsZCBQcm9taXNlIGlzXG4gKiBjcmVhdGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBjbGVhbnVwIHRha2VzIHBsYWNlIGFmdGVyIGNlcnRhaW5cbiAqIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLiBDYWxsYmFja3MgYWRkZWQgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30gd2lsbCBiZVxuICogZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgd2l0aCBvdGhlciBjYWxscyB0byB7QGNvZGUgdGhlbn0sXG4gKiB7QGNvZGUgdGhlbkFsd2F5c30sIG9yIHtAY29kZSB0aGVuQ2F0Y2h9LlxuICpcbiAqIFNpbmNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSBuZXcgY2hpbGQgUHJvbWlzZSwgY2FuY2VsbGF0aW9uIHByb3BhZ2F0aW9uIGlzXG4gKiBub3QgcHJldmVudGVkIGJ5IGFkZGluZyBjYWxsYmFja3Mgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30uIEEgUHJvbWlzZSB0aGF0IGhhc1xuICogYSBjbGVhbnVwIGhhbmRsZXIgYWRkZWQgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30gd2lsbCBiZSBjYW5jZWxlZCBpZiBhbGwgb2ZcbiAqIGl0cyBjaGlsZHJlbiBjcmVhdGVkIGJ5IHtAY29kZSB0aGVufSAob3Ige0Bjb2RlIHRoZW5DYXRjaH0pIGFyZSBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyk6IHZvaWR9IG9uUmVzb2x2ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxuICogICAgIHdoZW4gdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IFRoaXMgUHJvbWlzZSwgZm9yIGNoYWluaW5nIGFkZGl0aW9uYWwgY2FsbHMuXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5BbHdheXMgPSBmdW5jdGlvbihvblJlc29sdmVkLCBvcHRfY29udGV4dCkge1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gb25SZXNvbHZlZC5cbiAgICAgIG9uUmVzb2x2ZWQuY2FsbChvcHRfY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXy5jYWxsKG51bGwsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuYWRkQ2FsbGJhY2tFbnRyeV8oe1xuICAgIGNoaWxkOiBudWxsLFxuICAgIG9uUmVqZWN0ZWQ6IGNhbGxiYWNrLFxuICAgIG9uRnVsZmlsbGVkOiBjYWxsYmFja1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIG9ubHkgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXNcbiAqIGlzIGVxdWl2YWxlbnQgdG8ge0Bjb2RlIHRoZW4obnVsbCwgb25SZWplY3RlZCl9LlxuICpcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKHRoaXM6VEhJUywgKik6ICp9IG9uUmVqZWN0ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgICBpbnZva2VkIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gQSBuZXcgUHJvbWlzZSB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IG9mIHRoZVxuICogICAgIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQ2F0Y2ggPSBmdW5jdGlvbihvblJlamVjdGVkLCBvcHRfY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5hZGRDaGlsZFByb21pc2VfKG51bGwsIG9uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KTtcbn07XG5cbi8qKlxuICogQWxpYXMgb2Yge0BsaW5rIENhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhdGNofVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhdGNoID0gQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQ2F0Y2g7XG5cblxuLyoqXG4gKiBDYW5jZWxzIHRoZSBQcm9taXNlIGlmIGl0IGlzIHN0aWxsIHBlbmRpbmcgYnkgcmVqZWN0aW5nIGl0IHdpdGggYSBjYW5jZWxcbiAqIEVycm9yLiBObyBhY3Rpb24gaXMgcGVyZm9ybWVkIGlmIHRoZSBQcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQuXG4gKlxuICogQWxsIGNoaWxkIFByb21pc2VzIG9mIHRoZSBjYW5jZWxlZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICogY2FuY2VsIGVycm9yLCBhcyB3aXRoIG5vcm1hbCBQcm9taXNlIHJlamVjdGlvbi4gSWYgdGhlIFByb21pc2UgdG8gYmUgY2FuY2VsZWRcbiAqIGlzIHRoZSBvbmx5IGNoaWxkIG9mIGEgcGVuZGluZyBQcm9taXNlLCB0aGUgcGFyZW50IFByb21pc2Ugd2lsbCBhbHNvIGJlXG4gKiBjYW5jZWxlZC4gQ2FuY2VsbGF0aW9uIG1heSBwcm9wYWdhdGUgdXB3YXJkIHRocm91Z2ggbXVsdGlwbGUgZ2VuZXJhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBBbiBvcHRpb25hbCBkZWJ1Z2dpbmcgbWVzc2FnZSBmb3IgZGVzY3JpYmluZyB0aGVcbiAqICAgICBjYW5jZWxsYXRpb24gcmVhc29uLlxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKG9wdF9tZXNzYWdlKSB7XG4gIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HKSB7XG4gICAgYXN5bmMucnVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBDYW5jZWxsYWJsZVByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3Iob3B0X21lc3NhZ2UpO1xuICAgICAgZXJyLklTX0NBTkNFTExBVElPTl9FUlJPUiA9IHRydWU7XG4gICAgICB0aGlzLmNhbmNlbEludGVybmFsXyhlcnIpO1xuICAgIH0sIHRoaXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2FuY2VscyB0aGlzIFByb21pc2Ugd2l0aCB0aGUgZ2l2ZW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHshRXJyb3J9IGVyciBUaGUgY2FuY2VsbGF0aW9uIGVycm9yLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWxJbnRlcm5hbF8gPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRfKSB7XG4gICAgICAvLyBDYW5jZWwgdGhlIFByb21pc2UgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBwYXJlbnQncyBjaGlsZCBsaXN0LlxuICAgICAgdGhpcy5wYXJlbnRfLmNhbmNlbENoaWxkXyh0aGlzLCBlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIGVycik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQ2FuY2VscyBhIGNoaWxkIFByb21pc2UgZnJvbSB0aGUgbGlzdCBvZiBjYWxsYmFjayBlbnRyaWVzLiBJZiB0aGUgUHJvbWlzZSBoYXNcbiAqIG5vdCBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQsIHJlamVjdCBpdCB3aXRoIGEgY2FuY2VsIGVycm9yLiBJZiB0aGVyZSBhcmUgbm9cbiAqIG90aGVyIGNoaWxkcmVuIGluIHRoZSBsaXN0IG9mIGNhbGxiYWNrIGVudHJpZXMsIHByb3BhZ2F0ZSB0aGUgY2FuY2VsbGF0aW9uXG4gKiBieSBjYW5jZWxpbmcgdGhpcyBQcm9taXNlIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHshQ2FuY2VsbGFibGVQcm9taXNlfSBjaGlsZFByb21pc2UgVGhlIFByb21pc2UgdG8gY2FuY2VsLlxuICogQHBhcmFtIHshRXJyb3J9IGVyciBUaGUgY2FuY2VsIGVycm9yIHRvIHVzZSBmb3IgcmVqZWN0aW5nIHRoZSBQcm9taXNlLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWxDaGlsZF8gPSBmdW5jdGlvbihjaGlsZFByb21pc2UsIGVycikge1xuICBpZiAoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRDb3VudCA9IDA7XG4gIHZhciBjaGlsZEluZGV4ID0gLTE7XG5cbiAgLy8gRmluZCB0aGUgY2FsbGJhY2sgZW50cnkgZm9yIHRoZSBjaGlsZFByb21pc2UsIGFuZCBjb3VudCB3aGV0aGVyIHRoZXJlIGFyZVxuICAvLyBhZGRpdGlvbmFsIGNoaWxkIFByb21pc2VzLlxuICBmb3IgKHZhciBpID0gMCwgZW50cnk7IChlbnRyeSA9IHRoaXMuY2FsbGJhY2tFbnRyaWVzX1tpXSk7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGVudHJ5LmNoaWxkO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY2hpbGRDb3VudCsrO1xuICAgICAgaWYgKGNoaWxkID09PSBjaGlsZFByb21pc2UpIHtcbiAgICAgICAgY2hpbGRJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRJbmRleCA+PSAwICYmIGNoaWxkQ291bnQgPiAxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBjaGlsZCBQcm9taXNlIHdhcyB0aGUgb25seSBjaGlsZCwgY2FuY2VsIHRoaXMgUHJvbWlzZSBhcyB3ZWxsLlxuICAvLyBPdGhlcndpc2UsIHJlamVjdCBvbmx5IHRoZSBjaGlsZCBQcm9taXNlIHdpdGggdGhlIGNhbmNlbCBlcnJvci5cbiAgaWYgKGNoaWxkSW5kZXggPj0gMCkge1xuICAgIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HICYmIGNoaWxkQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuY2FuY2VsSW50ZXJuYWxfKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjYWxsYmFja0VudHJ5ID0gdGhpcy5jYWxsYmFja0VudHJpZXNfLnNwbGljZShjaGlsZEluZGV4LCAxKVswXTtcbiAgICAgIHRoaXMuZXhlY3V0ZUNhbGxiYWNrXyhcbiAgICAgICAgY2FsbGJhY2tFbnRyeSwgQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgZXJyKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgY2FsbGJhY2sgZW50cnkgdG8gdGhlIGN1cnJlbnQgUHJvbWlzZSwgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICogZXhlY3V0aW9uIGlmIHRoZSBQcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQuXG4gKlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV99IGNhbGxiYWNrRW50cnkgUmVjb3JkIGNvbnRhaW5pbmdcbiAqICAgICB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIHRvIGV4ZWN1dGUgYWZ0ZXJcbiAqICAgICB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuYWRkQ2FsbGJhY2tFbnRyeV8gPSBmdW5jdGlvbihjYWxsYmFja0VudHJ5KSB7XG4gIGlmICgoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXyB8fCAhdGhpcy5jYWxsYmFja0VudHJpZXNfLmxlbmd0aCkgJiZcbiAgICAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVEIHx8XG4gICAgdGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQpKSB7XG4gICAgdGhpcy5zY2hlZHVsZUNhbGxiYWNrc18oKTtcbiAgfVxuICBpZiAoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXykge1xuICAgIHRoaXMuY2FsbGJhY2tFbnRyaWVzXyA9IFtdO1xuICB9XG4gIHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5wdXNoKGNhbGxiYWNrRW50cnkpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjaGlsZCBQcm9taXNlIGFuZCBhZGRzIGl0IHRvIHRoZSBjYWxsYmFjayBlbnRyeSBsaXN0LiBUaGUgcmVzdWx0IG9mXG4gKiB0aGUgY2hpbGQgUHJvbWlzZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzdGF0ZSBvZiB0aGUgcGFyZW50IFByb21pc2UgYW5kIHRoZVxuICogcmVzdWx0IG9mIHRoZSB7QGNvZGUgb25GdWxmaWxsZWR9IG9yIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgYXNcbiAqIHNwZWNpZmllZCBpbiB0aGUgUHJvbWlzZSByZXNvbHV0aW9uIHByb2NlZHVyZS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8jdGhlX19tZXRob2RcbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlRISVMsIFRZUEUpOlxuICogICAgICAgICAgKFJFU1VMVHxDYW5jZWxsYWJsZVByb21pc2UuPFJFU1VMVD58VGhlbmFibGUpfSBvbkZ1bGZpbGxlZCBBIGNhbGxiYWNrIHRoYXRcbiAqICAgICB3aWxsIGJlIGludm9rZWQgaWYgdGhlIFByb21pc2UgaXMgZnVsbGZpbGxlZCwgb3IgbnVsbC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6VEhJUywgKik6ICp9IG9uUmVqZWN0ZWQgQSBjYWxsYmFjayB0aGF0IHdpbGwgYmVcbiAqICAgICBpbnZva2VkIGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBvciBudWxsLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuXG4gKiAgICAgaW4gdGhlIGRlZmF1bHQgY2FsbGluZyBjb250ZXh0LlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gVGhlIGNoaWxkIFByb21pc2UuXG4gKiBAdGVtcGxhdGUgUkVTVUxULFRISVNcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuYWRkQ2hpbGRQcm9taXNlXyA9IGZ1bmN0aW9uKFxub25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KSB7XG5cbiAgdmFyIGNhbGxiYWNrRW50cnkgPSB7XG4gICAgY2hpbGQ6IG51bGwsXG4gICAgb25GdWxmaWxsZWQ6IG51bGwsXG4gICAgb25SZWplY3RlZDogbnVsbFxuICB9O1xuXG4gIGNhbGxiYWNrRW50cnkuY2hpbGQgPSBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIEludm9rZSBvbkZ1bGZpbGxlZCwgb3IgcmVzb2x2ZSB3aXRoIHRoZSBwYXJlbnQncyB2YWx1ZSBpZiBhYnNlbnQuXG4gICAgY2FsbGJhY2tFbnRyeS5vbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBvbkZ1bGZpbGxlZC5jYWxsKG9wdF9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9IDogcmVzb2x2ZTtcblxuICAgIC8vIEludm9rZSBvblJlamVjdGVkLCBvciByZWplY3Qgd2l0aCB0aGUgcGFyZW50J3MgcmVhc29uIGlmIGFic2VudC5cbiAgICBjYWxsYmFja0VudHJ5Lm9uUmVqZWN0ZWQgPSBvblJlamVjdGVkID8gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb25SZWplY3RlZC5jYWxsKG9wdF9jb250ZXh0LCByZWFzb24pO1xuICAgICAgICBpZiAoIWNvcmUuaXNEZWYocmVzdWx0KSAmJiByZWFzb24uSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SKSB7XG4gICAgICAgICAgLy8gUHJvcGFnYXRlIGNhbmNlbGxhdGlvbiB0byBjaGlsZHJlbiBpZiBubyBvdGhlciByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSA6IHJlamVjdDtcbiAgfSk7XG5cbiAgY2FsbGJhY2tFbnRyeS5jaGlsZC5wYXJlbnRfID0gdGhpcztcbiAgdGhpcy5hZGRDYWxsYmFja0VudHJ5XyhcbiAgICAvKiogQHR5cGUge0NhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5X30gKi8gKGNhbGxiYWNrRW50cnkpKTtcbiAgcmV0dXJuIGNhbGxiYWNrRW50cnkuY2hpbGQ7XG59O1xuXG5cbi8qKlxuICogVW5ibG9ja3MgdGhlIFByb21pc2UgYW5kIGZ1bGZpbGxzIGl0IHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7VFlQRX0gdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudW5ibG9ja0FuZEZ1bGZpbGxfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbmNlbGxhYmxlUHJvbWlzZSBpcyBub3QgYmxvY2tlZC4nKTtcbiAgfVxuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcbiAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkZVTEZJTExFRCwgdmFsdWUpO1xufTtcblxuXG4vKipcbiAqIFVuYmxvY2tzIHRoZSBQcm9taXNlIGFuZCByZWplY3RzIGl0IHdpdGggdGhlIGdpdmVuIHJlamVjdGlvbiByZWFzb24uXG4gKlxuICogQHBhcmFtIHsqfSByZWFzb25cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudW5ibG9ja0FuZFJlamVjdF8gPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbmNlbGxhYmxlUHJvbWlzZSBpcyBub3QgYmxvY2tlZC4nKTtcbiAgfVxuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcbiAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCByZWFzb24pO1xufTtcblxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlc29sdmUgYSBQcm9taXNlIHdpdGggYSBnaXZlbiByZXNvbHV0aW9uIHN0YXRlIGFuZCB2YWx1ZS4gVGhpc1xuICogaXMgYSBuby1vcCBpZiB0aGUgZ2l2ZW4gUHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkLlxuICpcbiAqIElmIHRoZSBnaXZlbiByZXN1bHQgaXMgYSBUaGVuYWJsZSAoc3VjaCBhcyBhbm90aGVyIFByb21pc2UpLCB0aGUgUHJvbWlzZSB3aWxsXG4gKiBiZSByZXNvbHZlZCB3aXRoIHRoZSBzYW1lIHN0YXRlIGFuZCByZXN1bHQgYXMgdGhlIFRoZW5hYmxlIG9uY2UgaXQgaXMgaXRzZWxmXG4gKiByZXNvbHZlZC5cbiAqXG4gKiBJZiB0aGUgZ2l2ZW4gcmVzdWx0IGlzIG5vdCBhIFRoZW5hYmxlLCB0aGUgUHJvbWlzZSB3aWxsIGJlIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQgd2l0aCB0aGF0IHJlc3VsdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gc3RhdGUuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vI3RoZV9wcm9taXNlX3Jlc29sdXRpb25fcHJvY2VkdXJlXG4gKlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVffSBzdGF0ZVxuICogQHBhcmFtIHsqfSB4IFRoZSByZXN1bHQgdG8gYXBwbHkgdG8gdGhlIFByb21pc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnJlc29sdmVfID0gZnVuY3Rpb24oc3RhdGUsIHgpIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcyA9PT0geCkge1xuICAgIHN0YXRlID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRDtcbiAgICB4ID0gbmV3IFR5cGVFcnJvcignQ2FuY2VsbGFibGVQcm9taXNlIGNhbm5vdCByZXNvbHZlIHRvIGl0c2VsZicpO1xuXG4gIH0gZWxzZSBpZiAoVGhlbmFibGUuaXNJbXBsZW1lbnRlZEJ5KHgpKSB7XG4gICAgeCA9IC8qKiBAdHlwZSB7IVRoZW5hYmxlfSAqLyAoeCk7XG4gICAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQ7XG4gICAgeC50aGVuKHRoaXMudW5ibG9ja0FuZEZ1bGZpbGxfLCB0aGlzLnVuYmxvY2tBbmRSZWplY3RfLCB0aGlzKTtcbiAgICByZXR1cm47XG5cbiAgfSBlbHNlIGlmIChjb3JlLmlzT2JqZWN0KHgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGVuID0geC50aGVuO1xuICAgICAgaWYgKGNvcmUuaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICB0aGlzLnRyeVRoZW5fKHgsIHRoZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3RhdGUgPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEO1xuICAgICAgeCA9IGU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZXN1bHRfID0geDtcbiAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgdGhpcy5zY2hlZHVsZUNhbGxiYWNrc18oKTtcblxuICBpZiAoc3RhdGUgPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQgJiYgIXguSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SKSB7XG4gICAgQ2FuY2VsbGFibGVQcm9taXNlLmFkZFVuaGFuZGxlZFJlamVjdGlvbl8odGhpcywgeCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBjYWxsIHRoZSB7QGNvZGUgdGhlbn0gbWV0aG9kIG9uIGFuIG9iamVjdCBpbiB0aGUgaG9wZXMgdGhhdCBpdCBpc1xuICogYSBQcm9taXNlLWNvbXBhdGlibGUgaW5zdGFuY2UuIFRoaXMgYWxsb3dzIGludGVyb3BlcmF0aW9uIGJldHdlZW4gZGlmZmVyZW50XG4gKiBQcm9taXNlIGltcGxlbWVudGF0aW9ucywgaG93ZXZlciBhIG5vbi1jb21wbGlhbnQgb2JqZWN0IG1heSBjYXVzZSBhIFByb21pc2VcbiAqIHRvIGhhbmcgaW5kZWZpbml0ZWx5LiBJZiB0aGUge0Bjb2RlIHRoZW59IG1ldGhvZCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB0aGVcbiAqIGRlcGVuZGVudCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03MFxuICpcbiAqIEBwYXJhbSB7VGhlbmFibGV9IHRoZW5hYmxlIEFuIG9iamVjdCB3aXRoIGEge0Bjb2RlIHRoZW59IG1ldGhvZCB0aGF0IG1heSBiZVxuICogICAgIGNvbXBhdGlibGUgd2l0aCB0aGUgUHJvbWlzZS9BKyBzcGVjaWZpY2F0aW9uLlxuICogQHBhcmFtIHshRnVuY3Rpb259IHRoZW4gVGhlIHtAY29kZSB0aGVufSBtZXRob2Qgb2YgdGhlIFRoZW5hYmxlIG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudHJ5VGhlbl8gPSBmdW5jdGlvbih0aGVuYWJsZSwgdGhlbikge1xuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uQkxPQ0tFRDtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvbWlzZS51bmJsb2NrQW5kRnVsZmlsbF8odmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBwcm9taXNlLnVuYmxvY2tBbmRSZWplY3RfKHJlYXNvbik7XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgdGhlbi5jYWxsKHRoZW5hYmxlLCByZXNvbHZlLCByZWplY3QpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KGUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHBlbmRpbmcgY2FsbGJhY2tzIG9mIGEgcmVzb2x2ZWQgUHJvbWlzZSBhZnRlciBhIHRpbWVvdXQuXG4gKlxuICogU2VjdGlvbiAyLjIuNCBvZiB0aGUgUHJvbWlzZXMvQSsgc3BlY2lmaWNhdGlvbiByZXF1aXJlcyB0aGF0IFByb21pc2VcbiAqIGNhbGxiYWNrcyBtdXN0IG9ubHkgYmUgaW52b2tlZCBmcm9tIGEgY2FsbCBzdGFjayB0aGF0IG9ubHkgY29udGFpbnMgUHJvbWlzZVxuICogaW1wbGVtZW50YXRpb24gY29kZSwgd2hpY2ggd2UgYWNjb21wbGlzaCBieSBpbnZva2luZyBjYWxsYmFjayBleGVjdXRpb24gYWZ0ZXJcbiAqIGEgdGltZW91dC4gSWYge0Bjb2RlIHN0YXJ0RXhlY3V0aW9uX30gaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZVxuICogUHJvbWlzZSwgdGhlIGNhbGxiYWNrIGNoYWluIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgb25jZS4gQWRkaXRpb25hbCBjYWxsYmFja3NcbiAqIG1heSBiZSBhZGRlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24gcGhhc2UsIGFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lXG4gKiBldmVudCBsb29wLlxuICpcbiAqIEFsbCBQcm9taXNlcyBhZGRlZCB0byB0aGUgd2FpdGluZyBsaXN0IGR1cmluZyB0aGUgc2FtZSBicm93c2VyIGV2ZW50IGxvb3BcbiAqIHdpbGwgYmUgZXhlY3V0ZWQgaW4gb25lIGJhdGNoIHRvIGF2b2lkIHVzaW5nIGEgc2VwYXJhdGUgdGltZW91dCBwZXIgUHJvbWlzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnNjaGVkdWxlQ2FsbGJhY2tzXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZXhlY3V0aW5nXykge1xuICAgIHRoaXMuZXhlY3V0aW5nXyA9IHRydWU7XG4gICAgYXN5bmMucnVuKHRoaXMuZXhlY3V0ZUNhbGxiYWNrc18sIHRoaXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRXhlY3V0ZXMgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIGZvciB0aGlzIFByb21pc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5leGVjdXRlQ2FsbGJhY2tzXyA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5jYWxsYmFja0VudHJpZXNfICYmIHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5sZW5ndGgpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuY2FsbGJhY2tFbnRyaWVzXztcbiAgICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5leGVjdXRlQ2FsbGJhY2tfKGVudHJpZXNbaV0sIHRoaXMuc3RhdGVfLCB0aGlzLnJlc3VsdF8pO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4ZWN1dGluZ18gPSBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBFeGVjdXRlcyBhIHBlbmRpbmcgY2FsbGJhY2sgZm9yIHRoaXMgUHJvbWlzZS4gSW52b2tlcyBhbiB7QGNvZGUgb25GdWxmaWxsZWR9XG4gKiBvciB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgYmFzZWQgb24gdGhlIHJlc29sdmVkIHN0YXRlIG9mIHRoZSBQcm9taXNlLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5X30gY2FsbGJhY2tFbnRyeSBBbiBlbnRyeSBjb250YWluaW5nIHRoZVxuICogICAgIG9uRnVsZmlsbGVkIGFuZC9vciBvblJlamVjdGVkIGNhbGxiYWNrcyBmb3IgdGhpcyBzdGVwLlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVffSBzdGF0ZSBUaGUgcmVzb2x1dGlvbiBzdGF0dXMgb2YgdGhlIFByb21pc2UsXG4gKiAgICAgZWl0aGVyIEZVTEZJTExFRCBvciBSRUpFQ1RFRC5cbiAqIEBwYXJhbSB7Kn0gcmVzdWx0IFRoZSByZXNvbHZlZCByZXN1bHQgb2YgdGhlIFByb21pc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmV4ZWN1dGVDYWxsYmFja18gPSBmdW5jdGlvbihcbmNhbGxiYWNrRW50cnksIHN0YXRlLCByZXN1bHQpIHtcbiAgaWYgKHN0YXRlID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkZVTEZJTExFRCkge1xuICAgIGNhbGxiYWNrRW50cnkub25GdWxmaWxsZWQocmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlbW92ZVVuaGFuZGxlZFJlamVjdGlvbl8oKTtcbiAgICBjYWxsYmFja0VudHJ5Lm9uUmVqZWN0ZWQocmVzdWx0KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIE1hcmtzIHRoaXMgcmVqZWN0ZWQgUHJvbWlzZSBhcyBoYXZpbmcgYmVpbmcgaGFuZGxlZC4gQWxzbyBtYXJrcyBhbnkgcGFyZW50XG4gKiBQcm9taXNlcyBpbiB0aGUgcmVqZWN0ZWQgc3RhdGUgYXMgaGFuZGxlZC4gVGhlIHJlamVjdGlvbiBoYW5kbGVyIHdpbGwgbm9cbiAqIGxvbmdlciBiZSBpbnZva2VkIGZvciB0aGlzIFByb21pc2UgKGlmIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgYWxyZWFkeSkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5yZW1vdmVVbmhhbmRsZWRSZWplY3Rpb25fID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwO1xuICBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPiAwKSB7XG4gICAgZm9yIChwID0gdGhpczsgcCAmJiBwLnVuaGFuZGxlZFJlamVjdGlvbklkXzsgcCA9IHAucGFyZW50Xykge1xuICAgICAgY2xlYXJUaW1lb3V0KHAudW5oYW5kbGVkUmVqZWN0aW9uSWRfKTtcbiAgICAgIHAudW5oYW5kbGVkUmVqZWN0aW9uSWRfID0gMDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPT09IDApIHtcbiAgICBmb3IgKHAgPSB0aGlzOyBwICYmIHAuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXzsgcCA9IHAucGFyZW50Xykge1xuICAgICAgcC5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogTWFya3MgdGhpcyByZWplY3RlZCBQcm9taXNlIGFzIHVuaGFuZGxlZC4gSWYgbm8ge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrXG4gKiBpcyBjYWxsZWQgZm9yIHRoaXMgUHJvbWlzZSBiZWZvcmUgdGhlIHtAY29kZSBVTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZfVxuICogZXhwaXJlcywgdGhlIHJlYXNvbiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLiBUaGVcbiAqIGhhbmRsZXIgdHlwaWNhbGx5IHJldGhyb3dzIHRoZSByZWplY3Rpb24gcmVhc29uIHNvIHRoYXQgaXQgYmVjb21lcyB2aXNpYmxlIGluXG4gKiB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUuXG4gKlxuICogQHBhcmFtIHshQ2FuY2VsbGFibGVQcm9taXNlfSBwcm9taXNlIFRoZSByZWplY3RlZCBQcm9taXNlLlxuICogQHBhcmFtIHsqfSByZWFzb24gVGhlIFByb21pc2UgcmVqZWN0aW9uIHJlYXNvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5hZGRVbmhhbmRsZWRSZWplY3Rpb25fID0gZnVuY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA+IDApIHtcbiAgICBwcm9taXNlLnVuaGFuZGxlZFJlamVjdGlvbklkXyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXy5jYWxsKG51bGwsIHJlYXNvbik7XG4gICAgfSwgQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkpO1xuXG4gIH0gZWxzZSBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPT09IDApIHtcbiAgICBwcm9taXNlLmhhZFVuaGFuZGxlZFJlamVjdGlvbl8gPSB0cnVlO1xuICAgIGFzeW5jLnJ1bihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwcm9taXNlLmhhZFVuaGFuZGxlZFJlamVjdGlvbl8pIHtcbiAgICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCByZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQSBtZXRob2QgdGhhdCBpcyBpbnZva2VkIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb25zIGZvciBQcm9taXNlcyB0aGF0IGFyZVxuICogcmVqZWN0ZWQgYnV0IGhhdmUgbm8ge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcyByZWdpc3RlcmVkIHlldC5cbiAqIEB0eXBlIHtmdW5jdGlvbigqKX1cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fID0gYXN5bmMudGhyb3dFeGNlcHRpb247XG5cblxuLyoqXG4gKiBTZXRzIGEgaGFuZGxlciB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggcmVhc29ucyBmcm9tIHVuaGFuZGxlZCByZWplY3RlZFxuICogUHJvbWlzZXMuIElmIHRoZSByZWplY3RlZCBQcm9taXNlIChvciBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzKSBoYXMgYW5cbiAqIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayByZWdpc3RlcmVkLCB0aGUgcmVqZWN0aW9uIHdpbGwgYmUgY29uc2lkZXJlZFxuICogaGFuZGxlZCwgYW5kIHRoZSByZWplY3Rpb24gaGFuZGxlciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gKlxuICogQnkgZGVmYXVsdCwgdW5oYW5kbGVkIHJlamVjdGlvbnMgYXJlIHJldGhyb3duIHNvIHRoYXQgdGhlIGVycm9yIG1heSBiZVxuICogY2FwdHVyZWQgYnkgdGhlIGRldmVsb3BlciBjb25zb2xlIG9yIGEge0Bjb2RlIHdpbmRvdy5vbmVycm9yfSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IGhhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggcmVhc29ucyBmcm9tXG4gKiAgICAgcmVqZWN0ZWQgUHJvbWlzZXMuIERlZmF1bHRzIHRvIHtAY29kZSBhc3luYy50aHJvd0V4Y2VwdGlvbn0uXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5zZXRVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXyA9IGhhbmRsZXI7XG59O1xuXG5cblxuLyoqXG4gKiBFcnJvciB1c2VkIGFzIGEgcmVqZWN0aW9uIHJlYXNvbiBmb3IgY2FuY2VsZWQgUHJvbWlzZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAZmluYWxcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdF9tZXNzYWdlKSB7XG4gICAgIHN1cGVyKG9wdF9tZXNzYWdlKTtcblxuICAgICBpZiAob3B0X21lc3NhZ2UpIHtcbiAgICAgICB0aGlzLm1lc3NhZ2UgPSBvcHRfbWVzc2FnZTtcbiAgICAgfVxuICAgfVxufTtcblxuLyoqIEBvdmVycmlkZSAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ2NhbmNlbCc7XG5cbmV4cG9ydCB7Q2FuY2VsbGFibGVQcm9taXNlfTtcbmV4cG9ydCBkZWZhdWx0IENhbmNlbGxhYmxlUHJvbWlzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBVcmkgZnJvbSAnbWV0YWwtdXJpJztcbmltcG9ydCB7IENhbmNlbGxhYmxlUHJvbWlzZSBhcyBQcm9taXNlIH0gZnJvbSAnbWV0YWwtcHJvbWlzZSc7XG5cbmNsYXNzIEFqYXgge1xuXG5cdC8qKlxuXHQgKiBYbWxIdHRwUmVxdWVzdCdzIGdldEFsbFJlc3BvbnNlSGVhZGVycygpIG1ldGhvZCByZXR1cm5zIGEgc3RyaW5nIG9mXG5cdCAqIHJlc3BvbnNlIGhlYWRlcnMgYWNjb3JkaW5nIHRvIHRoZSBmb3JtYXQgZGVzY3JpYmVkIG9uIHRoZSBzcGVjOlxuXHQgKiB7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3RoZS1nZXRhbGxyZXNwb25zZWhlYWRlcnMtbWV0aG9kfS5cblx0ICogVGhpcyBtZXRob2QgcGFyc2VzIHRoYXQgc3RyaW5nIGludG8gYSB1c2VyLWZyaWVuZGx5IG5hbWUvdmFsdWUgcGFpclxuXHQgKiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhbGxIZWFkZXJzIEFsbCBoZWFkZXJzIGFzIHN0cmluZy5cblx0ICogQHJldHVybiB7IUFycmF5LjxPYmplY3Q8c3RyaW5nLCBzdHJpbmc+Pn1cblx0ICovXG5cdHN0YXRpYyBwYXJzZVJlc3BvbnNlSGVhZGVycyhhbGxIZWFkZXJzKSB7XG5cdFx0dmFyIGhlYWRlcnMgPSBbXTtcblx0XHRpZiAoIWFsbEhlYWRlcnMpIHtcblx0XHRcdHJldHVybiBoZWFkZXJzO1xuXHRcdH1cblx0XHR2YXIgcGFpcnMgPSBhbGxIZWFkZXJzLnNwbGl0KCdcXHUwMDBkXFx1MDAwYScpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpbmRleCA9IHBhaXJzW2ldLmluZGV4T2YoJ1xcdTAwM2FcXHUwMDIwJyk7XG5cdFx0XHRpZiAoaW5kZXggPiAwKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gcGFpcnNbaV0uc3Vic3RyaW5nKDAsIGluZGV4KTtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFpcnNbaV0uc3Vic3RyaW5nKGluZGV4ICsgMik7XG5cdFx0XHRcdGhlYWRlcnMucHVzaCh7XG5cdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBoZWFkZXJzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcXVlc3RzIHRoZSB1cmwgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdXJsXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gbWV0aG9kXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gYm9keVxuXHQgKiBAcGFyYW0ge011bHRpTWFwPX0gb3B0X2hlYWRlcnNcblx0ICogQHBhcmFtIHtNdWx0aU1hcD19IG9wdF9wYXJhbXNcblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfdGltZW91dFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc3luY1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfd2l0aENyZWRlbnRpYWxzXG5cdCAqIEByZXR1cm4ge1Byb21pc2V9IERlZmVycmVkIGFqYXggcmVxdWVzdC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c3RhdGljIHJlcXVlc3QodXJsLCBtZXRob2QsIGJvZHksIG9wdF9oZWFkZXJzLCBvcHRfcGFyYW1zLCBvcHRfdGltZW91dCwgb3B0X3N5bmMsIG9wdF93aXRoQ3JlZGVudGlhbHMpIHtcblx0XHR1cmwgPSB1cmwgfHwgJyc7XG5cdFx0bWV0aG9kID0gbWV0aG9kIHx8ICdHRVQnO1xuXG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRyZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG5cdFx0XHRcdFx0cmVxdWVzdC5vbmVycm9yKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc29sdmUocmVxdWVzdCk7XG5cdFx0XHR9O1xuXHRcdFx0cmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcignUmVxdWVzdCBlcnJvcicpO1xuXHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcblx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdH07XG5cdFx0fSkudGhlbkNhdGNoKGZ1bmN0aW9uKHJlYXNvbikge1xuXHRcdFx0cmVxdWVzdC5hYm9ydCgpO1xuXHRcdFx0dGhyb3cgcmVhc29uO1xuXHRcdH0pLnRoZW5BbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0fSk7XG5cblx0XHRpZiAob3B0X3BhcmFtcykge1xuXHRcdFx0dXJsID0gbmV3IFVyaSh1cmwpLmFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAob3B0X3BhcmFtcykudG9TdHJpbmcoKTtcblx0XHR9XG5cblx0XHRyZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsICFvcHRfc3luYyk7XG5cblx0XHRpZiAob3B0X3dpdGhDcmVkZW50aWFscykge1xuXHRcdFx0cmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChvcHRfaGVhZGVycykge1xuXHRcdFx0b3B0X2hlYWRlcnMubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0cmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG9wdF9oZWFkZXJzLmdldEFsbChuYW1lKS5qb2luKCcsICcpKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcXVlc3Quc2VuZChjb3JlLmlzRGVmKGJvZHkpID8gYm9keSA6IG51bGwpO1xuXG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKG9wdF90aW1lb3V0KSkge1xuXHRcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwcm9taXNlLmNhbmNlbCgnUmVxdWVzdCB0aW1lb3V0Jyk7XG5cdFx0XHR9LCBvcHRfdGltZW91dCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBamF4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQWpheCBmcm9tICdtZXRhbC1hamF4JztcbmltcG9ydCBUcmFuc3BvcnQgZnJvbSAnLi4vVHJhbnNwb3J0JztcbmltcG9ydCBDbGllbnRSZXNwb25zZSBmcm9tICcuLi9DbGllbnRSZXNwb25zZSc7XG5cbi8qKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIGFuIGFqYXggdHJhbnNwb3J0IHRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgV2VEZXBsb3l9LlxuICogQGV4dGVuZHMge1RyYW5zcG9ydH1cbiAqL1xuY2xhc3MgQWpheFRyYW5zcG9ydCBleHRlbmRzIFRyYW5zcG9ydCB7XG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0c2VuZChjbGllbnRSZXF1ZXN0KSB7XG5cdFx0dmFyIGRlZmVycmVkID0gQWpheC5yZXF1ZXN0KFxuXHRcdFx0Y2xpZW50UmVxdWVzdC51cmwoKSwgY2xpZW50UmVxdWVzdC5tZXRob2QoKSwgY2xpZW50UmVxdWVzdC5ib2R5KCksXG5cdFx0XHRjbGllbnRSZXF1ZXN0LmhlYWRlcnMoKSwgY2xpZW50UmVxdWVzdC5wYXJhbXMoKSwgbnVsbCwgZmFsc2UsIGNsaWVudFJlcXVlc3Qud2l0aENyZWRlbnRpYWxzKCkpO1xuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRcdHZhciBjbGllbnRSZXNwb25zZSA9IG5ldyBDbGllbnRSZXNwb25zZShjbGllbnRSZXF1ZXN0KTtcblx0XHRcdGNsaWVudFJlc3BvbnNlLmJvZHkocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcblx0XHRcdGNsaWVudFJlc3BvbnNlLnN0YXR1c0NvZGUocmVzcG9uc2Uuc3RhdHVzKTtcblx0XHRcdGNsaWVudFJlc3BvbnNlLnN0YXR1c1RleHQocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cdFx0XHRBamF4LnBhcnNlUmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKS5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuXHRcdFx0XHRjbGllbnRSZXNwb25zZS5oZWFkZXIoaGVhZGVyLm5hbWUsIGhlYWRlci52YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBjbGllbnRSZXNwb25zZTtcblx0XHR9KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBBamF4VHJhbnNwb3J0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQWpheFRyYW5zcG9ydCBmcm9tICcuL2Jyb3dzZXIvQWpheFRyYW5zcG9ydCc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBmYWN0b3J5IGZvciBkYXRhIHRyYW5zcG9ydC5cbiAqL1xuY2xhc3MgVHJhbnNwb3J0RmFjdG9yeSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMudHJhbnNwb3J0cyA9IHt9O1xuXHRcdHRoaXMudHJhbnNwb3J0c1tUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUVdID0gVHJhbnNwb3J0RmFjdG9yeVtUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMge0BsaW5rIFRyYW5zcG9ydEZhY3Rvcnl9IGluc3RhbmNlLlxuXHQgKi9cblx0c3RhdGljIGluc3RhbmNlKCkge1xuXHRcdGlmICghVHJhbnNwb3J0RmFjdG9yeS5pbnN0YW5jZV8pIHtcblx0XHRcdFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2VfID0gbmV3IFRyYW5zcG9ydEZhY3RvcnkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2VfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW1wbGVtZW50YXRpb25OYW1lXG5cdCAqIEByZXR1cm4geyFUcmFuc3BvcnR9XG5cdCAqL1xuXHRnZXQoaW1wbGVtZW50YXRpb25OYW1lKSB7XG5cdFx0dmFyIFRyYW5zcG9ydENsYXNzID0gdGhpcy50cmFuc3BvcnRzW2ltcGxlbWVudGF0aW9uTmFtZV07XG5cblx0XHRpZiAoIVRyYW5zcG9ydENsYXNzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNwb3J0IG5hbWU6ICcgKyBpbXBsZW1lbnRhdGlvbk5hbWUpO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gbmV3IChUcmFuc3BvcnRDbGFzcykoKTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjcmVhdGUgdHJhbnNwb3J0JywgZXJyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZGVmYXVsdCB0cmFuc3BvcnQgaW1wbGVtZW50YXRpb24uXG5cdCAqIEByZXR1cm4geyFUcmFuc3BvcnR9XG5cdCAqL1xuXHRnZXREZWZhdWx0KCkge1xuXHRcdHJldHVybiB0aGlzLmdldChUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUUpO1xuXHR9XG59XG5cblRyYW5zcG9ydEZhY3RvcnkuREVGQVVMVF9UUkFOU1BPUlRfTkFNRSA9ICdkZWZhdWx0JztcblxuVHJhbnNwb3J0RmFjdG9yeVtUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUVdID0gQWpheFRyYW5zcG9ydDtcblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNwb3J0RmFjdG9yeTtcbiIsInZhciBnbG9iYWxzID0ge307XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRnbG9iYWxzLndpbmRvdyA9IHdpbmRvdztcbn1cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0Z2xvYmFscy5kb2N1bWVudCA9IGRvY3VtZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnbG9iYWxzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWxzJztcbmltcG9ydCBVcmkgZnJvbSAnbWV0YWwtdXJpJztcblxuZnVuY3Rpb24gYXNzZXJ0QnJvd3NlckVudmlyb25tZW50KCkge1xuXHRpZiAoIWdsb2JhbHMud2luZG93KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdTaWduLWluIHR5cGUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVmQW5kTm90TnVsbCh2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG5cdGlmICghY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm90TnVsbCh2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG5cdGlmIChjb3JlLmlzTnVsbCh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG5cdGlmICghY29yZS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdCh2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG5cdGlmICghY29yZS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkge1xuXHRpZiAoIXJlc3BvbnNlLnN1Y2NlZWRlZCgpKSB7XG5cdFx0dGhyb3cgcmVzcG9uc2UuYm9keSgpO1xuXHR9XG5cdHJldHVybiByZXNwb25zZTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VXNlclNpZ25lZEluKHVzZXIpIHtcblx0aWYgKCFjb3JlLmlzRGVmQW5kTm90TnVsbCh1c2VyKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmUgc2lnbmVkLWluIHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24nKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnRVcmlXaXRoTm9QYXRoKHVybCwgbWVzc2FnZSkge1xuXHR2YXIgdXJpID0gbmV3IFVyaSh1cmwpO1xuXHRpZiAodXJpLmdldFBhdGhuYW1lKCkubGVuZ3RoID4gMSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0fVxufVxuXG5leHBvcnQgeyBhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQsIGFzc2VydERlZkFuZE5vdE51bGwsIGFzc2VydE5vdE51bGwsIGFzc2VydEZ1bmN0aW9uLCBhc3NlcnRPYmplY3QsIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkLCBhc3NlcnRVc2VyU2lnbmVkSW4sIGFzc2VydFVyaVdpdGhOb1BhdGggfTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcblxuaW1wb3J0IHsgYXNzZXJ0RGVmQW5kTm90TnVsbCwgYXNzZXJ0T2JqZWN0LCBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZCB9IGZyb20gJy4uL2Fzc2VydGlvbnMnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBzdG9yaW5nIGF1dGhvcml6YXRpb24gaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIEF1dGgge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbk9yRW1haWwgRWl0aGVyIHRoZSBhdXRob3JpemF0aW9uIHRva2VuLCBvclxuXHQgKiAgIHRoZSB1c2VybmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcGFzc3dvcmQgSWYgYSB1c2VybmFtZSBpcyBnaXZlbiBhcyB0aGUgZmlyc3QgcGFyYW0sXG5cdCAqICAgdGhpcyBzaG91bGQgYmUgdGhlIHBhc3N3b3JkLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkID0gbnVsbCkge1xuXHRcdHRoaXMudG9rZW4gPSBjb3JlLmlzU3RyaW5nKG9wdF9wYXNzd29yZCkgPyBudWxsIDogdG9rZW5PckVtYWlsO1xuXHRcdHRoaXMuZW1haWwgPSBjb3JlLmlzU3RyaW5nKG9wdF9wYXNzd29yZCkgPyB0b2tlbk9yRW1haWwgOiBudWxsO1xuXHRcdHRoaXMucGFzc3dvcmQgPSBvcHRfcGFzc3dvcmQ7XG5cblx0XHR0aGlzLmNyZWF0ZWRBdCA9IG51bGw7XG5cdFx0dGhpcy5pZCA9IG51bGw7XG5cdFx0dGhpcy5uYW1lID0gbnVsbDtcblx0XHR0aGlzLnBob3RvVXJsID0gbnVsbDtcblx0XHR0aGlzLndlZGVwbG95Q2xpZW50ID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRva2VuT3JVc2VybmFtZSBFaXRoZXIgdGhlIGF1dGhvcml6YXRpb24gdG9rZW4sIG9yXG5cdCAqICAgdGhlIHVzZXJuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9wYXNzd29yZCBJZiBhIHVzZXJuYW1lIGlzIGdpdmVuIGFzIHRoZSBmaXJzdCBwYXJhbSxcblx0ICogICB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4geyFBdXRofVxuXHQgKi9cblx0c3RhdGljIGNyZWF0ZSh0b2tlbk9yVXNlcm5hbWUsIG9wdF9wYXNzd29yZCkge1xuXHRcdHJldHVybiBuZXcgQXV0aCh0b2tlbk9yVXNlcm5hbWUsIG9wdF9wYXNzd29yZCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY3JlYXRlZCBhdCBkYXRlLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRDcmVhdGVkQXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlZEF0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGVtYWlsLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRFbWFpbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5lbWFpbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBpZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0SWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaWQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgbmFtZS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0TmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5uYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBhc3N3b3JkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRQYXNzd29yZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXNzd29yZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwaG90byB1cmwuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBob3RvVXJsKCkge1xuXHRcdHJldHVybiB0aGlzLnBob3RvVXJsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHRva2VuLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRUb2tlbigpIHtcblx0XHRyZXR1cm4gdGhpcy50b2tlbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgY3JlYXRlZCBhdCBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNDcmVhdGVkQXQoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuY3JlYXRlZEF0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGVtYWlsIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc0VtYWlsKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLmVtYWlsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGlkIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc0lkKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLmlkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIG5hbWUgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzTmFtZSgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5uYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHBhc3N3b3JkIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Bhc3N3b3JkKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnBhc3N3b3JkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHBob3RvIHVybCBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNQaG90b1VybCgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5waG90b1VybCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSB0b2tlbiBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNUb2tlbigpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy50b2tlbik7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBjcmVhdGVkIGF0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY3JlYXRlZEF0XG5cdCAqL1xuXHRzZXRDcmVhdGVkQXQoY3JlYXRlZEF0KSB7XG5cdFx0dGhpcy5jcmVhdGVkQXQgPSBjcmVhdGVkQXQ7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZW1haWwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuXHQgKi9cblx0c2V0RW1haWwoZW1haWwpIHtcblx0XHR0aGlzLmVtYWlsID0gZW1haWw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgaWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKi9cblx0c2V0SWQoaWQpIHtcblx0XHR0aGlzLmlkID0gaWQ7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICovXG5cdHNldE5hbWUobmFtZSkge1xuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGFzc3dvcmQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuXHQgKi9cblx0c2V0UGFzc3dvcmQocGFzc3dvcmQpIHtcblx0XHR0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGhvdG8gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGhvdG9Vcmxcblx0ICovXG5cdHNldFBob3RvVXJsKHBob3RvVXJsKSB7XG5cdFx0dGhpcy5waG90b1VybCA9IHBob3RvVXJsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHRva2VuLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cblx0ICovXG5cdHNldFRva2VuKHRva2VuKSB7XG5cdFx0dGhpcy50b2tlbiA9IHRva2VuO1xuXHR9XG5cblx0c2V0V2VkZXBsb3lDbGllbnQod2VkZXBsb3lDbGllbnQpIHtcblx0XHR0aGlzLndlZGVwbG95Q2xpZW50ID0gd2VkZXBsb3lDbGllbnQ7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgdXNlci5cblx0ICogQHBhcmFtIHshb2JqZWN0fSBkYXRhXG5cdCAqIEByZXR1cm4ge0NvbXBsZXRhYmxlRnV0dXJlfVxuXHQgKi9cblx0dXBkYXRlVXNlcihkYXRhKSB7XG5cdFx0YXNzZXJ0T2JqZWN0KGRhdGEsICdVc2VyIGRhdGEgbXVzdCBiZSBzcGVjaWZpZWQgYXMgb2JqZWN0Jyk7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvdXNlcnMnKVxuXHRcdFx0LmF1dGgodGhpcylcblx0XHRcdC5wYXRjaChkYXRhKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIHRoZSBjdXJyZW50IHVzZXIuXG5cdCAqIEByZXR1cm4ge0NvbXBsZXRhYmxlRnV0dXJlfVxuXHQgKi9cblx0ZGVsZXRlVXNlcigpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKHRoaXMuaWQsICdDYW5ub3QgZGVsZXRlIHVzZXIgd2l0aG91dCBpZCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJywgdGhpcy5pZClcblx0XHRcdC5hdXRoKHRoaXMpXG5cdFx0XHQuZGVsZXRlKClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBVcmkgZnJvbSAnbWV0YWwtdXJpJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGUgcHJvdmlkZXIgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIEF1dGhQcm92aWRlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMucHJvdmlkZXIgPSBudWxsO1xuXHRcdHRoaXMucHJvdmlkZXJTY29wZSA9IG51bGw7XG5cdFx0dGhpcy5yZWRpcmVjdFVyaSA9IG51bGw7XG5cdFx0dGhpcy5zY29wZSA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHByb3ZpZGVyIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUHJvdmlkZXIoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucHJvdmlkZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBzY29wZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Byb3ZpZGVyU2NvcGUoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucHJvdmlkZXJTY29wZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHJlZGlyZWN0IHVyaSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1JlZGlyZWN0VXJpKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnJlZGlyZWN0VXJpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgc2NvcGUgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNTY29wZSgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5zY29wZSk7XG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgYXV0aG9yaXphdGlvbiB1cmwuXG5cdCAqIEByZXR1cm4ge3N0cmluZz19IEF1dGhvcml6YXRpb24gdXJsLlxuXHQgKi9cblx0bWFrZUF1dGhvcml6YXRpb25Vcmwob3B0X2F1dGhVcmwpIHtcblx0XHR2YXIgdXJpID0gbmV3IFVyaShvcHRfYXV0aFVybCk7XG5cblx0XHR1cmkuc2V0UGF0aG5hbWUoJy9vYXV0aC9hdXRob3JpemUnKTtcblxuXHRcdGlmICh0aGlzLmhhc1Byb3ZpZGVyKCkpIHtcblx0XHRcdHVyaS5zZXRQYXJhbWV0ZXJWYWx1ZSgncHJvdmlkZXInLCB0aGlzLmdldFByb3ZpZGVyKCkpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5oYXNQcm92aWRlclNjb3BlKCkpIHtcblx0XHRcdHVyaS5zZXRQYXJhbWV0ZXJWYWx1ZSgncHJvdmlkZXJfc2NvcGUnLCB0aGlzLmdldFByb3ZpZGVyU2NvcGUoKSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmhhc1JlZGlyZWN0VXJpKCkpIHtcblx0XHRcdHVyaS5zZXRQYXJhbWV0ZXJWYWx1ZSgncmVkaXJlY3RfdXJpJywgdGhpcy5nZXRSZWRpcmVjdFVyaSgpKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaGFzU2NvcGUoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdzY29wZScsIHRoaXMuZ2V0U2NvcGUoKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVyaS50b1N0cmluZygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgcHJvdmlkZXIgbmFtZS5cblx0ICogQHJldHVybiB7c3RyaW5nPX0gUHJvdmlkZXIgbmFtZS5cblx0ICovXG5cdGdldFByb3ZpZGVyKCkge1xuXHRcdHJldHVybiB0aGlzLnByb3ZpZGVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgcHJvdmlkZXIgc2NvcGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZz19IFN0cmluZyB3aXRoIHNjb3Blcy5cblx0ICovXG5cdGdldFByb3ZpZGVyU2NvcGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvdmlkZXJTY29wZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHJlZGlyZWN0IHVyaS5cblx0ICogQHJldHVybiB7c3RyaW5nPX0uXG5cdCAqL1xuXHRnZXRSZWRpcmVjdFVyaSgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZWRpcmVjdFVyaTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHNjb3BlLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fSBTdHJpbmcgd2l0aCBzY29wZXMuXG5cdCAqL1xuXHRnZXRTY29wZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5zY29wZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHByb3ZpZGVyIHNjb3BlLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IHNjb3BlIFNjb3BlIHN0cmluZy4gU2VwYXJhdGUgYnkgc3BhY2UgZm9yIG11bHRpcGxlXG5cdCAqICAgc2NvcGVzLCBlLmcuIFwic2NvcGUxIHNjb3BlMlwiLlxuXHQgKi9cblx0c2V0UHJvdmlkZXJTY29wZShwcm92aWRlclNjb3BlKSB7XG5cdFx0YXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsKHByb3ZpZGVyU2NvcGUsICdQcm92aWRlciBzY29wZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cdFx0dGhpcy5wcm92aWRlclNjb3BlID0gcHJvdmlkZXJTY29wZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHJlZGlyZWN0IHVyaS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSByZWRpcmVjdFVyaS5cblx0ICovXG5cdHNldFJlZGlyZWN0VXJpKHJlZGlyZWN0VXJpKSB7XG5cdFx0YXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsKHJlZGlyZWN0VXJpLCAnUmVkaXJlY3QgdXJpIG11c3QgYmUgYSBzdHJpbmcnKTtcblx0XHR0aGlzLnJlZGlyZWN0VXJpID0gcmVkaXJlY3RVcmk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBzY29wZS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBzY29wZSBTY29wZSBzdHJpbmcuIFNlcGFyYXRlIGJ5IHNwYWNlIGZvciBtdWx0aXBsZVxuXHQgKiAgIHNjb3BlcywgZS5nLiBcInNjb3BlMSBzY29wZTJcIi5cblx0ICovXG5cdHNldFNjb3BlKHNjb3BlKSB7XG5cdFx0YXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsKHNjb3BlLCAnU2NvcGUgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdHRoaXMuc2NvcGUgPSBzY29wZTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuXHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpICYmICFjb3JlLmlzU3RyaW5nKHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhQcm92aWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGhQcm92aWRlciBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5cbi8qKlxuICogRmFjZWJvb2sgYXV0aCBwcm92aWRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgRmFjZWJvb2tBdXRoUHJvdmlkZXIgZXh0ZW5kcyBBdXRoUHJvdmlkZXIge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgRmFjZWJvb2tBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5wcm92aWRlciA9IEZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSO1xuXHR9XG59XG5cbkZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSID0gJ2ZhY2Vib29rJztcblxuZXhwb3J0IGRlZmF1bHQgRmFjZWJvb2tBdXRoUHJvdmlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBdXRoUHJvdmlkZXIgZnJvbSAnLi9BdXRoUHJvdmlkZXInO1xuXG4vKipcbiAqIEdpdGh1YiBhdXRoIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBHaXRodWJBdXRoUHJvdmlkZXIgZXh0ZW5kcyBBdXRoUHJvdmlkZXIge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgR2l0aHViQXV0aFByb3ZpZGVyfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMucHJvdmlkZXIgPSBHaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVI7XG5cdH1cbn1cblxuR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSID0gJ2dpdGh1Yic7XG5cbmV4cG9ydCBkZWZhdWx0IEdpdGh1YkF1dGhQcm92aWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGhQcm92aWRlciBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5cbi8qKlxuICogR29vZ2xlIGF1dGggcHJvdmlkZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIEdvb2dsZUF1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBHb29nbGVBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5wcm92aWRlciA9IEdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUjtcblx0fVxufVxuXG5Hb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZ29vZ2xlJztcblxuZXhwb3J0IGRlZmF1bHQgR29vZ2xlQXV0aFByb3ZpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5cbi8qKlxuICogQWJzdHJhY3QgaW50ZXJmYWNlIGZvciBzdG9yaW5nIGFuZCByZXRyaWV2aW5nIGRhdGEgdXNpbmcgc29tZSBwZXJzaXN0ZW5jZVxuICogbWVjaGFuaXNtLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFN0b3JhZ2VNZWNoYW5pc20ge1xuXHQvKipcblx0ICogQ2xlYXIgYWxsIGl0ZW1zIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICovXG5cdGNsZWFyKCkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgYW4gaXRlbSBpbiB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXJpYWxpemUgdG8gYSBzdHJpbmcgYW5kIHNhdmUuXG5cdCAqL1xuXHRzZXQoa2V5LCB2YWx1ZSkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBnZXQuXG5cdCAqIEByZXR1cm4geyp9IERlc2VyaWFsaXplZCB2YWx1ZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuXHQgKi9cblx0Z2V0KGtleSkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxpc3Qgb2Yga2V5cyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuXHQgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBrZXlzXG5cdCAqL1xuXHRrZXlzKCkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG5cdCAqL1xuXHRyZW1vdmUoa2V5KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgaXRlbXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZSgpIHtcblx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlTWVjaGFuaXNtO1xuXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgY29yZSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgU3RvcmFnZU1lY2hhbmlzbSBmcm9tICcuL21lY2hhbmlzbS9TdG9yYWdlTWVjaGFuaXNtJztcblxuY2xhc3MgU3RvcmFnZSB7XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY29udmVuaWVudCBBUEkgZm9yIGRhdGEgcGVyc2lzdGVuY2UgdXNpbmcgYSBzZWxlY3RlZCBkYXRhXG5cdCAqIHN0b3JhZ2UgbWVjaGFuaXNtLlxuXHQgKiBAcGFyYW0geyFTdG9yYWdlTWVjaGFuaXNtfSBtZWNoYW5pc20gVGhlIHVuZGVybHlpbmcgc3RvcmFnZSBtZWNoYW5pc20uXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IobWVjaGFuaXNtKSB7XG5cdFx0YXNzZXJ0TWVjaGFuaXNtRGVmQW5kTm90TnVsbChtZWNoYW5pc20pO1xuXHRcdGFzc2VydE1lY2hhbmlzbUludGFuY2VPZihtZWNoYW5pc20pO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1lY2hhbmlzbSB1c2VkIHRvIHBlcnNpc3Qga2V5LXZhbHVlIHBhaXJzLlxuXHRcdCAqIEB0eXBlIHtTdG9yYWdlTWVjaGFuaXNtfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLm1lY2hhbmlzbSA9IG1lY2hhbmlzbTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhciBhbGwgaXRlbXMgZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5tZWNoYW5pc20uY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGFuIGl0ZW0gaW4gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VyaWFsaXplIHRvIGEgc3RyaW5nIGFuZCBzYXZlLlxuXHQgKi9cblx0c2V0KGtleSwgdmFsdWUpIHtcblx0XHRpZiAoIWNvcmUuaXNEZWYodmFsdWUpKSB7XG5cdFx0XHR0aGlzLm1lY2hhbmlzbS5yZW1vdmUoa2V5KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5tZWNoYW5pc20uc2V0KGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFuIGl0ZW0gZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gZ2V0LlxuXHQgKiBAcmV0dXJuIHsqfSBEZXNlcmlhbGl6ZWQgdmFsdWUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cblx0ICovXG5cdGdldChrZXkpIHtcblx0XHR2YXIganNvbjtcblx0XHR0cnkge1xuXHRcdFx0anNvbiA9IHRoaXMubWVjaGFuaXNtLmdldChrZXkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChjb3JlLmlzTnVsbChqc29uKSkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRocm93IFN0b3JhZ2UuRXJyb3JDb2RlLklOVkFMSURfVkFMVUU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxpc3Qgb2Yga2V5cyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuXHQgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBrZXlzXG5cdCAqL1xuXHRrZXlzKCkge1xuXHRcdHJldHVybiB0aGlzLm1lY2hhbmlzbS5rZXlzKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHJlbW92ZS5cblx0ICovXG5cdHJlbW92ZShrZXkpIHtcblx0XHR0aGlzLm1lY2hhbmlzbS5yZW1vdmUoa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF0YSBpdGVtcyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLm1lY2hhbmlzbS5zaXplKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbGlzdCBvZiB2YWx1ZXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gdmFsdWVzXG5cdCAqL1xuXHR2YWx1ZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMua2V5cygpLm1hcCgoa2V5KSA9PiB0aGlzLmdldChrZXkpKTtcblx0fVxufVxuXG4vKipcbiAqIEVycm9ycyB0aHJvd24gYnkgdGhlIHN0b3JhZ2UuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5TdG9yYWdlLkVycm9yQ29kZSA9IHtcblx0SU5WQUxJRF9WQUxVRTogJ1N0b3JhZ2U6IEludmFsaWQgdmFsdWUgd2FzIGVuY291bnRlcmVkJ1xufTtcblxuZnVuY3Rpb24gYXNzZXJ0TWVjaGFuaXNtRGVmQW5kTm90TnVsbChtZWNoYW5pc20pIHtcblx0aWYgKCFjb3JlLmlzRGVmQW5kTm90TnVsbChtZWNoYW5pc20pKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1N0b3JhZ2UgbWVjaGFuaXNtIGlzIHJlcXVpcmVkJyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0TWVjaGFuaXNtSW50YW5jZU9mKG1lY2hhbmlzbSkge1xuXHRpZiAoIShtZWNoYW5pc20gaW5zdGFuY2VvZiBTdG9yYWdlTWVjaGFuaXNtKSkge1xuXHRcdHRocm93IEVycm9yKCdTdG9yYWdlIG1lY2hhbmlzbSBtdXN0IG1lIGFuIGltcGxlbWVudGF0aW9uIG9mIFN0b3JhZ2VNZWNoYW5pc20nKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgU3RvcmFnZU1lY2hhbmlzbSBmcm9tICcuL1N0b3JhZ2VNZWNoYW5pc20nO1xuXG4vKipcbiAqIEFic3RyYWN0IGludGVyZmFjZSBmb3Igc3RvcmluZyBhbmQgcmV0cmlldmluZyBkYXRhIHVzaW5nIHNvbWUgcGVyc2lzdGVuY2VcbiAqIG1lY2hhbmlzbS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBMb2NhbFN0b3JhZ2VNZWNoYW5pc20gZXh0ZW5kcyBTdG9yYWdlTWVjaGFuaXNtIHtcblx0LyoqXG5cdCAqIFJldHVybnMgcmVmZXJlbmNlIGZvciBnbG9iYWwgbG9jYWwgc3RvcmFnZS4gYnkgZGVmYXVsdFxuXHQgKi9cblx0c3RvcmFnZSgpIHtcblx0XHRyZXR1cm4gTG9jYWxTdG9yYWdlTWVjaGFuaXNtLmdsb2JhbHMubG9jYWxTdG9yYWdlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRjbGVhcigpIHtcblx0XHR0aGlzLnN0b3JhZ2UoKS5jbGVhcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRrZXlzKCkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2UoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGdldChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5zdG9yYWdlKCkuZ2V0SXRlbShrZXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRyZW1vdmUoa2V5KSB7XG5cdFx0dGhpcy5zdG9yYWdlKCkucmVtb3ZlSXRlbShrZXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRzZXQoa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMuc3RvcmFnZSgpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdHNpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RvcmFnZSgpLmxlbmd0aDtcblx0fVxufVxuXG5Mb2NhbFN0b3JhZ2VNZWNoYW5pc20uZ2xvYmFscyA9IHtcblx0bG9jYWxTdG9yYWdlOiB3aW5kb3cubG9jYWxTdG9yYWdlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBMb2NhbFN0b3JhZ2VNZWNoYW5pc207XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBTdG9yYWdlIGZyb20gJy4uL1N0b3JhZ2UnO1xuaW1wb3J0IFN0b3JhZ2VNZWNoYW5pc20gZnJvbSAnLi4vbWVjaGFuaXNtL1N0b3JhZ2VNZWNoYW5pc20nO1xuaW1wb3J0IExvY2FsU3RvcmFnZU1lY2hhbmlzbSBmcm9tICcuLi9tZWNoYW5pc20vTG9jYWxTdG9yYWdlTWVjaGFuaXNtJztcblxuZXhwb3J0IHsgU3RvcmFnZSwgU3RvcmFnZU1lY2hhbmlzbSwgTG9jYWxTdG9yYWdlTWVjaGFuaXNtIH07IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aCBmcm9tICcuL0F1dGgnO1xuaW1wb3J0IEZhY2Vib29rQXV0aFByb3ZpZGVyIGZyb20gJy4vRmFjZWJvb2tBdXRoUHJvdmlkZXInO1xuaW1wb3J0IEdpdGh1YkF1dGhQcm92aWRlciBmcm9tICcuL0dpdGh1YkF1dGhQcm92aWRlcic7XG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi8uLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IEdvb2dsZUF1dGhQcm92aWRlciBmcm9tICcuL0dvb2dsZUF1dGhQcm92aWRlcic7XG5pbXBvcnQgeyBTdG9yYWdlLCBMb2NhbFN0b3JhZ2VNZWNoYW5pc20gfSBmcm9tICdtZXRhbC1zdG9yYWdlJztcblxuaW1wb3J0IHsgYXNzZXJ0RGVmQW5kTm90TnVsbCwgYXNzZXJ0RnVuY3Rpb24sIGFzc2VydE9iamVjdCwgYXNzZXJ0VXNlclNpZ25lZEluLCBhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQsIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkIH0gZnJvbSAnLi4vYXNzZXJ0aW9ucyc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY2Fwc3VsYXRlIGF1dGggYXBpIGNhbGxzLlxuICovXG5jbGFzcyBBdXRoQXBpSGVscGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGhBcGlIZWxwZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHdlZGVwbG95Q2xpZW50KSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbCh3ZWRlcGxveUNsaWVudCwgJ1dlRGVwbG95IGNsaWVudCByZWZlcmVuY2UgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuXHRcdHRoaXMuY3VycmVudFVzZXIgPSBudWxsO1xuXHRcdHRoaXMub25TaWduSW5DYWxsYmFjayA9IG51bGw7XG5cdFx0dGhpcy5vblNpZ25PdXRDYWxsYmFjayA9IG51bGw7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuXHRcdHRoaXMuc3RvcmFnZSA9IG5ldyBTdG9yYWdlKG5ldyBMb2NhbFN0b3JhZ2VNZWNoYW5pc20oKSk7XG5cblx0XHR0aGlzLnByb2Nlc3NTaWduSW5fKCk7XG5cblx0XHR0aGlzLnByb3ZpZGVyID0ge1xuXHRcdFx0RmFjZWJvb2s6IEZhY2Vib29rQXV0aFByb3ZpZGVyLFxuXHRcdFx0R29vZ2xlOiBHb29nbGVBdXRoUHJvdmlkZXIsXG5cdFx0XHRHaXRodWI6IEdpdGh1YkF1dGhQcm92aWRlclxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyB1c2VyLlxuXHQgKiBAcGFyYW0geyFvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdXNlZCB0byBjcmVhdGUgdGhlIHVzZXIuXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGNyZWF0ZVVzZXIoZGF0YSkge1xuXHRcdGFzc2VydE9iamVjdChkYXRhLCAnVXNlciBkYXRhIG11c3QgYmUgc3BlY2lmaWVkIGFzIG9iamVjdCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJylcblx0XHRcdC5wb3N0KGRhdGEpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB0aGlzLm1ha2VVc2VyQXV0aEZyb21EYXRhKHJlc3BvbnNlLmJvZHkoKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnQgYnJvd3NlciB1cmwgd2l0aG91dCB0aGUgZnJhZ21lbnQgcGFydC5cblx0ICogQHJldHVybiB7IXN0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0SHJlZldpdGhvdXRGcmFnbWVudF8oKSB7XG5cdFx0dmFyIGxvY2F0aW9uID0gZ2xvYmFscy53aW5kb3cubG9jYXRpb247XG5cdFx0cmV0dXJuIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QgKyBsb2NhdGlvbi5wYXRobmFtZSArIChsb2NhdGlvbi5zZWFyY2ggPyBsb2NhdGlvbi5zZWFyY2ggOiAnJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgYWNjZXNzIHRva2VuIGZyb20gdGhlIHVybCBmcmFnbWVudCBhbmQgcmVtb3ZlcyBpdC5cblx0ICogQHJldHVybiB7P3N0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0UmVkaXJlY3RBY2Nlc3NUb2tlbl8oKSB7XG5cdFx0aWYgKGdsb2JhbHMud2luZG93KSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0aWYgKGZyYWdtZW50LmluZGV4T2YoJyNhY2Nlc3NfdG9rZW49JykgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIGZyYWdtZW50LnN1YnN0cmluZygxNCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdXNlciBieSBpZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB1c2VySWRcblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0Z2V0VXNlcih1c2VySWQpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKHVzZXJJZCwgJ1VzZXIgdXNlcklkIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0YXNzZXJ0VXNlclNpZ25lZEluKHRoaXMuY3VycmVudFVzZXIpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJywgdXNlcklkKVxuXHRcdFx0LmF1dGgodGhpcy5jdXJyZW50VXNlci50b2tlbilcblx0XHRcdC5nZXQoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMb2FkcyBjdXJyZW50IHVzZXIuIFJlcXVpcmVzIGEgdXNlciB0b2tlbiBhcyBhcmd1bWVudC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB0b2tlblxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRsb2FkQ3VycmVudFVzZXIodG9rZW4pIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKHRva2VuLCAnVXNlciB0b2tlbiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXInKVxuXHRcdFx0LmF1dGgodG9rZW4pXG5cdFx0XHQuZ2V0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblx0XHRcdFx0dmFyIGRhdGEgPSByZXNwb25zZS5ib2R5KCk7XG5cdFx0XHRcdGRhdGEudG9rZW4gPSB0b2tlbjtcblx0XHRcdFx0dGhpcy5jdXJyZW50VXNlciA9IHRoaXMubWFrZVVzZXJBdXRoRnJvbURhdGEoZGF0YSk7XG5cdFx0XHRcdHRoaXMuc3RvcmFnZS5zZXQoJ2N1cnJlbnRVc2VyJywgZGF0YSk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRVc2VyO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgdXNlciBBdXRoIGZyb20gZGF0YSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdCAqIEByZXR1cm4ge0F1dGh9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG1ha2VVc2VyQXV0aEZyb21EYXRhKGRhdGEpIHtcblx0XHR2YXIgYXV0aCA9IG5ldyBBdXRoKCk7XG5cdFx0YXV0aC5zZXRXZWRlcGxveUNsaWVudCh0aGlzLndlZGVwbG95Q2xpZW50KTtcblx0XHRhdXRoLnNldENyZWF0ZWRBdChkYXRhLmNyZWF0ZWRBdCk7XG5cdFx0YXV0aC5zZXRFbWFpbChkYXRhLmVtYWlsKTtcblx0XHRhdXRoLnNldElkKGRhdGEuaWQpO1xuXHRcdGF1dGguc2V0TmFtZShkYXRhLm5hbWUpO1xuXHRcdGF1dGguc2V0UGhvdG9VcmwoZGF0YS5waG90b1VybCk7XG5cdFx0YXV0aC5zZXRUb2tlbihkYXRhLnRva2VuKTtcblx0XHRyZXR1cm4gYXV0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyB0aGUgb24gc2lnbiBpbiBjYWxsYmFjayBpZiBzZXQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKCkge1xuXHRcdGlmICh0aGlzLm9uU2lnbkluQ2FsbGJhY2spIHtcblx0XHRcdHRoaXMub25TaWduSW5DYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuY3VycmVudFVzZXIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyB0aGUgb24gc2lnbiBvdXQgY2FsbGJhY2sgaWYgc2V0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRtYXliZUNhbGxPblNpZ25PdXRDYWxsYmFja18oKSB7XG5cdFx0aWYgKHRoaXMub25TaWduT3V0Q2FsbGJhY2spIHtcblx0XHRcdHRoaXMub25TaWduT3V0Q2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRVc2VyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRmlyZXMgcGFzc2VkIGNhbGxiYWNrIHdoZW4gYSB1c2VyIHNpZ24taW4uIE5vdGUgdGhhdCBpdCBrZWVwcyBvbmx5IHRoZVxuXHQgKiBsYXN0IGNhbGxiYWNrIHBhc3NlZC5cblx0ICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqL1xuXHRvblNpZ25JbihjYWxsYmFjaykge1xuXHRcdGFzc2VydEZ1bmN0aW9uKGNhbGxiYWNrLCAnU2lnbi1pbiBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHR0aGlzLm9uU2lnbkluQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0fVxuXG5cdC8qKlxuXHQgKiBGaXJlcyBwYXNzZWQgY2FsbGJhY2sgd2hlbiBhIHVzZXIgc2lnbi1vdXQuIE5vdGUgdGhhdCBpdCBrZWVwcyBvbmx5IHRoZVxuXHQgKiBsYXN0IGNhbGxiYWNrIHBhc3NlZC5cblx0ICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqL1xuXHRvblNpZ25PdXQoY2FsbGJhY2spIHtcblx0XHRhc3NlcnRGdW5jdGlvbihjYWxsYmFjaywgJ1NpZ24tb3V0IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdHRoaXMub25TaWduT3V0Q2FsbGJhY2sgPSBjYWxsYmFjaztcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzZXMgc2lnbi1pbiBieSBkZXRlY3RpbmcgYSBwcmVzZW5jZSBvZiBhIGZyYWdtZW50XG5cdCAqIDxjb2RlPiNhY2Nlc3NfdG9rZW49PC9jb2RlPiBpbiB0aGUgdXJsIG9yLCBhbHRlcm5hdGl2ZWx5LCBieSBsb2NhbFxuXHQgKiBzdG9yYWdlIGN1cnJlbnQgdXNlci5cblx0ICovXG5cdHByb2Nlc3NTaWduSW5fKCkge1xuXHRcdHZhciByZWRpcmVjdEFjY2Vzc1Rva2VuID0gdGhpcy5nZXRSZWRpcmVjdEFjY2Vzc1Rva2VuXygpO1xuXHRcdGlmIChyZWRpcmVjdEFjY2Vzc1Rva2VuKSB7XG5cdFx0XHR0aGlzLnJlbW92ZVVybEZyYWdtZW50Q29tcGxldGVseV8oKTtcblx0XHRcdHRoaXMubG9hZEN1cnJlbnRVc2VyKHJlZGlyZWN0QWNjZXNzVG9rZW4pXG5cdFx0XHRcdC50aGVuKCgpID0+IHRoaXMubWF5YmVDYWxsT25TaWduSW5DYWxsYmFja18oKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBjdXJyZW50VXNlciA9IHRoaXMuc3RvcmFnZS5nZXQoJ2N1cnJlbnRVc2VyJyk7XG5cdFx0aWYgKGN1cnJlbnRVc2VyKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRVc2VyID0gdGhpcy5tYWtlVXNlckF1dGhGcm9tRGF0YShjdXJyZW50VXNlcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgZnJhZ21lbnQgZnJvbSB1cmwgYnkgcGVyZm9ybWluZyBhIHB1c2ggc3RhdGUgdG8gdGhlIGN1cnJlbnQgcGF0aC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cmVtb3ZlVXJsRnJhZ21lbnRDb21wbGV0ZWx5XygpIHtcblx0XHRnbG9iYWxzLndpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgZG9jdW1lbnQudGl0bGUsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIHBhc3N3b3JkIHJlc2V0IGVtYWlsIHRvIHRoZSBzcGVjaWZpZWQgZW1haWwgaWYgZm91bmQgaW4gZGF0YWJhc2UuXG5cdCAqIEZvciBzZWN1cml0eSByZWFzb25zIGNhbGwgZG8gbm90IGZhaWwgaWYgZW1haWwgbm90IGZvdW5kLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IGVtYWlsXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHNlbmRQYXNzd29yZFJlc2V0RW1haWwoZW1haWwpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGVtYWlsLCAnU2VuZCBwYXNzd29yZCByZXNldCBlbWFpbCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXIvcmVjb3ZlcicpXG5cdFx0XHQucGFyYW0oJ2VtYWlsJywgZW1haWwpXG5cdFx0XHQucG9zdCgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpZ25zIGluIHVzaW5nIGVtYWlsIGFuZCBwYXNzd29yZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBlbWFpbFxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHBhc3N3b3JkXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkKGVtYWlsLCBwYXNzd29yZCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoZW1haWwsICdTaWduLWluIGVtYWlsIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChwYXNzd29yZCwgJ1NpZ24taW4gcGFzc3dvcmQgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL29hdXRoL3Rva2VuJylcblx0XHRcdC5wYXJhbSgnZ3JhbnRfdHlwZScsICdwYXNzd29yZCcpXG5cdFx0XHQucGFyYW0oJ3VzZXJuYW1lJywgZW1haWwpXG5cdFx0XHQucGFyYW0oJ3Bhc3N3b3JkJywgcGFzc3dvcmQpXG5cdFx0XHQuZ2V0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHRoaXMubG9hZEN1cnJlbnRVc2VyKHJlc3BvbnNlLmJvZHkoKS5hY2Nlc3NfdG9rZW4pKVxuXHRcdFx0LnRoZW4oKHVzZXIpID0+IHtcblx0XHRcdFx0dGhpcy5tYXliZUNhbGxPblNpZ25JbkNhbGxiYWNrXygpO1xuXHRcdFx0XHRyZXR1cm4gdXNlcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpZ25zIGluIHdpdGggcmVkaXJlY3QuIFNvbWUgcHJvdmlkZXJzIGFuZCBlbnZpcm9ubWVudCBtYXkgbm90IHN1cHBvcnRcblx0ICogdGhpcyBmbG93LlxuXHQgKiBAcGFyYW0ge0F1dGhQcm92aWRlcn0gcHJvdmlkZXJcblx0ICovXG5cdHNpZ25JbldpdGhSZWRpcmVjdChwcm92aWRlcikge1xuXHRcdGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCgpO1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwocHJvdmlkZXIsICdTaWduLWluIHByb3ZpZGVyIG11c3QgYmUgZGVmaW5lZCcpO1xuXHRcdGFzc2VydFN1cHBvcnRlZFByb3ZpZGVyKHByb3ZpZGVyKTtcblxuXHRcdGlmICghcHJvdmlkZXIuaGFzUmVkaXJlY3RVcmkoKSkge1xuXHRcdFx0cHJvdmlkZXIuc2V0UmVkaXJlY3RVcmkodGhpcy5nZXRIcmVmV2l0aG91dEZyYWdtZW50XygpKTtcblx0XHR9XG5cdFx0Z2xvYmFscy53aW5kb3cubG9jYXRpb24uaHJlZiA9IHByb3ZpZGVyLm1ha2VBdXRob3JpemF0aW9uVXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpZ25zIG91dCA8Y29kZT5jdXJyZW50VXNlcjwvY29kZT4gYW5kIHJlbW92ZXMgZnJvbSA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdHNpZ25PdXQoKSB7XG5cdFx0YXNzZXJ0VXNlclNpZ25lZEluKHRoaXMuY3VycmVudFVzZXIpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL29hdXRoL3Jldm9rZScpXG5cdFx0XHQucGFyYW0oJ3Rva2VuJywgdGhpcy5jdXJyZW50VXNlci50b2tlbilcblx0XHRcdC5nZXQoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXHRcdFx0XHR0aGlzLm1heWJlQ2FsbE9uU2lnbk91dENhbGxiYWNrXygpO1xuXHRcdFx0XHR0aGlzLnVubG9hZEN1cnJlbnRVc2VyXygpO1xuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVbmxvYWRzIGFsbCBpbmZvcm1hdGlvbiBmb3IgPGNvZGU+Y3VycmVudFVzZXI8L2NvZGU+IGFuZCByZW1vdmVzIGZyb21cblx0ICogPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBpZiBwcmVzZW50LlxuXHQgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdHVubG9hZEN1cnJlbnRVc2VyXygpIHtcblx0XHR0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcblx0XHR0aGlzLnN0b3JhZ2UucmVtb3ZlKCdjdXJyZW50VXNlcicpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN1cHBvcnRlZFByb3ZpZGVyKHByb3ZpZGVyKSB7XG5cdHN3aXRjaCAocHJvdmlkZXIuY29uc3RydWN0b3IuUFJPVklERVIpIHtcblx0XHRjYXNlIEZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuXHRcdGNhc2UgR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuXHRcdGNhc2UgR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2lnbi1pbiBwcm92aWRlciBub3Qgc3VwcG9ydGVkJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aEFwaUhlbHBlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIHByaW50ZWQgYXMgSlNPTlxuICogd2hlbiB0aGUgYHRvU3RyaW5nYCBtZXRob2QgaXMgY2FsbGVkLlxuICovXG5jbGFzcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgRW1ib2RpZWQgaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5ib2R5XyA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGpzb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGlzIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0Ym9keSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ib2R5Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIEVtYm9kaWVkLCB0aGlzIHdpbGxcblx0ICogcmV0dXJuIGl0cyBib2R5IGNvbnRlbnQuIE90aGVyd2lzZSB0aGlzIHdpbGwgcmV0dXJuIHRoZVxuXHQgKiBvcmlnaW5hbCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Kn0gb2JqXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0b0JvZHkob2JqKSB7XG5cdFx0cmV0dXJuIChvYmogaW5zdGFuY2VvZiBFbWJvZGllZCkgPyBvYmouYm9keSgpIDogb2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGpzb24gc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGlzIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KCkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVtYm9kaWVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBzdG9yaW5nIGFuZCBoYW5kbGluZyB0aGUgYm9keSBjb250ZW50c1xuICogb2YgYSBGaWx0ZXIgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIEZpbHRlckJvZHkge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBGaWx0ZXJCb2R5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gb3BlcmF0b3JPclZhbHVlIElmIGEgdGhpcmQgcGFyYW0gaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkXG5cdCAqICAgYmUgdGhlIGZpbHRlcidzIG9wZXJhdG9yIChsaWtlIFwiPj1cIikuIE90aGVyd2lzZSwgdGhpcyB3aWxsIGJlXG5cdCAqICAgdXNlZCBhcyB0aGUgZmlsdGVyJ3MgdmFsdWUsIGFuZCB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3Igd2lsbCBiZSBcIj1cIi5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgb2JqID0ge1xuXHRcdFx0b3BlcmF0b3I6IGNvcmUuaXNEZWYob3B0X3ZhbHVlKSA/IG9wZXJhdG9yT3JWYWx1ZSA6ICc9J1xuXHRcdH07XG5cdFx0dmFyIHZhbHVlID0gY29yZS5pc0RlZihvcHRfdmFsdWUpID8gb3B0X3ZhbHVlIDogb3BlcmF0b3JPclZhbHVlO1xuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbCh2YWx1ZSkpIHtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVtYm9kaWVkKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUuYm9keSgpO1xuXHRcdFx0fVxuXHRcdFx0b2JqLnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXHRcdHRoaXMuY3JlYXRlQm9keV8oZmllbGQsIG9iaik7XG5cdH1cblxuXHQvKipcblx0ICogQ29tcG9zZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHdpdGggdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHtGaWx0ZXI9fSBvcHRfZmlsdGVyIEFub3RoZXIgZmlsdGVyIHRvIGNvbXBvc2UgdGhpcyBmaWx0ZXIgd2l0aCxcblx0ICogICBpZiB0aGUgb3BlcmF0b3IgaXMgbm90IHVuYXJ5LlxuXHQgKi9cblx0YWRkKG9wZXJhdG9yLCBvcHRfZmlsdGVyKSB7XG5cdFx0aWYgKG9wdF9maWx0ZXIpIHtcblx0XHRcdHRoaXMuYWRkQXJyYXlPcGVyYXRvcl8ob3BlcmF0b3IsIG9wdF9maWx0ZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUJvZHlfKG9wZXJhdG9yLCB0aGlzLmJvZHlfKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ29tcG9zZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHdpdGggYW4gb3BlcmF0b3IgdGhhdCBzdG9yZXMgaXRzIHZhbHVlcyBpbiBhbiBhcnJheS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7IUZpbHRlcn0gZmlsdGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGFkZEFycmF5T3BlcmF0b3JfKG9wZXJhdG9yLCBmaWx0ZXIpIHtcblx0XHRpZiAoISh0aGlzLmJvZHlfW29wZXJhdG9yXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0dGhpcy5jcmVhdGVCb2R5XyhvcGVyYXRvciwgW3RoaXMuYm9keV9dKTtcblx0XHR9XG5cdFx0dGhpcy5ib2R5X1tvcGVyYXRvcl0ucHVzaChmaWx0ZXIuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciBib2R5IHVzaW5nIHRoZSBnaXZlbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7Li4uKn0gZmlsdGVycyBBIHZhcmlhYmxlIGFtb3VudCBvZiBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkLlxuXHQgKi9cblx0YWRkTWFueShvcGVyYXRvciwgLi4uZmlsdGVycykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5hZGQob3BlcmF0b3IsIGZpbHRlcnNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IGJvZHkgb2JqZWN0LCBzZXR0aW5nIHRoZSByZXF1ZXN0ZCBrZXkgdG8gdGhlIGdpdmVuIHZhbHVlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2V0IGluIHRoZSBuZXcgYm9keSBvYmplY3Rcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIHJlcXVlc3RlZCBrZXkgc2hvdWxkIGhhdmUgaW4gdGhlIG5ldyBib2R5IG9iamVjdC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Y3JlYXRlQm9keV8oa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMuYm9keV8gPSB7fTtcblx0XHR0aGlzLmJvZHlfW2tleV0gPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBmaWx0ZXIncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0Z2V0T2JqZWN0KCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlckJvZHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGdlb21ldHJpY1xuICogc2hhcGVzLlxuICovXG5jbGFzcyBHZW8ge1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQm91bmRpbmdCb3h9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHVwcGVyTGVmdCBUaGUgdXBwZXIgbGVmdCBwb2ludC5cblx0ICogQHBhcmFtIHsqfSBsb3dlclJpZ2h0IFRoZSBsb3dlciByaWdodCBwb2ludC5cblx0ICogQHJldHVybiB7IUJvdW5kaW5nQm94fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYm91bmRpbmdCb3godXBwZXJMZWZ0LCBsb3dlclJpZ2h0KSB7XG5cdFx0cmV0dXJuIG5ldyBHZW8uQm91bmRpbmdCb3godXBwZXJMZWZ0LCBsb3dlclJpZ2h0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBDaXJjbGV9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGNlbnRlciBUaGUgY2lyY2xlJ3MgY2VudGVyIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByYWRpdXMgVGhlIGNpcmNsZSdzIHJhZGl1cy5cblx0ICogQHJldHVybiB7IUNpcmNsZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGNpcmNsZShjZW50ZXIsIHJhZGl1cykge1xuXHRcdHJldHVybiBuZXcgR2VvLkNpcmNsZShjZW50ZXIsIHJhZGl1cyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgTGluZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgbGluZSdzIHBvaW50cy5cblx0ICogQHJldHVybiB7IUxpbmV9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBsaW5lKC4uLnBvaW50cykge1xuXHRcdHJldHVybiBuZXcgR2VvLkxpbmUoLi4ucG9pbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBQb2ludH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGNvb3JkaW5hdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxvbiBUaGUgbG9uZ2l0dWRlIGNvb3JkaW5hdGVcblx0ICogQHJldHVybiB7IVBvaW50fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcG9pbnQobGF0LCBsb24pIHtcblx0XHRyZXR1cm4gbmV3IEdlby5Qb2ludChsYXQsIGxvbik7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUG9seWdvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgcG9seWdvbidzIHBvaW50cy5cblx0ICogQHJldHVybiB7IVBvbHlnb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBwb2x5Z29uKC4uLnBvaW50cykge1xuXHRcdHJldHVybiBuZXcgR2VvLlBvbHlnb24oLi4ucG9pbnRzKTtcblx0fVxufVxuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvaW50IGNvb3JkaW5hdGUuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFBvaW50IGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBQb2ludH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGNvb3JkaW5hdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxvbiBUaGUgbG9uZ2l0dWRlIGNvb3JkaW5hdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihsYXQsIGxvbikge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IFtsYXQsIGxvbl07XG5cdH1cbn1cbkdlby5Qb2ludCA9IFBvaW50O1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGxpbmUuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIExpbmUgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIExpbmV9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0gey4uLip9IHBvaW50cyBUaGlzIGxpbmUncyBwb2ludHMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0ge1xuXHRcdFx0dHlwZTogJ2xpbmVzdHJpbmcnLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IHBvaW50cy5tYXAocG9pbnQgPT4gRW1ib2RpZWQudG9Cb2R5KHBvaW50KSlcblx0XHR9O1xuXHR9XG59XG5HZW8uTGluZSA9IExpbmU7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgYm91bmRpbmcgYm94LlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBCb3VuZGluZ0JveCBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgQm91bmRpbmdCb3h9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHVwcGVyTGVmdCBUaGUgdXBwZXIgbGVmdCBwb2ludC5cblx0ICogQHBhcmFtIHsqfSBsb3dlclJpZ2h0IFRoZSBsb3dlciByaWdodCBwb2ludC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih1cHBlckxlZnQsIGxvd2VyUmlnaHQpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSB7XG5cdFx0XHR0eXBlOiAnZW52ZWxvcGUnLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IFtFbWJvZGllZC50b0JvZHkodXBwZXJMZWZ0KSwgRW1ib2RpZWQudG9Cb2R5KGxvd2VyUmlnaHQpXVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGJvdW5kaW5nIGJveCdzIHBvaW50cy5cblx0ICogQHJldHVybiB7IUFycmF5fVxuXHQgKi9cblx0Z2V0UG9pbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfLmNvb3JkaW5hdGVzO1xuXHR9XG59XG5HZW8uQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBjaXJjbGUuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIENpcmNsZSBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgQ2lyY2xlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSBjZW50ZXIgVGhlIGNpcmNsZSdzIGNlbnRlciBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcmFkaXVzIFRoZSBjaXJjbGUncyByYWRpdXMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoY2VudGVyLCByYWRpdXMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSB7XG5cdFx0XHR0eXBlOiAnY2lyY2xlJyxcblx0XHRcdGNvb3JkaW5hdGVzOiBFbWJvZGllZC50b0JvZHkoY2VudGVyKSxcblx0XHRcdHJhZGl1czogcmFkaXVzXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgY2lyY2xlJ3MgY2VudGVyIGNvb3JkaW5hdGUuXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRnZXRDZW50ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV8uY29vcmRpbmF0ZXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGNpcmNsZSdzIHJhZGl1cy5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UmFkaXVzKCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfLnJhZGl1cztcblx0fVxufVxuR2VvLkNpcmNsZSA9IENpcmNsZTtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBwb2x5Z29uLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBQb2x5Z29uIGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBQb2x5Z29ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBwb2x5Z29uJ3MgcG9pbnRzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKC4uLnBvaW50cykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IHtcblx0XHRcdHR5cGU6ICdwb2x5Z29uJyxcblx0XHRcdGNvb3JkaW5hdGVzOiBbXVxuXHRcdH07XG5cdFx0dGhpcy5hZGRDb29yZGluYXRlc18oLi4ucG9pbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgY29vcmRpbmF0ZXMgZm9yIHRoaXMgcG9seWdvbi5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkQ29vcmRpbmF0ZXNfKC4uLnBvaW50cykge1xuXHRcdHRoaXMuYm9keV8uY29vcmRpbmF0ZXMucHVzaChwb2ludHMubWFwKHBvaW50ID0+IEVtYm9kaWVkLnRvQm9keShwb2ludCkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgYSBob2xlIGluc2lkZSB0aGlzIHBvbHlnb24uXG5cdCAqIEBwYXJhbSAgey4uLip9IHBvaW50c1xuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0aG9sZSguLi5wb2ludHMpIHtcblx0XHR0aGlzLmFkZENvb3JkaW5hdGVzXyguLi5wb2ludHMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5HZW8uUG9seWdvbiA9IFBvbHlnb247XG5cbmV4cG9ydCBkZWZhdWx0IEdlbztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgcmFuZ2Ugb2JqZWN0cyB0byBiZSB1c2VkIGJ5IGBGaWx0ZXJgLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBSYW5nZSBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHBhcmFtIHsqfSBvcHRfdG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihmcm9tLCBvcHRfdG8pIHtcblx0XHRzdXBlcigpO1xuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmcm9tKSkge1xuXHRcdFx0dGhpcy5ib2R5Xy5mcm9tID0gZnJvbTtcblx0XHR9XG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKG9wdF90bykpIHtcblx0XHRcdHRoaXMuYm9keV8udG8gPSBvcHRfdG87XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZnJvbShmcm9tKSB7XG5cdFx0cmV0dXJuIG5ldyBSYW5nZShmcm9tKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSBmcm9tXG5cdCAqIEBwYXJhbSB7Kn0gdG9cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmFuZ2UoZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSB0b1xuXHQgKiBAcmV0dXJuIHshUmFuZ2V9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0byh0bykge1xuXHRcdHJldHVybiBuZXcgUmFuZ2UobnVsbCwgdG8pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhbmdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuaW1wb3J0IEZpbHRlckJvZHkgZnJvbSAnLi9GaWx0ZXJCb2R5JztcbmltcG9ydCBHZW8gZnJvbSAnLi9HZW8nO1xuaW1wb3J0IFJhbmdlIGZyb20gJy4vUmFuZ2UnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBmaWx0ZXJzLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBGaWx0ZXIgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IG9wZXJhdG9yT3JWYWx1ZSBJZiBhIHRoaXJkIHBhcmFtIGlzIGdpdmVuLCB0aGlzIHNob3VsZFxuXHQgKiAgIGJlIHRoZSBmaWx0ZXIncyBvcGVyYXRvciAobGlrZSBcIj49XCIpLiBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZVxuXHQgKiAgIHVzZWQgYXMgdGhlIGZpbHRlcidzIHZhbHVlLCBhbmQgdGhlIGZpbHRlcidzIG9wZXJhdG9yIHdpbGwgYmUgXCI9XCIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0gbmV3IEZpbHRlckJvZHkoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFkZChvcGVyYXRvciwgZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0dmFyIGZpbHRlciA9IGZpZWxkT3JGaWx0ZXIgPyBGaWx0ZXIudG9GaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSA6IG51bGw7XG5cdFx0dGhpcy5ib2R5Xy5hZGQob3BlcmF0b3IsIGZpbHRlcik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHsuLi4qfSBmaWx0ZXJzIEEgdmFyaWFibGUgYW1vdW50IG9mIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRhZGRNYW55KG9wZXJhdG9yLCAuLi5maWx0ZXJzKSB7XG5cdFx0dGhpcy5ib2R5Xy5hZGRNYW55KG9wZXJhdG9yLCAuLi5maWx0ZXJzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIFwiYW5kXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRhbmQoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCdhbmQnLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiYW55XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyEoQXJyYXl8Li4uKil9IHZhbHVlcyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqICAgdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiAgIHNlcGFyYXRlIHBhcmFtcy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGFueShmaWVsZCkge1xuXHRcdHZhciB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdGlmICh2YWx1ZXMubGVuZ3RoID09PSAxICYmIHZhbHVlc1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR2YWx1ZXMgPSB2YWx1ZXNbMF07XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnYW55JywgdmFsdWVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdwXCIgb3BlcmF0b3IuXG5cdCAqIFRoaXMgaXMgYSBzcGVjaWFsIHVzZSBjYXNlIG9mIGBGaWx0ZXIucG9seWdvbmAgZm9yIGJvdW5kaW5nXG5cdCAqIGJveGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSBib3hPclVwcGVyTGVmdCBFaXRoZXIgYSBgR2VvLkJvdW5kaW5nQm94YCBpbnN0YW5jZSwgb3Jcblx0ICogICBhIGJvdW5kaW5nIGJveCdzIHVwcGVyIGxlZnQgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X2xvd2VyUmlnaHQgQSBib3VuZGluZyBib3gncyBsb3dlciByaWdodCBjb29yZGluYXRlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYm91bmRpbmdCb3goZmllbGQsIGJveE9yVXBwZXJMZWZ0LCBvcHRfbG93ZXJSaWdodCkge1xuXHRcdGlmIChib3hPclVwcGVyTGVmdCBpbnN0YW5jZW9mIEdlby5Cb3VuZGluZ0JveCkge1xuXHRcdFx0cmV0dXJuIEZpbHRlci5wb2x5Z29uKGZpZWxkLCAuLi5ib3hPclVwcGVyTGVmdC5nZXRQb2ludHMoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBGaWx0ZXIucG9seWdvbihmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUganNvbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoaXMgZmlsdGVyLlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0Ym9keSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ib2R5Xy5nZXRPYmplY3QoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdkXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uT3JDaXJjbGUgRWl0aGVyIGEgYEdlby5DaXJjbGVgIGluc3RhbmNlIG9yIGEgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtSYW5nZXxzdHJpbmc9fSBvcHRfcmFuZ2VPckRpc3RhbmNlIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3Jcblx0ICogICB0aGUgZGlzdGFuY2UgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBkaXN0YW5jZShmaWVsZCwgbG9jYXRpb25PckNpcmNsZSwgb3B0X3JhbmdlT3JEaXN0YW5jZSkge1xuXHRcdHZhciBsb2NhdGlvbiA9IGxvY2F0aW9uT3JDaXJjbGU7XG5cdFx0dmFyIHJhbmdlID0gb3B0X3JhbmdlT3JEaXN0YW5jZTtcblx0XHRpZiAobG9jYXRpb25PckNpcmNsZSBpbnN0YW5jZW9mIEdlby5DaXJjbGUpIHtcblx0XHRcdGxvY2F0aW9uID0gbG9jYXRpb25PckNpcmNsZS5nZXRDZW50ZXIoKTtcblx0XHRcdHJhbmdlID0gUmFuZ2UudG8obG9jYXRpb25PckNpcmNsZS5nZXRSYWRpdXMoKSk7XG5cdFx0fSBlbHNlIGlmICghKG9wdF9yYW5nZU9yRGlzdGFuY2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcblx0XHRcdHJhbmdlID0gUmFuZ2UudG8ob3B0X3JhbmdlT3JEaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBGaWx0ZXIuZGlzdGFuY2VJbnRlcm5hbF8oZmllbGQsIGxvY2F0aW9uLCByYW5nZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJnZFwiIG9wZXJhdG9yLiBUaGlzXG5cdCAqIGlzIGp1c3QgYW4gaW50ZXJuYWwgaGVscGVyIHVzZWQgYnkgYEZpbHRlci5kaXN0YW5jZWAuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uIEEgbG9jYXRpb24gY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgQSBgUmFuZ2VgIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBkaXN0YW5jZUludGVybmFsXyhmaWVsZCwgbG9jYXRpb24sIHJhbmdlKSB7XG5cdFx0dmFyIHZhbHVlID0ge1xuXHRcdFx0bG9jYXRpb246IEVtYm9kaWVkLnRvQm9keShsb2NhdGlvbilcblx0XHR9O1xuXHRcdHJhbmdlID0gcmFuZ2UuYm9keSgpO1xuXHRcdGlmIChyYW5nZS5mcm9tKSB7XG5cdFx0XHR2YWx1ZS5taW4gPSByYW5nZS5mcm9tO1xuXHRcdH1cblx0XHRpZiAocmFuZ2UudG8pIHtcblx0XHRcdHZhbHVlLm1heCA9IHJhbmdlLnRvO1xuXHRcdH1cblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnZ2QnLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI9XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGVxdWFsKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPScsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImV4aXN0c1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGV4aXN0cyhmaWVsZCkge1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdleGlzdHMnLCBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImZ1enp5XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSBvcHRfcXVlcnlPckZ1enppbmVzcyBJZiB0aGlzIGlzIGEgc3RyaW5nLCBpdCBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnksIG90aGVyd2lzZSBpdCBzaG91bGQgYmUgdGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnV6emluZXNzIFRoZSBmdXp6aW5lc3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmdXp6eShmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKSB7XG5cdFx0cmV0dXJuIEZpbHRlci5mdXp6eUludGVybmFsXygnZnV6enknLCBmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBnaXZlbiBmdXp6eSBvcGVyYXRvci4gVGhpc1xuXHQgKiBpcyBhbiBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IHRoZSBgRmlsdGVyLmZ1enp5YCBtZXRob2QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgZnV6enkgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSBvcHRfcXVlcnlPckZ1enppbmVzcyBJZiB0aGlzIGlzIGEgc3RyaW5nLCBpdCBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnksIG90aGVyd2lzZSBpdCBzaG91bGQgYmUgdGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnV6emluZXNzIFRoZSBmdXp6aW5lc3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZ1enp5SW50ZXJuYWxfKG9wZXJhdG9yLCBmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKSB7XG5cdFx0dmFyIGFyZzJJc1N0cmluZyA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5T3JGdXp6aW5lc3MpO1xuXG5cdFx0dmFyIHZhbHVlID0ge1xuXHRcdFx0cXVlcnk6IGFyZzJJc1N0cmluZyA/IG9wdF9xdWVyeU9yRnV6emluZXNzIDogZmllbGRPclF1ZXJ5XG5cdFx0fTtcblx0XHR2YXIgZnV6emluZXNzID0gYXJnMklzU3RyaW5nID8gb3B0X2Z1enppbmVzcyA6IG9wdF9xdWVyeU9yRnV6emluZXNzO1xuXHRcdGlmIChmdXp6aW5lc3MpIHtcblx0XHRcdHZhbHVlLmZ1enppbmVzcyA9IGZ1enppbmVzcztcblx0XHR9XG5cblx0XHR2YXIgZmllbGQgPSBhcmcySXNTdHJpbmcgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsIG9wZXJhdG9yLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI+XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGd0KGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPicsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIj49XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGd0ZShmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJz49JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwibWF0Y2hcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3F1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtYXRjaChmaWVsZE9yUXVlcnksIG9wdF9xdWVyeSkge1xuXHRcdHZhciBmaWVsZCA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHF1ZXJ5ID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdtYXRjaCcsIHF1ZXJ5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm1pc3NpbmdcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtaXNzaW5nKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ21pc3NpbmcnLCBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcInBocmFzZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogICBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHBocmFzZShmaWVsZE9yUXVlcnksIG9wdF9xdWVyeSkge1xuXHRcdHZhciBmaWVsZCA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHF1ZXJ5ID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdwaHJhc2UnLCBxdWVyeSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJncFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkLlxuXHQgKiBAcGFyYW0gey4uLiFPYmplY3R9IHBvaW50cyBPYmplY3RzIHJlcHJlc2VudGluZyBwb2ludHMgaW4gdGhlIHBvbHlnb24uXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBwb2x5Z29uKGZpZWxkLCAuLi5wb2ludHMpIHtcblx0XHRwb2ludHMgPSBwb2ludHMubWFwKHBvaW50ID0+IEVtYm9kaWVkLnRvQm9keShwb2ludCkpO1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdncCcsIHBvaW50cyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJwcmVmaXhcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkXG5cdCAqICAgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC4gT3RoZXJ3aXNlLFxuXHQgKiAgIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHByZWZpeChmaWVsZE9yUXVlcnksIG9wdF9xdWVyeSkge1xuXHRcdHZhciBmaWVsZCA9IG9wdF9xdWVyeSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHF1ZXJ5ID0gb3B0X3F1ZXJ5ID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdwcmVmaXgnLCBxdWVyeSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJyYW5nZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yTWluIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3IgYSB0aGUgcmFuZ2UncyBtaW4gdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9tYXggVGhlIHJhbmdlJ3MgbWF4IHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmFuZ2UoZmllbGQsIHJhbmdlT3JNaW4sIG9wdF9tYXgpIHtcblx0XHR2YXIgcmFuZ2UgPSByYW5nZU9yTWluO1xuXHRcdGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG5cdFx0XHRyYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JNaW4sIG9wdF9tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAncmFuZ2UnLCByYW5nZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJ+XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHJlZ2V4KGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnficsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0gey4uLiFPYmplY3R9IHNoYXBlcyBPYmplY3RzIHJlcHJlc2VudGluZyBzaGFwZXMuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzaGFwZShmaWVsZCwgLi4uc2hhcGVzKSB7XG5cdFx0c2hhcGVzID0gc2hhcGVzLm1hcChzaGFwZSA9PiBFbWJvZGllZC50b0JvZHkoc2hhcGUpKTtcblx0XHR2YXIgdmFsdWUgPSB7XG5cdFx0XHR0eXBlOiAnZ2VvbWV0cnljb2xsZWN0aW9uJyxcblx0XHRcdGdlb21ldHJpZXM6IHNoYXBlc1xuXHRcdH07XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ2dzJywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwic2ltaWxhclwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogICBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHs/c3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc2ltaWxhcihmaWVsZE9yUXVlcnksIHF1ZXJ5KSB7XG5cdFx0dmFyIGZpZWxkID0gY29yZS5pc1N0cmluZyhxdWVyeSkgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuXHRcdHZhciB2YWx1ZSA9IHtcblx0XHRcdHF1ZXJ5OiBjb3JlLmlzU3RyaW5nKHF1ZXJ5KSA/IHF1ZXJ5IDogZmllbGRPclF1ZXJ5XG5cdFx0fTtcblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnc2ltaWxhcicsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIjxcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbHQoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc8JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPD1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbHRlKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPD0nLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJub25lXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyEoQXJyYXl8Li4uKil9IHZhbHVlIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogICB0aGUgXCJub25lXCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqICAgc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbm9uZShmaWVsZCkge1xuXHRcdHZhciB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdGlmICh2YWx1ZXMubGVuZ3RoID09PSAxICYmIHZhbHVlc1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR2YWx1ZXMgPSB2YWx1ZXNbMF07XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnbm9uZScsIHZhbHVlcyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCIhPVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBub3RFcXVhbChmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJyE9JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwibm90XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBub3QoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIEZpbHRlci50b0ZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpLmFkZCgnbm90Jyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSBvcGVyYXRvck9yVmFsdWUgSWYgYSB0aGlyZCBwYXJhbSBpcyBnaXZlbiwgdGhpcyBzaG91bGRcblx0ICogICBiZSB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3IgKGxpa2UgXCI+PVwiKS4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgYmVcblx0ICogICB1c2VkIGFzIHRoZSBmaWx0ZXIncyB2YWx1ZSwgYW5kIHRoZSBmaWx0ZXIncyBvcGVyYXRvciB3aWxsIGJlIFwiPVwiLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZmllbGQoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIFwib3JcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdG9yKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLmFkZCgnb3InLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBhcmd1bWVudHMgaW50byBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKi9cblx0c3RhdGljIHRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHZhciBmaWx0ZXIgPSBmaWVsZE9yRmlsdGVyO1xuXHRcdGlmICghKGZpbHRlciBpbnN0YW5jZW9mIEZpbHRlcikpIHtcblx0XHRcdGZpbHRlciA9IEZpbHRlci5maWVsZChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmlsdGVyO1xuXHR9XG59XG5cbi8qKlxuICogU3RyaW5nIGNvbnN0YW50IHRoYXQgcmVwcmVzZW50cyBhbGwgZmllbGRzLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuRmlsdGVyLkFMTCA9ICcqJztcblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi9FbWJvZGllZCc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi9SYW5nZSc7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc2VhcmNoIGFnZ3JlZ2F0aW9uLlxuICovXG5jbGFzcyBBZ2dyZWdhdGlvbiB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgYWdncmVnYXRpb24gdmFsdWUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIG9wZXJhdG9yLCBvcHRfdmFsdWUpIHtcblx0XHR0aGlzLmZpZWxkXyA9IGZpZWxkO1xuXHRcdHRoaXMub3BlcmF0b3JfID0gb3BlcmF0b3I7XG5cdFx0dGhpcy52YWx1ZV8gPSBvcHRfdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiYXZnXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGF2ZyhmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ2F2ZycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImNvdW50XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGNvdW50KGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnY291bnQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBEaXN0YW5jZUFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImdlb0Rpc3RhbmNlXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb24gVGhlIGFnZ3JlZ2F0aW9uIGxvY2F0aW9uLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEByZXR1cm4geyFEaXN0YW5jZUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZGlzdGFuY2UoZmllbGQsIGxvY2F0aW9uLCAuLi5yYW5nZXMpIHtcblx0XHRyZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uLkRpc3RhbmNlQWdncmVnYXRpb24oZmllbGQsIGxvY2F0aW9uLCAuLi5yYW5nZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImV4dGVuZGVkU3RhdHNcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZXh0ZW5kZWRTdGF0cyhmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ2V4dGVuZGVkU3RhdHMnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgYWdncmVnYXRpb24ncyBmaWVsZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0RmllbGQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmllbGRfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhpcyBhZ2dyZWdhdGlvbidzIG9wZXJhdG9yLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRPcGVyYXRvcigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcGVyYXRvcl87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZV87XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiaGlzdG9ncmFtXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbCBUaGUgaGlzdG9ncmFtJ3MgaW50ZXJ2YWwuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGhpc3RvZ3JhbShmaWVsZCwgaW50ZXJ2YWwpIHtcblx0XHRyZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uKGZpZWxkLCAnaGlzdG9ncmFtJywgaW50ZXJ2YWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcIm1heFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtYXgoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdtYXgnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJtaW5cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbWluKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnbWluJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwibWlzc2luZ1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtaXNzaW5nKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnbWlzc2luZycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZmllbGQoZmllbGQsIG9wZXJhdG9yKSB7XG5cdFx0cmV0dXJuIG5ldyBBZ2dyZWdhdGlvbihmaWVsZCwgb3BlcmF0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIFJhbmdlQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwicmFuZ2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAcmV0dXJuIHshUmFuZ2VBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHJhbmdlKGZpZWxkLCAuLi5yYW5nZXMpIHtcblx0XHRyZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uLlJhbmdlQWdncmVnYXRpb24oZmllbGQsIC4uLnJhbmdlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwic3RhdHNcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc3RhdHMoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdzdGF0cycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcInN1bVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzdW0oZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdzdW0nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJ0ZXJtc1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0ZXJtcyhmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ3Rlcm1zJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBkaXN0YW5jZSBhZ2dyZWdhdGlvbi5cbiAqIEBleHRlbmRzIHtBZ2dyZWdhdGlvbn1cbiAqL1xuY2xhc3MgRGlzdGFuY2VBZ2dyZWdhdGlvbiBleHRlbmRzIEFnZ3JlZ2F0aW9uIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIERpc3RhbmNlQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uIFRoZSBhZ2dyZWdhdGlvbiBsb2NhdGlvbi5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGZpZWxkLCBsb2NhdGlvbiwgLi4ucmFuZ2VzKSB7XG5cdFx0c3VwZXIoZmllbGQsICdnZW9EaXN0YW5jZScsIHt9KTtcblx0XHR0aGlzLnZhbHVlXy5sb2NhdGlvbiA9IEVtYm9kaWVkLnRvQm9keShsb2NhdGlvbik7XG5cdFx0dGhpcy52YWx1ZV8ucmFuZ2VzID0gcmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSByYW5nZSB0byB0aGlzIGFnZ3JlZ2F0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhbmdlT3JGcm9tXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF90b1xuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0cmFuZ2UocmFuZ2VPckZyb20sIG9wdF90bykge1xuXHRcdHZhciByYW5nZSA9IHJhbmdlT3JGcm9tO1xuXHRcdGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG5cdFx0XHRyYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JGcm9tLCBvcHRfdG8pO1xuXHRcdH1cblx0XHR0aGlzLnZhbHVlXy5yYW5nZXMucHVzaChyYW5nZS5ib2R5KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBhZ2dyZWdhdGlvbidzIHVuaXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1bml0XG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHR1bml0KHVuaXQpIHtcblx0XHR0aGlzLnZhbHVlXy51bml0ID0gdW5pdDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuQWdncmVnYXRpb24uRGlzdGFuY2VBZ2dyZWdhdGlvbiA9IERpc3RhbmNlQWdncmVnYXRpb247XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcmFuZ2UgYWdncmVnYXRpb24uXG4gKiBAZXh0ZW5kcyB7QWdncmVnYXRpb259XG4gKi9cbmNsYXNzIFJhbmdlQWdncmVnYXRpb24gZXh0ZW5kcyBBZ2dyZWdhdGlvbiB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBSYW5nZUFnZ3JlZ2F0aW9ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGZpZWxkLCAuLi5yYW5nZXMpIHtcblx0XHRzdXBlcihmaWVsZCwgJ3JhbmdlJyk7XG5cdFx0dGhpcy52YWx1ZV8gPSByYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHJhbmdlIHRvIHRoaXMgYWdncmVnYXRpb24uXG5cdCAqIEBwYXJhbSB7Kn0gcmFuZ2VPckZyb21cblx0ICogQHBhcmFtIHsqPX0gb3B0X3RvXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRyYW5nZShyYW5nZU9yRnJvbSwgb3B0X3RvKSB7XG5cdFx0dmFyIHJhbmdlID0gcmFuZ2VPckZyb207XG5cdFx0aWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcblx0XHRcdHJhbmdlID0gUmFuZ2UucmFuZ2UocmFuZ2VPckZyb20sIG9wdF90byk7XG5cdFx0fVxuXHRcdHRoaXMudmFsdWVfLnB1c2gocmFuZ2UuYm9keSgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuQWdncmVnYXRpb24uUmFuZ2VBZ2dyZWdhdGlvbiA9IFJhbmdlQWdncmVnYXRpb247XG5cbmV4cG9ydCBkZWZhdWx0IEFnZ3JlZ2F0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgQWdncmVnYXRpb24gZnJvbSAnLi9BZ2dyZWdhdGlvbic7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGJ1aWxkaW5nIHF1ZXJpZXMuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQWRkcyBhbiBhZ2dyZWdhdGlvbiB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhZ2dyZWdhdGlvbiBuYW1lLlxuXHQgKiBAcGFyYW0geyFBZ2dyZWdhdGlvbnxzdHJpbmd9IGFnZ3JlZ2F0aW9uT3JGaWVsZCBFaXRoZXIgYW5cblx0ICogICB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIG9yIHRoZSBuYW1lIG9mIHRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfb3BlcmF0b3IgVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBhZ2dyZWdhdGUobmFtZSwgYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkuYWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiY291bnRcIi5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgY291bnQoKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnR5cGUoJ2NvdW50Jyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHF1ZXJ5J3MgdHlwZSB0byBcImZldGNoXCIuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZldGNoKCkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS50eXBlKCdmZXRjaCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gdGhpcyBRdWVyeS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5maWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSBvZmZzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbnRyeSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZFxuXHQgKiAgIGJ5IHRoaXMgcXVlcnkuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG9mZnNldChvZmZzZXQpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkub2Zmc2V0KG9mZnNldCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGhpZ2hsaWdodCBlbnRyeSB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBoaWdobGlnaHQoZmllbGQpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkuaGlnaGxpZ2h0KGZpZWxkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSBsaW1pdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IFRoZSBtYXggYW1vdW50IG9mIGVudHJpZXMgdGhhdCB0aGlzIHF1ZXJ5IHNob3VsZCByZXR1cm4uXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGxpbWl0KGxpbWl0KSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLmxpbWl0KGxpbWl0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc2VhcmNoIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmlsdGVyT3JUZXh0T3JGaWVsZCBJZiBubyBvdGhlciBhcmd1bWVudHNcblx0ICogICBhcmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIGVpdGhlciBhIHtAbGluayBGaWx0ZXJ9XG5cdCAqICAgaW5zdGFuY2Ugb3IgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYSBtYXRjaCBmaWx0ZXIuIEluIGJvdGggY2FzZXNcblx0ICogICB0aGUgZmlsdGVyIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgZmllbGRzLiBBbm90aGVyIG9wdGlvbiBpcyB0b1xuXHQgKiAgIHBhc3MgdGhpcyBhcyBhIGZpZWxkIG5hbWUgaW5zdGVhZCwgdG9nZXRoZXIgd2l0aCBvdGhlciBhcmd1bWVudHNcblx0ICogICBzbyB0aGUgZmlsdGVyIGNhbiBiZSBjcmVhdGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90ZXh0T3JPcGVyYXRvciBFaXRoZXIgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYVxuXHQgKiAgIG1hdGNoIGZpbHRlciwgb3IgdGhlIG9wZXJhdG9yIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyLiBTaG91bGRcblx0ICogICBvbmx5IGJlIHBhc3NlZCBpZiBhbiBvcGVyYXRvciB3YXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHNlYXJjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5zZWFyY2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzb3J0IGVudHJ5IHRvIHRoaXMgcXVlcnksIHNwZWNpZnlpbmcgdGhlIGZpZWxkIHRoaXMgcXVlcnkgc2hvdWxkIGJlXG5cdCAqIHNvcnRlZCBieSBhbmQsIG9wdGlvbmFsbHksIHRoZSBzb3J0IGRpcmVjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgc29ydGVkIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgc29ydCBvcGVyYXRpb24gc2hvdWxkIHVzZS5cblx0ICogICBJZiBub25lIGlzIGdpdmVuLCBcImFzY1wiIGlzIHVzZWQgYnkgZGVmYXVsdC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbikge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5zb3J0KGZpZWxkLCBvcHRfZGlyZWN0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSB0eXBlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgcXVlcnkncyB0eXBlLiBGb3IgZXhhbXBsZTogXCJjb3VudFwiLCBcImZldGNoXCIuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHR5cGUodHlwZSkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS50eXBlKHR5cGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYWdncmVnYXRpb24gdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWdncmVnYXRpb24gbmFtZS5cblx0ICogQHBhcmFtIHshQWdncmVnYXRpb258c3RyaW5nfSBhZ2dyZWdhdGlvbk9yRmllbGQgRWl0aGVyIGFuXG5cdCAqICAge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSBvciB0aGUgbmFtZSBvZiB0aGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X29wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcikge1xuXHRcdHZhciBhZ2dyZWdhdGlvbiA9IGFnZ3JlZ2F0aW9uT3JGaWVsZDtcblx0XHRpZiAoIShhZ2dyZWdhdGlvbiBpbnN0YW5jZW9mIEFnZ3JlZ2F0aW9uKSkge1xuXHRcdFx0YWdncmVnYXRpb24gPSBBZ2dyZWdhdGlvbi5maWVsZChhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG5cdFx0fVxuXG5cdFx0dmFyIGZpZWxkID0gYWdncmVnYXRpb24uZ2V0RmllbGQoKTtcblx0XHR2YXIgdmFsdWUgPSB7fTtcblx0XHR2YWx1ZVtmaWVsZF0gPSB7XG5cdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0b3BlcmF0b3I6IGFnZ3JlZ2F0aW9uLmdldE9wZXJhdG9yKClcblx0XHR9O1xuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChhZ2dyZWdhdGlvbi5nZXRWYWx1ZSgpKSkge1xuXHRcdFx0dmFsdWVbZmllbGRdLnZhbHVlID0gYWdncmVnYXRpb24uZ2V0VmFsdWUoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuYm9keV8uYWdncmVnYXRpb24pIHtcblx0XHRcdHRoaXMuYm9keV8uYWdncmVnYXRpb24gPSBbXTtcblx0XHR9XG5cdFx0dGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbi5wdXNoKHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiY291bnRcIi5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGNvdW50KCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUoJ2NvdW50Jyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHF1ZXJ5J3MgdHlwZSB0byBcImZldGNoXCIuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRmZXRjaCgpIHtcblx0XHRyZXR1cm4gdGhpcy50eXBlKCdmZXRjaCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gdGhpcyBRdWVyeS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgZmlsdGVyID0gRmlsdGVyLnRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdFx0aWYgKCF0aGlzLmJvZHlfLmZpbHRlcikge1xuXHRcdFx0dGhpcy5ib2R5Xy5maWx0ZXIgPSBbXTtcblx0XHR9XG5cdFx0dGhpcy5ib2R5Xy5maWx0ZXIucHVzaChmaWx0ZXIuYm9keSgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSBvZmZzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbnRyeSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZFxuXHQgKiAgIGJ5IHRoaXMgcXVlcnkuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRvZmZzZXQob2Zmc2V0KSB7XG5cdFx0dGhpcy5ib2R5Xy5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGhpZ2hsaWdodCBlbnRyeSB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0aGlnaGxpZ2h0KGZpZWxkKSB7XG5cdFx0aWYgKCF0aGlzLmJvZHlfLmhpZ2hsaWdodCkge1xuXHRcdFx0dGhpcy5ib2R5Xy5oaWdobGlnaHQgPSBbXTtcblx0XHR9XG5cblx0XHR0aGlzLmJvZHlfLmhpZ2hsaWdodC5wdXNoKGZpZWxkKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSBsaW1pdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IFRoZSBtYXggYW1vdW50IG9mIGVudHJpZXMgdGhhdCB0aGlzIHF1ZXJ5IHNob3VsZCByZXR1cm4uXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRsaW1pdChsaW1pdCkge1xuXHRcdHRoaXMuYm9keV8ubGltaXQgPSBsaW1pdDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc2VhcmNoIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmlsdGVyT3JUZXh0T3JGaWVsZCBJZiBubyBvdGhlciBhcmd1bWVudHNcblx0ICogICBhcmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIGVpdGhlciBhIHtAbGluayBGaWx0ZXJ9XG5cdCAqICAgaW5zdGFuY2Ugb3IgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYSBtYXRjaCBmaWx0ZXIuIEluIGJvdGggY2FzZXNcblx0ICogICB0aGUgZmlsdGVyIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgZmllbGRzLiBBbm90aGVyIG9wdGlvbiBpcyB0b1xuXHQgKiAgIHBhc3MgdGhpcyBhcyBhIGZpZWxkIG5hbWUgaW5zdGVhZCwgdG9nZXRoZXIgd2l0aCBvdGhlciBhcmd1bWVudHNcblx0ICogICBzbyB0aGUgZmlsdGVyIGNhbiBiZSBjcmVhdGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90ZXh0T3JPcGVyYXRvciBFaXRoZXIgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYVxuXHQgKiAgIG1hdGNoIGZpbHRlciwgb3IgdGhlIG9wZXJhdG9yIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyLiBTaG91bGRcblx0ICogICBvbmx5IGJlIHBhc3NlZCBpZiBhbiBvcGVyYXRvciB3YXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRzZWFyY2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgZmlsdGVyID0gZmlsdGVyT3JUZXh0T3JGaWVsZDtcblx0XHRpZiAob3B0X3ZhbHVlKSB7XG5cdFx0XHRmaWx0ZXIgPSBGaWx0ZXIuZmllbGQoZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAob3B0X3RleHRPck9wZXJhdG9yKSB7XG5cdFx0XHRmaWx0ZXIgPSBGaWx0ZXIubWF0Y2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yKTtcblx0XHR9IGVsc2UgaWYgKCEoZmlsdGVyIGluc3RhbmNlb2YgRmlsdGVyKSkge1xuXHRcdFx0ZmlsdGVyID0gRmlsdGVyLm1hdGNoKGZpbHRlck9yVGV4dE9yRmllbGQpO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuYm9keV8uc2VhcmNoKSB7XG5cdFx0XHR0aGlzLmJvZHlfLnNlYXJjaCA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLmJvZHlfLnNlYXJjaC5wdXNoKGZpbHRlci5ib2R5KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzb3J0IGVudHJ5IHRvIHRoaXMgcXVlcnksIHNwZWNpZnlpbmcgdGhlIGZpZWxkIHRoaXMgcXVlcnkgc2hvdWxkIGJlXG5cdCAqIHNvcnRlZCBieSBhbmQsIG9wdGlvbmFsbHksIHRoZSBzb3J0IGRpcmVjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgc29ydGVkIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgc29ydCBvcGVyYXRpb24gc2hvdWxkIHVzZS5cblx0ICogICBJZiBub25lIGlzIGdpdmVuLCBcImFzY1wiIGlzIHVzZWQgYnkgZGVmYXVsdC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcblx0XHRpZiAoIXRoaXMuYm9keV8uc29ydCkge1xuXHRcdFx0dGhpcy5ib2R5Xy5zb3J0ID0gW107XG5cdFx0fVxuXHRcdHZhciBzb3J0RW50cnkgPSB7fTtcblx0XHRzb3J0RW50cnlbZmllbGRdID0gb3B0X2RpcmVjdGlvbiB8fCAnYXNjJztcblx0XHR0aGlzLmJvZHlfLnNvcnQucHVzaChzb3J0RW50cnkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IHR5cGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBxdWVyeSdzIHR5cGUuIEZvciBleGFtcGxlOiBcImNvdW50XCIsIFwiZmV0Y2hcIi5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHR5cGUodHlwZSkge1xuXHRcdHRoaXMuYm9keV8udHlwZSA9IHR5cGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUXVlcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgeyBhc3NlcnROb3ROdWxsLCBhc3NlcnRPYmplY3QsIGFzc2VydERlZkFuZE5vdE51bGwsIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkIH0gZnJvbSAnLi4vYXNzZXJ0aW9ucyc7XG5pbXBvcnQgUXVlcnkgZnJvbSAnLi4vLi4vYXBpLXF1ZXJ5L1F1ZXJ5JztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGUgZGF0YSBhcGkgY2FsbHMuXG4gKi9cbmNsYXNzIERhdGFBcGlIZWxwZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBEYXRhQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwod2VkZXBsb3lDbGllbnQsICdXZURlcGxveSBjbGllbnQgcmVmZXJlbmNlIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuXG5cdFx0Ly8gc2FuZGJveFxuXHRcdHRoaXMud2VkZXBsb3lDbGllbnRJbnN0YW5jZSA9IHdlZGVwbG95Q2xpZW50LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKTtcblx0XHR0aGlzLnJlc3VsdCA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbGltaXQgZm9yIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgbWF4IGFtb3VudCBvZiBlbnRyaWVzIHRoYXQgdGhpcyByZXF1ZXN0IHNob3VsZCByZXR1cm4uXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGxpbWl0KGxpbWl0KSB7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LmdldE9yQ3JlYXRlUXVlcnkoKVxuXHRcdFx0LmxpbWl0KGxpbWl0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHRsaW1pdChsaW1pdCkge1xuXHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeSgpLmxpbWl0KGxpbWl0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBbc2FuZGJveF1cblx0ICogR2V0cyB0aGUgY3VycmVudGx5IHVzZWQge0BsaW5rIFF1ZXJ5fSBvYmplY3QuIElmIG5vbmUgZXhpc3RzIHlldCxcblx0ICogYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICovXG5cdGdldE9yQ3JlYXRlUXVlcnkoKSB7XG5cdFx0aWYgKCF0aGlzLndlZGVwbG95Q2xpZW50SW5zdGFuY2UucXVlcnlfKSB7XG5cdFx0XHR0aGlzLndlZGVwbG95Q2xpZW50SW5zdGFuY2UucXVlcnlfID0gbmV3IFF1ZXJ5KCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50SW5zdGFuY2UucXVlcnlfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzZWFyY2ggdG8gdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmlsdGVyT3JUZXh0T3JGaWVsZCBJZiBubyBvdGhlciBhcmd1bWVudHNcblx0ICogICBhcmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIGVpdGhlciBhIGBGaWx0ZXJgXG5cdCAqICAgaW5zdGFuY2Ugb3IgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYSBtYXRjaCBmaWx0ZXIuIEluIGJvdGggY2FzZXNcblx0ICogICB0aGUgZmlsdGVyIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgZmllbGRzLiBBbm90aGVyIG9wdGlvbiBpcyB0b1xuXHQgKiAgIHBhc3MgdGhpcyBhcyBhIGZpZWxkIG5hbWUgaW5zdGVhZCwgdG9nZXRoZXIgd2l0aCBvdGhlciBhcmd1bWVudHNcblx0ICogICBzbyB0aGUgZmlsdGVyIGNhbiBiZSBjcmVhdGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90ZXh0T3JPcGVyYXRvciBFaXRoZXIgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYVxuXHQgKiAgIG1hdGNoIGZpbHRlciwgb3IgdGhlIG9wZXJhdG9yIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyLiBTaG91bGRcblx0ICogICBvbmx5IGJlIHBhc3NlZCBpZiBhbiBvcGVyYXRvciB3YXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNlYXJjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSkge1xuXHRcdHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5nZXRPckNyZWF0ZVF1ZXJ5KClcblx0XHRcdC5zZWFyY2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnQ7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBvZmZzZXQgZm9yIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbnRyeSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZFxuXHQgKiAgIGJ5IHRoaXMgcXVlcnkuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdG9mZnNldChvZmZzZXQpIHtcblx0XHR0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQuZ2V0T3JDcmVhdGVRdWVyeSgpXG5cdFx0XHQub2Zmc2V0KG9mZnNldCk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0uXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEgRmlsdGVyIGluc3RhbmNlIG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHR3aGVyZShmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQuZ2V0T3JDcmVhdGVRdWVyeSgpXG5cdFx0XHQuZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRoaWdobGlnaHQoZmllbGQpIHtcblx0XHR0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQuZ2V0T3JDcmVhdGVRdWVyeSgpXG5cdFx0XHQuaGlnaGxpZ2h0KGZpZWxkKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYWdncmVnYXRpb24gdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWdncmVnYXRpb24gbmFtZS5cblx0ICogQHBhcmFtIHshQWdncmVnYXRpb258c3RyaW5nfSBhZ2dyZWdhdGlvbk9yRmllbGQgRWl0aGVyIGFuXG5cdCAqICAge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSBvciB0aGUgbmFtZSBvZiB0aGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X29wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuXHRcdFx0LmdldE9yQ3JlYXRlUXVlcnkoKVxuXHRcdFx0LmFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcmVxdWVzdCdzIHF1ZXJ5IHR5cGUgdG8gXCJjb3VudFwiLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0Y291bnQoKSB7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuXHRcdFx0LmdldE9yQ3JlYXRlUXVlcnkoKVxuXHRcdFx0LnR5cGUoJ2NvdW50Jyk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc29ydCBxdWVyeSB0byB0aGlzIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgdGhlIHF1ZXJ5IHNob3VsZCBiZSBzb3J0ZWQgYnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBzb3J0IG9wZXJhdGlvbiBzaG91bGQgdXNlLlxuXHQgKiAgIElmIG5vbmUgaXMgZ2l2ZW4sIFwiYXNjXCIgaXMgdXNlZCBieSBkZWZhdWx0LlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0b3JkZXJCeShmaWVsZCwgb3B0X2RpcmVjdGlvbikge1xuXHRcdHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5nZXRPckNyZWF0ZVF1ZXJ5KClcblx0XHRcdC5zb3J0KGZpZWxkLCBvcHRfZGlyZWN0aW9uKVxuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnQ7XG5cdH1cblxuXHQvKipcblx0ICogSW5zZXJ0IGRhdGEuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRjcmVhdGUoY29sbGVjdGlvbiwgZGF0YSkge1xuXHRcdGFzc2VydE5vdE51bGwoY29sbGVjdGlvbiwgXCJDb2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblx0XHRhc3NlcnRPYmplY3QoZGF0YSwgXCJEYXRhIGNhbid0IGJlIGVtcHR5XCIpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5wYXRoKGNvbGxlY3Rpb24pXG5cdFx0XHQucG9zdChkYXRhKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgZGF0YS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHVwZGF0ZShjb2xsZWN0aW9uLCBkYXRhKSB7XG5cdFx0YXNzZXJ0Tm90TnVsbChjb2xsZWN0aW9uLCBcIkNvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXHRcdGFzc2VydE9iamVjdChkYXRhLCBcIkRhdGEgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LnBhdGgoY29sbGVjdGlvbilcblx0XHRcdC5wdXQoZGF0YSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlIGRhdGFcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGRlbGV0ZShjb2xsZWN0aW9uKSB7XG5cdFx0YXNzZXJ0Tm90TnVsbChjb2xsZWN0aW9uLCBcIkNvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5wYXRoKGNvbGxlY3Rpb24pXG5cdFx0XHQuZGVsZXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogZ2V0L2ZpbmRjbGVhclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbGxlY3Rpb24gW2Rlc2NyaXB0aW9uXVxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdGdldChjb2xsZWN0aW9uKSB7XG5cdFx0YXNzZXJ0Tm90TnVsbChjb2xsZWN0aW9uLCBcIkNvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5wYXRoKGNvbGxlY3Rpb24pXG5cdFx0XHQuZ2V0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmJvZHkoKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRPIERPXG5cdCAqIEBwYXJhbSAge1t0eXBlXX0gY29sbGVjdGlvbiBbZGVzY3JpcHRpb25dXG5cdCAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG5cdCAqL1xuXHRhbGwoY29sbGVjdGlvbikge1xuXG5cdH1cblxuXHR1cmxJbnN0YW5jZSgpIHtcblx0XHRpZiAodGhpcy53ZWRlcGxveUNsaWVudCBpbnN0YW5jZW9mIFdlRGVwbG95KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuZGF0YVVybF8pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUTyBET1xuXHQgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdHJhbmdlKCkge1xuXG5cdH1cblxuXHQvKipcblx0ICogVE8gRE9cblx0ICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG5cdCAqL1xuXHRmaXJzdCgpIHtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRPIERPXG5cdCAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0bGFzdCgpIHtcblxuXHR9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhQXBpSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGxheWVyIGZvciBzdHJpbmcgdG8gYmFzZTY0IGNvbnZlcnNpb25cbiAqIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zNDYyXG4gKi9cbmNsYXNzIEJhc2U2NCB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYmFzZS02NCBlbmNvZGVkIEFTQ0lJIHN0cmluZyBmcm9tIGEgXCJzdHJpbmdcIiBvZiBiaW5hcnkgZGF0YS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBiZSBlbmNvZGVkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBlbmNvZGVTdHJpbmcoc3RyaW5nKSB7XG5cdFx0aWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gYnRvYShzdHJpbmcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQnVmZmVyKHN0cmluZy50b1N0cmluZygpLCAnYmluYXJ5Jyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZTY0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBBdXRoIGZyb20gJy4vYXV0aC9BdXRoJztcbmltcG9ydCBBdXRoQXBpSGVscGVyIGZyb20gJy4vYXV0aC9BdXRoQXBpSGVscGVyJztcbmltcG9ydCBEYXRhQXBpSGVscGVyIGZyb20gJy4vZGF0YS9EYXRhQXBpSGVscGVyJztcbmltcG9ydCBCYXNlNjQgZnJvbSAnLi4vY3J5cHQvQmFzZTY0JztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuLi9hcGktcXVlcnkvRW1ib2RpZWQnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi9hcGktcXVlcnkvRmlsdGVyJztcbmltcG9ydCBRdWVyeSBmcm9tICcuLi9hcGktcXVlcnkvUXVlcnknO1xuaW1wb3J0IFRyYW5zcG9ydEZhY3RvcnkgZnJvbSAnLi9UcmFuc3BvcnRGYWN0b3J5JztcbmltcG9ydCBDbGllbnRSZXF1ZXN0IGZyb20gJy4vQ2xpZW50UmVxdWVzdCc7XG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuaW1wb3J0IHsgYXNzZXJ0VXJpV2l0aE5vUGF0aCB9IGZyb20gJy4vYXNzZXJ0aW9ucyc7XG5cblxudmFyIGlvO1xuXG4vLyBPcHRpbWlzdGljIGluaXRpYWxpemF0aW9uIG9mIGBpb2AgcmVmZXJlbmNlIGZyb20gZ2xvYmFsIGBnbG9iYWxzLndpbmRvdy5pb2AuXG5pZiAodHlwZW9mIGdsb2JhbHMud2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRpbyA9IGdsb2JhbHMud2luZG93LmlvO1xufVxuXG4vKipcbiAqIFRoZSBtYWluIGNsYXNzIGZvciBtYWtpbmcgYXBpIHJlcXVlc3RzLiBTZW5kaW5nIHJlcXVlc3RzIHJldHVybnMgYSBwcm9taXNlIHRoYXQgaXNcbiAqIHJlc29sdmVkIHdoZW4gdGhlIHJlc3BvbnNlIGFycml2ZXMuIFVzYWdlIGV4YW1wbGU6XG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBXZURlcGxveVxuICogICAudXJsKCcvZGF0YS90YXNrcycpXG4gKiAgIC5wb3N0KHtkZXNjOiAnQnV5IG1pbGtsJ30pXG4gKiAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgLy8gSGFuZGxlIHJlc3BvbnNlIGhlcmUuXG4gKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2UuYm9keSgpKVxuICogICB9KTtcbiAqIGBgYFxuICovXG5jbGFzcyBXZURlcGxveSB7XG5cdC8qKlxuXHQgKiBXZURlcGxveSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSB1cmwuXG5cdCAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXRocyBBbnkgYW1vdW50IG9mIHBhdGhzIHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBiYXNlIHVybC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIC4uLnBhdGhzKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMsIHRyeSBgbmV3IFdlRGVwbG95KGJhc2VVcmwsIHVybClgJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5hdXRoXyA9IG51bGw7XG5cdFx0dGhpcy5ib2R5XyA9IG51bGw7XG5cdFx0dGhpcy51cmxfID0gVXJpLmpvaW5QYXRocyh1cmwgfHwgJycsIC4uLnBhdGhzKTtcblx0XHR0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG5cdFx0dGhpcy5wYXJhbXNfID0gbmV3IE11bHRpTWFwKCk7XG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHNfID0gdHJ1ZTtcblxuXHRcdHRoaXMuaGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdHRoaXMuaGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG5cdH1cblxuXHQvKipcblx0ICogU3RhdGljIGZhY3RvcnkgZm9yIGNyZWF0aW5nIFdlRGVwbG95IGRhdGEgZm9yIHRoZSBnaXZlbiB1cmxcblx0ICogQHBhcmFtICB7c3RyaW5nPX0gb3B0X2RhdGFVcmwgVGhlIHVybCB0aGF0IHBvaW50cyB0byB0aGUgZGF0YSBzZXJ2aWNlcy5cblx0ICogQHJldHVybiBAcmV0dXJuIHtkYXRhfSBXZURlcGxveSBkYXRhIGluc3RhbmNlXG5cdCAqL1xuXHRzdGF0aWMgZGF0YShvcHRfZGF0YVVybCkge1xuXHRcdGFzc2VydFVyaVdpdGhOb1BhdGgob3B0X2RhdGFVcmwsIFwiVGhlIGRhdGEgdXJsIHNob3VsZCBub3QgaGF2ZSBhIHBhdGhcIik7XG5cblx0XHRpZiAoY29yZS5pc1N0cmluZyhvcHRfZGF0YVVybCkpIHtcblx0XHRcdFdlRGVwbG95LmRhdGFVcmxfID0gb3B0X2RhdGFVcmw7XG5cdFx0fVxuXHRcdGlmICghV2VEZXBsb3kuZGF0YV8pIHtcblx0XHRcdFdlRGVwbG95LmRhdGFfID0gbmV3IERhdGFBcGlIZWxwZXIoV2VEZXBsb3kpO1xuXHRcdH1cblx0XHRyZXR1cm4gV2VEZXBsb3kuZGF0YV87XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIHRvIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQXV0aHxzdHJpbmd9IGF1dGhPclRva2VuT3JFbWFpbCBFaXRoZXIgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLFxuXHQgKiAgIGFuIGF1dGhvcml6YXRpb24gdG9rZW4sIG9yIHRoZSBlbWFpbC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcGFzc3dvcmQgSWYgYSBlbWFpbCBpcyBnaXZlbiBhcyB0aGUgZmlyc3QgcGFyYW0sXG5cdCAqICAgdGhpcyBzaG91bGQgYmUgdGhlIHBhc3N3b3JkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhdXRoKGF1dGhPclRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkKSB7XG5cdFx0dGhpcy5hdXRoXyA9IGF1dGhPclRva2VuT3JFbWFpbDtcblx0XHRpZiAoISh0aGlzLmF1dGhfIGluc3RhbmNlb2YgQXV0aCkpIHtcblx0XHRcdHRoaXMuYXV0aF8gPSBBdXRoLmNyZWF0ZShhdXRoT3JUb2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBmYWN0b3J5IGZvciBjcmVhdGluZyBXZURlcGxveSBhdXRoIGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9hdXRoVXJsIFRoZSB1cmwgdGhhdCBwb2ludHMgdG8gdGhlIGF1dGggc2VydmljZS5cblx0ICovXG5cdHN0YXRpYyBhdXRoKG9wdF9hdXRoVXJsKSB7XG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcob3B0X2F1dGhVcmwpKSB7XG5cdFx0XHRXZURlcGxveS5hdXRoVXJsXyA9IG9wdF9hdXRoVXJsO1xuXHRcdH1cblx0XHRpZiAoIVdlRGVwbG95LmF1dGhfKSB7XG5cdFx0XHRXZURlcGxveS5hdXRoXyA9IG5ldyBBdXRoQXBpSGVscGVyKFdlRGVwbG95KTtcblx0XHR9XG5cdFx0cmV0dXJuIFdlRGVwbG95LmF1dGhfO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGJvZHkgdGhhdCB3aWxsIGJlIHNlbnQgd2l0aCB0aGlzIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRib2R5KGJvZHkpIHtcblx0XHR0aGlzLmJvZHlfID0gYm9keTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYm9keSBvYmplY3QgdG8gcXVlcnkgcGFyYW1zLlxuXHQgKiBAcGFyYW0geyFDbGllbnRSZXF1ZXN0fSBjbGllbnRSZXF1ZXN0XG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRjb252ZXJ0Qm9keVRvUGFyYW1zXyhjbGllbnRSZXF1ZXN0LCBib2R5KSB7XG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcoYm9keSkpIHtcblx0XHRcdGJvZHkgPSB7XG5cdFx0XHRcdGJvZHk6IGJvZHlcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgRW1ib2RpZWQpIHtcblx0XHRcdGJvZHkgPSBib2R5LmJvZHkoKTtcblx0XHR9XG5cdFx0T2JqZWN0LmtleXMoYm9keSB8fCB7fSkuZm9yRWFjaChuYW1lID0+IGNsaWVudFJlcXVlc3QucGFyYW0obmFtZSwgYm9keVtuYW1lXSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgY2xpZW50IHJlcXVlc3QgYW5kIGVuY29kZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuXHQgKiBAcGFyYW0geyp9IGJvZHlcblx0ICogQHJldHVybiB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Y3JlYXRlQ2xpZW50UmVxdWVzdF8obWV0aG9kLCBib2R5KSB7XG5cdFx0dmFyIGNsaWVudFJlcXVlc3QgPSBuZXcgQ2xpZW50UmVxdWVzdCgpO1xuXG5cdFx0Y2xpZW50UmVxdWVzdC5ib2R5KGJvZHkgfHwgdGhpcy5ib2R5Xyk7XG5cblx0XHRpZiAoIWNvcmUuaXNEZWZBbmROb3ROdWxsKGNsaWVudFJlcXVlc3QuYm9keSgpKSkge1xuXHRcdFx0aWYgKHRoaXMucXVlcnlfKSB7XG5cdFx0XHRcdGNsaWVudFJlcXVlc3QuYm9keSh0aGlzLnF1ZXJ5Xy5ib2R5KCkpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmZvcm1EYXRhXykge1xuXHRcdFx0XHRjbGllbnRSZXF1ZXN0LmJvZHkodGhpcy5mb3JtRGF0YV8pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNsaWVudFJlcXVlc3QubWV0aG9kKG1ldGhvZCk7XG5cdFx0Y2xpZW50UmVxdWVzdC5oZWFkZXJzKHRoaXMuaGVhZGVycygpKTtcblx0XHRjbGllbnRSZXF1ZXN0LnBhcmFtcyh0aGlzLnBhcmFtcygpKTtcblx0XHRjbGllbnRSZXF1ZXN0LnVybCh0aGlzLnVybCgpKTtcblx0XHRjbGllbnRSZXF1ZXN0LndpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFsc18pO1xuXG5cdFx0dGhpcy5lbmNvZGUoY2xpZW50UmVxdWVzdCk7XG5cblx0XHRyZXR1cm4gY2xpZW50UmVxdWVzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGNsaWVudFJlc3BvbnNlIGJvZHksIHBhcnNpbmcgdGhlIGJvZHkgZm9yIGV4YW1wbGUuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlc3BvbnNlfSBjbGllbnRSZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0IHRvIGJlIGRlY29kZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRSZXNwb25zZX0gVGhlIGRlY29kZWQgcmVzcG9uc2UuXG5cdCAqL1xuXHRkZWNvZGUoY2xpZW50UmVzcG9uc2UpIHtcblx0XHRpZiAoV2VEZXBsb3kuaXNDb250ZW50VHlwZUpzb24oY2xpZW50UmVzcG9uc2UpKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjbGllbnRSZXNwb25zZS5ib2R5KEpTT04ucGFyc2UoY2xpZW50UmVzcG9uc2UuYm9keSgpKSk7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHt9XG5cdFx0fVxuXHRcdHJldHVybiBjbGllbnRSZXNwb25zZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIERFTEVURSBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2JvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGRlbGV0ZShvcHRfYm9keSkge1xuXHRcdHJldHVybiB0aGlzLnNlbmRBc3luYygnREVMRVRFJywgb3B0X2JvZHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgdGhlIGdpdmVuIHtAbGluayBDbGllbnRSZXF1ZXN0fSwgY29udmVydGluZyBpdHMgYm9keSB0byBhbiBhcHByb3ByaWF0ZVxuXHQgKiBmb3JtYXQgZm9yIGV4YW1wbGUuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3QgVGhlIHJlcXVlc3Qgb2JqZWN0IHRvIGVuY29kZS5cblx0ICogQHJldHVybiB7IUNsaWVudFJlcXVlc3R9IFRoZSBlbmNvZGVkIHJlcXVlc3QuXG5cdCAqL1xuXHRlbmNvZGUoY2xpZW50UmVxdWVzdCkge1xuXHRcdHZhciBib2R5ID0gY2xpZW50UmVxdWVzdC5ib2R5KCk7XG5cblx0XHRpZiAoY29yZS5pc0VsZW1lbnQoYm9keSkpIHtcblx0XHRcdGJvZHkgPSBuZXcgRm9ybURhdGEoYm9keSk7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmJvZHkoYm9keSk7XG5cdFx0fVxuXG5cdFx0Ym9keSA9IHRoaXMud3JhcFdpdGhRdWVyeV8oYm9keSk7XG5cdFx0aWYgKGNsaWVudFJlcXVlc3QubWV0aG9kKCkgPT09ICdHRVQnKSB7XG5cdFx0XHR0aGlzLmNvbnZlcnRCb2R5VG9QYXJhbXNfKGNsaWVudFJlcXVlc3QsIGJvZHkpO1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5yZW1vdmVCb2R5KCk7XG5cdFx0XHRib2R5ID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdGNsaWVudFJlcXVlc3QuaGVhZGVycygpLnJlbW92ZSgnY29udGVudC10eXBlJyk7XG5cdFx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgRW1ib2RpZWQpIHtcblx0XHRcdGNsaWVudFJlcXVlc3QuYm9keShib2R5LnRvU3RyaW5nKCkpO1xuXHRcdH0gZWxzZSBpZiAoV2VEZXBsb3kuaXNDb250ZW50VHlwZUpzb24oY2xpZW50UmVxdWVzdCkpIHtcblx0XHRcdGNsaWVudFJlcXVlc3QuYm9keShKU09OLnN0cmluZ2lmeShjbGllbnRSZXF1ZXN0LmJvZHkoKSkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZW5jb2RlUGFyYW1zXyhjbGllbnRSZXF1ZXN0KTtcblx0XHR0aGlzLnJlc29sdmVBdXRoZW50aWNhdGlvbl8oY2xpZW50UmVxdWVzdCk7XG5cblx0XHRyZXR1cm4gY2xpZW50UmVxdWVzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIHRoZSBwYXJhbXMgZm9yIHRoZSBnaXZlbiByZXF1ZXN0LCBhY2NvcmRpbmcgdG8gdGhlaXIgdHlwZXMuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZW5jb2RlUGFyYW1zXyhjbGllbnRSZXF1ZXN0KSB7XG5cdFx0dmFyIHBhcmFtcyA9IGNsaWVudFJlcXVlc3QucGFyYW1zKCk7XG5cdFx0cGFyYW1zLm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR2YXIgdmFsdWVzID0gcGFyYW1zLmdldEFsbChuYW1lKTtcblx0XHRcdHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjb3JlLmlzT2JqZWN0KHZhbHVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEga2V5L3ZhbHVlIHBhaXIgdG8gYmUgc2VudCB2aWEgdGhlIGJvZHkgaW4gYSBgbXVsdGlwYXJ0L2Zvcm0tZGF0YWAgZm9ybWF0LlxuXHQgKiBJZiB0aGUgYm9keSBpcyBzZXQgYnkgb3RoZXIgbWVhbnMgKGZvciBleGFtcGxlLCB0aHJvdWdoIHRoZSBgYm9keWAgbWV0aG9kKSwgdGhpc1xuXHQgKiB3aWxsIGJlIGlnbm9yZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Zm9ybShuYW1lLCB2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgRm9ybURhdGEgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Zvcm0oKSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIEZvcm1EYXRhIEFQSSBpcyBhdmFpbGFibGUuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmZvcm1EYXRhXykge1xuXHRcdFx0dGhpcy5mb3JtRGF0YV8gPSBuZXcgRm9ybURhdGEoKTtcblx0XHR9XG5cdFx0dGhpcy5mb3JtRGF0YV8uYXBwZW5kKG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIEdFVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9wYXJhbXMgUGFyYW1zIHRvIGJlIGFkZGVkIHRvIHRoZSByZXF1ZXN0IHVybC5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGdldChvcHRfcGFyYW1zKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdHRVQnLCBvcHRfcGFyYW1zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiB0aGUgaGVhZGVyIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbFxuXHQgKiBub3QgYmUgb3ZlcndyaXR0ZW4sIGJ1dCBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQuIFRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0aGVhZGVyKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcblx0XHR9XG5cdFx0dGhpcy5oZWFkZXJzXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhlYWRlcnMuXG5cdCAqIEByZXR1cm4geyFNdWx0aU1hcH1cblx0ICovXG5cdGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGVhZGVyc187XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHF1ZXJ5LiBJZiB0aGUgcXVlcnkgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIG5vdFxuXHQgKiBiZSBvdmVyd3JpdHRlbiwgYnV0IG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZC4gVGhlIG9yZGVyIGlzIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwYXJhbShuYW1lLCB2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG5cdFx0fVxuXHRcdHRoaXMucGFyYW1zXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHF1ZXJ5IHN0cmluZ3MgbWFwLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB9XG5cdCAqL1xuXHRwYXJhbXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyYW1zXztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIFBBVENIIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0cGF0Y2gob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BBVENIJywgb3B0X2JvZHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIHVybCByZXN1bHRpbmcgaW4gdGhlXG5cdCAqIHVuaW9uIG9mIHRoZSBjdXJyZW50IHVybCB3aXRoIHRoZSBnaXZlbiBwYXRocy5cblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IHBhdGhzIEFueSBudW1iZXIgb2YgcGF0aHMuXG5cdCAqIEByZXR1cm4geyFXZURlcGxveX0gQSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIGdpdmVuIHBhdGhzLlxuXHQgKi9cblx0cGF0aCguLi5wYXRocykge1xuXHRcdHJldHVybiBuZXcgV2VEZXBsb3kodGhpcy51cmwoKSwgLi4ucGF0aHMpLnVzZSh0aGlzLmN1c3RvbVRyYW5zcG9ydF8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgUE9TVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2JvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHBvc3Qob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BPU1QnLCBvcHRfYm9keSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBQVVQgaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9ib2R5IENvbnRlbnQgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRwdXQob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BVVCcsIG9wdF9ib2R5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBhdXRoZW50aWNhdGlvbiBpbmZvcm1hdGlvbiB0byB0aGUgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRyZXNvbHZlQXV0aGVudGljYXRpb25fKGNsaWVudFJlcXVlc3QpIHtcblx0XHRpZiAoIXRoaXMuYXV0aF8pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuYXV0aF8uaGFzVG9rZW4oKSkge1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5oZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB0aGlzLmF1dGhfLnRva2VuKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNyZWRlbnRpYWxzID0gdGhpcy5hdXRoXy5lbWFpbCArICc6JyArIHRoaXMuYXV0aF8ucGFzc3dvcmQ7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgQmFzZTY0LmVuY29kZVN0cmluZyhjcmVkZW50aWFscykpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VzIHRyYW5zcG9ydCB0byBzZW5kIHJlcXVlc3Qgd2l0aCBnaXZlbiBtZXRob2QgbmFtZSBhbmQgYm9keVxuXHQgKiBhc3luY2hyb25vdXNseS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgSFRUUCBtZXRob2QgdG8gYmUgdXNlZCB3aGVuIHNlbmRpbmcgZGF0YS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gRGVmZXJyZWQgcmVxdWVzdC5cblx0ICovXG5cdHNlbmRBc3luYyhtZXRob2QsIGJvZHkpIHtcblx0XHR2YXIgdHJhbnNwb3J0ID0gdGhpcy5jdXN0b21UcmFuc3BvcnRfIHx8IFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2UoKS5nZXREZWZhdWx0KCk7XG5cblx0XHR2YXIgY2xpZW50UmVxdWVzdCA9IHRoaXMuY3JlYXRlQ2xpZW50UmVxdWVzdF8obWV0aG9kLCBib2R5KTtcblxuXHRcdHJldHVybiB0cmFuc3BvcnQuc2VuZChjbGllbnRSZXF1ZXN0KS50aGVuKHRoaXMuZGVjb2RlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzb2NrZXQgdHJhbnNwb3J0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXQgaW1wbGVtZW50YXRpb24gb2JqZWN0LlxuXHQgKi9cblx0c3RhdGljIHNvY2tldChzb2NrZXQpIHtcblx0XHRpbyA9IHNvY2tldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGF0aWMgZmFjdG9yeSBmb3IgY3JlYXRpbmcgV2VEZXBsb3kgY2xpZW50IGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdGhhdCB0aGUgY2xpZW50IHNob3VsZCB1c2UgZm9yIHNlbmRpbmcgcmVxdWVzdHMuXG5cdCAqL1xuXHRzdGF0aWMgdXJsKHVybCkge1xuXHRcdHJldHVybiBuZXcgV2VEZXBsb3kodXJsKS51c2UodGhpcy5jdXN0b21UcmFuc3BvcnRfKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBVUkwgdXNlZCBieSB0aGlzIGNsaWVudC5cblx0ICovXG5cdHVybCgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmxfO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyB7QGxpbmsgVHJhbnNwb3J0fSBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHBhcmFtIHshVHJhbnNwb3J0fSB0cmFuc3BvcnQgVGhlIHRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbiB0aGF0IHNob3VsZCBiZSB1c2VkLlxuXHQgKi9cblx0dXNlKHRyYW5zcG9ydCkge1xuXHRcdHRoaXMuY3VzdG9tVHJhbnNwb3J0XyA9IHRyYW5zcG9ydDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bHkgdXNlZCB7QGxpbmsgUXVlcnl9IG9iamVjdC4gSWYgbm9uZSBleGlzdHMgeWV0LFxuXHQgKiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKi9cblx0Z2V0T3JDcmVhdGVRdWVyeSgpIHtcblx0XHRpZiAoIXRoaXMucXVlcnlfKSB7XG5cdFx0XHR0aGlzLnF1ZXJ5XyA9IG5ldyBRdWVyeSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5xdWVyeV87XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBuZXcgc29ja2V0LmlvIGluc3RhbmNlLiBUaGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gc29ja2V0LmlvXG5cdCAqIGNvbnN0cnVjdG9yIHdpbGwgYmUgcHJvdmlkZWQ6XG5cdCAqXG5cdCAqIGBgYGphdmFzY3JpcHRcblx0ICogV2VEZXBsb3kudXJsKCdodHRwOi8vZG9tYWluOjgwODAvcGF0aC9hJykud2F0Y2goe2lkOiAnbXlJZCd9LCB7Zm9vOiB0cnVlfSk7XG5cdCAqIC8vIEVxdWFsczpcblx0ICogaW8oJ2RvbWFpbjo4MDgwLz91cmw9cGF0aCUyRmElM0ZpZCUzRG15SWQnLCB7Zm9vOiB0cnVlfSk7XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdD19IG9wdF9wYXJhbXMgUGFyYW1zIHRvIGJlIHNlbnQgd2l0aCB0aGUgU29ja2V0IElPIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29wdGlvbnMgT2JqZWN0IHdpdGggU29ja2V0IElPIG9wdGlvbnMuXG5cdCAqIEByZXR1cm4geyFpb30gU29ja2V0IElPIHJlZmVyZW5jZS4gU2VydmVyIGV2ZW50cyBjYW4gYmUgbGlzdGVuZWQgb24gaXQuXG5cdCAqL1xuXHR3YXRjaChvcHRfcGFyYW1zLCBvcHRfb3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2YgaW8gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NvY2tldC5pbyBjbGllbnQgbm90IGxvYWRlZCcpO1xuXHRcdH1cblxuXHRcdHZhciBjbGllbnRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVDbGllbnRSZXF1ZXN0XygnR0VUJywgb3B0X3BhcmFtcyk7XG5cdFx0dmFyIHVyaSA9IG5ldyBVcmkoY2xpZW50UmVxdWVzdC51cmwoKSk7XG5cdFx0dXJpLmFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAoY2xpZW50UmVxdWVzdC5wYXJhbXMoKSk7XG5cblx0XHRvcHRfb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHtcblx0XHRcdGZvcmNlTmV3OiB0cnVlXG5cdFx0fTtcblx0XHRvcHRfb3B0aW9ucy5xdWVyeSA9ICd1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1cmkuZ2V0UGF0aG5hbWUoKSArIHVyaS5nZXRTZWFyY2goKSk7XG5cdFx0b3B0X29wdGlvbnMucGF0aCA9IG9wdF9vcHRpb25zLnBhdGggfHwgdXJpLmdldFBhdGhuYW1lKCk7XG5cblx0XHRyZXR1cm4gaW8odXJpLmdldEhvc3QoKSwgb3B0X29wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X3dpdGhDcmVkZW50aWFsc1xuXHQgKi9cblx0d2l0aENyZWRlbnRpYWxzKHdpdGhDcmVkZW50aWFscykge1xuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzXyA9ICEhd2l0aENyZWRlbnRpYWxzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyYXBzIHRoZSBnaXZlbiBgRW1ib2RpZWRgIGluc3RhbmNlIHdpdGggYSB7QGxpbmsgUXVlcnl9IGluc3RhbmNlIGlmIG5lZWRlZC5cblx0ICogQHBhcmFtIHtFbWJvZGllZH0gZW1ib2RpZWRcblx0ICogQHJldHVybiB7RW1ib2RpZWR9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHdyYXBXaXRoUXVlcnlfKGVtYm9kaWVkKSB7XG5cdFx0aWYgKGVtYm9kaWVkIGluc3RhbmNlb2YgRmlsdGVyKSB7XG5cdFx0XHRlbWJvZGllZCA9IFF1ZXJ5LmZpbHRlcihlbWJvZGllZCk7XG5cdFx0fVxuXHRcdHJldHVybiBlbWJvZGllZDtcblx0fVxufVxuXG5XZURlcGxveS5pc0NvbnRlbnRUeXBlSnNvbiA9IGZ1bmN0aW9uKGNsaWVudE1lc3NhZ2UpIHtcblx0dmFyIGNvbnRlbnRUeXBlID0gY2xpZW50TWVzc2FnZS5oZWFkZXJzKCkuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcblx0cmV0dXJuIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA9PT0gMDtcbn07XG5cbldlRGVwbG95LmF1dGhfID0gbnVsbDtcbldlRGVwbG95LmF1dGhVcmxfID0gJyc7XG5XZURlcGxveS5kYXRhXyA9IG51bGw7XG5XZURlcGxveS5kYXRhVXJsXyA9ICcnO1xuXG5leHBvcnQgZGVmYXVsdCBXZURlcGxveTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWxzJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vYXBpLXF1ZXJ5L0ZpbHRlcic7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2FwaS1xdWVyeS9HZW8nO1xuaW1wb3J0IFdlRGVwbG95IGZyb20gJy4uL2FwaS9XZURlcGxveSc7XG5pbXBvcnQgUXVlcnkgZnJvbSAnLi4vYXBpLXF1ZXJ5L1F1ZXJ5JztcbmltcG9ydCBSYW5nZSBmcm9tICcuLi9hcGktcXVlcnkvUmFuZ2UnO1xuXG5nbG9iYWxzLndpbmRvdy5GaWx0ZXIgPSBGaWx0ZXI7XG5nbG9iYWxzLndpbmRvdy5HZW8gPSBHZW87XG5nbG9iYWxzLndpbmRvdy5RdWVyeSA9IFF1ZXJ5O1xuZ2xvYmFscy53aW5kb3cuUmFuZ2UgPSBSYW5nZTtcbmdsb2JhbHMud2luZG93LldlRGVwbG95ID0gV2VEZXBsb3k7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
