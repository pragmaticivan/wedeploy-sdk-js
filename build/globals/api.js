(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["io"] = factory();
	else
		root["io"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Module dependencies.
	 */

	var url = __webpack_require__(1);
	var parser = __webpack_require__(6);
	var Manager = __webpack_require__(14);
	var debug = __webpack_require__(3)('socket.io-client');

	/**
	 * Module exports.
	 */

	module.exports = exports = lookup;

	/**
	 * Managers cache.
	 */

	var cache = exports.managers = {};

	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */

	function lookup(uri, opts) {
	  if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
	    opts = uri;
	    uri = undefined;
	  }

	  opts = opts || {};

	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;

	  var io;

	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	  if (parsed.query && !opts.query) {
	    opts.query = parsed.query;
	  } else if (opts && 'object' === _typeof(opts.query)) {
	    opts.query = encodeQueryString(opts.query);
	  }
	  return io.socket(parsed.path, opts);
	}
	/**
	 *  Helper method to parse query objects to string.
	 * @param {object} query
	 * @returns {string}
	 */
	function encodeQueryString(obj) {
	  var str = [];
	  for (var p in obj) {
	    if (obj.hasOwnProperty(p)) {
	      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
	    }
	  }
	  return str.join('&');
	}
	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = parser.protocol;

	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */

	exports.connect = lookup;

	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */

	exports.Manager = __webpack_require__(14);
	exports.Socket = __webpack_require__(42);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	/**
	 * Module dependencies.
	 */

	var parseuri = __webpack_require__(2);
	var debug = __webpack_require__(3)('socket.io-client:url');

	/**
	 * Module exports.
	 */

	module.exports = url;

	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */

	function url(uri, loc) {
	  var obj = uri;

	  // default to window.location
	  loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;

	  // relative path support
	  if ('string' === typeof uri) {
	    if ('/' === uri.charAt(0)) {
	      if ('/' === uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }

	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' !== typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }

	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }

	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    } else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }

	  obj.path = obj.path || '/';

	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);

	  return obj;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */

	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];

	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');

	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }

	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;

	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }

	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }

	    return uri;
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(4);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(5);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var debug = __webpack_require__(3)('socket.io-parser');
	var json = __webpack_require__(7);
	var isArray = __webpack_require__(10);
	var Emitter = __webpack_require__(11);
	var binary = __webpack_require__(12);
	var isBuf = __webpack_require__(13);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = 4;

	/**
	 * Packet types.
	 *
	 * @api public
	 */

	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'ACK',
	  'ERROR',
	  'BINARY_EVENT',
	  'BINARY_ACK'
	];

	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */

	exports.CONNECT = 0;

	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */

	exports.DISCONNECT = 1;

	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */

	exports.EVENT = 2;

	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */

	exports.ACK = 3;

	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */

	exports.ERROR = 4;

	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */

	exports.BINARY_EVENT = 5;

	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */

	exports.BINARY_ACK = 6;

	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */

	exports.Encoder = Encoder;

	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */

	exports.Decoder = Decoder;

	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */

	function Encoder() {}

	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */

	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);

	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};

	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */

	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;

	  // first is type
	  str += obj.type;

	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }

	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }

	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }

	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }

	  debug('encoded %j as %s', obj, str);
	  return str;
	}

	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */

	function encodeAsBinary(obj, callback) {

	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;

	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }

	  binary.removeBlobs(obj, writeEncoding);
	}

	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */

	function Decoder() {
	  this.reconstructor = null;
	}

	/**
	 * Mix in `Emitter` with Decoder.
	 */

	Emitter(Decoder.prototype);

	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */

	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);

	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};

	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */

	function decodeString(str) {
	  var p = {};
	  var i = 0;

	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();

	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }

	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }

	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }

	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }

	  debug('decoded %s as %j', str, p);
	  return p;
	}

	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */

	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};

	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */

	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}

	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */

	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};

	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */

	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};

	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(9);

	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };

	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }

	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());

	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];

	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }

	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;

	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}

	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }

	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";

	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");

	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }

	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }

	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;

	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;

	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;

	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };

	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };

	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };

	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };

	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };

	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }

	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;

	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };

	        // Internal: Stores the parser state.
	        var Index, Source;

	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };

	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };

	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };

	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };

	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };

	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }

	    exports["runInContext"] = runInContext;
	    return exports;
	  }

	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;

	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));

	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }

	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)(module), (function() { return this; }())))

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 9 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 11 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */

	module.exports = Emitter;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};

	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/

	/**
	 * Module requirements
	 */

	var isArray = __webpack_require__(10);
	var isBuf = __webpack_require__(13);

	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */

	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;

	  function _deconstructPacket(data) {
	    if (!data) return data;

	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }

	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};

	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */

	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;

	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }

	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};

	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */

	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;

	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;

	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }

	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };

	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }

	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 13 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	module.exports = isBuf;

	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */

	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Module dependencies.
	 */

	var eio = __webpack_require__(15);
	var Socket = __webpack_require__(42);
	var Emitter = __webpack_require__(43);
	var parser = __webpack_require__(6);
	var on = __webpack_require__(45);
	var bind = __webpack_require__(46);
	var debug = __webpack_require__(3)('socket.io-client:manager');
	var indexOf = __webpack_require__(40);
	var Backoff = __webpack_require__(49);

	/**
	 * IE6+ hasOwnProperty
	 */

	var has = Object.prototype.hasOwnProperty;

	/**
	 * Module exports
	 */

	module.exports = Manager;

	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */

	function Manager(uri, opts) {
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};

	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}

	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */

	Manager.prototype.emitAll = function () {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};

	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */

	Manager.prototype.updateSocketIds = function () {
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.engine.id;
	    }
	  }
	};

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Manager.prototype);

	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnection = function (v) {
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};

	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionAttempts = function (v) {
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};

	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelay = function (v) {
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};

	Manager.prototype.randomizationFactor = function (v) {
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};

	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelayMax = function (v) {
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};

	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.timeout = function (v) {
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};

	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */

	Manager.prototype.maybeReconnectOnOpen = function () {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};

	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */

	Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;

	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;

	  // emit `open`
	  var openSub = on(socket, 'open', function () {
	    self.onopen();
	    fn && fn();
	  });

	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function (data) {
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });

	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);

	    // set timer
	    var timer = setTimeout(function () {
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);

	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }

	  this.subs.push(openSub);
	  this.subs.push(errorSub);

	  return this;
	};

	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */

	Manager.prototype.onopen = function () {
	  debug('open');

	  // clear old subs
	  this.cleanup();

	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');

	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};

	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */

	Manager.prototype.onping = function () {
	  this.lastPing = new Date();
	  this.emitAll('ping');
	};

	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */

	Manager.prototype.onpong = function () {
	  this.emitAll('pong', new Date() - this.lastPing);
	};

	/**
	 * Called with data.
	 *
	 * @api private
	 */

	Manager.prototype.ondata = function (data) {
	  this.decoder.add(data);
	};

	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */

	Manager.prototype.ondecoded = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */

	Manager.prototype.onerror = function (err) {
	  debug('error', err);
	  this.emitAll('error', err);
	};

	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */

	Manager.prototype.socket = function (nsp, opts) {
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp, opts);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function () {
	      socket.id = self.engine.id;
	    });

	    if (this.autoConnect) {
	      // manually call here since connecting evnet is fired before listening
	      onConnecting();
	    }
	  }

	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }

	  return socket;
	};

	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */

	Manager.prototype.destroy = function (socket) {
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;

	  this.close();
	};

	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Manager.prototype.packet = function (packet) {
	  debug('writing packet %j', packet);
	  var self = this;
	  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function (encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else {
	    // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};

	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */

	Manager.prototype.processPacketQueue = function () {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};

	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */

	Manager.prototype.cleanup = function () {
	  debug('cleanup');

	  var subsLength = this.subs.length;
	  for (var i = 0; i < subsLength; i++) {
	    var sub = this.subs.shift();
	    sub.destroy();
	  }

	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;

	  this.decoder.destroy();
	};

	/**
	 * Close the current socket.
	 *
	 * @api private
	 */

	Manager.prototype.close = Manager.prototype.disconnect = function () {
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' === this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};

	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */

	Manager.prototype.onclose = function (reason) {
	  debug('onclose');

	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);

	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};

	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */

	Manager.prototype.reconnect = function () {
	  if (this.reconnecting || this.skipReconnect) return this;

	  var self = this;

	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);

	    this.reconnecting = true;
	    var timer = setTimeout(function () {
	      if (self.skipReconnect) return;

	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);

	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;

	      self.open(function (err) {
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);

	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	};

	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */

	Manager.prototype.onreconnect = function () {
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports =  __webpack_require__(16);


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(17);

	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(24);


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var transports = __webpack_require__(18);
	var Emitter = __webpack_require__(33);
	var debug = __webpack_require__(3)('engine.io-client:socket');
	var index = __webpack_require__(40);
	var parser = __webpack_require__(24);
	var parseuri = __webpack_require__(2);
	var parsejson = __webpack_require__(41);
	var parseqs = __webpack_require__(34);

	/**
	 * Module exports.
	 */

	module.exports = Socket;

	/**
	 * Noop function.
	 *
	 * @api private
	 */

	function noop(){}

	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */

	function Socket(uri, opts){
	  if (!(this instanceof Socket)) return new Socket(uri, opts);

	  opts = opts || {};

	  if (uri && 'object' == typeof uri) {
	    opts = uri;
	    uri = null;
	  }

	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }

	  this.secure = null != opts.secure ? opts.secure :
	    (global.location && 'https:' == location.protocol);

	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }

	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ?
	       location.port :
	       (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }

	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

	  // other options for Node.js client
	  var freeGlobal = typeof global == 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	  }

	  this.open();
	}

	Socket.priorWebsocketSuccess = false;

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	Socket.protocol = parser.protocol; // this is an int

	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */

	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(23);
	Socket.transports = __webpack_require__(18);
	Socket.parser = __webpack_require__(24);

	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */

	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);

	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;

	  // transport name
	  query.transport = name;

	  // session id if we already have one
	  if (this.id) query.sid = this.id;

	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized,
	    perMessageDeflate: this.perMessageDeflate,
	    extraHeaders: this.extraHeaders
	  });

	  return transport;
	};

	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}

	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function() {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';

	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }

	  transport.open();
	  this.setTransport(transport);
	};

	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */

	Socket.prototype.setTransport = function(transport){
	  debug('setting transport %s', transport.name);
	  var self = this;

	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }

	  // set up transport
	  this.transport = transport;

	  // set up transport listeners
	  transport
	  .on('drain', function(){
	    self.onDrain();
	  })
	  .on('packet', function(packet){
	    self.onPacket(packet);
	  })
	  .on('error', function(e){
	    self.onError(e);
	  })
	  .on('close', function(){
	    self.onClose('transport close');
	  });
	};

	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */

	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 })
	    , failed = false
	    , self = this;

	  Socket.priorWebsocketSuccess = false;

	  function onTransportOpen(){
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;

	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');

	          cleanup();

	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }

	  function freezeTransport() {
	    if (failed) return;

	    // Any callback called by transport should be ignored since now
	    failed = true;

	    cleanup();

	    transport.close();
	    transport = null;
	  }

	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;

	    freezeTransport();

	    debug('probe transport "%s" failed because of error: %s', name, err);

	    self.emit('upgradeError', error);
	  }

	  function onTransportClose(){
	    onerror("transport closed");
	  }

	  //When the socket is closed while we're probing
	  function onclose(){
	    onerror("socket closed");
	  }

	  //When the socket is upgraded while we're probing
	  function onupgrade(to){
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }

	  //Remove all listeners on the transport and on self
	  function cleanup(){
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }

	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);

	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);

	  transport.open();

	};

	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */

	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();

	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};

	/**
	 * Handles a packet.
	 *
	 * @api private
	 */

	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

	    this.emit('packet', packet);

	    // Socket is live - any packet counts
	    this.emit('heartbeat');

	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;

	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;

	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;

	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};

	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */

	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if  ('closed' == this.readyState) return;
	  this.setPing();

	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};

	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */

	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};

	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */

	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};

	/**
	* Sends a ping packet.
	*
	* @api private
	*/

	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function(){
	    self.emit('ping');
	  });
	};

	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */

	Socket.prototype.onDrain = function() {
	  this.writeBuffer.splice(0, this.prevBufferLen);

	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;

	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};

	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */

	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};

	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */

	Socket.prototype.write =
	Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */

	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if('function' == typeof data) {
	    fn = data;
	    data = undefined;
	  }

	  if ('function' == typeof options) {
	    fn = options;
	    options = null;
	  }

	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }

	  options = options || {};
	  options.compress = false !== options.compress;

	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};

	/**
	 * Closes the connection.
	 *
	 * @api private
	 */

	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';

	    var self = this;

	    if (this.writeBuffer.length) {
	      this.once('drain', function() {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }

	  function close() {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }

	  function cleanupAndClose() {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }

	  function waitForUpgrade() {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }

	  return this;
	};

	/**
	 * Called upon transport error
	 *
	 * @api private
	 */

	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};

	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */

	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;

	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);

	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');

	    // ensure transport won't stay open
	    this.transport.close();

	    // ignore further transport communication
	    this.transport.removeAllListeners();

	    // set ready state
	    this.readyState = 'closed';

	    // clear session id
	    this.id = null;

	    // emit close event
	    this.emit('close', reason, desc);

	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};

	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */

	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i<j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies
	 */

	var XMLHttpRequest = __webpack_require__(19);
	var XHR = __webpack_require__(21);
	var JSONP = __webpack_require__(37);
	var websocket = __webpack_require__(38);

	/**
	 * Export transports.
	 */

	exports.polling = polling;
	exports.websocket = websocket;

	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */

	function polling(opts){
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;

	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }

	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);

	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// browser shim for xmlhttprequest module
	var hasCORS = __webpack_require__(20);

	module.exports = function(opts) {
	  var xdomain = opts.xdomain;

	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;

	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;

	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }

	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }

	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch(e) { }
	  }
	}


/***/ },
/* 20 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */

	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */

	var XMLHttpRequest = __webpack_require__(19);
	var Polling = __webpack_require__(22);
	var Emitter = __webpack_require__(33);
	var inherit = __webpack_require__(35);
	var debug = __webpack_require__(3)('engine.io-client:polling-xhr');

	/**
	 * Module exports.
	 */

	module.exports = XHR;
	module.exports.Request = Request;

	/**
	 * Empty function
	 */

	function empty(){}

	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function XHR(opts){
	  Polling.call(this, opts);

	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    this.xd = opts.hostname != global.location.hostname ||
	      port != opts.port;
	    this.xs = opts.secure != isSSL;
	  } else {
	    this.extraHeaders = opts.extraHeaders;
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(XHR, Polling);

	/**
	 * XHR supports binary
	 */

	XHR.prototype.supportsBinary = true;

	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */

	XHR.prototype.request = function(opts){
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;

	  return new Request(opts);
	};

	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */

	XHR.prototype.doWrite = function(data, fn){
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function(err){
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	XHR.prototype.doPoll = function(){
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function(data){
	    self.onData(data);
	  });
	  req.on('error', function(err){
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};

	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */

	function Request(opts){
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;

	  this.create();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Request.prototype);

	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */

	Request.prototype.create = function(){
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;

	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }

	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }

	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }

	    if (this.hasXDR()) {
	      xhr.onload = function(){
	        self.onLoad();
	      };
	      xhr.onerror = function(){
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function(){
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function(){
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }

	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function() {
	      self.onError(e);
	    }, 0);
	    return;
	  }

	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};

	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */

	Request.prototype.onSuccess = function(){
	  this.emit('success');
	  this.cleanup();
	};

	/**
	 * Called if we have data.
	 *
	 * @api private
	 */

	Request.prototype.onData = function(data){
	  this.emit('data', data);
	  this.onSuccess();
	};

	/**
	 * Called upon error.
	 *
	 * @api private
	 */

	Request.prototype.onError = function(err){
	  this.emit('error', err);
	  this.cleanup(true);
	};

	/**
	 * Cleans up house.
	 *
	 * @api private
	 */

	Request.prototype.cleanup = function(fromError){
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }

	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch(e) {}
	  }

	  if (global.document) {
	    delete Request.requests[this.index];
	  }

	  this.xhr = null;
	};

	/**
	 * Called upon load.
	 *
	 * @api private
	 */

	Request.prototype.onLoad = function(){
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        try {
	          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
	        } catch (e) {
	          var ui8Arr = new Uint8Array(this.xhr.response);
	          var dataArray = [];
	          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
	            dataArray.push(ui8Arr[idx]);
	          }

	          data = String.fromCharCode.apply(null, dataArray);
	        }
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};

	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */

	Request.prototype.hasXDR = function(){
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};

	/**
	 * Aborts the request.
	 *
	 * @api public
	 */

	Request.prototype.abort = function(){
	  this.cleanup();
	};

	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */

	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}

	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(23);
	var parseqs = __webpack_require__(34);
	var parser = __webpack_require__(24);
	var inherit = __webpack_require__(35);
	var yeast = __webpack_require__(36);
	var debug = __webpack_require__(3)('engine.io-client:polling');

	/**
	 * Module exports.
	 */

	module.exports = Polling;

	/**
	 * Is XHR2 supported?
	 */

	var hasXHR2 = (function() {
	  var XMLHttpRequest = __webpack_require__(19);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();

	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */

	function Polling(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(Polling, Transport);

	/**
	 * Transport name.
	 */

	Polling.prototype.name = 'polling';

	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */

	Polling.prototype.doOpen = function(){
	  this.poll();
	};

	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */

	Polling.prototype.pause = function(onPause){
	  var pending = 0;
	  var self = this;

	  this.readyState = 'pausing';

	  function pause(){
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }

	  if (this.polling || !this.writable) {
	    var total = 0;

	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function(){
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }

	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function(){
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};

	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */

	Polling.prototype.poll = function(){
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};

	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */

	Polling.prototype.onData = function(data){
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }

	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }

	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };

	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);

	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');

	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};

	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */

	Polling.prototype.doClose = function(){
	  var self = this;

	  function close(){
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }

	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};

	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */

	Polling.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  var callbackfn = function() {
	    self.writable = true;
	    self.emit('drain');
	  };

	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.doWrite(data, callbackfn);
	  });
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	Polling.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';

	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }

	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // avoid port if default for schema
	  if (this.port && (('https' == schema && this.port != 443) ||
	     ('http' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(24);
	var Emitter = __webpack_require__(33);

	/**
	 * Module exports.
	 */

	module.exports = Transport;

	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */

	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Transport.prototype);

	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */

	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};

	/**
	 * Opens the transport.
	 *
	 * @api public
	 */

	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }

	  return this;
	};

	/**
	 * Closes the transport.
	 *
	 * @api private
	 */

	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }

	  return this;
	};

	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */

	Transport.prototype.send = function(packets){
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};

	/**
	 * Called upon open
	 *
	 * @api private
	 */

	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};

	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */

	Transport.prototype.onData = function(data){
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};

	/**
	 * Called with a decoded packet.
	 */

	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon close.
	 *
	 * @api private
	 */

	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var keys = __webpack_require__(25);
	var hasBinary = __webpack_require__(26);
	var sliceBuffer = __webpack_require__(28);
	var base64encoder = __webpack_require__(29);
	var after = __webpack_require__(30);
	var utf8 = __webpack_require__(31);

	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */

	var isAndroid = navigator.userAgent.match(/Android/i);

	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;

	/**
	 * Current protocol version.
	 */

	exports.protocol = 3;

	/**
	 * Packet types.
	 */

	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};

	var packetslist = keys(packets);

	/**
	 * Premade error packet.
	 */

	var err = { type: 'error', data: 'parser error' };

	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */

	var Blob = __webpack_require__(32);

	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */

	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }

	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }

	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;

	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }

	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }

	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];

	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }

	  return callback('' + encoded);

	};

	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}

	/**
	 * Encode packet helpers for binary types
	 */

	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);

	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }

	  return callback(resultBuffer.buffer);
	}

	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}

	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }

	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);

	  return callback(blob);
	}

	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */

	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }

	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};

	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */

	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }

	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);

	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }

	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }

	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};

	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */

	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }

	  var data = base64encoder.decode(msg.substr(1));

	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }

	  return { type: type, data: data };
	};

	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */

	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }

	  var isBinary = hasBinary(packets);

	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }

	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }

	  if (!packets.length) {
	    return callback('0:');
	  }

	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};

	/**
	 * Async array map using after
	 */

	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);

	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };

	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}

	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */

	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }

	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	  var length = ''
	    , n, msg;

	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);

	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      msg = data.substr(i + 1, n);

	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);

	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }

	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }

	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }

	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	};

	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */

	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }

	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);

	    var resultArray = new Uint8Array(totalLength);

	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }

	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }

	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;

	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });

	    return callback(resultArray.buffer);
	  });
	};

	/**
	 * Encode as Blob
	 */

	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }

	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;

	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;

	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};

	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */

	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var bufferTail = data;
	  var buffers = [];

	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';

	    for (var i = 1; ; i++) {
	      if (tailArray[i] == 255) break;

	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }

	      msgLength += tailArray[i];
	    }

	    if(numberTooLong) return callback(err, 0, 1);

	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);

	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }

	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }

	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 25 */
/***/ function(module, exports) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */

	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;

	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */

	var isArray = __webpack_require__(27);

	/**
	 * Module exports.
	 */

	module.exports = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary(data) {

	  function _hasBinary(obj) {
	    if (!obj) return false;

	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }

	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }

	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  return _hasBinary(data);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */

	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;

	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }

	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }

	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ },
/* 29 */
/***/ function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(chars){
	  "use strict";

	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";

	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }

	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }

	    return base64;
	  };

	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;

	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }

	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);

	    for (i = 0; i < len; i+=4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i+1]);
	      encoded3 = chars.indexOf(base64[i+2]);
	      encoded4 = chars.indexOf(base64[i+3]);

	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }

	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = after

	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count

	    return (count === 0) ? callback() : proxy

	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count

	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}

	function noop() {}


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, its not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)(module), (function() { return this; }())))

/***/ },
/* 32 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Create a blob builder even when vendor prefixes exist
	 */

	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;

	/**
	 * Check if Blob constructor is supported
	 */

	var blobSupported = (function() {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();

	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */

	var blobSupportsArrayBufferView = blobSupported && (function() {
	  try {
	    var b = new Blob([new Uint8Array([1,2])]);
	    return b.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();

	/**
	 * Check if BlobBuilder is supported
	 */

	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;

	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */

	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;

	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }

	      ary[i] = buf;
	    }
	  }
	}

	function BlobBuilderConstructor(ary, options) {
	  options = options || {};

	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);

	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }

	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};

	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};

	module.exports = (function() {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 33 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */

	module.exports = Emitter;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};

	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 34 */
/***/ function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */

	exports.encode = function (obj) {
	  var str = '';

	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }

	  return str;
	};

	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */

	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ },
/* 35 */
/***/ function(module, exports) {

	
	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	'use strict';

	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;

	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';

	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);

	  return encoded;
	}

	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;

	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }

	  return decoded;
	}

	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());

	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}

	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;

	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module requirements.
	 */

	var Polling = __webpack_require__(22);
	var inherit = __webpack_require__(35);

	/**
	 * Module exports.
	 */

	module.exports = JSONPPolling;

	/**
	 * Cached regular expressions.
	 */

	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;

	/**
	 * Global JSONP callbacks.
	 */

	var callbacks;

	/**
	 * Callbacks count.
	 */

	var index = 0;

	/**
	 * Noop.
	 */

	function empty () { }

	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */

	function JSONPPolling (opts) {
	  Polling.call(this, opts);

	  this.query = this.query || {};

	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }

	  // callback identifier
	  this.index = callbacks.length;

	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });

	  // append to query string
	  this.query.j = this.index;

	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(JSONPPolling, Polling);

	/*
	 * JSONP only supports binary as base64 encoded strings
	 */

	JSONPPolling.prototype.supportsBinary = false;

	/**
	 * Closes the socket.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }

	  Polling.prototype.doClose.call(this);
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');

	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function(e){
	    self.onError('jsonp poll error',e);
	  };

	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  }
	  else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;

	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	  
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};

	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */

	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;

	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;

	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);

	    this.form = form;
	    this.area = area;
	  }

	  this.form.action = this.uri();

	  function complete () {
	    initIframe();
	    fn();
	  }

	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }

	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }

	    iframe.id = self.iframeId;

	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }

	  initIframe();

	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');

	  try {
	    this.form.submit();
	  } catch(e) {}

	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function(){
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(23);
	var parser = __webpack_require__(24);
	var parseqs = __webpack_require__(34);
	var inherit = __webpack_require__(35);
	var yeast = __webpack_require__(36);
	var debug = __webpack_require__(3)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */

	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  try {
	    WebSocket = __webpack_require__(39);
	  } catch (e) { }
	}

	/**
	 * Module exports.
	 */

	module.exports = WS;

	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */

	function WS(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(WS, Transport);

	/**
	 * Transport name.
	 *
	 * @api public
	 */

	WS.prototype.name = 'websocket';

	/*
	 * WebSockets support binary
	 */

	WS.prototype.supportsBinary = true;

	/**
	 * Opens socket.
	 *
	 * @api private
	 */

	WS.prototype.doOpen = function(){
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }

	  var self = this;
	  var uri = this.uri();
	  var protocols = void(0);
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }

	  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }

	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'buffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }

	  this.addEventListeners();
	};

	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */

	WS.prototype.addEventListeners = function(){
	  var self = this;

	  this.ws.onopen = function(){
	    self.onOpen();
	  };
	  this.ws.onclose = function(){
	    self.onClose();
	  };
	  this.ws.onmessage = function(ev){
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function(e){
	    self.onError('websocket error', e);
	  };
	};

	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */

	if ('undefined' != typeof navigator
	  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function(data){
	    var self = this;
	    setTimeout(function(){
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}

	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */

	WS.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;

	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function(packet) {
	      parser.encodePacket(packet, self.supportsBinary, function(data) {
	        if (!BrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }

	          if (self.perMessageDeflate) {
	            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }

	        //Sometimes the websocket has already been closed but the browser didn't
	        //have a chance of informing us about it yet, in that case send will
	        //throw an error
	        try {
	          if (BrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e){
	          debug('websocket closed before onclose event');
	        }

	        --total || done();
	      });
	    })(packets[i]);
	  }

	  function done(){
	    self.emit('flush');

	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function(){
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};

	/**
	 * Called upon close
	 *
	 * @api private
	 */

	WS.prototype.onClose = function(){
	  Transport.prototype.onClose.call(this);
	};

	/**
	 * Closes socket.
	 *
	 * @api private
	 */

	WS.prototype.doClose = function(){
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	WS.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';

	  // avoid port if default for schema
	  if (this.port && (('wss' == schema && this.port != 443)
	    || ('ws' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }

	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }

	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};

	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */

	WS.prototype.check = function(){
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 39 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 40 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */

	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;

	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }

	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }

	  if (rvalidchars.test(data.replace(rvalidescape, '@')
	      .replace(rvalidtokens, ']')
	      .replace(rvalidbraces, ''))) {
	    return (new Function('return ' + data))();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(6);
	var Emitter = __webpack_require__(43);
	var toArray = __webpack_require__(44);
	var on = __webpack_require__(45);
	var bind = __webpack_require__(46);
	var debug = __webpack_require__(3)('socket.io-client:socket');
	var hasBin = __webpack_require__(47);

	/**
	 * Module exports.
	 */

	module.exports = exports = Socket;

	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */

	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};

	/**
	 * Shortcut to `Emitter#emit`.
	 */

	var emit = Emitter.prototype.emit;

	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */

	function Socket(io, nsp, opts) {
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  if (opts && opts.query) {
	    this.query = opts.query;
	  }
	  if (this.io.autoConnect) this.open();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */

	Socket.prototype.subEvents = function () {
	  if (this.subs) return;

	  var io = this.io;
	  this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
	};

	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */

	Socket.prototype.open = Socket.prototype.connect = function () {
	  if (this.connected) return this;

	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' === this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};

	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.send = function () {
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};

	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.emit = function (ev) {
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }

	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) {
	    parserType = parser.BINARY_EVENT;
	  } // binary
	  var packet = { type: parserType, data: args };

	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;

	  // event ack callback
	  if ('function' === typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }

	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }

	  delete this.flags;

	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.packet = function (packet) {
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};

	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */

	Socket.prototype.onopen = function () {
	  debug('transport is open - connecting');

	  // write connect packet if necessary
	  if ('/' !== this.nsp) {
	    if (this.query) {
	      this.packet({ type: parser.CONNECT, query: this.query });
	    } else {
	      this.packet({ type: parser.CONNECT });
	    }
	  }
	};

	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */

	Socket.prototype.onclose = function (reason) {
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};

	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onpacket = function (packet) {
	  if (packet.nsp !== this.nsp) return;

	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;

	    case parser.EVENT:
	      this.onevent(packet);
	      break;

	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;

	    case parser.ACK:
	      this.onack(packet);
	      break;

	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;

	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;

	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};

	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onevent = function (packet) {
	  var args = packet.data || [];
	  debug('emitting event %j', args);

	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }

	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};

	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */

	Socket.prototype.ack = function (id) {
	  var self = this;
	  var sent = false;
	  return function () {
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);

	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};

	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onack = function (packet) {
	  var ack = this.acks[packet.id];
	  if ('function' === typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};

	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */

	Socket.prototype.onconnect = function () {
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};

	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */

	Socket.prototype.emitBuffered = function () {
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];

	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};

	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */

	Socket.prototype.ondisconnect = function () {
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};

	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */

	Socket.prototype.destroy = function () {
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }

	  this.io.destroy(this);
	};

	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.close = Socket.prototype.disconnect = function () {
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }

	  // remove socket from pool
	  this.destroy();

	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};

	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.compress = function (compress) {
	  this.flags = this.flags || {};
	  this.flags.compress = compress;
	  return this;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */

	module.exports = Emitter;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = toArray

	function toArray(list, index) {
	    var array = []

	    index = index || 0

	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }

	    return array
	}


/***/ },
/* 45 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Module exports.
	 */

	module.exports = on;

	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */

	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function destroy() {
	      obj.removeListener(ev, fn);
	    }
	  };
	}

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Slice reference.
	 */

	var slice = [].slice;

	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */

	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */

	var isArray = __webpack_require__(48);

	/**
	 * Module exports.
	 */

	module.exports = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary(data) {

	  function _hasBinary(obj) {
	    if (!obj) return false;

	    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }

	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      // see: https://github.com/Automattic/has-binary/pull/4
	      if (obj.toJSON && 'function' == typeof obj.toJSON) {
	        obj = obj.toJSON();
	      }

	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  return _hasBinary(data);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 49 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */

	module.exports = Backoff;

	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}

	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */

	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};

	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */

	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};

	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};

	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};

	/**
	 * Set the jitter
	 *
	 * @api public
	 */

	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};



/***/ }
/******/ ])
});
;
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.wedeploy = global.wedeploy || {})));
}(this, (function (exports) { 'use strict';

var globals = {};

if (typeof window !== 'undefined') {
	globals.window = window;
}

if (typeof document !== 'undefined') {
	globals.document = document;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/**
 * A collection of core utility functions.
 * @const
 */

var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Loops constructor super classes collecting its properties values. If
 * property is not available on the super class `undefined` will be
 * collected as value for the class hierarchy position.
 * @param {!function()} constructor Class constructor.
 * @param {string} propertyName Property name to be collected.
 * @return {Array.<*>} Array of collected values.
 * TODO(*): Rethink superclass loop.
 */
function collectSuperClassesProperty(constructor, propertyName) {
  var propertyValues = [constructor[propertyName]];
  while (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {
    constructor = constructor.__proto__;
    propertyValues.push(constructor[propertyName]);
  }
  return propertyValues;
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = null;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (!compatibilityModeData_) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Merges the values of a export function property a class with the values of that
 * property for all its super classes, and stores it as a new static
 * property of that class. If the export function property already existed, it won't
 * be recalculated.
 * @param {!function()} constructor Class constructor.
 * @param {string} propertyName Property name to be collected.
 * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled
 *   with the values of the property for the current class and all its super classes.
 *   Should return the merged value to be stored on the current class.
 * @return {boolean} Returns true if merge happens, false otherwise.
 */
function mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (constructor.hasOwnProperty(mergedName)) {
    return false;
  }

  var merged = collectSuperClassesProperty(constructor, propertyName);
  if (opt_mergeFn) {
    merged = opt_mergeFn(merged);
  }
  constructor[mergedName] = merged;
  return true;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}



var core$2 = Object.freeze({
	UID_PROPERTY: UID_PROPERTY,
	abstractMethod: abstractMethod,
	collectSuperClassesProperty: collectSuperClassesProperty,
	disableCompatibilityMode: disableCompatibilityMode,
	enableCompatibilityMode: enableCompatibilityMode,
	getCompatibilityModeData: getCompatibilityModeData,
	getFunctionName: getFunctionName,
	getUid: getUid,
	identityFunction: identityFunction,
	isBoolean: isBoolean,
	isDef: isDef,
	isDefAndNotNull: isDefAndNotNull,
	isDocument: isDocument,
	isElement: isElement,
	isFunction: isFunction,
	isNull: isNull,
	isNumber: isNumber,
	isWindow: isWindow,
	isObject: isObject,
	isPromise: isPromise,
	isString: isString,
	mergeSuperClassesProperty: mergeSuperClassesProperty,
	nullFunction: nullFunction
});

// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

var array = function () {
	function array() {
		classCallCheck(this, array);
	}

	createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = isDef(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);
	return array;
}();

/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */

var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

var Disposable = function () {
	function Disposable() {
		classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);
	return Disposable;
}();

var object = function () {
	function object() {
		classCallCheck(this, object);
	}

	createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key, source;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);
	return object;
}();

var string = function () {
	function string() {
		classCallCheck(this, string);
	}

	createClass(string, null, [{
		key: 'collapseBreakingSpaces',

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);
	return string;
}();

/**
 * Class responsible for storing an object that will be printed as JSON
 * when the `toString` method is called.
 */

var Embodied = function () {
	/**
  * Constructs a Embodied instance.
  * @constructor
  */
	function Embodied() {
		classCallCheck(this, Embodied);

		this.body_ = {};
	}

	/**
  * Gets the json object that represents this instance.
  * @return {!Object}
  */


	createClass(Embodied, [{
		key: 'body',
		value: function body() {
			return this.body_;
		}

		/**
   * If the given object is an instance of Embodied, this will
   * return its body content. Otherwise this will return the
   * original object.
   * @param {*} obj
   * @return {*}
   * @static
   */

	}, {
		key: 'toString',


		/**
   * Gets the json string that represents this instance.
   * @return {string}
   */
		value: function toString() {
			return JSON.stringify(this.body());
		}
	}], [{
		key: 'toBody',
		value: function toBody(obj) {
			return obj instanceof Embodied ? obj.body() : obj;
		}
	}]);
	return Embodied;
}();

/**
 * Class responsible for storing and handling the body contents
 * of a Filter instance.
 */

var FilterBody = function () {
	/**
  * Constructs a {@link FilterBody} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
	function FilterBody(field, operatorOrValue, opt_value) {
		classCallCheck(this, FilterBody);

		var obj = {
			operator: isDef(opt_value) ? operatorOrValue : '='
		};

		var value = isDef(opt_value) ? opt_value : operatorOrValue;

		if (isDefAndNotNull(value)) {
			if (value instanceof Embodied) {
				value = value.body();
			}
			obj.value = value;
		}

		if (isDefAndNotNull(field)) {
			this.createBody_(field, obj);
		} else {
			this.createBody_('and', []);
		}
	}

	/**
  * Composes the current filter with the given operator.
  * @param {string} operator
  * @param {Filter=} opt_filter Another filter to compose this filter with,
  *   if the operator is not unary.
  */


	createClass(FilterBody, [{
		key: 'add',
		value: function add(operator, opt_filter) {
			if (opt_filter) {
				this.addArrayOperator_(operator, opt_filter);
			} else {
				this.createBody_(operator, this.body_);
			}
		}

		/**
   * Composes the current filter with an operator that stores its values in an array.
   * @param {string} operator
   * @param {!Filter} filter
   * @protected
   */

	}, {
		key: 'addArrayOperator_',
		value: function addArrayOperator_(operator, filter) {
			if (!(this.body_[operator] instanceof Array)) {
				this.createBody_(operator, [this.body_]);
			}
			this.body_[operator].push(filter.body());
		}

		/**
   * Adds filters to be composed with this filter body using the given operator.
   * @param {string} operator
   * @param {...*} filters A variable amount of filters to be composed.
   */

	}, {
		key: 'addMany',
		value: function addMany(operator) {
			for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				filters[_key - 1] = arguments[_key];
			}

			for (var i = 0; i < filters.length; i++) {
				this.add(operator, filters[i]);
			}
		}

		/**
   * Creates a new body object, setting the requestd key to the given value.
   * @param {string} key The key to set in the new body object
   * @param {*} value The value the requested key should have in the new body object.
   * @protected
   */

	}, {
		key: 'createBody_',
		value: function createBody_(key, value) {
			this.body_ = {};
			this.body_[key] = value;
		}

		/**
   * Gets the json object that represents this filter's body.
   * @return {!Object}
   */

	}, {
		key: 'getObject',
		value: function getObject() {
			return this.body_;
		}
	}]);
	return FilterBody;
}();

/**
 * Class responsible for building different types of geometric
 * shapes.
 */

var Geo = function () {
	function Geo() {
		classCallCheck(this, Geo);
	}

	createClass(Geo, null, [{
		key: 'boundingBox',

		/**
   * Creates a new {@link BoundingBox} instance.
   * @param {*} upperLeft The upper left point.
   * @param {*} lowerRight The lower right point.
   * @return {!BoundingBox}
   * @static
   */
		value: function boundingBox(upperLeft, lowerRight) {
			return new Geo.BoundingBox(upperLeft, lowerRight);
		}

		/**
   * Creates a new {@link Circle} instance.
   * @param {*} center The circle's center coordinate.
   * @param {string} radius The circle's radius.
   * @return {!Circle}
   * @static
   */

	}, {
		key: 'circle',
		value: function circle(center, radius) {
			return new Geo.Circle(center, radius);
		}

		/**
   * Creates a new {@link Line} instance.
   * @param {...*} points This line's points.
   * @return {!Line}
   * @static
   */

	}, {
		key: 'line',
		value: function line() {
			for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
				points[_key] = arguments[_key];
			}

			return new (Function.prototype.bind.apply(Geo.Line, [null].concat(points)))();
		}

		/**
   * Creates a new {@link Point} instance.
   * @param {number} lat The latitude coordinate
   * @param {number} lon The longitude coordinate
   * @return {!Point}
   * @static
   */

	}, {
		key: 'point',
		value: function point(lat, lon) {
			return new Geo.Point(lat, lon);
		}

		/**
   * Creates a new {@link Polygon} instance.
   * @param {...*} points This polygon's points.
   * @return {!Polygon}
   * @static
   */

	}, {
		key: 'polygon',
		value: function polygon() {
			for (var _len2 = arguments.length, points = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				points[_key2] = arguments[_key2];
			}

			return new (Function.prototype.bind.apply(Geo.Polygon, [null].concat(points)))();
		}
	}]);
	return Geo;
}();

/**
 * Class that represents a point coordinate.
 * @extends {Embodied}
 */


var Point = function (_Embodied) {
	inherits(Point, _Embodied);

	/**
  * Constructs a {@link Point} instance.
  * @param {number} lat The latitude coordinate
  * @param {number} lon The longitude coordinate
  * @constructor
  */
	function Point(lat, lon) {
		classCallCheck(this, Point);

		var _this = possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this));

		_this.body_ = [lat, lon];
		return _this;
	}

	return Point;
}(Embodied);

Geo.Point = Point;

/**
 * Class that represents a line.
 * @extends {Embodied}
 */

var Line = function (_Embodied2) {
	inherits(Line, _Embodied2);

	/**
  * Constructs a {@link Line} instance.
  * @param {...*} points This line's points.
  * @constructor
  */
	function Line() {
		classCallCheck(this, Line);

		var _this2 = possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this));

		for (var _len3 = arguments.length, points = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
			points[_key3] = arguments[_key3];
		}

		_this2.body_ = {
			type: 'linestring',
			coordinates: points.map(function (point) {
				return Embodied.toBody(point);
			})
		};
		return _this2;
	}

	return Line;
}(Embodied);

Geo.Line = Line;

/**
 * Class that represents a bounding box.
 * @extends {Embodied}
 */

var BoundingBox = function (_Embodied3) {
	inherits(BoundingBox, _Embodied3);

	/**
  * Constructs a {@link BoundingBox} instance.
  * @param {*} upperLeft The upper left point.
  * @param {*} lowerRight The lower right point.
  * @constructor
  */
	function BoundingBox(upperLeft, lowerRight) {
		classCallCheck(this, BoundingBox);

		var _this3 = possibleConstructorReturn(this, (BoundingBox.__proto__ || Object.getPrototypeOf(BoundingBox)).call(this));

		_this3.body_ = {
			type: 'envelope',
			coordinates: [Embodied.toBody(upperLeft), Embodied.toBody(lowerRight)]
		};
		return _this3;
	}

	/**
  * Gets this bounding box's points.
  * @return {!Array}
  */


	createClass(BoundingBox, [{
		key: 'getPoints',
		value: function getPoints() {
			return this.body_.coordinates;
		}
	}]);
	return BoundingBox;
}(Embodied);

Geo.BoundingBox = BoundingBox;

/**
 * Class that represents a circle.
 * @extends {Embodied}
 */

var Circle = function (_Embodied4) {
	inherits(Circle, _Embodied4);

	/**
  * Constructs a {@link Circle} instance.
  * @param {*} center The circle's center coordinate.
  * @param {string} radius The circle's radius.
  * @constructor
  */
	function Circle(center, radius) {
		classCallCheck(this, Circle);

		var _this4 = possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this));

		_this4.body_ = {
			type: 'circle',
			coordinates: Embodied.toBody(center),
			radius: radius
		};
		return _this4;
	}

	/**
  * Gets this circle's center coordinate.
  * @return {*}
  */


	createClass(Circle, [{
		key: 'getCenter',
		value: function getCenter() {
			return this.body_.coordinates;
		}

		/**
   * Gets this circle's radius.
   * @return {string}
   */

	}, {
		key: 'getRadius',
		value: function getRadius() {
			return this.body_.radius;
		}
	}]);
	return Circle;
}(Embodied);

Geo.Circle = Circle;

/**
 * Class that represents a polygon.
 * @extends {Embodied}
 */

var Polygon = function (_Embodied5) {
	inherits(Polygon, _Embodied5);

	/**
  * Constructs a {@link Polygon} instance.
  * @param {...*} points This polygon's points.
  * @constructor
  */
	function Polygon() {
		classCallCheck(this, Polygon);

		var _this5 = possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this));

		_this5.body_ = {
			type: 'polygon',
			coordinates: []
		};
		_this5.addCoordinates_.apply(_this5, arguments);
		return _this5;
	}

	/**
  * Adds the given points as coordinates for this polygon.
  * @param {...*} points
  * @protected
  */


	createClass(Polygon, [{
		key: 'addCoordinates_',
		value: function addCoordinates_() {
			for (var _len4 = arguments.length, points = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
				points[_key4] = arguments[_key4];
			}

			this.body_.coordinates.push(points.map(function (point) {
				return Embodied.toBody(point);
			}));
		}

		/**
   * Adds the given points as a hole inside this polygon.
   * @param  {...*} points
   * @chainnable
   */

	}, {
		key: 'hole',
		value: function hole() {
			this.addCoordinates_.apply(this, arguments);
			return this;
		}
	}]);
	return Polygon;
}(Embodied);

Geo.Polygon = Polygon;

/**
 * Class responsible for building range objects to be used by `Filter`.
 * @extends {Embodied}
 */

var Range = function (_Embodied) {
	inherits(Range, _Embodied);

	/**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @param {*} opt_to
  * @constructor
  */
	function Range(from, opt_to) {
		classCallCheck(this, Range);

		var _this = possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this));

		if (isDefAndNotNull(from)) {
			_this.body_.from = from;
		}
		if (isDefAndNotNull(opt_to)) {
			_this.body_.to = opt_to;
		}
		return _this;
	}

	/**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @return {!Range}
  * @static
  */


	createClass(Range, null, [{
		key: 'from',
		value: function from(_from) {
			return new Range(_from);
		}

		/**
   * Constructs a {@link Range} instance.
   * @param {*} from
   * @param {*} to
   * @return {!Range}
   * @static
   */

	}, {
		key: 'range',
		value: function range(from, to) {
			return new Range(from, to);
		}

		/**
   * Constructs a {@link Range} instance.
   * @param {*} to
   * @return {!Range}
   * @static
   */

	}, {
		key: 'to',
		value: function to(_to) {
			return new Range(null, _to);
		}
	}]);
	return Range;
}(Embodied);

/**
 * Class responsible for building filters.
 * @extends {Embodied}
 */

var Filter = function (_Embodied) {
	inherits(Filter, _Embodied);

	/**
  * Constructs a {@link Filter} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
	function Filter(field, operatorOrValue, opt_value) {
		classCallCheck(this, Filter);

		var _this = possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).call(this));

		_this.body_ = new FilterBody(field, operatorOrValue, opt_value);
		return _this;
	}

	/**
  * Adds a filter to be composed with this filter using the given operator.
  * @param {string} operator
  * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
  *   name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @chainnable
  */


	createClass(Filter, [{
		key: 'add',
		value: function add(operator, fieldOrFilter, opt_operatorOrValue, opt_value) {
			var filter = fieldOrFilter ? Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) : null;
			this.body_.add(operator, filter);
			return this;
		}

		/**
   * Adds filters to be composed with this filter using the given operator.
   * @param {string} operator
   * @param {...*} filters A variable amount of filters to be composed.
   * @chainnable
   */

	}, {
		key: 'addMany',
		value: function addMany(operator) {
			var _body_;

			for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				filters[_key - 1] = arguments[_key];
			}

			(_body_ = this.body_).addMany.apply(_body_, [operator].concat(filters));
			return this;
		}

		/**
   * Adds a filter to be composed with this filter using the "and" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */

	}, {
		key: 'and',
		value: function and(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return this.add('and', fieldOrFilter, opt_operatorOrValue, opt_value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "any" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} values A variable amount of values to be used with
   *   the "none" operator. Can be passed either as a single array or as
   *   separate params.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'body',


		/**
   * Gets the json object that represents this filter.
   * @return {!Object}
   */
		value: function body() {
			return this.body_.getObject();
		}

		/**
   * Returns a {@link Filter} instance that uses the "gd" operator.
   * @param {string} field The field's name.
   * @param {*} locationOrCircle Either a `Geo.Circle` instance or a coordinate.
   * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
   *   the distance value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'or',


		/**
   * Adds a filter to be composed with this filter using the "or" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   * the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */
		value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return this.add('or', fieldOrFilter, opt_operatorOrValue, opt_value);
		}

		/**
   * Converts the given arguments into a {@link Filter} instance.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   * the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @return {!Filter}
   */

	}], [{
		key: 'any',
		value: function any(field) {
			var values = Array.prototype.slice.call(arguments, 1);
			if (values.length === 1 && values[0] instanceof Array) {
				values = values[0];
			}
			return new Filter(field, 'any', values);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gp" operator.
   * This is a special use case of `Filter.polygon` for bounding
   * boxes.
   * @param {string} field The field's name.
   * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or
   *   a bounding box's upper left coordinate.
   * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'boundingBox',
		value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
			if (boxOrUpperLeft instanceof Geo.BoundingBox) {
				return Filter.polygon.apply(Filter, [field].concat(toConsumableArray(boxOrUpperLeft.getPoints())));
			} else {
				return Filter.polygon(field, boxOrUpperLeft, opt_lowerRight);
			}
		}
	}, {
		key: 'distance',
		value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
			var location = locationOrCircle;
			var range = opt_rangeOrDistance;
			if (locationOrCircle instanceof Geo.Circle) {
				location = locationOrCircle.getCenter();
				range = Range.to(locationOrCircle.getRadius());
			} else if (!(opt_rangeOrDistance instanceof Range)) {
				range = Range.to(opt_rangeOrDistance);
			}
			return Filter.distanceInternal_(field, location, range);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gd" operator. This
   * is just an internal helper used by `Filter.distance`.
   * @param {string} field The field's name.
   * @param {*} location A location coordinate.
   * @param {Range} range A `Range` instance.
   * @return {!Filter}
   * @protected
   * @static
   */

	}, {
		key: 'distanceInternal_',
		value: function distanceInternal_(field, location, range) {
			var value = {
				location: Embodied.toBody(location)
			};
			range = range.body();
			if (range.from) {
				value.min = range.from;
			}
			if (range.to) {
				value.max = range.to;
			}
			return Filter.field(field, 'gd', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'equal',
		value: function equal(field, value) {
			return new Filter(field, '=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "exists" operator.
   * @param {string} field The field's name.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'exists',
		value: function exists(field) {
			return Filter.field(field, 'exists', null);
		}

		/**
   * Returns a {@link Filter} instance that uses the "fuzzy" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
   *   be the query, otherwise it should be the fuzziness value.
   * @param {number=} opt_fuzziness The fuzziness value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'fuzzy',
		value: function fuzzy(fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
			return Filter.fuzzyInternal_('fuzzy', fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness);
		}

		/**
   * Returns a {@link Filter} instance that uses the given fuzzy operator. This
   * is an internal implementation used by the `Filter.fuzzy` method.
   * @param {string} operator The fuzzy operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
   *   be the query, otherwise it should be the fuzziness value.
   * @param {number=} opt_fuzziness The fuzziness value.
   * @return {!Filter}
   * @protected
   * @static
   */

	}, {
		key: 'fuzzyInternal_',
		value: function fuzzyInternal_(operator, fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
			var arg2IsString = isString(opt_queryOrFuzziness);

			var value = {
				query: arg2IsString ? opt_queryOrFuzziness : fieldOrQuery
			};
			var fuzziness = arg2IsString ? opt_fuzziness : opt_queryOrFuzziness;
			if (fuzziness) {
				value.fuzziness = fuzziness;
			}

			var field = arg2IsString ? fieldOrQuery : Filter.ALL;
			return Filter.field(field, operator, value);
		}

		/**
   * Returns a {@link Filter} instance that uses the ">" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'gt',
		value: function gt(field, value) {
			return new Filter(field, '>', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the ">=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'gte',
		value: function gte(field, value) {
			return new Filter(field, '>=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "match" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'match',
		value: function match(fieldOrQuery, opt_query) {
			var field = isString(opt_query) ? fieldOrQuery : Filter.ALL;
			var query = isString(opt_query) ? opt_query : fieldOrQuery;
			return Filter.field(field, 'match', query);
		}

		/**
   * Returns a {@link Filter} instance that uses the "missing" operator.
   * @param {string} field The field's name.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'missing',
		value: function missing(field) {
			return Filter.field(field, 'missing', null);
		}

		/**
   * Returns a {@link Filter} instance that uses the "phrase" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'phrase',
		value: function phrase(fieldOrQuery, opt_query) {
			var field = isString(opt_query) ? fieldOrQuery : Filter.ALL;
			var query = isString(opt_query) ? opt_query : fieldOrQuery;
			return Filter.field(field, 'phrase', query);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gp" operator.
   * @param {string} field The name of the field.
   * @param {...!Object} points Objects representing points in the polygon.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'polygon',
		value: function polygon(field) {
			for (var _len2 = arguments.length, points = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				points[_key2 - 1] = arguments[_key2];
			}

			points = points.map(function (point) {
				return Embodied.toBody(point);
			});
			return Filter.field(field, 'gp', points);
		}

		/**
   * Returns a {@link Filter} instance that uses the "prefix" operator.
   * @param {string} fieldOrQuery If no second argument is given, this should
   *   be the query string, in which case all fields will be matched. Otherwise,
   *   this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'prefix',
		value: function prefix(fieldOrQuery, opt_query) {
			var field = opt_query ? fieldOrQuery : Filter.ALL;
			var query = opt_query ? opt_query : fieldOrQuery;
			return Filter.field(field, 'prefix', query);
		}

		/**
   * Returns a {@link Filter} instance that uses the "range" operator.
   * @param {string} field The field's name.
   * @param {*} rangeOrMin Either a `Range` instance or a the range's min value.
   * @param {*=} opt_max The range's max value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'range',
		value: function range(field, rangeOrMin, opt_max) {
			var range = rangeOrMin;
			if (!(range instanceof Range)) {
				range = Range.range(rangeOrMin, opt_max);
			}
			return Filter.field(field, 'range', range);
		}

		/**
   * Returns a {@link Filter} instance that uses the "~" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'regex',
		value: function regex(field, value) {
			return new Filter(field, '~', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gs" operator.
   * @param {string} field The field's name.
   * @param {...!Object} shapes Objects representing shapes.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'shape',
		value: function shape(field) {
			for (var _len3 = arguments.length, shapes = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
				shapes[_key3 - 1] = arguments[_key3];
			}

			shapes = shapes.map(function (shape) {
				return Embodied.toBody(shape);
			});
			var value = {
				type: 'geometrycollection',
				geometries: shapes
			};
			return Filter.field(field, 'gs', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "similar" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {?string} query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'similar',
		value: function similar(fieldOrQuery, query) {
			var field = isString(query) ? fieldOrQuery : Filter.ALL;
			var value = {
				query: isString(query) ? query : fieldOrQuery
			};
			return Filter.field(field, 'similar', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "<" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lt',
		value: function lt(field, value) {
			return new Filter(field, '<', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "<=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lte',
		value: function lte(field, value) {
			return new Filter(field, '<=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "none" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} value A variable amount of values to be used with
   * the "none" operator. Can be passed either as a single array or as
   * separate params.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'none',
		value: function none(field) {
			var values = Array.prototype.slice.call(arguments, 1);
			if (values.length === 1 && values[0] instanceof Array) {
				values = values[0];
			}
			return new Filter(field, 'none', values);
		}

		/**
   * Returns a {@link Filter} instance that uses the "!=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'notEqual',
		value: function notEqual(field, value) {
			return new Filter(field, '!=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "not" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   * the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'not',
		value: function not(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value).add('not');
		}

		/**
   * Returns a {@link Filter} instance.
   * @param {string} field The name of the field to filter by.
   * @param {*} operatorOrValue If a third param is given, this should be the
   * filter's operator (like ">="). Otherwise, this will be used as the
   * filter's value, and the filter's operator will be "=".
   * @param {*=} opt_value The filter's value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'field',
		value: function field(_field, operatorOrValue, opt_value) {
			return new Filter(_field, operatorOrValue, opt_value);
		}
	}, {
		key: 'toFilter',
		value: function toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) {
			var filter = fieldOrFilter;
			if (!(filter instanceof Filter)) {
				filter = Filter.field(fieldOrFilter, opt_operatorOrValue, opt_value);
			}
			return filter;
		}
	}]);
	return Filter;
}(Embodied);

/**
 * String constant that represents all fields.
 * @type {string}
 * @static
 */


Filter.ALL = '*';

/**
 * Parses the given uri string into an object.
 * @param {*=} opt_uri Optional string URI to parse
 */

function parseFromAnchor(opt_uri) {
	var link = document.createElement('a');
	link.href = opt_uri;
	return {
		hash: link.hash,
		hostname: link.hostname,
		password: link.password,
		pathname: link.pathname[0] === '/' ? link.pathname : '/' + link.pathname,
		port: link.port,
		protocol: link.protocol,
		search: link.search,
		username: link.username
	};
}

/**
 * Parses the given uri string into an object. The URL function will be used
 * when present, otherwise we'll fall back to the anchor node element.
 * @param {*=} opt_uri Optional string URI to parse
 */
function parse(opt_uri) {
	if (isFunction(URL) && URL.length) {
		return new URL(opt_uri);
	} else {
		return parseFromAnchor(opt_uri);
	}
}

/**
 * A cached reference to the create function.
 */
var create$1 = Object.create;

/**
 * Case insensitive string Multimap implementation. Allows multiple values for
 * the same key name.
 * @extends {Disposable}
 */

var MultiMap = function (_Disposable) {
	inherits(MultiMap, _Disposable);

	function MultiMap() {
		classCallCheck(this, MultiMap);

		var _this = possibleConstructorReturn(this, (MultiMap.__proto__ || Object.getPrototypeOf(MultiMap)).call(this));

		_this.keys = create$1(null);
		_this.values = create$1(null);
		return _this;
	}

	/**
  * Adds value to a key name.
  * @param {string} name
  * @param {*} value
  * @chainable
  */


	createClass(MultiMap, [{
		key: 'add',
		value: function add(name, value) {
			this.keys[name.toLowerCase()] = name;
			this.values[name.toLowerCase()] = this.values[name.toLowerCase()] || [];
			this.values[name.toLowerCase()].push(value);
			return this;
		}

		/**
   * Clears map names and values.
   * @chainable
   */

	}, {
		key: 'clear',
		value: function clear() {
			this.keys = create$1(null);
			this.values = create$1(null);
			return this;
		}

		/**
   * Checks if map contains a value to the key name.
   * @param {string} name
   * @return {boolean}
   * @chainable
   */

	}, {
		key: 'contains',
		value: function contains(name) {
			return name.toLowerCase() in this.values;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.values = null;
		}

		/**
   * Creates a `MultiMap` instance from the given object.
   * @param {!Object} obj
   * @return {!MultiMap}
   */

	}, {
		key: 'get',


		/**
   * Gets the first added value from a key name.
   * @param {string} name
   * @return {*}
   * @chainable
   */
		value: function get(name) {
			var values = this.values[name.toLowerCase()];
			if (values) {
				return values[0];
			}
		}

		/**
   * Gets all values from a key name.
   * @param {string} name
   * @return {Array.<*>}
   */

	}, {
		key: 'getAll',
		value: function getAll(name) {
			return this.values[name.toLowerCase()];
		}

		/**
   * Returns true if the map is empty, false otherwise.
   * @return {boolean}
   */

	}, {
		key: 'isEmpty',
		value: function isEmpty() {
			return this.size() === 0;
		}

		/**
   * Gets array of key names.
   * @return {Array.<string>}
   */

	}, {
		key: 'names',
		value: function names() {
			var _this2 = this;

			return Object.keys(this.values).map(function (key) {
				return _this2.keys[key];
			});
		}

		/**
   * Removes all values from a key name.
   * @param {string} name
   * @chainable
   */

	}, {
		key: 'remove',
		value: function remove(name) {
			delete this.keys[name.toLowerCase()];
			delete this.values[name.toLowerCase()];
			return this;
		}

		/**
   * Sets the value of a key name. Relevant to replace the current values with
   * a new one.
   * @param {string} name
   * @param {*} value
   * @chainable
   */

	}, {
		key: 'set',
		value: function set(name, value) {
			this.keys[name.toLowerCase()] = name;
			this.values[name.toLowerCase()] = [value];
			return this;
		}

		/**
   * Gets the size of the map key names.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			return this.names().length;
		}

		/**
   * Returns the parsed values as a string.
   * @return {string}
   */

	}, {
		key: 'toString',
		value: function toString() {
			return JSON.stringify(this.values);
		}
	}], [{
		key: 'fromObject',
		value: function fromObject(obj) {
			var map = new MultiMap();
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				map.set(keys[i], obj[keys[i]]);
			}
			return map;
		}
	}]);
	return MultiMap;
}(Disposable);

/**
 * Generic tree node data structure with arbitrary number of child nodes.
 * @param {V} value Value.
 * @constructor
 */

var TreeNode = function () {
	function TreeNode(value) {
		classCallCheck(this, TreeNode);

		/**
   * The value.
   * @private {V}
   */
		this.value_ = value;

		/**
   * Reference to the parent node or null if it has no parent.
   * @private {TreeNode}
   */
		this.parent_ = null;

		/**
   * Child nodes or null in case of leaf node.
   * @private {Array<!TreeNode>}
   */
		this.children_ = null;
	}

	/**
  * Appends a child node to this node.
  * @param {!TreeNode} child Orphan child node.
  */


	createClass(TreeNode, [{
		key: 'addChild',
		value: function addChild(child) {
			assertChildHasNoParent(child);
			child.setParent(this);
			this.children_ = this.children_ || [];
			this.children_.push(child);
		}

		/**
   * Tells whether this node is the ancestor of the given node.
   * @param {!TreeNode} node A node.
   * @return {boolean} Whether this node is the ancestor of {@code node}.
   */

	}, {
		key: 'contains',
		value: function contains(node) {
			var current = node.getParent();
			while (current) {
				if (current === this) {
					return true;
				}
				current = current.getParent();
			}
			return false;
		}

		/**
   * @return {!Array<TreeNode>} All ancestor nodes in bottom-up order.
   */

	}, {
		key: 'getAncestors',
		value: function getAncestors() {
			var ancestors = [];
			var node = this.getParent();
			while (node) {
				ancestors.push(node);
				node = node.getParent();
			}
			return ancestors;
		}

		/**
   * Gets the child node of this node at the given index.
   * @param {number} index Child index.
   * @return {?TreeNode} The node at the given index
   * or null if not found.
   */

	}, {
		key: 'getChildAt',
		value: function getChildAt(index) {
			return this.getChildren()[index] || null;
		}

		/**
   * @return {?Array<!TreeNode>} Child nodes or null in case of leaf node.
   */

	}, {
		key: 'getChildren',
		value: function getChildren() {
			return this.children_ || TreeNode.EMPTY_ARRAY;
		}

		/**
   * @return {number} The number of children.
   */

	}, {
		key: 'getChildCount',
		value: function getChildCount() {
			return this.getChildren().length;
		}

		/**
   * @return {number} The number of ancestors of the node.
   */

	}, {
		key: 'getDepth',
		value: function getDepth() {
			var depth = 0;
			var node = this;
			while (node.getParent()) {
				depth++;
				node = node.getParent();
			}
			return depth;
		}

		/**
   * @return {?TreeNode} Parent node or null if it has no parent.
   */

	}, {
		key: 'getParent',
		value: function getParent() {
			return this.parent_;
		}

		/**
   * @return {!TreeNode} The root of the tree structure, i.e. the farthest
   * ancestor of the node or the node itself if it has no parents.
   */

	}, {
		key: 'getRoot',
		value: function getRoot() {
			var root = this;
			while (root.getParent()) {
				root = root.getParent();
			}
			return root;
		}

		/**
   * Gets the value.
   * @return {V} The value.
   */

	}, {
		key: 'getValue',
		value: function getValue() {
			return this.value_;
		}

		/**
   * @return {boolean} Whether the node is a leaf node.
   */

	}, {
		key: 'isLeaf',
		value: function isLeaf() {
			return !this.getChildCount();
		}

		/**
   * Removes the given child node of this node.
   * @param {TreeNode} child The node to remove.
   * @return {TreeNode} The removed node if any, null otherwise.
   */

	}, {
		key: 'removeChild',
		value: function removeChild(child) {
			if (array.remove(this.getChildren(), child)) {
				return child;
			}
			return null;
		}

		/**
   * Sets the parent node of this node. The callers must ensure that the
   * parent node and only that has this node among its children.
   * @param {TreeNode} parent The parent to set. If null, the node will be
   * detached from the tree.
   * @protected
   */

	}, {
		key: 'setParent',
		value: function setParent(parent) {
			this.parent_ = parent;
		}

		/**
   * Traverses the subtree. The first callback starts with this node,
   * and visits the descendant nodes depth-first, in preorder.
   * The second callback, starts with deepest child then visits
   * the ancestor nodes depth-first, in postorder. E.g.
   *
   *  	 A
   *    / \
   *   B   C
   *  /   / \
   * D   E   F
   *
   * preorder -> ['A', 'B', 'D', 'C', 'E', 'F']
   * postorder -> ['D', 'B', 'E', 'F', 'C', 'A']
   *
   * @param {function=} opt_preorderFn The callback to execute when visiting a node.
   * @param {function=} opt_postorderFn The callback to execute before leaving a node.
   */

	}, {
		key: 'traverse',
		value: function traverse(opt_preorderFn, opt_postorderFn) {
			if (opt_preorderFn) {
				opt_preorderFn(this);
			}
			this.getChildren().forEach(function (child) {
				return child.traverse(opt_preorderFn, opt_postorderFn);
			});
			if (opt_postorderFn) {
				opt_postorderFn(this);
			}
		}
	}]);
	return TreeNode;
}();

/**
 * Constant for empty array to avoid unnecessary allocations.
 * @private
 */


TreeNode.EMPTY_ARRAY = [];

/**
 * Asserts that child has no parent.
 * @param {TreeNode} child A child.
 * @private
 */
var assertChildHasNoParent = function assertChildHasNoParent(child) {
	if (child.getParent()) {
		throw new Error('Cannot add child with parent.');
	}
};

var parseFn_ = parse;

var Uri = function () {

	/**
  * This class contains setters and getters for the parts of the URI.
  * The following figure displays an example URIs and their component parts.
  *
  *                                  path
  *	                             
  *	  abc://example.com:123/path/data?key=value#fragid1
  *	                  
  * protocol  hostname  port            search    hash
  *          
  *                host
  *
  * @param {*=} opt_uri Optional string URI to parse
  * @constructor
  */
	function Uri() {
		var opt_uri = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
		classCallCheck(this, Uri);

		this.url = Uri.parse(this.maybeAddProtocolAndHostname_(opt_uri));
	}

	/**
  * Adds parameters to uri from a <code>MultiMap</code> as source.
  * @param {MultiMap} multimap The <code>MultiMap</code> containing the
  *   parameters.
  * @protected
  * @chainable
  */


	createClass(Uri, [{
		key: 'addParametersFromMultiMap',
		value: function addParametersFromMultiMap(multimap) {
			var _this = this;

			multimap.names().forEach(function (name) {
				multimap.getAll(name).forEach(function (value) {
					_this.addParameterValue(name, value);
				});
			});
			return this;
		}

		/**
   * Adds the value of the named query parameters.
   * @param {string} key The parameter to set.
   * @param {*} value The new value. Will be explicitly casted to String.
   * @chainable
   */

	}, {
		key: 'addParameterValue',
		value: function addParameterValue(name, value) {
			this.ensureQueryInitialized_();
			if (isDef(value)) {
				value = String(value);
			}
			this.query.add(name, value);
			return this;
		}

		/**
   * Adds the values of the named query parameter.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'addParameterValues',
		value: function addParameterValues(name, values) {
			var _this2 = this;

			values.forEach(function (value) {
				return _this2.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Ensures query internal map is initialized and synced with initial value
   * extracted from URI search part.
   * @protected
   */

	}, {
		key: 'ensureQueryInitialized_',
		value: function ensureQueryInitialized_() {
			var _this3 = this;

			if (this.query) {
				return;
			}
			this.query = new MultiMap();
			var search = this.url.search;
			if (search) {
				search.substring(1).split('&').forEach(function (param) {
					var _param$split = param.split('=');

					var _param$split2 = slicedToArray(_param$split, 2);

					var key = _param$split2[0];
					var value = _param$split2[1];

					if (isDef(value)) {
						value = Uri.urlDecode(value);
					}
					_this3.addParameterValue(key, value);
				});
			}
		}

		/**
   * Gets the hash part of uri.
   * @return {string}
   */

	}, {
		key: 'getHash',
		value: function getHash() {
			return this.url.hash || '';
		}

		/**
   * Gets the host part of uri. E.g. <code>[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getHost',
		value: function getHost() {
			var host = this.getHostname();
			if (host) {
				var port = this.getPort();
				if (port && port !== '80') {
					host += ':' + port;
				}
			}
			return host;
		}

		/**
   * Gets the hostname part of uri without protocol and port.
   * @return {string}
   */

	}, {
		key: 'getHostname',
		value: function getHostname() {
			var hostname = this.url.hostname;
			if (hostname === Uri.HOSTNAME_PLACEHOLDER) {
				return '';
			}
			return hostname;
		}

		/**
   * Gets the origin part of uri. E.g. <code>http://[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getOrigin',
		value: function getOrigin() {
			var host = this.getHost();
			if (host) {
				return this.getProtocol() + '//' + host;
			}
			return '';
		}

		/**
   * Returns the first value for a given parameter or undefined if the given
   * parameter name does not appear in the query string.
   * @param {string} paramName Unescaped parameter name.
   * @return {string|undefined} The first value for a given parameter or
   *   undefined if the given parameter name does not appear in the query
   *   string.
   */

	}, {
		key: 'getParameterValue',
		value: function getParameterValue(name) {
			this.ensureQueryInitialized_();
			return this.query.get(name);
		}

		/**
   * Returns the value<b>s</b> for a given parameter as a list of decoded
   * query parameter values.
   * @param {string} name The parameter to get values for.
   * @return {!Array<?>} The values for a given parameter as a list of decoded
   *   query parameter values.
   */

	}, {
		key: 'getParameterValues',
		value: function getParameterValues(name) {
			this.ensureQueryInitialized_();
			return this.query.getAll(name);
		}

		/**
   * Returns the name<b>s</b> of the parameters.
   * @return {!Array<string>} The names for the parameters as a list of
   *   strings.
   */

	}, {
		key: 'getParameterNames',
		value: function getParameterNames() {
			this.ensureQueryInitialized_();
			return this.query.names();
		}

		/**
   * Gets the function currently being used to parse URIs.
   * @return {!function()}
   */

	}, {
		key: 'getPathname',


		/**
   * Gets the pathname part of uri.
   * @return {string}
   */
		value: function getPathname() {
			return this.url.pathname;
		}

		/**
   * Gets the port number part of uri as string.
   * @return {string}
   */

	}, {
		key: 'getPort',
		value: function getPort() {
			return this.url.port;
		}

		/**
   * Gets the protocol part of uri. E.g. <code>http:</code>.
   * @return {string}
   */

	}, {
		key: 'getProtocol',
		value: function getProtocol() {
			return this.url.protocol;
		}

		/**
   * Gets the search part of uri. Search value is retrieved from query
   * parameters.
   * @return {string}
   */

	}, {
		key: 'getSearch',
		value: function getSearch() {
			var _this4 = this;

			var search = '';
			var querystring = '';
			this.getParameterNames().forEach(function (name) {
				_this4.getParameterValues(name).forEach(function (value) {
					querystring += name;
					if (isDef(value)) {
						querystring += '=' + encodeURIComponent(value);
					}
					querystring += '&';
				});
			});
			querystring = querystring.slice(0, -1);
			if (querystring) {
				search += '?' + querystring;
			}
			return search;
		}

		/**
   * Checks if uri contains the parameter.
   * @param {string} name
   * @return {boolean}
   */

	}, {
		key: 'hasParameter',
		value: function hasParameter(name) {
			this.ensureQueryInitialized_();
			return this.query.contains(name);
		}

		/**
   * Makes this URL unique by adding a random param to it. Useful for avoiding
   * cache.
   */

	}, {
		key: 'makeUnique',
		value: function makeUnique() {
			this.setParameterValue(Uri.RANDOM_PARAM, string.getRandomString());
			return this;
		}

		/**
   * Maybe adds protocol and a hostname placeholder on a parial URI if needed.
   * Relevent for compatibility with <code>URL</code> native object.
   * @param {string=} opt_uri
   * @return {string} URI with protocol and hostname placeholder.
   */

	}, {
		key: 'maybeAddProtocolAndHostname_',
		value: function maybeAddProtocolAndHostname_(opt_uri) {
			var url = opt_uri;
			if (opt_uri.indexOf('://') === -1 && opt_uri.indexOf('javascript:') !== 0) {
				// jshint ignore:line

				url = Uri.DEFAULT_PROTOCOL;
				if (opt_uri[0] !== '/' || opt_uri[1] !== '/') {
					url += '//';
				}

				switch (opt_uri.charAt(0)) {
					case '.':
					case '?':
					case '#':
						url += Uri.HOSTNAME_PLACEHOLDER;
						url += '/';
						url += opt_uri;
						break;
					case '':
					case '/':
						if (opt_uri[1] !== '/') {
							url += Uri.HOSTNAME_PLACEHOLDER;
						}
						url += opt_uri;
						break;
					default:
						url += opt_uri;
				}
			}
			return url;
		}

		/**
   * Normalizes the parsed object to be in the expected standard.
   * @param {!Object}
   */

	}, {
		key: 'removeParameter',


		/**
   * Removes the named query parameter.
   * @param {string} name The parameter to remove.
   * @chainable
   */
		value: function removeParameter(name) {
			this.ensureQueryInitialized_();
			this.query.remove(name);
			return this;
		}

		/**
   * Removes uniqueness parameter of the uri.
   * @chainable
   */

	}, {
		key: 'removeUnique',
		value: function removeUnique() {
			this.removeParameter(Uri.RANDOM_PARAM);
			return this;
		}

		/**
   * Sets the hash.
   * @param {string} hash
   * @chainable
   */

	}, {
		key: 'setHash',
		value: function setHash(hash) {
			this.url.hash = hash;
			return this;
		}

		/**
   * Sets the hostname.
   * @param {string} hostname
   * @chainable
   */

	}, {
		key: 'setHostname',
		value: function setHostname(hostname) {
			this.url.hostname = hostname;
			return this;
		}

		/**
   * Sets the value of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValue',
		value: function setParameterValue(name, value) {
			this.removeParameter(name);
			this.addParameterValue(name, value);
			return this;
		}

		/**
   * Sets the values of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValues',
		value: function setParameterValues(name, values) {
			var _this5 = this;

			this.removeParameter(name);
			values.forEach(function (value) {
				return _this5.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Sets the pathname.
   * @param {string} pathname
   * @chainable
   */

	}, {
		key: 'setPathname',
		value: function setPathname(pathname) {
			this.url.pathname = pathname;
			return this;
		}

		/**
   * Sets the port number.
   * @param {*} port Port number.
   * @chainable
   */

	}, {
		key: 'setPort',
		value: function setPort(port) {
			this.url.port = port;
			return this;
		}

		/**
   * Sets the function that will be used for parsing the original string uri
   * into an object.
   * @param {!function()} parseFn
   */

	}, {
		key: 'setProtocol',


		/**
   * Sets the protocol. If missing <code>http:</code> is used as default.
   * @param {string} protocol
   * @chainable
   */
		value: function setProtocol(protocol) {
			this.url.protocol = protocol;
			if (this.url.protocol[this.url.protocol.length - 1] !== ':') {
				this.url.protocol += ':';
			}
			return this;
		}

		/**
   * @return {string} The string form of the url.
   * @override
   */

	}, {
		key: 'toString',
		value: function toString() {
			var href = '';
			var host = this.getHost();
			if (host) {
				href += this.getProtocol() + '//';
			}
			href += host + this.getPathname() + this.getSearch() + this.getHash();
			return href;
		}

		/**
   * Joins the given paths.
   * @param {string} basePath
   * @param {...string} ...paths Any number of paths to be joined with the base url.
   * @static
   */

	}], [{
		key: 'getParseFn',
		value: function getParseFn() {
			return parseFn_;
		}
	}, {
		key: 'normalizeObject',
		value: function normalizeObject(parsed) {
			var length = parsed.pathname ? parsed.pathname.length : 0;
			if (length > 1 && parsed.pathname[length - 1] === '/') {
				parsed.pathname = parsed.pathname.substr(0, length - 1);
			}
			return parsed;
		}

		/**
   * Parses the given uri string into an object.
   * @param {*=} opt_uri Optional string URI to parse
   */

	}, {
		key: 'parse',
		value: function parse(opt_uri) {
			return Uri.normalizeObject(parseFn_(opt_uri));
		}
	}, {
		key: 'setParseFn',
		value: function setParseFn(parseFn) {
			parseFn_ = parseFn;
		}
	}, {
		key: 'joinPaths',
		value: function joinPaths(basePath) {
			for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				paths[_key - 1] = arguments[_key];
			}

			if (basePath.charAt(basePath.length - 1) === '/') {
				basePath = basePath.substring(0, basePath.length - 1);
			}
			paths = paths.map(function (path) {
				return path.charAt(0) === '/' ? path.substring(1) : path;
			});
			return [basePath].concat(paths).join('/').replace(/\/$/, '');
		}

		/**
   * URL-decodes the string. We need to specially handle '+'s because
   * the javascript library doesn't convert them to spaces.
   * @param {string} str The string to url decode.
   * @return {string} The decoded {@code str}.
   */

	}, {
		key: 'urlDecode',
		value: function urlDecode(str) {
			return decodeURIComponent(str.replace(/\+/g, ' '));
		}
	}]);
	return Uri;
}();

/**
 * Default protocol value.
 * @type {string}
 * @default http:
 * @static
 */


Uri.DEFAULT_PROTOCOL = 'http:';

/**
 * Hostname placeholder. Relevant to internal usage only.
 * @type {string}
 * @static
 */
Uri.HOSTNAME_PLACEHOLDER = 'hostname' + Date.now();

/**
 * Name used by the param generated by `makeUnique`.
 * @type {string}
 * @static
 */
Uri.RANDOM_PARAM = 'zx';

function assertBrowserEnvironment() {
	if (!globals.window) {
		throw new Error('Sign-in type not supported in this environment');
	}
}

function assertDefAndNotNull(value, errorMessage) {
	if (!isDefAndNotNull(value)) {
		throw new Error(errorMessage);
	}
}

function assertFunction(value, errorMessage) {
	if (!isFunction(value)) {
		throw new Error(errorMessage);
	}
}

function assertObject(value, errorMessage) {
	if (!isObject(value)) {
		throw new Error(errorMessage);
	}
}

function assertResponseSucceeded(response) {
	if (!response.succeeded()) {
		throw response.body();
	}
	return response;
}

function assertUserSignedIn(user) {
	if (!isDefAndNotNull(user)) {
		throw new Error('You must be signed-in to perform this operation');
	}
}

function assertUriWithNoPath(url, message) {
	var uri = new Uri(url);
	if (uri.getPathname().length > 1) {
		throw new Error(message);
	}
}

/**
 * Class responsible for storing authorization information.
 */

var Auth = function () {
	/**
  * Constructs an {@link Auth} instance.
  * @param {string} tokenOrEmail Either the authorization token, or
  *   the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @constructor
  */
	function Auth(tokenOrEmail) {
		var opt_password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
		classCallCheck(this, Auth);

		this.token = isString(opt_password) ? null : tokenOrEmail;
		this.email = isString(opt_password) ? tokenOrEmail : null;
		this.password = opt_password;

		this.createdAt = null;
		this.id = null;
		this.name = null;
		this.photoUrl = null;
		this.wedeployClient = null;
	}

	/**
  * Constructs an {@link Auth} instance.
  * @param {string} tokenOrUsername Either the authorization token, or
  *   the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @return {!Auth}
  */


	createClass(Auth, [{
		key: 'getCreatedAt',


		/**
   * Gets the created at date.
   * @return {string}
   */
		value: function getCreatedAt() {
			return this.createdAt;
		}

		/**
   * Gets the email.
   * @return {string}
   */

	}, {
		key: 'getEmail',
		value: function getEmail() {
			return this.email;
		}

		/**
   * Gets the id.
   * @return {string}
   */

	}, {
		key: 'getId',
		value: function getId() {
			return this.id;
		}

		/**
   * Gets the name.
   * @return {string}
   */

	}, {
		key: 'getName',
		value: function getName() {
			return this.name;
		}

		/**
   * Gets the password.
   * @return {string}
   */

	}, {
		key: 'getPassword',
		value: function getPassword() {
			return this.password;
		}

		/**
   * Gets the photo url.
   * @return {string}
   */

	}, {
		key: 'getPhotoUrl',
		value: function getPhotoUrl() {
			return this.photoUrl;
		}

		/**
   * Gets the token.
   * @return {string}
   */

	}, {
		key: 'getToken',
		value: function getToken() {
			return this.token;
		}

		/**
   * Checks if created at is set.
   * @return {boolean}
   */

	}, {
		key: 'hasCreatedAt',
		value: function hasCreatedAt() {
			return isDefAndNotNull(this.createdAt);
		}

		/**
   * Checks if the email is set.
   * @return {boolean}
   */

	}, {
		key: 'hasEmail',
		value: function hasEmail() {
			return isDefAndNotNull(this.email);
		}

		/**
   * Checks if the id is set.
   * @return {boolean}
   */

	}, {
		key: 'hasId',
		value: function hasId() {
			return isDefAndNotNull(this.id);
		}

		/**
   * Checks if the name is set.
   * @return {boolean}
   */

	}, {
		key: 'hasName',
		value: function hasName() {
			return isDefAndNotNull(this.name);
		}

		/**
   * Checks if the password is set.
   * @return {boolean}
   */

	}, {
		key: 'hasPassword',
		value: function hasPassword() {
			return isDefAndNotNull(this.password);
		}

		/**
   * Checks if the photo url is set.
   * @return {boolean}
   */

	}, {
		key: 'hasPhotoUrl',
		value: function hasPhotoUrl() {
			return isDefAndNotNull(this.photoUrl);
		}

		/**
   * Checks if the token is set.
   * @return {boolean}
   */

	}, {
		key: 'hasToken',
		value: function hasToken() {
			return isDefAndNotNull(this.token);
		}

		/**
   * Sets created at.
   * @param {string} createdAt
   */

	}, {
		key: 'setCreatedAt',
		value: function setCreatedAt(createdAt) {
			this.createdAt = createdAt;
		}

		/**
   * Sets the email.
   * @param {string} email
   */

	}, {
		key: 'setEmail',
		value: function setEmail(email) {
			this.email = email;
		}

		/**
   * Sets the id.
   * @param {string} id
   */

	}, {
		key: 'setId',
		value: function setId(id) {
			this.id = id;
		}

		/**
   * Sets the name.
   * @param {string} name
   */

	}, {
		key: 'setName',
		value: function setName(name) {
			this.name = name;
		}

		/**
   * Sets the password.
   * @param {string} password
   */

	}, {
		key: 'setPassword',
		value: function setPassword(password) {
			this.password = password;
		}

		/**
   * Sets the photo url.
   * @param {string} photoUrl
   */

	}, {
		key: 'setPhotoUrl',
		value: function setPhotoUrl(photoUrl) {
			this.photoUrl = photoUrl;
		}

		/**
   * Sets the token.
   * @param {string} token
   */

	}, {
		key: 'setToken',
		value: function setToken(token) {
			this.token = token;
		}
	}, {
		key: 'setWedeployClient',
		value: function setWedeployClient(wedeployClient) {
			this.wedeployClient = wedeployClient;
		}

		/**
   * Updates the user.
   * @param {!object} data
   * @return {CompletableFuture}
   */

	}, {
		key: 'updateUser',
		value: function updateUser(data) {
			assertObject(data, 'User data must be specified as object');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users').auth(this).patch(data).then(function (response) {
				return assertResponseSucceeded(response);
			});
		}

		/**
   * Deletes the current user.
   * @return {CompletableFuture}
   */

	}, {
		key: 'deleteUser',
		value: function deleteUser() {
			assertDefAndNotNull(this.id, 'Cannot delete user without id');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users', this.id).auth(this).delete().then(function (response) {
				return assertResponseSucceeded(response);
			});
		}
	}], [{
		key: 'create',
		value: function create(tokenOrUsername, opt_password) {
			return new Auth(tokenOrUsername, opt_password);
		}
	}]);
	return Auth;
}();

var ApiHelper = function () {

	/**
  * Constructs an {@link ApiHelper} instance.
  * @constructor
  */
	function ApiHelper(wedeployClient) {
		classCallCheck(this, ApiHelper);

		assertDefAndNotNull(wedeployClient, 'WeDeploy client reference must be specified');
		this.wedeployClient = wedeployClient;
	}

	/**
  * Adds authorization information to this request.
  * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
  * an authorization token, or the email.
  * @param {string=} opt_password If a email is given as the first param,
  * this should be the password.
  * @chainable
  */


	createClass(ApiHelper, [{
		key: 'auth',
		value: function auth(authOrTokenOrEmail, opt_password) {
			this.helperAuthScope = authOrTokenOrEmail;
			if (!(this.helperAuthScope instanceof Auth)) {
				this.helperAuthScope = Auth.create(authOrTokenOrEmail, opt_password);
			}
			return this;
		}
	}]);
	return ApiHelper;
}();

/**
 * Class responsible for encapsulate provider information.
 */

var AuthProvider = function () {
	/**
  * Constructs an {@link AuthProvider} instance.
  * @constructor
  */
	function AuthProvider() {
		classCallCheck(this, AuthProvider);

		this.provider = null;
		this.providerScope = null;
		this.redirectUri = null;
		this.scope = null;
	}

	/**
  * Checks if provider is defined and not null.
  * @return {boolean}
  */


	createClass(AuthProvider, [{
		key: 'hasProvider',
		value: function hasProvider() {
			return isDefAndNotNull(this.provider);
		}

		/**
   * Checks if scope is defined and not null.
   * @return {boolean}
   */

	}, {
		key: 'hasProviderScope',
		value: function hasProviderScope() {
			return isDefAndNotNull(this.providerScope);
		}

		/**
   * Checks if redirect uri is defined and not null.
   * @return {boolean}
   */

	}, {
		key: 'hasRedirectUri',
		value: function hasRedirectUri() {
			return isDefAndNotNull(this.redirectUri);
		}

		/**
   * Checks if scope is defined and not null.
   * @return {boolean}
   */

	}, {
		key: 'hasScope',
		value: function hasScope() {
			return isDefAndNotNull(this.scope);
		}

		/**
   * Makes authorization url.
   * @return {string=} Authorization url.
   */

	}, {
		key: 'makeAuthorizationUrl',
		value: function makeAuthorizationUrl(opt_authUrl) {
			var uri = new Uri(opt_authUrl);

			uri.setPathname('/oauth/authorize');

			if (this.hasProvider()) {
				uri.setParameterValue('provider', this.getProvider());
			}
			if (this.hasProviderScope()) {
				uri.setParameterValue('provider_scope', this.getProviderScope());
			}
			if (this.hasRedirectUri()) {
				uri.setParameterValue('redirect_uri', this.getRedirectUri());
			}
			if (this.hasScope()) {
				uri.setParameterValue('scope', this.getScope());
			}

			return uri.toString();
		}

		/**
   * Gets provider name.
   * @return {string=} Provider name.
   */

	}, {
		key: 'getProvider',
		value: function getProvider() {
			return this.provider;
		}

		/**
   * Gets provider scope.
   * @return {string=} String with scopes.
   */

	}, {
		key: 'getProviderScope',
		value: function getProviderScope() {
			return this.providerScope;
		}

		/**
   * Gets redirect uri.
   * @return {string=}.
   */

	}, {
		key: 'getRedirectUri',
		value: function getRedirectUri() {
			return this.redirectUri;
		}

		/**
   * Gets scope.
   * @return {string=} String with scopes.
   */

	}, {
		key: 'getScope',
		value: function getScope() {
			return this.scope;
		}

		/**
   * Sets provider scope.
   * @param {string=} scope Scope string. Separate by space for multiple
   *   scopes, e.g. "scope1 scope2".
   */

	}, {
		key: 'setProviderScope',
		value: function setProviderScope(providerScope) {
			assertStringIfDefAndNotNull(providerScope, 'Provider scope must be a string');
			this.providerScope = providerScope;
		}

		/**
   * Sets redirect uri.
   * @param {string=} redirectUri.
   */

	}, {
		key: 'setRedirectUri',
		value: function setRedirectUri(redirectUri) {
			assertStringIfDefAndNotNull(redirectUri, 'Redirect uri must be a string');
			this.redirectUri = redirectUri;
		}

		/**
   * Sets scope.
   * @param {string=} scope Scope string. Separate by space for multiple
   *   scopes, e.g. "scope1 scope2".
   */

	}, {
		key: 'setScope',
		value: function setScope(scope) {
			assertStringIfDefAndNotNull(scope, 'Scope must be a string');
			this.scope = scope;
		}
	}]);
	return AuthProvider;
}();

function assertStringIfDefAndNotNull(value, errorMessage) {
	if (isDefAndNotNull(value) && !isString(value)) {
		throw new Error(errorMessage);
	}
}

/**
 * Facebook auth provider implementation.
 */

var FacebookAuthProvider = function (_AuthProvider) {
	inherits(FacebookAuthProvider, _AuthProvider);

	/**
  * Constructs an {@link FacebookAuthProvider} instance.
  * @constructor
  */
	function FacebookAuthProvider() {
		classCallCheck(this, FacebookAuthProvider);

		var _this = possibleConstructorReturn(this, (FacebookAuthProvider.__proto__ || Object.getPrototypeOf(FacebookAuthProvider)).call(this));

		_this.provider = FacebookAuthProvider.PROVIDER;
		return _this;
	}

	return FacebookAuthProvider;
}(AuthProvider);

FacebookAuthProvider.PROVIDER = 'facebook';

/**
 * Github auth provider implementation.
 */

var GithubAuthProvider = function (_AuthProvider) {
	inherits(GithubAuthProvider, _AuthProvider);

	/**
  * Constructs an {@link GithubAuthProvider} instance.
  * @constructor
  */
	function GithubAuthProvider() {
		classCallCheck(this, GithubAuthProvider);

		var _this = possibleConstructorReturn(this, (GithubAuthProvider.__proto__ || Object.getPrototypeOf(GithubAuthProvider)).call(this));

		_this.provider = GithubAuthProvider.PROVIDER;
		return _this;
	}

	return GithubAuthProvider;
}(AuthProvider);

GithubAuthProvider.PROVIDER = 'github';

/**
 * Google auth provider implementation.
 */

var GoogleAuthProvider = function (_AuthProvider) {
	inherits(GoogleAuthProvider, _AuthProvider);

	/**
  * Constructs an {@link GoogleAuthProvider} instance.
  * @constructor
  */
	function GoogleAuthProvider() {
		classCallCheck(this, GoogleAuthProvider);

		var _this = possibleConstructorReturn(this, (GoogleAuthProvider.__proto__ || Object.getPrototypeOf(GoogleAuthProvider)).call(this));

		_this.provider = GoogleAuthProvider.PROVIDER;
		return _this;
	}

	return GoogleAuthProvider;
}(AuthProvider);

GoogleAuthProvider.PROVIDER = 'google';

/* jshint ignore:start */

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */

var StorageMechanism = function () {
	function StorageMechanism() {
		classCallCheck(this, StorageMechanism);
	}

	createClass(StorageMechanism, [{
		key: 'clear',

		/**
   * Clear all items from the data storage.
   */
		value: function clear() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Checks if this mechanism is supported in the current environment.
   * Subclasses should override this when necessary.
   */

	}, {
		key: 'keys',


		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */
		value: function keys() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			throw Error('Unimplemented abstract method');
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return true;
		}
	}]);
	return StorageMechanism;
}();

/* jshint ignore:end */

var Storage = function () {

	/**
  * Provides a convenient API for data persistence using a selected data
  * storage mechanism.
  * @param {!StorageMechanism} mechanism The underlying storage mechanism.
  * @constructor
  */
	function Storage(mechanism) {
		classCallCheck(this, Storage);

		assertMechanismDefAndNotNull(mechanism);
		assertMechanismIntanceOf(mechanism);

		/**
   * The mechanism used to persist key-value pairs.
   * @type {StorageMechanism}
   * @protected
   */
		this.mechanism = mechanism;
	}

	/**
  * Clear all items from the data storage.
  */


	createClass(Storage, [{
		key: 'clear',
		value: function clear() {
			this.mechanism.clear();
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			if (!core$2.isDef(value)) {
				this.mechanism.remove(key);
				return;
			}
			this.mechanism.set(key, JSON.stringify(value));
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			var json;
			try {
				json = this.mechanism.get(key);
			} catch (e) {
				return undefined;
			}
			if (core$2.isNull(json)) {
				return undefined;
			}
			try {
				return JSON.parse(json);
			} catch (e) {
				throw Storage.ErrorCode.INVALID_VALUE;
			}
		}

		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */

	}, {
		key: 'keys',
		value: function keys() {
			return this.mechanism.keys();
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			this.mechanism.remove(key);
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			return this.mechanism.size();
		}

		/**
   * Returns the list of values stored in the Storage object.
   * @param {!Array<string>} values
   */

	}, {
		key: 'values',
		value: function values() {
			var _this = this;

			return this.keys().map(function (key) {
				return _this.get(key);
			});
		}
	}]);
	return Storage;
}();

/**
 * Errors thrown by the storage.
 * @enum {string}
 */


Storage.ErrorCode = {
	INVALID_VALUE: 'Storage: Invalid value was encountered'
};

function assertMechanismDefAndNotNull(mechanism) {
	if (!core$2.isDefAndNotNull(mechanism)) {
		throw Error('Storage mechanism is required');
	}
}

function assertMechanismIntanceOf(mechanism) {
	if (!(mechanism instanceof StorageMechanism)) {
		throw Error('Storage mechanism must me an implementation of StorageMechanism');
	}
}

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */

var LocalStorageMechanism = function (_StorageMechanism) {
	inherits(LocalStorageMechanism, _StorageMechanism);

	function LocalStorageMechanism() {
		classCallCheck(this, LocalStorageMechanism);
		return possibleConstructorReturn(this, (LocalStorageMechanism.__proto__ || Object.getPrototypeOf(LocalStorageMechanism)).apply(this, arguments));
	}

	createClass(LocalStorageMechanism, [{
		key: 'storage',

		/**
   * Returns reference for global local storage. by default
   */
		value: function storage() {
			return LocalStorageMechanism.globals.localStorage;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'clear',
		value: function clear() {
			this.storage().clear();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'keys',
		value: function keys() {
			return Object.keys(this.storage());
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'get',
		value: function get(key) {
			return this.storage().getItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'remove',


		/**
   * @inheritDoc
   */
		value: function remove(key) {
			this.storage().removeItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			this.storage().setItem(key, value);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'size',
		value: function size() {
			return this.storage().length;
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return typeof window !== 'undefined';
		}
	}]);
	return LocalStorageMechanism;
}(StorageMechanism);

if (LocalStorageMechanism.isSupported()) {
	LocalStorageMechanism.globals = {
		localStorage: window.localStorage
	};
}

/**
 * Class responsible for encapsulate auth api calls.
 */

var AuthApiHelper = function (_ApiHelper) {
	inherits(AuthApiHelper, _ApiHelper);

	/**
  * Constructs an {@link AuthApiHelper} instance.
  * @constructor
  */
	function AuthApiHelper(wedeployClient) {
		classCallCheck(this, AuthApiHelper);

		var _this = possibleConstructorReturn(this, (AuthApiHelper.__proto__ || Object.getPrototypeOf(AuthApiHelper)).call(this, wedeployClient));

		_this.currentUser = null;
		_this.onSignInCallback = null;
		_this.onSignOutCallback = null;
		if (LocalStorageMechanism.isSupported()) {
			_this.storage = new Storage(new LocalStorageMechanism());
		}

		_this.processSignIn_();

		_this.provider = {
			Facebook: FacebookAuthProvider,
			Google: GoogleAuthProvider,
			Github: GithubAuthProvider
		};
		return _this;
	}

	/**
  * Creates user.
  * @param {!object} data The data to be used to create the user.
  * @return {CancellablePromise}
  */


	createClass(AuthApiHelper, [{
		key: 'createUser',
		value: function createUser(data) {
			var _this2 = this;

			assertObject(data, 'User data must be specified as object');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users').post(data).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return _this2.makeUserAuthFromData(response.body());
			});
		}

		/**
   * Gets the current browser url without the fragment part.
   * @return {!string}
   * @protected
   */

	}, {
		key: 'getHrefWithoutFragment_',
		value: function getHrefWithoutFragment_() {
			var location = globals.window.location;
			return location.protocol + '//' + location.host + location.pathname + (location.search ? location.search : '');
		}

		/**
   * Gets the access token from the url fragment and removes it.
   * @return {?string}
   * @protected
   */

	}, {
		key: 'getRedirectAccessToken_',
		value: function getRedirectAccessToken_() {
			if (globals.window) {
				var fragment = globals.window.location.hash;
				if (fragment.indexOf('#access_token=') === 0) {
					return fragment.substring(14);
				}
			}
			return null;
		}

		/**
   * Gets user by id.
   * @param {!string} userId
   * @return {CancellablePromise}
   */

	}, {
		key: 'getUser',
		value: function getUser(userId) {
			var _this3 = this;

			assertDefAndNotNull(userId, 'User userId must be specified');
			assertUserSignedIn(this.currentUser);
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users', userId).auth(this.resolveAuthScope().token).get().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return _this3.makeUserAuthFromData(response.body());
			});
		}

		/**
   * Loads current user. Requires a user token as argument.
   * @param {!string} token
   * @return {CancellablePromise}
   */

	}, {
		key: 'loadCurrentUser',
		value: function loadCurrentUser(token) {
			var _this4 = this;

			assertDefAndNotNull(token, 'User token must be specified');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/user').auth(token).get().then(function (response) {
				var data = response.body();
				data.token = token;
				_this4.currentUser = _this4.makeUserAuthFromData(data);
				if (_this4.storage) {
					_this4.storage.set('currentUser', data);
				}
				return _this4.currentUser;
			});
		}

		/**
   * Makes user Auth from data object.
   * @param {object} data
   * @return {Auth}
   * @protected
   */

	}, {
		key: 'makeUserAuthFromData',
		value: function makeUserAuthFromData(data) {
			var auth = new Auth();
			auth.setWedeployClient(this.wedeployClient);
			auth.setCreatedAt(data.createdAt);
			auth.setEmail(data.email);
			auth.setId(data.id);
			auth.setName(data.name);
			auth.setPhotoUrl(data.photoUrl);
			auth.setToken(data.token);
			return auth;
		}

		/**
   * Calls the on sign in callback if set.
   * @protected
   */

	}, {
		key: 'maybeCallOnSignInCallback_',
		value: function maybeCallOnSignInCallback_() {
			if (this.onSignInCallback) {
				this.onSignInCallback.call(this, this.currentUser);
			}
		}

		/**
   * Calls the on sign out callback if set.
   * @protected
   */

	}, {
		key: 'maybeCallOnSignOutCallback_',
		value: function maybeCallOnSignOutCallback_() {
			if (this.onSignOutCallback) {
				this.onSignOutCallback.call(this, this.currentUser);
			}
		}

		/**
   * Fires passed callback when a user sign-in. Note that it keeps only the
   * last callback passed.
   * @param {!Function} callback
   */

	}, {
		key: 'onSignIn',
		value: function onSignIn(callback) {
			assertFunction(callback, 'Sign-in callback must be a function');
			this.onSignInCallback = callback;
		}

		/**
   * Fires passed callback when a user sign-out. Note that it keeps only the
   * last callback passed.
   * @param {!Function} callback
   */

	}, {
		key: 'onSignOut',
		value: function onSignOut(callback) {
			assertFunction(callback, 'Sign-out callback must be a function');
			this.onSignOutCallback = callback;
		}

		/**
   * Processes sign-in by detecting a presence of a fragment
   * <code>#access_token=</code> in the url or, alternatively, by local
   * storage current user.
   */

	}, {
		key: 'processSignIn_',
		value: function processSignIn_() {
			var _this5 = this;

			var redirectAccessToken = this.getRedirectAccessToken_();
			if (redirectAccessToken) {
				this.removeUrlFragmentCompletely_();
				this.loadCurrentUser(redirectAccessToken).then(function () {
					return _this5.maybeCallOnSignInCallback_();
				});
				return;
			}
			var currentUser = this.storage && this.storage.get('currentUser');
			if (currentUser) {
				this.currentUser = this.makeUserAuthFromData(currentUser);
			}
		}

		/**
   * Removes fragment from url by performing a push state to the current path.
   * @protected
   */

	}, {
		key: 'removeUrlFragmentCompletely_',
		value: function removeUrlFragmentCompletely_() {
			globals.window.history.pushState({}, document.title, window.location.pathname + window.location.search);
		}

		/**
   * Resolves auth scope from last login or api helper.
   * @return {Auth}
   */

	}, {
		key: 'resolveAuthScope',
		value: function resolveAuthScope() {
			if (this.helperAuthScope) {
				return this.helperAuthScope;
			}
			return this.currentUser;
		}

		/**
   * Sends password reset email to the specified email if found in database.
   * For security reasons call do not fail if email not found.
   * @param {!string} email
   * @return {CancellablePromise}
   */

	}, {
		key: 'sendPasswordResetEmail',
		value: function sendPasswordResetEmail(email) {
			assertDefAndNotNull(email, 'Send password reset email must be specified');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/user/recover').param('email', email).post().then(function (response) {
				return assertResponseSucceeded(response);
			});
		}

		/**
   * Signs in using email and password.
   * @param {!string} email
   * @param {!string} password
   * @return {CancellablePromise}
   */

	}, {
		key: 'signInWithEmailAndPassword',
		value: function signInWithEmailAndPassword(email, password) {
			var _this6 = this;

			assertDefAndNotNull(email, 'Sign-in email must be specified');
			assertDefAndNotNull(password, 'Sign-in password must be specified');

			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/oauth/token').param('grant_type', 'password').param('username', email).param('password', password).get().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return _this6.loadCurrentUser(response.body().access_token);
			}).then(function (user) {
				_this6.maybeCallOnSignInCallback_();
				return user;
			});
		}

		/**
   * Signs in with redirect. Some providers and environment may not support
   * this flow.
   * @param {AuthProvider} provider
   */

	}, {
		key: 'signInWithRedirect',
		value: function signInWithRedirect(provider) {
			assertBrowserEnvironment();
			assertDefAndNotNull(provider, 'Sign-in provider must be defined');
			assertSupportedProvider(provider);

			if (!provider.hasRedirectUri()) {
				provider.setRedirectUri(this.getHrefWithoutFragment_());
			}
			globals.window.location.href = provider.makeAuthorizationUrl(this.wedeployClient.authUrl_);
		}

		/**
   * Signs out <code>currentUser</code> and removes from <code>localStorage</code>.
   * @return {[type]} [description]
   */

	}, {
		key: 'signOut',
		value: function signOut() {
			var _this7 = this;

			assertUserSignedIn(this.currentUser);
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/oauth/revoke').param('token', this.currentUser.token).get().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				_this7.maybeCallOnSignOutCallback_();
				_this7.unloadCurrentUser_();
				return response;
			});
		}

		/**
   * Unloads all information for <code>currentUser</code> and removes from
   * <code>localStorage</code> if present.
   * @return {[type]} [description]
   */

	}, {
		key: 'unloadCurrentUser_',
		value: function unloadCurrentUser_() {
			this.currentUser = null;
			if (this.storage) {
				this.storage.remove('currentUser');
			}
		}
	}]);
	return AuthApiHelper;
}(ApiHelper);

function assertSupportedProvider(provider) {
	switch (provider.constructor.PROVIDER) {
		case FacebookAuthProvider.PROVIDER:
		case GithubAuthProvider.PROVIDER:
		case GoogleAuthProvider.PROVIDER:
			break;
		default:
			throw new Error('Sign-in provider not supported');
	}
}

/**
 * Class that represents a search aggregation.
 */

var Aggregation = function () {
	/**
  * Constructs an {@link Aggregation} instance.
  * @param {string} field The aggregation field.
  * @param {string} operator The aggregation operator.
  * @param {*=} opt_value The aggregation value.
  * @constructor
  */
	function Aggregation(field, operator, opt_value) {
		classCallCheck(this, Aggregation);

		this.field_ = field;
		this.operator_ = operator;
		this.value_ = opt_value;
	}

	/**
  * Creates an {@link Aggregation} instance with the "avg" operator.
  * @param {string} field The aggregation field.
  * @return {!Aggregation}
  * @static
  */


	createClass(Aggregation, [{
		key: 'getField',


		/**
   * Gets this aggregation's field.
   * @return {string}
   */
		value: function getField() {
			return this.field_;
		}

		/**
   * Gets this aggregation's operator.
   * @return {string}
   */

	}, {
		key: 'getOperator',
		value: function getOperator() {
			return this.operator_;
		}

		/**
   * Gets this aggregation's value.
   * @return {*}
   */

	}, {
		key: 'getValue',
		value: function getValue() {
			return this.value_;
		}

		/**
   * Creates an {@link Aggregation} instance with the "histogram" operator.
   * @param {string} field The aggregation field.
   * @param {number} interval The histogram's interval.
   * @return {!Aggregation}
   * @static
   */

	}], [{
		key: 'avg',
		value: function avg(field) {
			return Aggregation.field(field, 'avg');
		}

		/**
   * Creates an {@link Aggregation} instance with the "count" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'count',
		value: function count(field) {
			return Aggregation.field(field, 'count');
		}

		/**
   * Creates an {@link DistanceAggregation} instance with the "geoDistance" operator.
   * @param {string} field The aggregation field.
   * @param {*} location The aggregation location.
   * @param {...!Range} ranges The aggregation ranges.
   * @return {!DistanceAggregation}
   * @static
   */

	}, {
		key: 'distance',
		value: function distance(field, location) {
			for (var _len = arguments.length, ranges = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
				ranges[_key - 2] = arguments[_key];
			}

			return new (Function.prototype.bind.apply(Aggregation.DistanceAggregation, [null].concat([field, location], ranges)))();
		}

		/**
   * Creates an {@link Aggregation} instance with the "extendedStats" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'extendedStats',
		value: function extendedStats(field) {
			return Aggregation.field(field, 'extendedStats');
		}
	}, {
		key: 'histogram',
		value: function histogram(field, interval) {
			return new Aggregation(field, 'histogram', interval);
		}

		/**
   * Creates an {@link Aggregation} instance with the "max" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'max',
		value: function max(field) {
			return Aggregation.field(field, 'max');
		}

		/**
   * Creates an {@link Aggregation} instance with the "min" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'min',
		value: function min(field) {
			return Aggregation.field(field, 'min');
		}

		/**
   * Creates an {@link Aggregation} instance with the "missing" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'missing',
		value: function missing(field) {
			return Aggregation.field(field, 'missing');
		}

		/**
   * Creates a new {@link Aggregation} instance.
   * @param {string} field The aggregation field.
   * @param {string} operator The aggregation operator.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'field',
		value: function field(_field, operator) {
			return new Aggregation(_field, operator);
		}

		/**
   * Creates an {@link RangeAggregation} instance with the "range" operator.
   * @param {string} field The aggregation field.
   * @param {...!Range} ranges The aggregation ranges.
   * @return {!RangeAggregation}
   * @static
   */

	}, {
		key: 'range',
		value: function range(field) {
			for (var _len2 = arguments.length, ranges = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				ranges[_key2 - 1] = arguments[_key2];
			}

			return new (Function.prototype.bind.apply(Aggregation.RangeAggregation, [null].concat([field], ranges)))();
		}

		/**
   * Creates an {@link Aggregation} instance with the "stats" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'stats',
		value: function stats(field) {
			return Aggregation.field(field, 'stats');
		}

		/**
   * Creates an {@link Aggregation} instance with the "sum" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'sum',
		value: function sum(field) {
			return Aggregation.field(field, 'sum');
		}

		/**
   * Creates an {@link Aggregation} instance with the "terms" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'terms',
		value: function terms(field) {
			return Aggregation.field(field, 'terms');
		}
	}]);
	return Aggregation;
}();

/**
 * Class that represents a distance aggregation.
 * @extends {Aggregation}
 */


var DistanceAggregation = function (_Aggregation) {
	inherits(DistanceAggregation, _Aggregation);

	/**
  * Constructs an {@link DistanceAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {*} location The aggregation location.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
	function DistanceAggregation(field, location) {
		classCallCheck(this, DistanceAggregation);

		var _this = possibleConstructorReturn(this, (DistanceAggregation.__proto__ || Object.getPrototypeOf(DistanceAggregation)).call(this, field, 'geoDistance', {}));

		_this.value_.location = Embodied.toBody(location);

		for (var _len3 = arguments.length, ranges = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
			ranges[_key3 - 2] = arguments[_key3];
		}

		_this.value_.ranges = ranges.map(function (range) {
			return range.body();
		});
		return _this;
	}

	/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @chainnable
  */


	createClass(DistanceAggregation, [{
		key: 'range',
		value: function range(rangeOrFrom, opt_to) {
			var range = rangeOrFrom;
			if (!(range instanceof Range)) {
				range = Range.range(rangeOrFrom, opt_to);
			}
			this.value_.ranges.push(range.body());
			return this;
		}

		/**
   * Sets this aggregation's unit.
   * @param {string} unit
   * @chainnable
   */

	}, {
		key: 'unit',
		value: function unit(_unit) {
			this.value_.unit = _unit;
			return this;
		}
	}]);
	return DistanceAggregation;
}(Aggregation);

Aggregation.DistanceAggregation = DistanceAggregation;

/**
 * Class that represents a range aggregation.
 * @extends {Aggregation}
 */

var RangeAggregation = function (_Aggregation2) {
	inherits(RangeAggregation, _Aggregation2);

	/**
  * Constructs an {@link RangeAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
	function RangeAggregation(field) {
		classCallCheck(this, RangeAggregation);

		var _this2 = possibleConstructorReturn(this, (RangeAggregation.__proto__ || Object.getPrototypeOf(RangeAggregation)).call(this, field, 'range'));

		for (var _len4 = arguments.length, ranges = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
			ranges[_key4 - 1] = arguments[_key4];
		}

		_this2.value_ = ranges.map(function (range) {
			return range.body();
		});
		return _this2;
	}

	/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @chainnable
  */


	createClass(RangeAggregation, [{
		key: 'range',
		value: function range(rangeOrFrom, opt_to) {
			var range = rangeOrFrom;
			if (!(range instanceof Range)) {
				range = Range.range(rangeOrFrom, opt_to);
			}
			this.value_.push(range.body());
			return this;
		}
	}]);
	return RangeAggregation;
}(Aggregation);

Aggregation.RangeAggregation = RangeAggregation;

/**
 * Class responsible for building queries.
 * @extends {Embodied}
 */

var Query = function (_Embodied) {
	inherits(Query, _Embodied);

	function Query() {
		classCallCheck(this, Query);
		return possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).apply(this, arguments));
	}

	createClass(Query, [{
		key: 'aggregate',


		/**
   * Adds an aggregation to this {@link Query} instance.
   * @param {string} name The aggregation name.
   * @param {!Aggregation|string} aggregationOrField Either an
   *   {@link Aggregation} instance or the name of the aggregation field.
   * @param {string=} opt_operator The aggregation operator.
   * @chainnable
   */
		value: function aggregate(name, aggregationOrField, opt_operator) {
			var aggregation = aggregationOrField;
			if (!(aggregation instanceof Aggregation)) {
				aggregation = Aggregation.field(aggregationOrField, opt_operator);
			}

			var field = aggregation.getField();
			var value = {};
			value[field] = {
				name: name,
				operator: aggregation.getOperator()
			};
			if (isDefAndNotNull(aggregation.getValue())) {
				value[field].value = aggregation.getValue();
			}

			if (!this.body_.aggregation) {
				this.body_.aggregation = [];
			}
			this.body_.aggregation.push(value);
			return this;
		}

		/**
   * Sets this query's type to "count".
   * @chainnable
   */

	}, {
		key: 'count',
		value: function count() {
			return this.type('count');
		}

		/**
   * Sets this query's type to "fetch".
   * @chainnable
   */

	}, {
		key: 'fetch',
		value: function fetch() {
			return this.type('fetch');
		}

		/**
   * Adds a filter to this Query.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */

	}, {
		key: 'filter',
		value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
			var filter = Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value);
			if (!this.body_.filter) {
				this.body_.filter = [];
			}
			this.body_.filter.push(filter.body());
			return this;
		}

		/**
   * Sets the query offset.
   * @param {number} offset The index of the first entry that should be returned
   *   by this query.
   * @chainnable
   */

	}, {
		key: 'offset',
		value: function offset(_offset2) {
			this.body_.offset = _offset2;
			return this;
		}

		/**
   * Adds a highlight entry to this {@link Query} instance.
   * @param {string} field The field's name.
   * @chainnable
   */

	}, {
		key: 'highlight',
		value: function highlight(field) {
			if (!this.body_.highlight) {
				this.body_.highlight = [];
			}

			this.body_.highlight.push(field);
			return this;
		}

		/**
   * Sets the query limit.
   * @param {number} limit The max amount of entries that this query should return.
   * @chainnable
   */

	}, {
		key: 'limit',
		value: function limit(_limit2) {
			this.body_.limit = _limit2;
			return this;
		}

		/**
   * Adds a search to this {@link Query} instance.
   * @param {!Filter|string} filterOrTextOrField If no other arguments
   *   are passed to this function, this should be either a {@link Filter}
   *   instance or a text to be used in a match filter. In both cases
   *   the filter will be applied to all fields. Another option is to
   *   pass this as a field name instead, together with other arguments
   *   so the filter can be created.
   * @param {string=} opt_textOrOperator Either a text to be used in a
   *   match filter, or the operator that should be used.
   * @param {*=} opt_value The value to be used by the filter. Should
   *   only be passed if an operator was passed as the second argument.
   * @chainnable
   */

	}, {
		key: 'search',
		value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
			var filter = filterOrTextOrField;

			if (opt_value) {
				filter = Filter.field(filterOrTextOrField, opt_textOrOperator, opt_value);
			} else if (opt_textOrOperator) {
				filter = Filter.match(filterOrTextOrField, opt_textOrOperator);
			} else if (!(filter instanceof Filter)) {
				filter = Filter.match(filterOrTextOrField);
			}

			if (!this.body_.search) {
				this.body_.search = [];
			}

			if (isDefAndNotNull(filterOrTextOrField)) {
				this.body_.search.push(filter.body());
			} else {
				this.body_.search.push({});
			}

			return this;
		}

		/**
   * Adds a sort entry to this query, specifying the field this query should be
   * sorted by and, optionally, the sort direction.
   * @param {string} field The field that the query should be sorted by.
   * @param {string=} opt_direction The direction the sort operation should use.
   *   If none is given, "asc" is used by default.
   * @chainnable
   */

	}, {
		key: 'sort',
		value: function sort(field, opt_direction) {
			if (!this.body_.sort) {
				this.body_.sort = [];
			}
			var sortEntry = {};
			sortEntry[field] = opt_direction || 'asc';
			this.body_.sort.push(sortEntry);
			return this;
		}

		/**
   * Sets the query type.
   * @param {string} type The query's type. For example: "count", "fetch".
   * @chainnable
   */

	}, {
		key: 'type',
		value: function type(_type2) {
			this.body_.type = _type2;
			return this;
		}
	}], [{
		key: 'aggregate',

		/**
   * Adds an aggregation to this {@link Query} instance.
   * @param {string} name The aggregation name.
   * @param {!Aggregation|string} aggregationOrField Either an
   *   {@link Aggregation} instance or the name of the aggregation field.
   * @param {string=} opt_operator The aggregation operator.
   * @return {!Query}
   * @static
   */
		value: function aggregate(name, aggregationOrField, opt_operator) {
			return new Query().aggregate(name, aggregationOrField, opt_operator);
		}

		/**
   * Sets this query's type to "count".
   * @return {!Query}
   * @static
   */

	}, {
		key: 'count',
		value: function count() {
			return new Query().type('count');
		}

		/**
   * Sets this query's type to "fetch".
   * @return {!Query}
   * @static
   */

	}, {
		key: 'fetch',
		value: function fetch() {
			return new Query().type('fetch');
		}

		/**
   * Adds a filter to this Query.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'filter',
		value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return new Query().filter(fieldOrFilter, opt_operatorOrValue, opt_value);
		}

		/**
   * Sets the query offset.
   * @param {number} offset The index of the first entry that should be returned
   *   by this query.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'offset',
		value: function offset(_offset) {
			return new Query().offset(_offset);
		}

		/**
   * Adds a highlight entry to this {@link Query} instance.
   * @param {string} field The field's name.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'highlight',
		value: function highlight(field) {
			return new Query().highlight(field);
		}

		/**
   * Sets the query limit.
   * @param {number} limit The max amount of entries that this query should return.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'limit',
		value: function limit(_limit) {
			return new Query().limit(_limit);
		}

		/**
   * Adds a search to this {@link Query} instance.
   * @param {!Filter|string} filterOrTextOrField If no other arguments
   *   are passed to this function, this should be either a {@link Filter}
   *   instance or a text to be used in a match filter. In both cases
   *   the filter will be applied to all fields. Another option is to
   *   pass this as a field name instead, together with other arguments
   *   so the filter can be created.
   * @param {string=} opt_textOrOperator Either a text to be used in a
   *   match filter, or the operator that should be used.
   * @param {*=} opt_value The value to be used by the filter. Should
   *   only be passed if an operator was passed as the second argument.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'search',
		value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
			return new Query().search(filterOrTextOrField, opt_textOrOperator, opt_value);
		}

		/**
   * Adds a sort entry to this query, specifying the field this query should be
   * sorted by and, optionally, the sort direction.
   * @param {string} field The field that the query should be sorted by.
   * @param {string=} opt_direction The direction the sort operation should use.
   *   If none is given, "asc" is used by default.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'sort',
		value: function sort(field, opt_direction) {
			return new Query().sort(field, opt_direction);
		}

		/**
   * Sets the query type.
   * @param {string} type The query's type. For example: "count", "fetch".
   * @return {!Query}
   * @static
   */

	}, {
		key: 'type',
		value: function type(_type) {
			return new Query().type(_type);
		}
	}]);
	return Query;
}(Embodied);

/**
 * Class responsible for encapsulate data api calls.
 */

var DataApiHelper = function (_ApiHelper) {
	inherits(DataApiHelper, _ApiHelper);

	/**
  * Constructs an {@link DataApiHelper} instance.
  * @param {@link WeDeploy} instance.
  * @constructor
  */
	function DataApiHelper(wedeployClient) {
		classCallCheck(this, DataApiHelper);
		return possibleConstructorReturn(this, (DataApiHelper.__proto__ || Object.getPrototypeOf(DataApiHelper)).call(this, wedeployClient));
	}

	/**
  * Adds a filter to this request's {@link Query}.
  * @param {!Filter|string} fieldOrFilter Either a Filter instance or the
  *   name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @chainable
  */


	createClass(DataApiHelper, [{
		key: 'where',
		value: function where(fieldOrFilter, opt_operatorOrValue, opt_value) {
			this.getOrCreateFilter_().and(fieldOrFilter, opt_operatorOrValue, opt_value);
			return this;
		}

		/**
   * Adds a filter to be composed with this filter using the "or" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   *   the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */

	}, {
		key: 'or',
		value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
			if (this.getOrCreateFilter_().body().and.length === 0) {
				throw Error('It\'s required to have a condition before using an \'or()\' for the first time.');
			}
			this.getOrCreateFilter_().or(fieldOrFilter, opt_operatorOrValue, opt_value);
			return this;
		}

		/**
   * Adds a filter to be compose with this filter using "none" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} args A variable amount of values to be used with
   * the "none" operator. Can be passed either as a single array or as
   * separate params.
   * @chainnable
   */

	}, {
		key: 'none',
		value: function none(field) {
			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			return this.where(Filter.none(field, args));
		}

		/**
   * Adds a filter to be compose with this filter using "match" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   * should be the query string, in which case all fields will be matched.
   * Otherwise, this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @chainnable
   */

	}, {
		key: 'match',
		value: function match(field, value) {
			return this.where(Filter.match(field, value));
		}

		/**
   * Adds a filter to be compose with this filter using "similar" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   * should be the query string, in which case all fields will be matched.
   * Otherwise, this should be the name of the field to match.
   * @param {?string} query The query string.
   * @chainnable
   */

	}, {
		key: 'similar',
		value: function similar(fieldOrQuery, query) {
			return this.where(Filter.similar(fieldOrQuery, query));
		}

		/**
   * Returns a {@link Filter} instance that uses the "<" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lt',
		value: function lt(field, value) {
			return this.where(Filter.lt(field, value));
		}

		/**
   * Returns a {@link Filter} instance that uses the "<=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lte',
		value: function lte(field, value) {
			return this.where(Filter.lte(field, value));
		}

		/**
   * Adds a filter to be compose with this filter using "any" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} args A variable amount of values to be used with
   * the "none" operator. Can be passed either as a single array or as
   * separate params.
   * @chainnable
   */

	}, {
		key: 'any',
		value: function any(field) {
			for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				args[_key2 - 1] = arguments[_key2];
			}

			return this.where(Filter.any(field, args));
		}

		/**
   * Adds a filter to be compose with this filter using "gp" operator. This is a
   * special use case of `Filter.polygon` for bounding boxes.
   * @param {string} field The field's name.
   * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or a
   * bounding box's upper left coordinate.
   * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
   * @chainnable
   */

	}, {
		key: 'boundingBox',
		value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
			return this.where(Filter.boundingBox(field, boxOrUpperLeft, opt_lowerRight));
		}

		/**
   * Adds a filter to be compose with this filter using "gd" operator.
   * @param {string} field The field's name.
   * @param {*} locationOrCircle Either a `Geo.Circle` instance or a
   * coordinate.
   * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
   * the distance value.
   * @return {!Filter}
   * @chainnable
   */

	}, {
		key: 'distance',
		value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
			return this.where(Filter.distance(field, locationOrCircle, opt_rangeOrDistance));
		}

		/**
   * Adds a filter to be compose with this filter using "range" operator.
   * @param {string} field The field's name.
   * @param {*} rangeOrMin Either a `Range` instance or a the range's min
   * value.
   * @param {*=} opt_max The range's max value.
   * @return {!Filter}
   * @chainnable
   */

	}, {
		key: 'range',
		value: function range(field, rangeOrMin, opt_max) {
			return this.where(Filter.range(field, rangeOrMin, opt_max));
		}

		/**
   * Sets the limit for this request's {@link Query}.
   * @param {number} limit The max amount of entries that this request should return.
   * @chainable
   */

	}, {
		key: 'limit',
		value: function limit(_limit) {
			this.getOrCreateQuery_().limit(_limit);
			return this;
		}

		/**
   * Sets the offset for this request's {@link Query}.
   * @param {number} offset The index of the first entry that should be
   * returned by this query.
   * @chainable
   */

	}, {
		key: 'offset',
		value: function offset(_offset) {
			this.getOrCreateQuery_().offset(_offset);
			return this;
		}

		/**
   * Adds a highlight entry to this request's {@link Query} instance.
   * @param {string} field The field's name.
   * @chainable
   */

	}, {
		key: 'highlight',
		value: function highlight(field) {
			this.getOrCreateQuery_().highlight(field);
			return this;
		}

		/**
   * Adds an aggregation to this {@link Query} instance.
   * @param {string} name The aggregation name.
   * @param {!Aggregation|string} aggregationOrField Either an {@link
   * Aggregation} instance or the name of the aggregation field.
   * @param {string=} opt_operator The aggregation operator.
   * @chainable
   */

	}, {
		key: 'aggregate',
		value: function aggregate(name, aggregationOrField, opt_operator) {
			this.getOrCreateQuery_().aggregate(name, aggregationOrField, opt_operator);
			return this;
		}

		/**
   * Sets this request's query type to 'count'.
   * @chainnable
   */

	}, {
		key: 'count',
		value: function count() {
			this.getOrCreateQuery_().type('count');
			return this;
		}

		/**
   * Adds a sort query to this request's body.
   * @param {string} field The field that the query should be sorted by.
   * @param {string=} opt_direction The direction the sort operation should
   * use. If none is given, 'asc' is used by default.
   * @chainnable
   */

	}, {
		key: 'orderBy',
		value: function orderBy(field, opt_direction) {
			this.getOrCreateQuery_().sort(field, opt_direction);
			return this;
		}

		/**
   * Creates an object (or multiple objects) and saves it to WeDeploy data. If
   * there's a validation registered in the collection and the request is
   * successful, the resulting object (or array of objects) is returned. The
   * data parameter can be either an Object or an Array of Objects.
   * These Objects describe the attributes on the objects that are to be created.
   * ```javascript
   * var data = WeDeploy.data('http://demodata.wedeploy.io');
   *
   * data.create('movies', {'title'=> 'Star Wars: Episode I  The Phantom Menace'})
   * 		 .then(function(movie){
   * 			 console.log(movie)
   *     });
   *
   * data.create('movies', [{'title'=> 'Star Wars: Episode II  Attack of the Clones'},
   * 												{'title'=> 'Star Wars: Episode III  Revenge of the Sith'})
   * 		 .then(function(movies){
   * 			 console.log(movies)
   *     });
   * ```
   * @param {string} collection Collection (key) used to create the new data.
   * @param {Object} data Attributes on the object that is to be created.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'create',
		value: function create(collection, data) {
			assertDefAndNotNull(collection, 'Collection key must be specified.');
			assertObject(data, 'Data can\'t be empty.');

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(collection).post(data).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Update the attributes of a document form the passed-in object and saves
   * the record. If the object is invalid, the saving will fail and an error
   * object will be returned.
   *
   * ```javascript
   * var data = WeDeploy.data('http://demodata.wedeploy.io');
   *
   * data.update('movies/1019112353', {'title'=> 'Star Wars: Episode I'})
   * 		 .then(function(movie){
   * 			 console.log(movie)
   *     });
   * ```
   * @param {string} document Key used to update the document.
   * @param {Object} data Attributes on the object that is to be updated.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'update',
		value: function update(document, data) {
			assertDefAndNotNull(document, 'Document key must be specified.');
			assertObject(data, 'Data must be specified.');

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(document).put(data).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Deletes a [document/field/collection].
   * @param {string} key Key used to delete the
   * document/field/collection.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'delete',
		value: function _delete(key) {
			assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(key).delete().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function () {
				return undefined;
			});
		}

		/**
   * Retrieve data from a [document/field/collection].
   * @param {string} key Key used to delete the document/field/collection.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'get',
		value: function get(key) {
			assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

			this.addFiltersToQuery_();

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(key).get(this.query_).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Retrieve data from a [document/field/collection] and put it in a search
   * format.
   * @param {string} key Key used to delete the document/field/collection.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'search',
		value: function search(key) {
			assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

			this.onSearch_();

			this.addFiltersToQuery_();

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(key).get(this.query_).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Creates new socket.io instance. Monitor the arrival of new broadcasted
   * data.
   * @param  {string} collection key/collection used to find organized data.
   * @param  {Object=} opt_options Object with Socket IO options.
   * @return {!io} Socket IO reference. Server events can be listened on it.
   */

	}, {
		key: 'watch',
		value: function watch(collection, opt_options) {
			assertDefAndNotNull(collection, 'Collection key must be specified');

			this.addFiltersToQuery_();

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(collection).watch(this.query_, opt_options);
		}

		/**
   * Gets the currentl used main {@link Filter} object. If none exists yet, a
   * new one is created.
   * @return {!Query}
   * @protected
   */

	}, {
		key: 'getOrCreateFilter_',
		value: function getOrCreateFilter_() {
			if (!this.filter_) {
				this.filter_ = new Filter();
			}
			return this.filter_;
		}

		/**
   * Gets the currently used {@link Query} object. If none exists yet,
   * a new one is created.
   * @return {!Query}
   * @protected
   */

	}, {
		key: 'getOrCreateQuery_',
		value: function getOrCreateQuery_() {
			if (!this.query_) {
				this.query_ = new Query();
			}
			return this.query_;
		}

		/**
   * Load the currently used main {@link Filter} object into the currently
   * used {@link Query}.
   * @chainable
   * @protected
   */

	}, {
		key: 'addFiltersToQuery_',
		value: function addFiltersToQuery_() {
			if (isDef(this.filter_) && this.toSearch_ !== true) {
				this.getOrCreateQuery_().filter(this.filter_);
			}
			return this;
		}

		/**
   * Adds a search to this request's {@link Query} instance.
   * @chainable
   * @protected
   */

	}, {
		key: 'onSearch_',
		value: function onSearch_() {
			if (isDef(this.filter_)) {
				this.getOrCreateQuery_().search(this.getOrCreateFilter_());
			} else {
				throw Error('It\'s required to have a condition before using an \'search()\' for the first time.');
			}
			this.toSearch_ = true;
			return this;
		}
	}]);
	return DataApiHelper;
}(ApiHelper);

/**
 * Abstraction layer for string to base64 conversion
 * reference: https://github.com/nodejs/node/issues/3462
 */

var Base64 = function () {
	function Base64() {
		classCallCheck(this, Base64);
	}

	createClass(Base64, null, [{
		key: 'encodeString',

		/**
   * Creates a base-64 encoded ASCII string from a "string" of binary data.
   * @param {string} string to be encoded.
   * @return {string}
   * @static
   */
		value: function encodeString(string) {
			if (typeof btoa === 'function') {
				return btoa(string);
			}

			return new Buffer(string.toString(), 'binary');
		}
	}]);
	return Base64;
}();

/*!
 * Promises polyfill from Google's Closure Library.
 *
 *      Copyright 2013 The Closure Library Authors. All Rights Reserved.
 *
 * NOTE(eduardo): Promise support is not ready on all supported browsers,
 * therefore metal-promise is temporarily using Google's promises as polyfill.
 * It supports cancellable promises and has clean and fast implementation.
 */

/**
 * Provides a more strict interface for Thenables in terms of
 * http://promisesaplus.com for interop with {@see CancellablePromise}.
 *
 * @interface
 * @extends {IThenable.<TYPE>}
 * @template TYPE
 */
var Thenable = function Thenable() {};

/**
 * Adds callbacks that will operate on the result of the Thenable, returning a
 * new child Promise.
 *
 * If the Thenable is fulfilled, the {@code onFulfilled} callback will be
 * invoked with the fulfillment value as argument, and the child Promise will
 * be fulfilled with the return value of the callback. If the callback throws
 * an exception, the child Promise will be rejected with the thrown value
 * instead.
 *
 * If the Thenable is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value of the callback or thrown value.
 *
 * @param {?(function(this:THIS, TYPE):
 *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {?(function(*): *)=} opt_onRejected A function that will be invoked
 *     with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 */
Thenable.prototype.then = function () {};

/**
 * An expando property to indicate that an object implements
 * {@code Thenable}.
 *
 * {@see addImplementation}.
 *
 * @const
 */
Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';

/**
 * Marks a given class (constructor) as an implementation of Thenable, so
 * that we can query that fact at runtime. The class must have already
 * implemented the interface.
 * Exports a 'then' method on the constructor prototype, so that the objects
 * also implement the extern {@see Thenable} interface for interop with
 * other Promise implementations.
 * @param {function(new:Thenable,...[?])} ctor The class constructor. The
 *     corresponding class must have already implemented the interface.
 */
Thenable.addImplementation = function (ctor) {
  ctor.prototype.then = ctor.prototype.then;
  ctor.prototype.$goog_Thenable = true;
};

/**
 * @param {*} object
 * @return {boolean} Whether a given instance implements {@code Thenable}.
 *     The class/superclass of the instance must call {@code addImplementation}.
 */
Thenable.isImplementedBy = function (object$$1) {
  if (!object$$1) {
    return false;
  }
  try {
    return !!object$$1.$goog_Thenable;
  } catch (e) {
    // Property access seems to be forbidden.
    return false;
  }
};

/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
var partial = function partial(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function () {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};

/**
 * Promises provide a result that may be resolved asynchronously. A Promise may
 * be resolved by being fulfilled or rejected with a value, which will be known
 * as the fulfillment value or the rejection reason. Whether fulfilled or
 * rejected, the Promise result is immutable once it is set.
 *
 * Promises may represent results of any type, including undefined. Rejection
 * reasons are typically Errors, but may also be of any type. Closure Promises
 * allow for optional type annotations that enforce that fulfillment values are
 * of the appropriate types at compile time.
 *
 * The result of a Promise is accessible by calling {@code then} and registering
 * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise
 * resolves, the relevant callbacks are invoked with the fulfillment value or
 * rejection reason as argument. Callbacks are always invoked in the order they
 * were registered, even when additional {@code then} calls are made from inside
 * another callback. A callback is always run asynchronously sometime after the
 * scope containing the registering {@code then} invocation has returned.
 *
 * If a Promise is resolved with another Promise, the first Promise will block
 * until the second is resolved, and then assumes the same result as the second
 * Promise. This allows Promises to depend on the results of other Promises,
 * linking together multiple asynchronous operations.
 *
 * This implementation is compatible with the Promises/A+ specification and
 * passes that specification's conformance test suite. A Closure Promise may be
 * resolved with a Promise instance (or sufficiently compatible Promise-like
 * object) created by other Promise implementations. From the specification,
 * Promise-like objects are known as "Thenables".
 *
 * @see http://promisesaplus.com/
 *
 * @param {function(
 *             this:RESOLVER_CONTEXT,
 *             function((TYPE|IThenable.<TYPE>|Thenable)),
 *             function(*)): void} resolver
 *     Initialization function that is invoked immediately with {@code resolve}
 *     and {@code reject} functions as arguments. The Promise is resolved or
 *     rejected with the first argument passed to either function.
 * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the
 *     resolver function. If unspecified, the resolver function will be executed
 *     in the default scope.
 * @constructor
 * @struct
 * @final
 * @implements {Thenable.<TYPE>}
 * @template TYPE,RESOLVER_CONTEXT
 */
var CancellablePromise = function CancellablePromise(resolver, opt_context) {
  /**
   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
   * BLOCKED.
   * @private {CancellablePromise.State_}
   */
  this.state_ = CancellablePromise.State_.PENDING;

  /**
   * The resolved result of the Promise. Immutable once set with either a
   * fulfillment value or rejection reason.
   * @private {*}
   */
  this.result_ = undefined;

  /**
   * For Promises created by calling {@code then()}, the originating parent.
   * @private {CancellablePromise}
   */
  this.parent_ = null;

  /**
   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to
   * this Promise by calls to {@code then()}.
   * @private {Array.<CancellablePromise.CallbackEntry_>}
   */
  this.callbackEntries_ = null;

  /**
   * Whether the Promise is in the queue of Promises to execute.
   * @private {boolean}
   */
  this.executing_ = false;

  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    /**
     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater
     * than 0 milliseconds. The ID is set when the Promise is rejected, and
     * cleared only if an {@code onRejected} callback is invoked for the
     * Promise (or one of its descendants) before the delay is exceeded.
     *
     * If the rejection is not handled before the timeout completes, the
     * rejection reason is passed to the unhandled rejection handler.
     * @private {number}
     */
    this.unhandledRejectionId_ = 0;
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    /**
     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a
     * boolean that is set if the Promise is rejected, and reset to false if an
     * {@code onRejected} callback is invoked for the Promise (or one of its
     * descendants). If the rejection is not handled before the next timestep,
     * the rejection reason is passed to the unhandled rejection handler.
     * @private {boolean}
     */
    this.hadUnhandledRejection_ = false;
  }

  try {
    var self = this;
    resolver.call(opt_context, function (value) {
      self.resolve_(CancellablePromise.State_.FULFILLED, value);
    }, function (reason) {
      self.resolve_(CancellablePromise.State_.REJECTED, reason);
    });
  } catch (e) {
    this.resolve_(CancellablePromise.State_.REJECTED, e);
  }
};

/**
 * The delay in milliseconds before a rejected Promise's reason is passed to
 * the rejection handler. By default, the rejection handler rethrows the
 * rejection reason so that it appears in the developer console or
 * {@code window.onerror} handler.
 * Rejections are rethrown as quickly as possible by default. A negative value
 * disables rejection handling entirely.
 * @type {number}
 */
CancellablePromise.UNHANDLED_REJECTION_DELAY = 0;

/**
 * The possible internal states for a Promise. These states are not directly
 * observable to external callers.
 * @enum {number}
 * @private
 */
CancellablePromise.State_ = {
  /** The Promise is waiting for resolution. */
  PENDING: 0,

  /** The Promise is blocked waiting for the result of another Thenable. */
  BLOCKED: 1,

  /** The Promise has been resolved with a fulfillment value. */
  FULFILLED: 2,

  /** The Promise has been resolved with a rejection reason. */
  REJECTED: 3
};

/**
 * Typedef for entries in the callback chain. Each call to {@code then},
 * {@code thenCatch}, or {@code thenAlways} creates an entry containing the
 * functions that may be invoked once the Promise is resolved.
 *
 * @typedef {{
 *   child: CancellablePromise,
 *   onFulfilled: function(*),
 *   onRejected: function(*)
 * }}
 * @private
 */
CancellablePromise.CallbackEntry_ = null;

/**
 * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value
 * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved
 *     with the given value.
 * @template TYPE
 */
CancellablePromise.resolve = function (opt_value) {
  return new CancellablePromise(function (resolve) {
    resolve(opt_value);
  });
};

/**
 * @param {*=} opt_reason
 * @return {!CancellablePromise} A new Promise that is immediately rejected with the
 *     given reason.
 */
CancellablePromise.reject = function (opt_reason) {
  return new CancellablePromise(function (resolve, reject) {
    reject(opt_reason);
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the
 *     first Promise (or Promise-like) input to complete.
 * @template TYPE
 */
CancellablePromise.race = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    if (!promises.length) {
      resolve(undefined);
    }
    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(resolve, reject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of
 *     every fulfilled value once every input Promise (or Promise-like) is
 *     successfully fulfilled, or is rejected by the first rejection result.
 * @template TYPE
 */
CancellablePromise.all = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toFulfill = promises.length;
    var values = [];

    if (!toFulfill) {
      resolve(values);
      return;
    }

    var onFulfill = function onFulfill(index, value) {
      toFulfill--;
      values[index] = value;
      if (toFulfill === 0) {
        resolve(values);
      }
    };

    var onReject = function onReject(reason) {
      reject(reason);
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(partial(onFulfill, i), onReject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of
 *     the first input to be fulfilled, or is rejected with a list of every
 *     rejection reason if all inputs are rejected.
 * @template TYPE
 */
CancellablePromise.firstFulfilled = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toReject = promises.length;
    var reasons = [];

    if (!toReject) {
      resolve(undefined);
      return;
    }

    var onFulfill = function onFulfill(value) {
      resolve(value);
    };

    var onReject = function onReject(index, reason) {
      toReject--;
      reasons[index] = reason;
      if (toReject === 0) {
        reject(reasons);
      }
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(onFulfill, partial(onReject, i));
    }
  });
};

/**
 * Adds callbacks that will operate on the result of the Promise, returning a
 * new child Promise.
 *
 * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked
 * with the fulfillment value as argument, and the child Promise will be
 * fulfilled with the return value of the callback. If the callback throws an
 * exception, the child Promise will be rejected with the thrown value instead.
 *
 * If the Promise is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value (or thrown value) of the callback.
 *
 * @override
 */
CancellablePromise.prototype.then = function (opt_onFulfilled, opt_onRejected, opt_context) {
  return this.addChildPromise_(isFunction(opt_onFulfilled) ? opt_onFulfilled : null, isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);
};
Thenable.addImplementation(CancellablePromise);

/**
 * Adds a callback that will be invoked whether the Promise is fulfilled or
 * rejected. The callback receives no argument, and no new child Promise is
 * created. This is useful for ensuring that cleanup takes place after certain
 * asynchronous operations. Callbacks added with {@code thenAlways} will be
 * executed in the same order with other calls to {@code then},
 * {@code thenAlways}, or {@code thenCatch}.
 *
 * Since it does not produce a new child Promise, cancellation propagation is
 * not prevented by adding callbacks with {@code thenAlways}. A Promise that has
 * a cleanup handler added with {@code thenAlways} will be canceled if all of
 * its children created by {@code then} (or {@code thenCatch}) are canceled.
 *
 * @param {function(this:THIS): void} onResolved A function that will be invoked
 *     when the Promise is resolved.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.
 * @template THIS
 */
CancellablePromise.prototype.thenAlways = function (onResolved, opt_context) {
  var callback = function callback() {
    try {
      // Ensure that no arguments are passed to onResolved.
      onResolved.call(opt_context);
    } catch (err) {
      CancellablePromise.handleRejection_.call(null, err);
    }
  };

  this.addCallbackEntry_({
    child: null,
    onRejected: callback,
    onFulfilled: callback
  });
  return this;
};

/**
 * Adds a callback that will be invoked only if the Promise is rejected. This
 * is equivalent to {@code then(null, onRejected)}.
 *
 * @param {!function(this:THIS, *): *} onRejected A function that will be
 *     invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise} A new Promise that will receive the result of the
 *     callback.
 * @template THIS
 */
CancellablePromise.prototype.thenCatch = function (onRejected, opt_context) {
  return this.addChildPromise_(null, onRejected, opt_context);
};

/**
 * Alias of {@link CancellablePromise.prototype.thenCatch}
 */
CancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;

/**
 * Cancels the Promise if it is still pending by rejecting it with a cancel
 * Error. No action is performed if the Promise is already resolved.
 *
 * All child Promises of the canceled Promise will be rejected with the same
 * cancel error, as with normal Promise rejection. If the Promise to be canceled
 * is the only child of a pending Promise, the parent Promise will also be
 * canceled. Cancellation may propagate upward through multiple generations.
 *
 * @param {string=} opt_message An optional debugging message for describing the
 *     cancellation reason.
 */
CancellablePromise.prototype.cancel = function (opt_message) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    async.run(function () {
      var err = new CancellablePromise.CancellationError(opt_message);
      err.IS_CANCELLATION_ERROR = true;
      this.cancelInternal_(err);
    }, this);
  }
};

/**
 * Cancels this Promise with the given error.
 *
 * @param {!Error} err The cancellation error.
 * @private
 */
CancellablePromise.prototype.cancelInternal_ = function (err) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    if (this.parent_) {
      // Cancel the Promise and remove it from the parent's child list.
      this.parent_.cancelChild_(this, err);
    } else {
      this.resolve_(CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Cancels a child Promise from the list of callback entries. If the Promise has
 * not already been resolved, reject it with a cancel error. If there are no
 * other children in the list of callback entries, propagate the cancellation
 * by canceling this Promise as well.
 *
 * @param {!CancellablePromise} childPromise The Promise to cancel.
 * @param {!Error} err The cancel error to use for rejecting the Promise.
 * @private
 */
CancellablePromise.prototype.cancelChild_ = function (childPromise, err) {
  if (!this.callbackEntries_) {
    return;
  }
  var childCount = 0;
  var childIndex = -1;

  // Find the callback entry for the childPromise, and count whether there are
  // additional child Promises.
  for (var i = 0, entry; entry = this.callbackEntries_[i]; i++) {
    var child = entry.child;
    if (child) {
      childCount++;
      if (child === childPromise) {
        childIndex = i;
      }
      if (childIndex >= 0 && childCount > 1) {
        break;
      }
    }
  }

  // If the child Promise was the only child, cancel this Promise as well.
  // Otherwise, reject only the child Promise with the cancel error.
  if (childIndex >= 0) {
    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {
      this.cancelInternal_(err);
    } else {
      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];
      this.executeCallback_(callbackEntry, CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Adds a callback entry to the current Promise, and schedules callback
 * execution if the Promise has already been resolved.
 *
 * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing
 *     {@code onFulfilled} and {@code onRejected} callbacks to execute after
 *     the Promise is resolved.
 * @private
 */
CancellablePromise.prototype.addCallbackEntry_ = function (callbackEntry) {
  if ((!this.callbackEntries_ || !this.callbackEntries_.length) && (this.state_ === CancellablePromise.State_.FULFILLED || this.state_ === CancellablePromise.State_.REJECTED)) {
    this.scheduleCallbacks_();
  }
  if (!this.callbackEntries_) {
    this.callbackEntries_ = [];
  }
  this.callbackEntries_.push(callbackEntry);
};

/**
 * Creates a child Promise and adds it to the callback entry list. The result of
 * the child Promise is determined by the state of the parent Promise and the
 * result of the {@code onFulfilled} or {@code onRejected} callbacks as
 * specified in the Promise resolution procedure.
 *
 * @see http://promisesaplus.com/#the__method
 *
 * @param {?function(this:THIS, TYPE):
 *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that
 *     will be invoked if the Promise is fullfilled, or null.
 * @param {?function(this:THIS, *): *} onRejected A callback that will be
 *     invoked if the Promise is rejected, or null.
 * @param {THIS=} opt_context An optional execution context for the callbacks.
 *     in the default calling context.
 * @return {!CancellablePromise} The child Promise.
 * @template RESULT,THIS
 * @private
 */
CancellablePromise.prototype.addChildPromise_ = function (onFulfilled, onRejected, opt_context) {

  var callbackEntry = {
    child: null,
    onFulfilled: null,
    onRejected: null
  };

  callbackEntry.child = new CancellablePromise(function (resolve, reject) {
    // Invoke onFulfilled, or resolve with the parent's value if absent.
    callbackEntry.onFulfilled = onFulfilled ? function (value) {
      try {
        var result = onFulfilled.call(opt_context, value);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    } : resolve;

    // Invoke onRejected, or reject with the parent's reason if absent.
    callbackEntry.onRejected = onRejected ? function (reason) {
      try {
        var result = onRejected.call(opt_context, reason);
        if (!isDef(result) && reason.IS_CANCELLATION_ERROR) {
          // Propagate cancellation to children if no other result is returned.
          reject(reason);
        } else {
          resolve(result);
        }
      } catch (err) {
        reject(err);
      }
    } : reject;
  });

  callbackEntry.child.parent_ = this;
  this.addCallbackEntry_(
  /** @type {CancellablePromise.CallbackEntry_} */callbackEntry);
  return callbackEntry.child;
};

/**
 * Unblocks the Promise and fulfills it with the given value.
 *
 * @param {TYPE} value
 * @private
 */
CancellablePromise.prototype.unblockAndFulfill_ = function (value) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.FULFILLED, value);
};

/**
 * Unblocks the Promise and rejects it with the given rejection reason.
 *
 * @param {*} reason
 * @private
 */
CancellablePromise.prototype.unblockAndReject_ = function (reason) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.REJECTED, reason);
};

/**
 * Attempts to resolve a Promise with a given resolution state and value. This
 * is a no-op if the given Promise has already been resolved.
 *
 * If the given result is a Thenable (such as another Promise), the Promise will
 * be resolved with the same state and result as the Thenable once it is itself
 * resolved.
 *
 * If the given result is not a Thenable, the Promise will be fulfilled or
 * rejected with that result based on the given state.
 *
 * @see http://promisesaplus.com/#the_promise_resolution_procedure
 *
 * @param {CancellablePromise.State_} state
 * @param {*} x The result to apply to the Promise.
 * @private
 */
CancellablePromise.prototype.resolve_ = function (state, x) {
  if (this.state_ !== CancellablePromise.State_.PENDING) {
    return;
  }

  if (this === x) {
    state = CancellablePromise.State_.REJECTED;
    x = new TypeError('CancellablePromise cannot resolve to itself');
  } else if (Thenable.isImplementedBy(x)) {
    x = /** @type {!Thenable} */x;
    this.state_ = CancellablePromise.State_.BLOCKED;
    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);
    return;
  } else if (isObject(x)) {
    try {
      var then = x.then;
      if (isFunction(then)) {
        this.tryThen_(x, then);
        return;
      }
    } catch (e) {
      state = CancellablePromise.State_.REJECTED;
      x = e;
    }
  }

  this.result_ = x;
  this.state_ = state;
  this.scheduleCallbacks_();

  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {
    CancellablePromise.addUnhandledRejection_(this, x);
  }
};

/**
 * Attempts to call the {@code then} method on an object in the hopes that it is
 * a Promise-compatible instance. This allows interoperation between different
 * Promise implementations, however a non-compliant object may cause a Promise
 * to hang indefinitely. If the {@code then} method throws an exception, the
 * dependent Promise will be rejected with the thrown value.
 *
 * @see http://promisesaplus.com/#point-70
 *
 * @param {Thenable} thenable An object with a {@code then} method that may be
 *     compatible with the Promise/A+ specification.
 * @param {!Function} then The {@code then} method of the Thenable object.
 * @private
 */
CancellablePromise.prototype.tryThen_ = function (thenable, then) {
  this.state_ = CancellablePromise.State_.BLOCKED;
  var promise = this;
  var called = false;

  var resolve = function resolve(value) {
    if (!called) {
      called = true;
      promise.unblockAndFulfill_(value);
    }
  };

  var reject = function reject(reason) {
    if (!called) {
      called = true;
      promise.unblockAndReject_(reason);
    }
  };

  try {
    then.call(thenable, resolve, reject);
  } catch (e) {
    reject(e);
  }
};

/**
 * Executes the pending callbacks of a resolved Promise after a timeout.
 *
 * Section 2.2.4 of the Promises/A+ specification requires that Promise
 * callbacks must only be invoked from a call stack that only contains Promise
 * implementation code, which we accomplish by invoking callback execution after
 * a timeout. If {@code startExecution_} is called multiple times for the same
 * Promise, the callback chain will be evaluated only once. Additional callbacks
 * may be added during the evaluation phase, and will be executed in the same
 * event loop.
 *
 * All Promises added to the waiting list during the same browser event loop
 * will be executed in one batch to avoid using a separate timeout per Promise.
 *
 * @private
 */
CancellablePromise.prototype.scheduleCallbacks_ = function () {
  if (!this.executing_) {
    this.executing_ = true;
    async.run(this.executeCallbacks_, this);
  }
};

/**
 * Executes all pending callbacks for this Promise.
 *
 * @private
 */
CancellablePromise.prototype.executeCallbacks_ = function () {
  while (this.callbackEntries_ && this.callbackEntries_.length) {
    var entries = this.callbackEntries_;
    this.callbackEntries_ = [];

    for (var i = 0; i < entries.length; i++) {
      this.executeCallback_(entries[i], this.state_, this.result_);
    }
  }
  this.executing_ = false;
};

/**
 * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}
 * or {@code onRejected} callback based on the resolved state of the Promise.
 *
 * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the
 *     onFulfilled and/or onRejected callbacks for this step.
 * @param {CancellablePromise.State_} state The resolution status of the Promise,
 *     either FULFILLED or REJECTED.
 * @param {*} result The resolved result of the Promise.
 * @private
 */
CancellablePromise.prototype.executeCallback_ = function (callbackEntry, state, result) {
  if (state === CancellablePromise.State_.FULFILLED) {
    callbackEntry.onFulfilled(result);
  } else {
    this.removeUnhandledRejection_();
    callbackEntry.onRejected(result);
  }
};

/**
 * Marks this rejected Promise as having being handled. Also marks any parent
 * Promises in the rejected state as handled. The rejection handler will no
 * longer be invoked for this Promise (if it has not been called already).
 *
 * @private
 */
CancellablePromise.prototype.removeUnhandledRejection_ = function () {
  var p;
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {
      clearTimeout(p.unhandledRejectionId_);
      p.unhandledRejectionId_ = 0;
    }
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
      p.hadUnhandledRejection_ = false;
    }
  }
};

/**
 * Marks this rejected Promise as unhandled. If no {@code onRejected} callback
 * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}
 * expires, the reason will be passed to the unhandled rejection handler. The
 * handler typically rethrows the rejection reason so that it becomes visible in
 * the developer console.
 *
 * @param {!CancellablePromise} promise The rejected Promise.
 * @param {*} reason The Promise rejection reason.
 * @private
 */
CancellablePromise.addUnhandledRejection_ = function (promise, reason) {
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    promise.unhandledRejectionId_ = setTimeout(function () {
      CancellablePromise.handleRejection_.call(null, reason);
    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    promise.hadUnhandledRejection_ = true;
    async.run(function () {
      if (promise.hadUnhandledRejection_) {
        CancellablePromise.handleRejection_.call(null, reason);
      }
    });
  }
};

/**
 * A method that is invoked with the rejection reasons for Promises that are
 * rejected but have no {@code onRejected} callbacks registered yet.
 * @type {function(*)}
 * @private
 */
CancellablePromise.handleRejection_ = async.throwException;

/**
 * Sets a handler that will be called with reasons from unhandled rejected
 * Promises. If the rejected Promise (or one of its descendants) has an
 * {@code onRejected} callback registered, the rejection will be considered
 * handled, and the rejection handler will not be called.
 *
 * By default, unhandled rejections are rethrown so that the error may be
 * captured by the developer console or a {@code window.onerror} handler.
 *
 * @param {function(*)} handler A function that will be called with reasons from
 *     rejected Promises. Defaults to {@code async.throwException}.
 */
CancellablePromise.setUnhandledRejectionHandler = function (handler) {
  CancellablePromise.handleRejection_ = handler;
};

/**
 * Error used as a rejection reason for canceled Promises.
 *
 * @param {string=} opt_message
 * @constructor
 * @extends {Error}
 * @final
 */
CancellablePromise.CancellationError = function (_Error) {
  inherits(_class, _Error);

  function _class(opt_message) {
    classCallCheck(this, _class);

    var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, opt_message));

    if (opt_message) {
      _this.message = opt_message;
    }
    return _this;
  }

  return _class;
}(Error);

/** @override */
CancellablePromise.CancellationError.prototype.name = 'cancel';

var Ajax = function () {
	function Ajax() {
		classCallCheck(this, Ajax);
	}

	createClass(Ajax, null, [{
		key: 'parseResponseHeaders',


		/**
   * XmlHttpRequest's getAllResponseHeaders() method returns a string of
   * response headers according to the format described on the spec:
   * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}.
   * This method parses that string into a user-friendly name/value pair
   * object.
   * @param {string} allHeaders All headers as string.
   * @return {!Array.<Object<string, string>>}
   */
		value: function parseResponseHeaders(allHeaders) {
			var headers = [];
			if (!allHeaders) {
				return headers;
			}
			var pairs = allHeaders.split('\r\n');
			for (var i = 0; i < pairs.length; i++) {
				var index = pairs[i].indexOf(': ');
				if (index > 0) {
					var name = pairs[i].substring(0, index);
					var value = pairs[i].substring(index + 2);
					headers.push({
						name: name,
						value: value
					});
				}
			}
			return headers;
		}

		/**
   * Requests the url using XMLHttpRequest.
   * @param {!string} url
   * @param {!string} method
   * @param {?string} body
   * @param {MultiMap=} opt_headers
   * @param {MultiMap=} opt_params
   * @param {number=} opt_timeout
   * @param {boolean=} opt_sync
   * @param {boolean=} opt_withCredentials
   * @return {Promise} Deferred ajax request.
   * @protected
   */

	}, {
		key: 'request',
		value: function request(url, method, body, opt_headers, opt_params, opt_timeout, opt_sync, opt_withCredentials) {
			url = url || '';
			method = method || 'GET';

			var request = new XMLHttpRequest();

			var promise = new CancellablePromise(function (resolve, reject) {
				request.onload = function () {
					if (request.aborted) {
						request.onerror();
						return;
					}
					resolve(request);
				};
				request.onerror = function () {
					var error = new Error('Request error');
					error.request = request;
					reject(error);
				};
			}).thenCatch(function (reason) {
				request.abort();
				throw reason;
			}).thenAlways(function () {
				clearTimeout(timeout);
			});

			if (opt_params) {
				url = new Uri(url).addParametersFromMultiMap(opt_params).toString();
			}

			request.open(method, url, !opt_sync);

			if (opt_withCredentials) {
				request.withCredentials = true;
			}

			if (opt_headers) {
				opt_headers.names().forEach(function (name) {
					request.setRequestHeader(name, opt_headers.getAll(name).join(', '));
				});
			}

			request.send(isDef(body) ? body : null);

			if (isDefAndNotNull(opt_timeout)) {
				var timeout = setTimeout(function () {
					promise.cancel('Request timeout');
				}, opt_timeout);
			}

			return promise;
		}
	}]);
	return Ajax;
}();

/**
 * Provides a convenient interface for data transport.
 * @interface
 */

var Transport = function () {
	function Transport() {
		classCallCheck(this, Transport);
	}

	createClass(Transport, [{
		key: 'send',


		/**
   * Sends a message for the specified client.
   * @param {!ClientRequest} clientRequest
   * @return {!Promise} Deferred request.
   */
		value: function send() {}
	}]);
	return Transport;
}();

/**
 * Represents a client message (e.g. a request or a response).
 */

var ClientMessage = function () {
	function ClientMessage() {
		classCallCheck(this, ClientMessage);

		this.headers_ = new MultiMap();
	}

	/**
  * Fluent getter and setter for request body.
  * @param {*=} opt_body Request body to be set. If none is given,
  *   the current value of the body will be returned.
  * @return {*} Returns request body if no body value was given. Otherwise
  *   returns the {@link ClientMessage} object itself, so calls can be chained.
  * @chainable Chainable when used as setter.
  */


	createClass(ClientMessage, [{
		key: 'body',
		value: function body(opt_body) {
			if (isDef(opt_body)) {
				this.body_ = opt_body;
				return this;
			}
			return this.body_;
		}

		/**
   * Adds a header. If a header with the same name already exists, it will not be
   * overwritten, but the new value will be stored as well. The order is preserved.
   * @param {string} name
   * @param {string} value
   * @chainable
   */

	}, {
		key: 'header',
		value: function header(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.headers_.set(name, value);
			return this;
		}

		/**
   * Fluent getter and setter for request headers.
   * @param {MultiMap|Object=} opt_headers Request headers list to
   *   be set. If none is given the current value of the headers will
   *   be returned.
   * @return {!MultiMap|ClientMessage} Returns map of request headers
   *   if no new value was given. Otherwise returns the {@link ClientMessage}
   *   object itself, so calls can be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'headers',
		value: function headers(opt_headers) {
			if (isDef(opt_headers)) {
				if (opt_headers instanceof MultiMap) {
					this.headers_ = opt_headers;
				} else {
					this.headers_.values = opt_headers;
				}
				return opt_headers;
			}
			return this.headers_;
		}

		/**
   * Removes the body.
   */

	}, {
		key: 'removeBody',
		value: function removeBody() {
			this.body_ = undefined;
		}
	}]);
	return ClientMessage;
}();

/**
 * Represents a client response object.
 * @extends {ClientMessage}
 */

var ClientResponse = function (_ClientMessage) {
	inherits(ClientResponse, _ClientMessage);

	function ClientResponse(clientRequest) {
		classCallCheck(this, ClientResponse);

		var _this = possibleConstructorReturn(this, (ClientResponse.__proto__ || Object.getPrototypeOf(ClientResponse)).call(this));

		if (!clientRequest) {
			throw new Error('Can\'t create response without request');
		}
		_this.clientRequest_ = clientRequest;
		return _this;
	}

	/**
  * Returns request that created this response.
  * @return {!ClientRequest}
  */


	createClass(ClientResponse, [{
		key: 'request',
		value: function request() {
			return this.clientRequest_;
		}

		/**
   * Fluent getter and setter for response status code.
   * @param {number=} opt_statusCode Request status code to be set. If none is given,
   *   the current status code value will be returned.
   * @return {!ClientMessage|number} Returns response status code if no new value was
   *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
   *   be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'statusCode',
		value: function statusCode(opt_statusCode) {
			if (isDef(opt_statusCode)) {
				this.statusCode_ = opt_statusCode;
				return this;
			}
			return this.statusCode_;
		}

		/**
   * Fluent getter and setter for response status text.
   * @param {string=} opt_statusText Request status text to be set. If none is given,
   *   the current status text value will be returned.
   * @return {!ClientMessage|number} Returns response status text if no new value was
   *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
   *   be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'statusText',
		value: function statusText(opt_statusText) {
			if (isDef(opt_statusText)) {
				this.statusText_ = opt_statusText;
				return this;
			}
			return this.statusText_;
		}

		/**
   * Checks if response succeeded. Any status code 2xx or 3xx is considered valid.
   * @return {boolean}
   */

	}, {
		key: 'succeeded',
		value: function succeeded() {
			return this.statusCode() >= 200 && this.statusCode() <= 399;
		}
	}]);
	return ClientResponse;
}(ClientMessage);

/**
 * The implementation of an ajax transport to be used with {@link WeDeploy}.
 * @extends {Transport}
 */

var AjaxTransport = function (_Transport) {
	inherits(AjaxTransport, _Transport);

	function AjaxTransport() {
		classCallCheck(this, AjaxTransport);
		return possibleConstructorReturn(this, (AjaxTransport.__proto__ || Object.getPrototypeOf(AjaxTransport)).apply(this, arguments));
	}

	createClass(AjaxTransport, [{
		key: 'send',

		/**
   * @inheritDoc
   */
		value: function send(clientRequest) {
			var deferred = Ajax.request(clientRequest.url(), clientRequest.method(), clientRequest.body(), clientRequest.headers(), clientRequest.params(), null, false, clientRequest.withCredentials());

			return deferred.then(function (response) {
				var clientResponse = new ClientResponse(clientRequest);
				clientResponse.body(response.responseText);
				clientResponse.statusCode(response.status);
				clientResponse.statusText(response.statusText);
				Ajax.parseResponseHeaders(response.getAllResponseHeaders()).forEach(function (header) {
					clientResponse.header(header.name, header.value);
				});
				return clientResponse;
			});
		}
	}]);
	return AjaxTransport;
}(Transport);

/**
 * Provides a factory for data transport.
 */

var TransportFactory = function () {
	function TransportFactory() {
		classCallCheck(this, TransportFactory);

		this.transports = {};
		this.transports[TransportFactory.DEFAULT_TRANSPORT_NAME] = TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME];
	}

	/**
  * Returns {@link TransportFactory} instance.
  */


	createClass(TransportFactory, [{
		key: 'get',


		/**
   * Gets an instance of the transport implementation with the given name.
   * @param {string} implementationName
   * @return {!Transport}
   */
		value: function get(implementationName) {
			var TransportClass = this.transports[implementationName];

			if (!TransportClass) {
				throw new Error('Invalid transport name: ' + implementationName);
			}

			try {
				return new TransportClass();
			} catch (err) {
				throw new Error('Can\'t create transport', err);
			}
		}

		/**
   * Returns the default transport implementation.
   * @return {!Transport}
   */

	}, {
		key: 'getDefault',
		value: function getDefault() {
			return this.get(TransportFactory.DEFAULT_TRANSPORT_NAME);
		}
	}], [{
		key: 'instance',
		value: function instance() {
			if (!TransportFactory.instance_) {
				TransportFactory.instance_ = new TransportFactory();
			}
			return TransportFactory.instance_;
		}
	}]);
	return TransportFactory;
}();

TransportFactory.DEFAULT_TRANSPORT_NAME = 'default';

TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME] = AjaxTransport;

/**
 * Represents a client request object.
 * @extends {ClientMessage}
 */

var ClientRequest = function (_ClientMessage) {
	inherits(ClientRequest, _ClientMessage);

	function ClientRequest() {
		classCallCheck(this, ClientRequest);

		var _this = possibleConstructorReturn(this, (ClientRequest.__proto__ || Object.getPrototypeOf(ClientRequest)).call(this));

		_this.params_ = new MultiMap();
		_this.withCredentials_ = true;
		return _this;
	}

	/**
  * Fluent getter and setter for with credentials option.
  * @param {boolean=} opt_withCredentials
  * @chainable Chainable when used as setter.
  */


	createClass(ClientRequest, [{
		key: 'withCredentials',
		value: function withCredentials(opt_withCredentials) {
			if (isDef(opt_withCredentials)) {
				this.withCredentials_ = !!opt_withCredentials;
				return this;
			}
			return this.withCredentials_;
		}

		/**
   * Fluent getter and setter for request method.
   * @param {string=} opt_method Request method to be set. If none is given,
   *   the current method value will be returned.
   * @return {!ClientMessage|string} Returns request method if no new value was
   *   given. Otherwise returns the {@link ClientMessage} object itself, so
   *   calls can be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'method',
		value: function method(opt_method) {
			if (isDef(opt_method)) {
				this.method_ = opt_method;
				return this;
			}
			return this.method_ || ClientRequest.DEFAULT_METHOD;
		}

		/**
   * Adds a query. If a query with the same name already exists, it will not
   * be overwritten, but new value will be stored as well. The order is preserved.
   * @param {string} name
   * @param {string} value
   * @chainable
   */

	}, {
		key: 'param',
		value: function param(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.params_.set(name, value);
			return this;
		}

		/**
   * Fluent getter and setter for request querystring.
   * @param {MultiMap|Object=} opt_params Request querystring map to be set.
   *   If none is given the current value of the params will be returned.
   * @return {!MultiMap|ClientMessage} Returns map of request querystring if
   *   no new value was given. Otherwise returns the {@link ClientMessage}
   *   object itself, so calls can be chained.
   */

	}, {
		key: 'params',
		value: function params(opt_params) {
			if (isDef(opt_params)) {
				if (opt_params instanceof MultiMap) {
					this.params_ = opt_params;
				} else {
					this.params_.values = opt_params;
				}
				return opt_params;
			}
			return this.params_;
		}

		/**
   * Fluent getter and setter for request url.
   * @param {string=} opt_url Request url to be set. If none is given,
   *   the current value of the url will be returned.
   * @return {!ClientMessage|string} Returns request url if no new value was given.
   *   Otherwise returns the {@link ClientMessage} object itself, so calls can be
   *   chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'url',
		value: function url(opt_url) {
			if (isDef(opt_url)) {
				this.url_ = opt_url;
				return this;
			}
			return this.url_;
		}
	}]);
	return ClientRequest;
}(ClientMessage);

ClientRequest.DEFAULT_METHOD = 'GET';

var io;

// Optimistic initialization of `io` reference from global `globals.window.io`.
if (typeof globals.window !== 'undefined') {
	io = globals.window.io;
}

/**
 * The main class for making api requests. Sending requests returns a promise
 * that is resolved when the response arrives. Usage example:
 * ```javascript
 * WeDeploy
 *   .url('/data/tasks')
 *   .post({desc: 'Buy milkl'})
 *   .then(function(response) {
 *     // Handle response here.
 *     console.log(response.body())
 *   });
 * ```
 */

var WeDeploy$1 = function () {
	/**
  * WeDeploy constructor function.
  * @param {string} url The base url.
  * @param {...string} paths Any amount of paths to be appended to the base
  * url.
  * @constructor
  */
	function WeDeploy(url) {
		for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			paths[_key - 1] = arguments[_key];
		}

		classCallCheck(this, WeDeploy);

		if (arguments.length === 0) {
			throw new Error('Invalid arguments, try `new WeDeploy(baseUrl, url)`');
		}

		this.auth_ = null;
		this.body_ = null;
		this.url_ = Uri.joinPaths.apply(Uri, [url || ''].concat(paths));
		this.headers_ = new MultiMap();
		this.params_ = new MultiMap();
		this.withCredentials_ = true;

		this.header('Content-Type', 'application/json');
		this.header('X-Requested-With', 'XMLHttpRequest');
	}

	/**
  * Static factory for creating WeDeploy data for the given url.
  * @param {string=} opt_dataUrl The url that points to the data services.
  * @return @return {data} WeDeploy data instance.
  */


	createClass(WeDeploy, [{
		key: 'auth',


		/**
   * Adds authorization information to this request.
   * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
   * an authorization token, or the email.
   * @param {string=} opt_password If a email is given as the first param,
   * this should be the password.
   * @chainable
   */
		value: function auth(authOrTokenOrEmail, opt_password) {
			this.auth_ = authOrTokenOrEmail;
			if (!(this.auth_ instanceof Auth)) {
				this.auth_ = Auth.create(authOrTokenOrEmail, opt_password);
			}
			return this;
		}

		/**
   * Static factory for creating WeDeploy auth for the given url.
   * @param {string=} opt_authUrl The url that points to the auth service.
   */

	}, {
		key: 'body',


		/**
   * Sets the body that will be sent with this request.
   * @param {*} body
   * @chainable
   */
		value: function body(_body) {
			this.body_ = _body;
			return this;
		}

		/**
   * Converts the given body object to query params.
   * @param {!ClientRequest} clientRequest Client request.
   * @param {*} body
   * @protected
   */

	}, {
		key: 'convertBodyToParams_',
		value: function convertBodyToParams_(clientRequest, body) {
			if (isString(body)) {
				body = {
					body: body
				};
			} else if (body instanceof Embodied) {
				body = body.body();
			}
			Object.keys(body || {}).forEach(function (name) {
				return clientRequest.param(name, body[name]);
			});
		}

		/**
   * Creates client request and encode.
   * @param {string} method
   * @param {*} body
   * @return {!ClientRequest} Client request.
   * @protected
   */

	}, {
		key: 'createClientRequest_',
		value: function createClientRequest_(method, body) {
			var clientRequest = new ClientRequest();

			clientRequest.body(body || this.body_);

			if (!isDefAndNotNull(clientRequest.body())) {
				if (this.formData_) {
					clientRequest.body(this.formData_);
				}
			}

			clientRequest.method(method);
			clientRequest.headers(this.headers());
			clientRequest.params(this.params());
			clientRequest.url(this.url());
			clientRequest.withCredentials(this.withCredentials_);

			this.encode(clientRequest);

			return clientRequest;
		}

		/**
   * Decodes clientResponse body, parsing the body for example.
   * @param {!ClientResponse} clientResponse The response object to be
   * decoded.
   * @return {!ClientResponse} The decoded response.
   */

	}, {
		key: 'decode',
		value: function decode(clientResponse) {
			if (WeDeploy.isContentTypeJson(clientResponse)) {
				try {
					clientResponse.body(JSON.parse(clientResponse.body()));
				} catch (err) {}
			}
			return clientResponse;
		}

		/**
   * Sends message with the DELETE http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'delete',
		value: function _delete(opt_body) {
			return this.sendAsync('DELETE', opt_body);
		}

		/**
   * Encodes the given {@link ClientRequest}, converting its body to an
   * appropriate format for example.
   * @param {!ClientRequest} clientRequest The request object to encode.
   * @return {!ClientRequest} The encoded request.
   */

	}, {
		key: 'encode',
		value: function encode(clientRequest) {
			var body = clientRequest.body();

			if (isElement(body)) {
				body = new FormData(body);
				clientRequest.body(body);
			}

			body = this.maybeWrapWithQuery_(body);
			if (clientRequest.method() === 'GET') {
				this.convertBodyToParams_(clientRequest, body);
				clientRequest.removeBody();
				body = null;
			}

			if (typeof FormData !== 'undefined' && body instanceof FormData) {
				clientRequest.headers().remove('content-type');
			} else if (body instanceof Embodied) {
				clientRequest.body(body.toString());
			} else if (WeDeploy.isContentTypeJson(clientRequest)) {
				clientRequest.body(JSON.stringify(clientRequest.body()));
			}

			this.encodeParams_(clientRequest);
			this.resolveAuthentication_(clientRequest);

			return clientRequest;
		}

		/**
   * Encodes the params for the given request, according to their types.
   * @param {!ClientRequest} clientRequest
   * @protected
   */

	}, {
		key: 'encodeParams_',
		value: function encodeParams_(clientRequest) {
			var params = clientRequest.params();
			params.names().forEach(function (name) {
				var values = params.getAll(name);
				values.forEach(function (value, index) {
					if (value instanceof Embodied) {
						value = value.toString();
					} else if (isObject(value) || value instanceof Array) {
						value = JSON.stringify(value);
					}
					values[index] = value;
				});
			});
		}

		/**
   * Adds a key/value pair to be sent via the body in a `multipart/form-data` format.
   * If the body is set by other means (for example, through the `body` method), this
   * will be ignored.
   * @param {string} name
   * @param {*} value
   * @chainable
   */

	}, {
		key: 'form',
		value: function form(name, value) {
			if (typeof FormData === 'undefined') {
				throw new Error('form() is only available when FormData API is available.');
			}

			if (!this.formData_) {
				this.formData_ = new FormData();
			}
			this.formData_.append(name, value);
			return this;
		}

		/**
   * Sends message with the GET http verb.
   * @param {*=} opt_params Params to be added to the request url.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'get',
		value: function get(opt_params) {
			return this.sendAsync('GET', opt_params);
		}

		/**
   * Adds a header. If the header with the same name already exists, it will
   * not be overwritten, but new value will be stored. The order is preserved.
   * @param {string} name Header key.
   * @param {*} value Header value.
   * @chainable
   */

	}, {
		key: 'header',
		value: function header(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.headers_.set(name, value);
			return this;
		}

		/**
   * Gets the headers.
   * @return {!MultiMap}
   */

	}, {
		key: 'headers',
		value: function headers() {
			return this.headers_;
		}

		/**
   * Wraps the given `Embodied` instance with a {@link Query} instance if needed.
   * @param {Embodied} embodied
   * @return {Embodied}
   * @protected
   */

	}, {
		key: 'maybeWrapWithQuery_',
		value: function maybeWrapWithQuery_(embodied) {
			if (embodied instanceof Filter) {
				embodied = Query.filter(embodied);
			}
			return embodied;
		}

		/**
   * Adds a query. If the query with the same name already exists, it will not
   * be overwritten, but new value will be stored. The order is preserved.
   * @param {string} name Param key.
   * @param {*} value Param value.
   * @chainable
   */

	}, {
		key: 'param',
		value: function param(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.params_.set(name, value);
			return this;
		}

		/**
   * Gets the query strings map.
   * @return {!MultiMap}
   */

	}, {
		key: 'params',
		value: function params() {
			return this.params_;
		}

		/**
   * Sends message with the PATCH http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'patch',
		value: function patch(opt_body) {
			return this.sendAsync('PATCH', opt_body);
		}

		/**
   * Creates a new {@link WeDeploy} instance for handling the url resulting in the
   * union of the current url with the given paths.
   * @param {...string} paths Any number of paths.
   * @return {!WeDeploy} A new {@link WeDeploy} instance for handling the given paths.
   */

	}, {
		key: 'path',
		value: function path() {
			for (var _len2 = arguments.length, paths = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				paths[_key2] = arguments[_key2];
			}

			var wedeployClient = new (Function.prototype.bind.apply(WeDeploy, [null].concat([this.url()], paths)))();

			if (isDefAndNotNull(this.auth_)) {
				wedeployClient.auth(this.auth_);
			}

			return wedeployClient.use(this.customTransport_);
		}

		/**
   * Sends message with the POST http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'post',
		value: function post(opt_body) {
			return this.sendAsync('POST', opt_body);
		}

		/**
   * Sends message with the PUT http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'put',
		value: function put(opt_body) {
			return this.sendAsync('PUT', opt_body);
		}

		/**
   * Adds the authentication information to the request.
   * @param {!ClientRequest} clientRequest
   * @protected
   */

	}, {
		key: 'resolveAuthentication_',
		value: function resolveAuthentication_(clientRequest) {
			if (!this.auth_) {
				return;
			}
			if (this.auth_.hasToken()) {
				clientRequest.header('Authorization', 'Bearer ' + this.auth_.token);
			} else {
				var credentials = this.auth_.email + ':' + this.auth_.password;
				clientRequest.header('Authorization', 'Basic ' + Base64.encodeString(credentials));
			}
		}

		/**
   * Uses transport to send request with given method name and body
   * asynchronously.
   * @param {string} method The HTTP method to be used when sending data.
   * @param {string} body Content to be sent as the request's body.
   * @return {!CancellablePromise} Deferred request.
   */

	}, {
		key: 'sendAsync',
		value: function sendAsync(method, body) {
			var transport = this.customTransport_ || TransportFactory.instance().getDefault();

			var clientRequest = this.createClientRequest_(method, body);

			return transport.send(clientRequest).then(this.decode);
		}

		/**
   * Sets the socket transport
   * @param {Object} socket implementation object.
   */

	}, {
		key: 'url',


		/**
   * Returns the URL used by this client.
   */
		value: function url() {
			return this.url_;
		}

		/**
   * Specifies {@link Transport} implementation.
   * @param {!Transport} transport The transport implementation that should be
   * used.
   */

	}, {
		key: 'use',
		value: function use(transport) {
			this.customTransport_ = transport;
			return this;
		}

		/**
   * Creates new socket.io instance. The parameters passed to socket.io
   * constructor will be provided:
   *
   * ```javascript
   * WeDeploy.url('http://domain:8080/path/a').watch({id: 'myId'}, {foo: true});
   * // Equals:
   * io('domain:8080/?url=path%2Fa%3Fid%3DmyId', {foo: true});
   * ```
   *
   * @param {Object=} opt_params Params to be sent with the Socket IO request.
   * @param {Object=} opt_options Object with Socket IO options.
   * @return {!io} Socket IO reference. Server events can be listened on it.
   */

	}, {
		key: 'watch',
		value: function watch(opt_params, opt_options) {
			if (typeof io === 'undefined') {
				throw new Error('Socket.io client not loaded');
			}

			var clientRequest = this.createClientRequest_('GET', opt_params);
			var uri = new Uri(clientRequest.url());
			uri.addParametersFromMultiMap(clientRequest.params());

			opt_options = opt_options || {
				forceNew: true
			};
			opt_options.query = 'url=' + encodeURIComponent(uri.getPathname() + uri.getSearch());
			opt_options.path = opt_options.path || uri.getPathname();

			return io(uri.getHost(), opt_options);
		}

		/**
   * @param {boolean} opt_withCredentials
   */

	}, {
		key: 'withCredentials',
		value: function withCredentials(_withCredentials) {
			this.withCredentials_ = !!_withCredentials;
			return this;
		}
	}], [{
		key: 'data',
		value: function data(opt_dataUrl) {
			assertUriWithNoPath(opt_dataUrl, 'The data url should not have a path');

			if (isString(opt_dataUrl)) {
				WeDeploy.dataUrl_ = opt_dataUrl;
			}

			var data = new DataApiHelper(WeDeploy);

			data.auth(WeDeploy.auth().currentUser);

			return data;
		}
	}, {
		key: 'auth',
		value: function auth(opt_authUrl) {
			if (isString(opt_authUrl)) {
				WeDeploy.authUrl_ = opt_authUrl;
			}
			if (!WeDeploy.auth_) {
				WeDeploy.auth_ = new AuthApiHelper(WeDeploy);
			}
			return WeDeploy.auth_;
		}
	}, {
		key: 'socket',
		value: function socket(_socket) {
			io = _socket;
		}

		/**
   * Static factory for creating WeDeploy client for the given url.
   * @param {string} url The url that the client should use for sending requests.
   */

	}, {
		key: 'url',
		value: function url(_url) {
			return new WeDeploy(_url).use(this.customTransport_);
		}
	}]);
	return WeDeploy;
}();

WeDeploy$1.isContentTypeJson = function (clientMessage) {
	var contentType = clientMessage.headers().get('content-type') || '';
	return contentType.indexOf('application/json') === 0;
};

WeDeploy$1.auth_ = null;
WeDeploy$1.authUrl_ = '';
WeDeploy$1.data_ = null;
WeDeploy$1.dataUrl_ = '';

globals.window.Filter = Filter;
globals.window.Geo = Geo;
globals.window.Query = Query;
globals.window.Range = Range;
globals.window.WeDeploy = WeDeploy$1;

exports.Filter = Filter;
exports.Geo = Geo;
exports.Query = Query;
exports.Range = Range;
exports.WeDeploy = WeDeploy$1;
exports['default'] = WeDeploy$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));



//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNvY2tldC5pby5qcyIsInNyYy9nbG9iYWxzL2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL2NvcmVOYW1lZC5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC9zcmMvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC9zcmMvYXJyYXkvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL2FzeW5jL2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsL3NyYy9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL29iamVjdC9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL3N0cmluZy9zdHJpbmcuanMiLCJzcmMvYXBpLXF1ZXJ5L0VtYm9kaWVkLmpzIiwic3JjL2FwaS1xdWVyeS9GaWx0ZXJCb2R5LmpzIiwic3JjL2FwaS1xdWVyeS9HZW8uanMiLCJzcmMvYXBpLXF1ZXJ5L1JhbmdlLmpzIiwic3JjL2FwaS1xdWVyeS9GaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtdXJpL3NyYy9wYXJzZUZyb21BbmNob3IuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtdXJpL3NyYy9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1zdHJ1Y3RzL3NyYy9NdWx0aU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1zdHJ1Y3RzL3NyYy9UcmVlTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC11cmkvc3JjL1VyaS5qcyIsInNyYy9hcGkvYXNzZXJ0aW9ucy5qcyIsInNyYy9hcGkvYXV0aC9BdXRoLmpzIiwic3JjL2FwaS9BcGlIZWxwZXIuanMiLCJzcmMvYXBpL2F1dGgvQXV0aFByb3ZpZGVyLmpzIiwic3JjL2FwaS9hdXRoL0ZhY2Vib29rQXV0aFByb3ZpZGVyLmpzIiwic3JjL2FwaS9hdXRoL0dpdGh1YkF1dGhQcm92aWRlci5qcyIsInNyYy9hcGkvYXV0aC9Hb29nbGVBdXRoUHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtc3RvcmFnZS9zcmMvbWVjaGFuaXNtL1N0b3JhZ2VNZWNoYW5pc20uanMiLCJub2RlX21vZHVsZXMvbWV0YWwtc3RvcmFnZS9zcmMvU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1zdG9yYWdlL3NyYy9tZWNoYW5pc20vTG9jYWxTdG9yYWdlTWVjaGFuaXNtLmpzIiwic3JjL2FwaS9hdXRoL0F1dGhBcGlIZWxwZXIuanMiLCJzcmMvYXBpLXF1ZXJ5L0FnZ3JlZ2F0aW9uLmpzIiwic3JjL2FwaS1xdWVyeS9RdWVyeS5qcyIsInNyYy9hcGkvZGF0YS9EYXRhQXBpSGVscGVyLmpzIiwic3JjL2NyeXB0L0Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1wcm9taXNlL3NyYy9wcm9taXNlL1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtYWpheC9zcmMvQWpheC5qcyIsInNyYy9hcGkvVHJhbnNwb3J0LmpzIiwic3JjL2FwaS9DbGllbnRNZXNzYWdlLmpzIiwic3JjL2FwaS9DbGllbnRSZXNwb25zZS5qcyIsInNyYy9hcGkvYnJvd3Nlci9BamF4VHJhbnNwb3J0LmpzIiwic3JjL2FwaS9UcmFuc3BvcnRGYWN0b3J5LmpzIiwic3JjL2FwaS9DbGllbnRSZXF1ZXN0LmpzIiwic3JjL2FwaS9XZURlcGxveS5qcyIsInNyYy9lbnYvYnJvd3Nlci5qcyJdLCJuYW1lcyI6WyJnbG9iYWxzIiwid2luZG93IiwiZG9jdW1lbnQiLCJjb21wYXRpYmlsaXR5TW9kZURhdGFfIiwidW5pcXVlSWRDb3VudGVyXyIsIlVJRF9QUk9QRVJUWSIsIk1hdGgiLCJyYW5kb20iLCJhYnN0cmFjdE1ldGhvZCIsIkVycm9yIiwiY29sbGVjdFN1cGVyQ2xhc3Nlc1Byb3BlcnR5IiwiY29uc3RydWN0b3IiLCJwcm9wZXJ0eU5hbWUiLCJwcm9wZXJ0eVZhbHVlcyIsIl9fcHJvdG9fXyIsImlzUHJvdG90eXBlT2YiLCJGdW5jdGlvbiIsInB1c2giLCJkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUiLCJlbmFibGVDb21wYXRpYmlsaXR5TW9kZSIsIm9wdF9kYXRhIiwiZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhIiwiX19NRVRBTF9DT01QQVRJQklMSVRZX18iLCJnZXRGdW5jdGlvbk5hbWUiLCJmbiIsIm5hbWUiLCJzdHIiLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsImluZGV4T2YiLCJnZXRVaWQiLCJvcHRfb2JqZWN0Iiwib3B0X25vSW5oZXJpdGFuY2UiLCJpZCIsImhhc093blByb3BlcnR5IiwiaWRlbnRpdHlGdW5jdGlvbiIsIm9wdF9yZXR1cm5WYWx1ZSIsImlzQm9vbGVhbiIsInZhbCIsImlzRGVmIiwidW5kZWZpbmVkIiwiaXNEZWZBbmROb3ROdWxsIiwiaXNOdWxsIiwiaXNEb2N1bWVudCIsIm5vZGVUeXBlIiwiaXNFbGVtZW50IiwiaXNGdW5jdGlvbiIsImlzTnVtYmVyIiwiaXNXaW5kb3ciLCJpc09iamVjdCIsInR5cGUiLCJpc1Byb21pc2UiLCJ0aGVuIiwiaXNTdHJpbmciLCJTdHJpbmciLCJtZXJnZVN1cGVyQ2xhc3Nlc1Byb3BlcnR5Iiwib3B0X21lcmdlRm4iLCJtZXJnZWROYW1lIiwibWVyZ2VkIiwibnVsbEZ1bmN0aW9uIiwiYXJyYXkiLCJhcnIxIiwiYXJyMiIsImxlbmd0aCIsImkiLCJhcnIiLCJvcHRfb3V0cHV0Iiwib3V0cHV0IiwiQXJyYXkiLCJpc0FycmF5IiwiZmxhdHRlbiIsIm9iaiIsInJ2IiwicmVtb3ZlQXQiLCJwcm90b3R5cGUiLCJzcGxpY2UiLCJjYWxsIiwic3RhcnQiLCJvcHRfZW5kIiwic2xpY2VkIiwiZW5kIiwiYXN5bmMiLCJ0aHJvd0V4Y2VwdGlvbiIsImV4Y2VwdGlvbiIsIm5leHRUaWNrIiwicnVuIiwiY2FsbGJhY2siLCJvcHRfY29udGV4dCIsIndvcmtRdWV1ZVNjaGVkdWxlZF8iLCJwcm9jZXNzV29ya1F1ZXVlIiwid29ya1F1ZXVlXyIsIldvcmtJdGVtXyIsIndvcmtJdGVtcyIsIndvcmtJdGVtIiwic2NvcGUiLCJlIiwiY2IiLCJiaW5kIiwid3JhcENhbGxiYWNrXyIsInNldEltbWVkaWF0ZSIsInNldEltbWVkaWF0ZV8iLCJnZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8iLCJDaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3N0TWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJpZnJhbWUiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJkaXNwbGF5Iiwic3JjIiwiZG9jdW1lbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJ3aW4iLCJjb250ZW50V2luZG93IiwiZG9jIiwib3BlbiIsIndyaXRlIiwiY2xvc2UiLCJtZXNzYWdlIiwib3JpZ2luIiwibG9jYXRpb24iLCJwcm90b2NvbCIsImhvc3QiLCJvbm1lc3NhZ2UiLCJkYXRhIiwicG9ydDEiLCJwb3J0MiIsImNoYW5uZWwiLCJoZWFkIiwidGFpbCIsIm5leHQiLCJzY3JpcHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJEaXNwb3NhYmxlIiwiZGlzcG9zZWRfIiwiZGlzcG9zZUludGVybmFsIiwib2JqZWN0IiwidGFyZ2V0Iiwia2V5Iiwic291cmNlIiwiYXJndW1lbnRzIiwib3B0X29iaiIsInBhcnRzIiwic3BsaXQiLCJyZWR1Y2UiLCJwYXJ0IiwibWFwcGVkT2JqIiwia2V5cyIsIk9iamVjdCIsIm9iajEiLCJvYmoyIiwia2V5czEiLCJrZXlzMiIsInN0cmluZyIsInJlcGxhY2UiLCJ4IiwiZmxvb3IiLCJhYnMiLCJEYXRlIiwibm93IiwiaGFzaCIsImxlbiIsImNoYXJDb2RlQXQiLCJ2YWx1ZSIsIkVtYm9kaWVkIiwiYm9keV8iLCJKU09OIiwic3RyaW5naWZ5IiwiYm9keSIsIkZpbHRlckJvZHkiLCJmaWVsZCIsIm9wZXJhdG9yT3JWYWx1ZSIsIm9wdF92YWx1ZSIsImNvcmUiLCJjcmVhdGVCb2R5XyIsIm9wZXJhdG9yIiwib3B0X2ZpbHRlciIsImFkZEFycmF5T3BlcmF0b3JfIiwiZmlsdGVyIiwiZmlsdGVycyIsImFkZCIsIkdlbyIsInVwcGVyTGVmdCIsImxvd2VyUmlnaHQiLCJCb3VuZGluZ0JveCIsImNlbnRlciIsInJhZGl1cyIsIkNpcmNsZSIsInBvaW50cyIsIkxpbmUiLCJsYXQiLCJsb24iLCJQb2ludCIsIlBvbHlnb24iLCJtYXAiLCJ0b0JvZHkiLCJwb2ludCIsImNvb3JkaW5hdGVzIiwiYWRkQ29vcmRpbmF0ZXNfIiwiUmFuZ2UiLCJmcm9tIiwib3B0X3RvIiwidG8iLCJGaWx0ZXIiLCJmaWVsZE9yRmlsdGVyIiwib3B0X29wZXJhdG9yT3JWYWx1ZSIsInRvRmlsdGVyIiwiYWRkTWFueSIsImdldE9iamVjdCIsInZhbHVlcyIsInNsaWNlIiwiYm94T3JVcHBlckxlZnQiLCJvcHRfbG93ZXJSaWdodCIsInBvbHlnb24iLCJnZXRQb2ludHMiLCJsb2NhdGlvbk9yQ2lyY2xlIiwib3B0X3JhbmdlT3JEaXN0YW5jZSIsInJhbmdlIiwiZ2V0Q2VudGVyIiwiZ2V0UmFkaXVzIiwiZGlzdGFuY2VJbnRlcm5hbF8iLCJtaW4iLCJtYXgiLCJmaWVsZE9yUXVlcnkiLCJvcHRfcXVlcnlPckZ1enppbmVzcyIsIm9wdF9mdXp6aW5lc3MiLCJmdXp6eUludGVybmFsXyIsImFyZzJJc1N0cmluZyIsImZ1enppbmVzcyIsIkFMTCIsIm9wdF9xdWVyeSIsInF1ZXJ5IiwicmFuZ2VPck1pbiIsIm9wdF9tYXgiLCJzaGFwZXMiLCJzaGFwZSIsInBhcnNlRnJvbUFuY2hvciIsIm9wdF91cmkiLCJsaW5rIiwiaHJlZiIsImhvc3RuYW1lIiwicGFzc3dvcmQiLCJwYXRobmFtZSIsInBvcnQiLCJzZWFyY2giLCJ1c2VybmFtZSIsInBhcnNlIiwiVVJMIiwiY3JlYXRlIiwiTXVsdGlNYXAiLCJ0b0xvd2VyQ2FzZSIsInNpemUiLCJuYW1lcyIsInNldCIsIlRyZWVOb2RlIiwidmFsdWVfIiwicGFyZW50XyIsImNoaWxkcmVuXyIsImNoaWxkIiwic2V0UGFyZW50Iiwibm9kZSIsImN1cnJlbnQiLCJnZXRQYXJlbnQiLCJhbmNlc3RvcnMiLCJpbmRleCIsImdldENoaWxkcmVuIiwiRU1QVFlfQVJSQVkiLCJkZXB0aCIsInJvb3QiLCJnZXRDaGlsZENvdW50IiwicmVtb3ZlIiwicGFyZW50Iiwib3B0X3ByZW9yZGVyRm4iLCJvcHRfcG9zdG9yZGVyRm4iLCJmb3JFYWNoIiwidHJhdmVyc2UiLCJhc3NlcnRDaGlsZEhhc05vUGFyZW50IiwicGFyc2VGbl8iLCJVcmkiLCJ1cmwiLCJtYXliZUFkZFByb3RvY29sQW5kSG9zdG5hbWVfIiwibXVsdGltYXAiLCJnZXRBbGwiLCJhZGRQYXJhbWV0ZXJWYWx1ZSIsImVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfIiwicGFyYW0iLCJ1cmxEZWNvZGUiLCJnZXRIb3N0bmFtZSIsImdldFBvcnQiLCJIT1NUTkFNRV9QTEFDRUhPTERFUiIsImdldEhvc3QiLCJnZXRQcm90b2NvbCIsImdldCIsInF1ZXJ5c3RyaW5nIiwiZ2V0UGFyYW1ldGVyTmFtZXMiLCJnZXRQYXJhbWV0ZXJWYWx1ZXMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJjb250YWlucyIsInNldFBhcmFtZXRlclZhbHVlIiwiUkFORE9NX1BBUkFNIiwiZ2V0UmFuZG9tU3RyaW5nIiwiREVGQVVMVF9QUk9UT0NPTCIsImNoYXJBdCIsInJlbW92ZVBhcmFtZXRlciIsImdldFBhdGhuYW1lIiwiZ2V0U2VhcmNoIiwiZ2V0SGFzaCIsInBhcnNlZCIsInN1YnN0ciIsIm5vcm1hbGl6ZU9iamVjdCIsInBhcnNlRm4iLCJiYXNlUGF0aCIsInBhdGhzIiwicGF0aCIsImNvbmNhdCIsImpvaW4iLCJkZWNvZGVVUklDb21wb25lbnQiLCJhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQiLCJhc3NlcnREZWZBbmROb3ROdWxsIiwiZXJyb3JNZXNzYWdlIiwiYXNzZXJ0RnVuY3Rpb24iLCJhc3NlcnRPYmplY3QiLCJhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZCIsInJlc3BvbnNlIiwic3VjY2VlZGVkIiwiYXNzZXJ0VXNlclNpZ25lZEluIiwidXNlciIsImFzc2VydFVyaVdpdGhOb1BhdGgiLCJ1cmkiLCJBdXRoIiwidG9rZW5PckVtYWlsIiwib3B0X3Bhc3N3b3JkIiwidG9rZW4iLCJlbWFpbCIsImNyZWF0ZWRBdCIsInBob3RvVXJsIiwid2VkZXBsb3lDbGllbnQiLCJhdXRoVXJsXyIsImF1dGgiLCJwYXRjaCIsImRlbGV0ZSIsInRva2VuT3JVc2VybmFtZSIsIkFwaUhlbHBlciIsImF1dGhPclRva2VuT3JFbWFpbCIsImhlbHBlckF1dGhTY29wZSIsIkF1dGhQcm92aWRlciIsInByb3ZpZGVyIiwicHJvdmlkZXJTY29wZSIsInJlZGlyZWN0VXJpIiwib3B0X2F1dGhVcmwiLCJzZXRQYXRobmFtZSIsImhhc1Byb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJoYXNQcm92aWRlclNjb3BlIiwiZ2V0UHJvdmlkZXJTY29wZSIsImhhc1JlZGlyZWN0VXJpIiwiZ2V0UmVkaXJlY3RVcmkiLCJoYXNTY29wZSIsImdldFNjb3BlIiwiYXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsIiwiRmFjZWJvb2tBdXRoUHJvdmlkZXIiLCJQUk9WSURFUiIsIkdpdGh1YkF1dGhQcm92aWRlciIsIkdvb2dsZUF1dGhQcm92aWRlciIsIlN0b3JhZ2VNZWNoYW5pc20iLCJTdG9yYWdlIiwibWVjaGFuaXNtIiwiY2xlYXIiLCJqc29uIiwiRXJyb3JDb2RlIiwiSU5WQUxJRF9WQUxVRSIsImFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwiLCJhc3NlcnRNZWNoYW5pc21JbnRhbmNlT2YiLCJMb2NhbFN0b3JhZ2VNZWNoYW5pc20iLCJsb2NhbFN0b3JhZ2UiLCJzdG9yYWdlIiwiZ2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJzZXRJdGVtIiwiaXNTdXBwb3J0ZWQiLCJBdXRoQXBpSGVscGVyIiwiY3VycmVudFVzZXIiLCJvblNpZ25JbkNhbGxiYWNrIiwib25TaWduT3V0Q2FsbGJhY2siLCJwcm9jZXNzU2lnbkluXyIsInBvc3QiLCJtYWtlVXNlckF1dGhGcm9tRGF0YSIsImZyYWdtZW50IiwidXNlcklkIiwicmVzb2x2ZUF1dGhTY29wZSIsInNldFdlZGVwbG95Q2xpZW50Iiwic2V0Q3JlYXRlZEF0Iiwic2V0RW1haWwiLCJzZXRJZCIsInNldE5hbWUiLCJzZXRQaG90b1VybCIsInNldFRva2VuIiwicmVkaXJlY3RBY2Nlc3NUb2tlbiIsImdldFJlZGlyZWN0QWNjZXNzVG9rZW5fIiwicmVtb3ZlVXJsRnJhZ21lbnRDb21wbGV0ZWx5XyIsImxvYWRDdXJyZW50VXNlciIsIm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfIiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsInRpdGxlIiwiYWNjZXNzX3Rva2VuIiwic2V0UmVkaXJlY3RVcmkiLCJnZXRIcmVmV2l0aG91dEZyYWdtZW50XyIsIm1ha2VBdXRob3JpemF0aW9uVXJsIiwibWF5YmVDYWxsT25TaWduT3V0Q2FsbGJhY2tfIiwidW5sb2FkQ3VycmVudFVzZXJfIiwiYXNzZXJ0U3VwcG9ydGVkUHJvdmlkZXIiLCJBZ2dyZWdhdGlvbiIsImZpZWxkXyIsIm9wZXJhdG9yXyIsInJhbmdlcyIsIkRpc3RhbmNlQWdncmVnYXRpb24iLCJpbnRlcnZhbCIsIlJhbmdlQWdncmVnYXRpb24iLCJyYW5nZU9yRnJvbSIsInVuaXQiLCJRdWVyeSIsImFnZ3JlZ2F0aW9uT3JGaWVsZCIsIm9wdF9vcGVyYXRvciIsImFnZ3JlZ2F0aW9uIiwiZ2V0RmllbGQiLCJnZXRPcGVyYXRvciIsImdldFZhbHVlIiwib2Zmc2V0IiwiaGlnaGxpZ2h0IiwibGltaXQiLCJmaWx0ZXJPclRleHRPckZpZWxkIiwib3B0X3RleHRPck9wZXJhdG9yIiwibWF0Y2giLCJvcHRfZGlyZWN0aW9uIiwic29ydCIsInNvcnRFbnRyeSIsImFnZ3JlZ2F0ZSIsIkRhdGFBcGlIZWxwZXIiLCJnZXRPckNyZWF0ZUZpbHRlcl8iLCJhbmQiLCJvciIsImFyZ3MiLCJ3aGVyZSIsIm5vbmUiLCJzaW1pbGFyIiwibHQiLCJsdGUiLCJhbnkiLCJib3VuZGluZ0JveCIsImRpc3RhbmNlIiwiZ2V0T3JDcmVhdGVRdWVyeV8iLCJjb2xsZWN0aW9uIiwiZGF0YVVybF8iLCJwdXQiLCJhZGRGaWx0ZXJzVG9RdWVyeV8iLCJxdWVyeV8iLCJvblNlYXJjaF8iLCJvcHRfb3B0aW9ucyIsIndhdGNoIiwiZmlsdGVyXyIsInRvU2VhcmNoXyIsIkJhc2U2NCIsImJ0b2EiLCJCdWZmZXIiLCJUaGVuYWJsZSIsIklNUExFTUVOVEVEX0JZX1BST1AiLCJhZGRJbXBsZW1lbnRhdGlvbiIsImN0b3IiLCIkZ29vZ19UaGVuYWJsZSIsImlzSW1wbGVtZW50ZWRCeSIsInBhcnRpYWwiLCJuZXdBcmdzIiwiYXBwbHkiLCJDYW5jZWxsYWJsZVByb21pc2UiLCJyZXNvbHZlciIsInN0YXRlXyIsIlN0YXRlXyIsIlBFTkRJTkciLCJyZXN1bHRfIiwiY2FsbGJhY2tFbnRyaWVzXyIsImV4ZWN1dGluZ18iLCJVTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZIiwidW5oYW5kbGVkUmVqZWN0aW9uSWRfIiwiaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyIsInNlbGYiLCJyZXNvbHZlXyIsIkZVTEZJTExFRCIsInJlYXNvbiIsIlJFSkVDVEVEIiwiQ2FsbGJhY2tFbnRyeV8iLCJyZXNvbHZlIiwicmVqZWN0Iiwib3B0X3JlYXNvbiIsInJhY2UiLCJwcm9taXNlcyIsInByb21pc2UiLCJhbGwiLCJ0b0Z1bGZpbGwiLCJvbkZ1bGZpbGwiLCJvblJlamVjdCIsImZpcnN0RnVsZmlsbGVkIiwidG9SZWplY3QiLCJyZWFzb25zIiwib3B0X29uRnVsZmlsbGVkIiwib3B0X29uUmVqZWN0ZWQiLCJhZGRDaGlsZFByb21pc2VfIiwidGhlbkFsd2F5cyIsIm9uUmVzb2x2ZWQiLCJlcnIiLCJoYW5kbGVSZWplY3Rpb25fIiwiYWRkQ2FsbGJhY2tFbnRyeV8iLCJ0aGVuQ2F0Y2giLCJvblJlamVjdGVkIiwiY2F0Y2giLCJjYW5jZWwiLCJvcHRfbWVzc2FnZSIsIkNhbmNlbGxhdGlvbkVycm9yIiwiSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SIiwiY2FuY2VsSW50ZXJuYWxfIiwiY2FuY2VsQ2hpbGRfIiwiY2hpbGRQcm9taXNlIiwiY2hpbGRDb3VudCIsImNoaWxkSW5kZXgiLCJlbnRyeSIsImNhbGxiYWNrRW50cnkiLCJleGVjdXRlQ2FsbGJhY2tfIiwic2NoZWR1bGVDYWxsYmFja3NfIiwib25GdWxmaWxsZWQiLCJyZXN1bHQiLCJ1bmJsb2NrQW5kRnVsZmlsbF8iLCJCTE9DS0VEIiwidW5ibG9ja0FuZFJlamVjdF8iLCJzdGF0ZSIsIlR5cGVFcnJvciIsInRyeVRoZW5fIiwiYWRkVW5oYW5kbGVkUmVqZWN0aW9uXyIsInRoZW5hYmxlIiwiY2FsbGVkIiwiZXhlY3V0ZUNhbGxiYWNrc18iLCJlbnRyaWVzIiwicmVtb3ZlVW5oYW5kbGVkUmVqZWN0aW9uXyIsInAiLCJzZXRUaW1lb3V0Iiwic2V0VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlciIsImhhbmRsZXIiLCJBamF4IiwiYWxsSGVhZGVycyIsImhlYWRlcnMiLCJwYWlycyIsIm1ldGhvZCIsIm9wdF9oZWFkZXJzIiwib3B0X3BhcmFtcyIsIm9wdF90aW1lb3V0Iiwib3B0X3N5bmMiLCJvcHRfd2l0aENyZWRlbnRpYWxzIiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwiUHJvbWlzZSIsIm9ubG9hZCIsImFib3J0ZWQiLCJvbmVycm9yIiwiZXJyb3IiLCJhYm9ydCIsInRpbWVvdXQiLCJhZGRQYXJhbWV0ZXJzRnJvbU11bHRpTWFwIiwid2l0aENyZWRlbnRpYWxzIiwic2V0UmVxdWVzdEhlYWRlciIsInNlbmQiLCJUcmFuc3BvcnQiLCJDbGllbnRNZXNzYWdlIiwiaGVhZGVyc18iLCJvcHRfYm9keSIsIkNsaWVudFJlc3BvbnNlIiwiY2xpZW50UmVxdWVzdCIsImNsaWVudFJlcXVlc3RfIiwib3B0X3N0YXR1c0NvZGUiLCJzdGF0dXNDb2RlXyIsIm9wdF9zdGF0dXNUZXh0Iiwic3RhdHVzVGV4dF8iLCJzdGF0dXNDb2RlIiwiQWpheFRyYW5zcG9ydCIsImRlZmVycmVkIiwicGFyYW1zIiwiY2xpZW50UmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwicGFyc2VSZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJoZWFkZXIiLCJUcmFuc3BvcnRGYWN0b3J5IiwidHJhbnNwb3J0cyIsIkRFRkFVTFRfVFJBTlNQT1JUX05BTUUiLCJpbXBsZW1lbnRhdGlvbk5hbWUiLCJUcmFuc3BvcnRDbGFzcyIsImluc3RhbmNlXyIsIkNsaWVudFJlcXVlc3QiLCJwYXJhbXNfIiwid2l0aENyZWRlbnRpYWxzXyIsIm9wdF9tZXRob2QiLCJtZXRob2RfIiwiREVGQVVMVF9NRVRIT0QiLCJvcHRfdXJsIiwidXJsXyIsImlvIiwiV2VEZXBsb3kiLCJhdXRoXyIsImpvaW5QYXRocyIsImZvcm1EYXRhXyIsImVuY29kZSIsImlzQ29udGVudFR5cGVKc29uIiwic2VuZEFzeW5jIiwiRm9ybURhdGEiLCJtYXliZVdyYXBXaXRoUXVlcnlfIiwiY29udmVydEJvZHlUb1BhcmFtc18iLCJyZW1vdmVCb2R5IiwiZW5jb2RlUGFyYW1zXyIsInJlc29sdmVBdXRoZW50aWNhdGlvbl8iLCJhcHBlbmQiLCJlbWJvZGllZCIsInVzZSIsImN1c3RvbVRyYW5zcG9ydF8iLCJoYXNUb2tlbiIsImNyZWRlbnRpYWxzIiwiZW5jb2RlU3RyaW5nIiwidHJhbnNwb3J0IiwiaW5zdGFuY2UiLCJnZXREZWZhdWx0IiwiY3JlYXRlQ2xpZW50UmVxdWVzdF8iLCJkZWNvZGUiLCJvcHRfZGF0YVVybCIsInNvY2tldCIsImNsaWVudE1lc3NhZ2UiLCJjb250ZW50VHlwZSIsImRhdGFfIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVnUEEsSUFBSUEsVUFBVSxFQUFkOztBQUVBLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztTQUMxQkEsTUFBUixHQUFpQkEsTUFBakI7OztBQUdELElBQUksT0FBT0MsUUFBUCxLQUFvQixXQUF4QixFQUFxQztTQUM1QkEsUUFBUixHQUFtQkEsUUFBbkI7Q0FHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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RUFBa0JzVixHQUFsQixDQUFzQixLQUFLQyxnQkFBM0IsQ0FBUDs7Ozs7O0FBNkRGaEIsV0FBU0ssaUJBQVQsR0FBNkIsVUFBU3NCLGFBQVQsRUFBd0I7S0FDOUNDLGNBQWNELGNBQWNyRixPQUFkLEdBQXdCaFEsR0FBeEIsQ0FBNEIsY0FBNUIsS0FBK0MsRUFBbkU7UUFDT3NWLFlBQVlobUIsT0FBWixDQUFvQixrQkFBcEIsTUFBNEMsQ0FBbkQ7Q0FGRDs7QUFLQW9rQixXQUFTQyxLQUFULEdBQWlCLElBQWpCO0FBQ0FELFdBQVM3USxRQUFULEdBQW9CLEVBQXBCO0FBQ0E2USxXQUFTNkIsS0FBVCxHQUFpQixJQUFqQjtBQUNBN0IsV0FBU3pKLFFBQVQsR0FBb0IsRUFBcEIsQ0FFQTs7QUNwZUF4YyxRQUFRQyxNQUFSLENBQWU2TSxNQUFmLEdBQXdCQSxNQUF4QjtBQUNBOU0sUUFBUUMsTUFBUixDQUFldUwsR0FBZixHQUFxQkEsR0FBckI7QUFDQXhMLFFBQVFDLE1BQVIsQ0FBZXVhLEtBQWYsR0FBdUJBLEtBQXZCO0FBQ0F4YSxRQUFRQyxNQUFSLENBQWV5TSxLQUFmLEdBQXVCQSxLQUF2QjtBQUNBMU0sUUFBUUMsTUFBUixDQUFlZ21CLFFBQWYsR0FBMEJBLFVBQTFCLENBRUEsQUFDQSIsImZpbGUiOiJhcGkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpb1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJpb1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0dmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuXHQvKipcblx0ICogTWFuYWdlcnMgY2FjaGUuXG5cdCAqL1xuXG5cdHZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuXHQvKipcblx0ICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG5cdCAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG5cdCAqXG5cdCAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG5cdCAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG5cdCAqXG5cdCAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG5cdCAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG5cdCAgaWYgKCh0eXBlb2YgdXJpID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih1cmkpKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIG9wdHMgPSB1cmk7XG5cdCAgICB1cmkgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cblx0ICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG5cdCAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG5cdCAgdmFyIGlkID0gcGFyc2VkLmlkO1xuXHQgIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG5cdCAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcblx0ICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fCBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuXHQgIHZhciBpbztcblxuXHQgIGlmIChuZXdDb25uZWN0aW9uKSB7XG5cdCAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG5cdCAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKCFjYWNoZVtpZF0pIHtcblx0ICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuXHQgICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG5cdCAgICB9XG5cdCAgICBpbyA9IGNhY2hlW2lkXTtcblx0ICB9XG5cdCAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuXHQgICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcblx0ICB9IGVsc2UgaWYgKG9wdHMgJiYgJ29iamVjdCcgPT09IF90eXBlb2Yob3B0cy5xdWVyeSkpIHtcblx0ICAgIG9wdHMucXVlcnkgPSBlbmNvZGVRdWVyeVN0cmluZyhvcHRzLnF1ZXJ5KTtcblx0ICB9XG5cdCAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG5cdH1cblx0LyoqXG5cdCAqICBIZWxwZXIgbWV0aG9kIHRvIHBhcnNlIHF1ZXJ5IG9iamVjdHMgdG8gc3RyaW5nLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcXVlcnlcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZVF1ZXJ5U3RyaW5nKG9iaikge1xuXHQgIHZhciBzdHIgPSBbXTtcblx0ICBmb3IgKHZhciBwIGluIG9iaikge1xuXHQgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwKSkge1xuXHQgICAgICBzdHIucHVzaChlbmNvZGVVUklDb21wb25lbnQocCkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW3BdKSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBzdHIuam9pbignJicpO1xuXHR9XG5cdC8qKlxuXHQgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG5cdC8qKlxuXHQgKiBgY29ubmVjdGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG5cdC8qKlxuXHQgKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLk1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0ZXhwb3J0cy5Tb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBwYXJzZXVyaSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuXHQvKipcblx0ICogVVJMIHBhcnNlci5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybFxuXHQgKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cblx0ICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gdXJsKHVyaSwgbG9jKSB7XG5cdCAgdmFyIG9iaiA9IHVyaTtcblxuXHQgIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG5cdCAgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbjtcblx0ICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuXHQgIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuXHQgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuXHQgICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgwKSkge1xuXHQgICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG5cdCAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG5cdCAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG5cdCAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGxvYykge1xuXHQgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICAvLyBwYXJzZVxuXHQgICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcblx0ICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG5cdCAgfVxuXG5cdCAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG5cdCAgaWYgKCFvYmoucG9ydCkge1xuXHQgICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG5cdCAgICAgIG9iai5wb3J0ID0gJzgwJztcblx0ICAgIH0gZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG5cdCAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cblx0ICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG5cdCAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuXHQgIC8vIGRlZmluZSB1bmlxdWUgaWRcblx0ICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcblx0ICAvLyBkZWZpbmUgaHJlZlxuXHQgIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PT0gb2JqLnBvcnQgPyAnJyA6ICc6JyArIG9iai5wb3J0KTtcblxuXHQgIHJldHVybiBvYmo7XG5cdH1cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdCAqIFBhcnNlcyBhbiBVUklcblx0ICpcblx0ICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0dmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5cblx0dmFyIHBhcnRzID0gW1xuXHQgICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5cdF07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcblx0ICAgIHZhciBzcmMgPSBzdHIsXG5cdCAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXG5cdCAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cblx0ICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcblx0ICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcblx0ICAgICAgICB1cmkgPSB7fSxcblx0ICAgICAgICBpID0gMTQ7XG5cblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcblx0ICAgIH1cblxuXHQgICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuXHQgICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XG5cdCAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuXHQgICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG5cdCAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdXJpO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyoqXG5cdCAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cblx0ICpcblx0ICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuXHQgKi9cblxuXHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRleHBvcnRzLmxvZyA9IGxvZztcblx0ZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcblx0ZXhwb3J0cy5zYXZlID0gc2F2ZTtcblx0ZXhwb3J0cy5sb2FkID0gbG9hZDtcblx0ZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cdGV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcblx0ICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG5cdCAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcblx0ICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuXHQvKipcblx0ICogQ29sb3JzLlxuXHQgKi9cblxuXHRleHBvcnRzLmNvbG9ycyA9IFtcblx0ICAnbGlnaHRzZWFncmVlbicsXG5cdCAgJ2ZvcmVzdGdyZWVuJyxcblx0ICAnZ29sZGVucm9kJyxcblx0ICAnZG9kZ2VyYmx1ZScsXG5cdCAgJ2RhcmtvcmNoaWQnLFxuXHQgICdjcmltc29uJ1xuXHRdO1xuXG5cdC8qKlxuXHQgKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuXHQgKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cblx0ICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuXHQgKlxuXHQgKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuXHQgKi9cblxuXHRmdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdCAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0ICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG5cdCAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdCAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuXHQgICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG5cdCAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0ICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG5cdH1cblxuXHQvKipcblx0ICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuXHQgKi9cblxuXHRleHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcblx0ICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH07XG5cblxuXHQvKipcblx0ICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuXHQgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHQgIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuXHQgIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuXHQgICAgKyB0aGlzLm5hbWVzcGFjZVxuXHQgICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG5cdCAgICArIGFyZ3NbMF1cblx0ICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuXHQgICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0ICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cblx0ICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdCAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG5cdCAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0ICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdCAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdCAgdmFyIGluZGV4ID0gMDtcblx0ICB2YXIgbGFzdEMgPSAwO1xuXHQgIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuXHQgICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG5cdCAgICBpbmRleCsrO1xuXHQgICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG5cdCAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHQgICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHQgICAgICBsYXN0QyA9IGluZGV4O1xuXHQgICAgfVxuXHQgIH0pO1xuXG5cdCAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuXHQgIHJldHVybiBhcmdzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuXHQgKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBsb2coKSB7XG5cdCAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcblx0ICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuXHQgIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcblx0ICAgICYmIGNvbnNvbGUubG9nXG5cdCAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTYXZlIGBuYW1lc3BhY2VzYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHQgIHRyeSB7XG5cdCAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG5cdCAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcblx0ICAgIH1cblx0ICB9IGNhdGNoKGUpIHt9XG5cdH1cblxuXHQvKipcblx0ICogTG9hZCBgbmFtZXNwYWNlc2AuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxvYWQoKSB7XG5cdCAgdmFyIHI7XG5cdCAgdHJ5IHtcblx0ICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG5cdCAgfSBjYXRjaChlKSB7fVxuXHQgIHJldHVybiByO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG5cdCAqL1xuXG5cdGV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cblx0LyoqXG5cdCAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cblx0ICpcblx0ICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG5cdCAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG5cdCAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuXHQgIHRyeSB7XG5cdCAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcblx0ICB9IGNhdGNoIChlKSB7fVxuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxuXHQvKipcblx0ICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuXHQgKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuXHQgKlxuXHQgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG5cdCAqL1xuXG5cdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuXHRleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcblx0ZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcblx0ZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5cdGV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGV4cG9ydHMuaHVtYW5pemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0ICovXG5cblx0ZXhwb3J0cy5uYW1lcyA9IFtdO1xuXHRleHBvcnRzLnNraXBzID0gW107XG5cblx0LyoqXG5cdCAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0ICpcblx0ICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG5cdCAqL1xuXG5cdGV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuXHQgKi9cblxuXHR2YXIgcHJldkNvbG9yID0gMDtcblxuXHQvKipcblx0ICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cblx0ICovXG5cblx0dmFyIHByZXZUaW1lO1xuXG5cdC8qKlxuXHQgKiBTZWxlY3QgYSBjb2xvci5cblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG5cdCAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cblx0ICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuXHQgIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuXHQgIH1cblx0ICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cblx0ICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG5cdCAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuXHQgICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG5cdCAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHQgICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcblx0ICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdCAgICBzZWxmLmRpZmYgPSBtcztcblx0ICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHQgICAgc2VsZi5jdXJyID0gY3Vycjtcblx0ICAgIHByZXZUaW1lID0gY3VycjtcblxuXHQgICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcblx0ICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG5cdCAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuXHQgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG5cdCAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cblx0ICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcblx0ICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cblx0ICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG5cdCAgICB9XG5cblx0ICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdCAgICB2YXIgaW5kZXggPSAwO1xuXHQgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcblx0ICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHQgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcblx0ICAgICAgaW5kZXgrKztcblx0ICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHQgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuXHQgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcblx0ICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0ICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdCAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgIGluZGV4LS07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG1hdGNoO1xuXHQgICAgfSk7XG5cblx0ICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG5cdCAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG5cdCAgICB9XG5cdCAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuXHQgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdCAgfVxuXHQgIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cblx0ICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuXHQgIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuXHQgIHJldHVybiBmbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdCAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG5cdCAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdCAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHQgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cdCAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdCAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHQgIGV4cG9ydHMuZW5hYmxlKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHQgIHZhciBpLCBsZW47XG5cdCAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb2VyY2UgYHZhbGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQgKiBAcmV0dXJuIHtNaXhlZH1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0ICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdCAgcmV0dXJuIHZhbDtcblx0fVxuXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogSGVscGVycy5cblx0ICovXG5cblx0dmFyIHMgPSAxMDAwO1xuXHR2YXIgbSA9IHMgKiA2MDtcblx0dmFyIGggPSBtICogNjA7XG5cdHZhciBkID0gaCAqIDI0O1xuXHR2YXIgeSA9IGQgKiAzNjUuMjU7XG5cblx0LyoqXG5cdCAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG5cdCAqXG5cdCAqIE9wdGlvbnM6XG5cdCAqXG5cdCAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuXHQgIHJldHVybiBvcHRpb25zLmxvbmdcblx0ICAgID8gbG9uZyh2YWwpXG5cdCAgICA6IHNob3J0KHZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBwYXJzZShzdHIpIHtcblx0ICBzdHIgPSAnJyArIHN0cjtcblx0ICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG5cdCAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuXHQgIGlmICghbWF0Y2gpIHJldHVybjtcblx0ICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuXHQgIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG5cdCAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICBjYXNlICd5ZWFycyc6XG5cdCAgICBjYXNlICd5ZWFyJzpcblx0ICAgIGNhc2UgJ3lycyc6XG5cdCAgICBjYXNlICd5cic6XG5cdCAgICBjYXNlICd5Jzpcblx0ICAgICAgcmV0dXJuIG4gKiB5O1xuXHQgICAgY2FzZSAnZGF5cyc6XG5cdCAgICBjYXNlICdkYXknOlxuXHQgICAgY2FzZSAnZCc6XG5cdCAgICAgIHJldHVybiBuICogZDtcblx0ICAgIGNhc2UgJ2hvdXJzJzpcblx0ICAgIGNhc2UgJ2hvdXInOlxuXHQgICAgY2FzZSAnaHJzJzpcblx0ICAgIGNhc2UgJ2hyJzpcblx0ICAgIGNhc2UgJ2gnOlxuXHQgICAgICByZXR1cm4gbiAqIGg7XG5cdCAgICBjYXNlICdtaW51dGVzJzpcblx0ICAgIGNhc2UgJ21pbnV0ZSc6XG5cdCAgICBjYXNlICdtaW5zJzpcblx0ICAgIGNhc2UgJ21pbic6XG5cdCAgICBjYXNlICdtJzpcblx0ICAgICAgcmV0dXJuIG4gKiBtO1xuXHQgICAgY2FzZSAnc2Vjb25kcyc6XG5cdCAgICBjYXNlICdzZWNvbmQnOlxuXHQgICAgY2FzZSAnc2Vjcyc6XG5cdCAgICBjYXNlICdzZWMnOlxuXHQgICAgY2FzZSAncyc6XG5cdCAgICAgIHJldHVybiBuICogcztcblx0ICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG5cdCAgICBjYXNlICdtaWxsaXNlY29uZCc6XG5cdCAgICBjYXNlICdtc2Vjcyc6XG5cdCAgICBjYXNlICdtc2VjJzpcblx0ICAgIGNhc2UgJ21zJzpcblx0ICAgICAgcmV0dXJuIG47XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHNob3J0KG1zKSB7XG5cdCAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG5cdCAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG5cdCAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG5cdCAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG5cdCAgcmV0dXJuIG1zICsgJ21zJztcblx0fVxuXG5cdC8qKlxuXHQgKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxvbmcobXMpIHtcblx0ICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5Jylcblx0ICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuXHQgICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcblx0ICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG5cdCAgICB8fCBtcyArICcgbXMnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcblx0ICBpZiAobXMgPCBuKSByZXR1cm47XG5cdCAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG5cdCAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcblx0fVxuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ3NvY2tldC5pby1wYXJzZXInKTtcblx0dmFyIGpzb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHR2YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHR2YXIgYmluYXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdHZhciBpc0J1ZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5cdC8qKlxuXHQgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLnByb3RvY29sID0gNDtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGVzLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLnR5cGVzID0gW1xuXHQgICdDT05ORUNUJyxcblx0ICAnRElTQ09OTkVDVCcsXG5cdCAgJ0VWRU5UJyxcblx0ICAnQUNLJyxcblx0ICAnRVJST1InLFxuXHQgICdCSU5BUllfRVZFTlQnLFxuXHQgICdCSU5BUllfQUNLJ1xuXHRdO1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGV2ZW50YC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5FVkVOVCA9IDI7XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBhY2tgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkFDSyA9IDM7XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuRVJST1IgPSA0O1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG5cdC8qKlxuXHQgKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG5cdC8qKlxuXHQgKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG5cdC8qKlxuXHQgKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcblx0ICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcblx0ICogQHJldHVybiBDYWxscyBjYWxsYmFjayB3aXRoIEFycmF5IG9mIGVuY29kaW5nc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKXtcblx0ICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuXHQgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcblx0ICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG5cdCAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG5cdCAgdmFyIHN0ciA9ICcnO1xuXHQgIHZhciBuc3AgPSBmYWxzZTtcblxuXHQgIC8vIGZpcnN0IGlzIHR5cGVcblx0ICBzdHIgKz0gb2JqLnR5cGU7XG5cblx0ICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cblx0ICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG5cdCAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzO1xuXHQgICAgc3RyICs9ICctJztcblx0ICB9XG5cblx0ICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG5cdCAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG5cdCAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcblx0ICAgIG5zcCA9IHRydWU7XG5cdCAgICBzdHIgKz0gb2JqLm5zcDtcblx0ICB9XG5cblx0ICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcblx0ICBpZiAobnVsbCAhPSBvYmouaWQpIHtcblx0ICAgIGlmIChuc3ApIHtcblx0ICAgICAgc3RyICs9ICcsJztcblx0ICAgICAgbnNwID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBzdHIgKz0gb2JqLmlkO1xuXHQgIH1cblxuXHQgIC8vIGpzb24gZGF0YVxuXHQgIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG5cdCAgICBpZiAobnNwKSBzdHIgKz0gJywnO1xuXHQgICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcblx0ICB9XG5cblx0ICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcblx0ICByZXR1cm4gc3RyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuXHQgKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG5cdCAqIGEgbGlzdCBvZiBidWZmZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG5cdCAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcblx0ICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuXHQgICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuXHQgICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG5cdCAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG5cdCAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG5cdCAgfVxuXG5cdCAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG5cdH1cblxuXHQvKipcblx0ICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gRGVjb2RlcigpIHtcblx0ICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuXHQgKi9cblxuXHRFbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcblx0ICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgdmFyIHBhY2tldDtcblx0ICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuXHQgICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG5cdCAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG5cdCAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG5cblx0ICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcblx0ICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcblx0ICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG5cdCAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGVsc2UgaWYgKGlzQnVmKG9iaikgfHwgb2JqLmJhc2U2NCkgeyAvLyByYXcgYmluYXJ5IGRhdGFcblx0ICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcblx0ICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcblx0ICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIG9iaik7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcblx0ICB2YXIgcCA9IHt9O1xuXHQgIHZhciBpID0gMDtcblxuXHQgIC8vIGxvb2sgdXAgdHlwZVxuXHQgIHAudHlwZSA9IE51bWJlcihzdHIuY2hhckF0KDApKTtcblx0ICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG5cdCAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuXHQgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHAudHlwZSkge1xuXHQgICAgdmFyIGJ1ZiA9ICcnO1xuXHQgICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcblx0ICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG5cdCAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9ICctJykge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcblx0ICAgIH1cblx0ICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcblx0ICB9XG5cblx0ICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuXHQgIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcblx0ICAgIHAubnNwID0gJyc7XG5cdCAgICB3aGlsZSAoKytpKSB7XG5cdCAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcblx0ICAgICAgaWYgKCcsJyA9PSBjKSBicmVhaztcblx0ICAgICAgcC5uc3AgKz0gYztcblx0ICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIHAubnNwID0gJy8nO1xuXHQgIH1cblxuXHQgIC8vIGxvb2sgdXAgaWRcblx0ICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuXHQgIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuXHQgICAgcC5pZCA9ICcnO1xuXHQgICAgd2hpbGUgKCsraSkge1xuXHQgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG5cdCAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcblx0ICAgICAgICAtLWk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuXHQgICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcblx0ICAgIH1cblx0ICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG5cdCAgfVxuXG5cdCAgLy8gbG9vayB1cCBqc29uIGRhdGFcblx0ICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuXHQgICAgfSBjYXRjaChlKXtcblx0ICAgICAgcmV0dXJuIGVycm9yKCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdERlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG5cdCAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuXHQgKiBiZSBjb25zdHJ1Y3RlZCB3aGVuZXZlciBhIHBhY2tldCBvZiB0eXBlIEJJTkFSWV9FVkVOVCBpc1xuXHQgKiBkZWNvZGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3Jcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG5cdCAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG5cdCAgdGhpcy5idWZmZXJzID0gW107XG5cdH1cblxuXHQvKipcblx0ICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuXHQgKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG5cdCAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG5cdCAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0QmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG5cdCAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG5cdCAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG5cdCAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuXHQgICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG5cdCAgICByZXR1cm4gcGFja2V0O1xuXHQgIH1cblx0ICByZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0QmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgIHRoaXMucmVjb25QYWNrID0gbnVsbDtcblx0ICB0aGlzLmJ1ZmZlcnMgPSBbXTtcblx0fTtcblxuXHRmdW5jdGlvbiBlcnJvcihkYXRhKXtcblx0ICByZXR1cm4ge1xuXHQgICAgdHlwZTogZXhwb3J0cy5FUlJPUixcblx0ICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG5cdCAgfTtcblx0fVxuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKG1vZHVsZSwgZ2xvYmFsKSB7LyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuXHQ7KGZ1bmN0aW9uICgpIHtcblx0ICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcblx0ICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuXHQgIHZhciBpc0xvYWRlciA9IFwiZnVuY3Rpb25cIiA9PT0gXCJmdW5jdGlvblwiICYmIF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblx0ICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuXHQgIHZhciBvYmplY3RUeXBlcyA9IHtcblx0ICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcblx0ICAgIFwib2JqZWN0XCI6IHRydWVcblx0ICB9O1xuXG5cdCAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuXHQgIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cblx0ICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuXHQgIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG5cdCAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuXHQgIC8vIGluc3RlYWQuXG5cdCAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcblx0ICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cblx0ICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuXHQgICAgcm9vdCA9IGZyZWVHbG9iYWw7XG5cdCAgfVxuXG5cdCAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcblx0ICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuXHQgIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG5cdCAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblx0ICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG5cdCAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cblx0ICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG5cdCAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuXHQgICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcblx0ICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG5cdCAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuXHQgICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcblx0ICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG5cdCAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG5cdCAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cblx0ICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcblx0ICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcblx0ICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG5cdCAgICB9XG5cblx0ICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG5cdCAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuXHQgICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG5cdCAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cblx0ICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cblx0ICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcblx0ICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cblx0ICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuXHQgICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG5cdCAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2Zcblx0ICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG5cdCAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG5cdCAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cblx0ICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG5cdCAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG5cdCAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuXHQgICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuXHQgICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cblx0ICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBpc1N1cHBvcnRlZDtcblx0ICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuXHQgICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcblx0ICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cblx0ICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuXHQgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcblx0ICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcblx0ICAgICAgICAvLyBzdXBwb3J0ZWQuXG5cdCAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuXHQgICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cblx0ICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcblx0ICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcblx0ICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcblx0ICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cblx0ICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuXHQgICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuXHQgICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG5cdCAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3Rcblx0ICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcblx0ICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuXHQgICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuXHQgICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG5cdCAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG5cdCAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG5cdCAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG5cdCAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG5cdCAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG5cdCAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuXHQgICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG5cdCAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuXHQgICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcblx0ICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcblx0ICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuXHQgICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcblx0ICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcblx0ICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcblx0ICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuXHQgICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcblx0ICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcblx0ICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG5cdCAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcblx0ICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cblx0ICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuXHQgICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuXHQgICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG5cdCAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcblx0ICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcblx0ICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG5cdCAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG5cdCAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuXHQgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuXHQgICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcblx0ICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuXHQgICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG5cdCAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG5cdCAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG5cdCAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cblx0ICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuXHQgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cdCAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG5cdCAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuXHQgICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cblx0ICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG5cdCAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcblx0ICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuXHQgICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG5cdCAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICghaGFzKFwianNvblwiKSkge1xuXHQgICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuXHQgICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcblx0ICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuXHQgICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuXHQgICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuXHQgICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcblx0ICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG5cdCAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cblx0ICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG5cdCAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuXHQgICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcblx0ICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXHQgICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG5cdCAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cblx0ICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcblx0ICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG5cdCAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cblx0ICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG5cdCAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG5cdCAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuXHQgICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG5cdCAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHQgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG5cdCAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG5cdCAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG5cdCAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cblx0ICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG5cdCAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuXHQgICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuXHQgICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuXHQgICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdCAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcblx0ICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG5cdCAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuXHQgICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcblx0ICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG5cdCAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcblx0ICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuXHQgICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuXHQgICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG5cdCAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0ICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcblx0ICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcblx0ICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuXHQgICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG5cdCAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuXHQgICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cblx0ICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcblx0ICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuXHQgICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuXHQgICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcblx0ICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cblx0ICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cblx0ICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcblx0ICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcblx0ICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG5cdCAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuXHQgICAgICAgICAgICBzaXplKys7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuXHQgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cblx0ICAgICAgICBpZiAoIXNpemUpIHtcblx0ICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cblx0ICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG5cdCAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcblx0ICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG5cdCAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG5cdCAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG5cdCAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuXHQgICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG5cdCAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG5cdCAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcblx0ICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG5cdCAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG5cdCAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG5cdCAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG5cdCAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcblx0ICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuXHQgICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cblx0ICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cblx0ICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3Rvcjtcblx0ICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcblx0ICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cblx0ICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuXHQgICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuXHQgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuXHQgICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuXHQgICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcblx0ICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG5cdCAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuXHQgICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuXHQgICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG5cdCAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cblx0ICAgICAgICB2YXIgRXNjYXBlcyA9IHtcblx0ICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG5cdCAgICAgICAgICAzNDogJ1xcXFxcIicsXG5cdCAgICAgICAgICA4OiBcIlxcXFxiXCIsXG5cdCAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuXHQgICAgICAgICAgMTA6IFwiXFxcXG5cIixcblx0ICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG5cdCAgICAgICAgICA5OiBcIlxcXFx0XCJcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG5cdCAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cblx0ICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG5cdCAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuXHQgICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuXHQgICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG5cdCAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuXHQgICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcblx0ICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuXHQgICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG5cdCAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcblx0ICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuXHQgICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG5cdCAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcblx0ICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG5cdCAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG5cdCAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG5cdCAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcblx0ICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5Mjpcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuXHQgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcblx0ICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cblx0ICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcblx0ICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG5cdCAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG5cdCAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblx0ICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuXHQgICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcblx0ICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcblx0ICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuXHQgICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuXHQgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG5cdCAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuXHQgICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuXHQgICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG5cdCAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuXHQgICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuXHQgICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG5cdCAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuXHQgICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcblx0ICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcblx0ICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuXHQgICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcblx0ICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3Rcblx0ICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuXHQgICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcblx0ICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuXHQgICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuXHQgICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuXHQgICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcblx0ICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG5cdCAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcblx0ICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuXHQgICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuXHQgICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG5cdCAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG5cdCAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG5cdCAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcblx0ICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG5cdCAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cblx0ICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG5cdCAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuXHQgICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cblx0ICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuXHQgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuXHQgICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcblx0ICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG5cdCAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cblx0ICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG5cdCAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuXHQgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuXHQgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcblx0ICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cblx0ICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG5cdCAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcblx0ICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG5cdCAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG5cdCAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cblx0ICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuXHQgICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuXHQgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG5cdCAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuXHQgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cblx0ICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuXHQgICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcblx0ICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcblx0ICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG5cdCAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuXHQgICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG5cdCAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuXHQgICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3Rcblx0ICAgICAgICAgICAgICAvLyBpdHNlbGYuXG5cdCAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcblx0ICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG5cdCAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuXHQgICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG5cdCAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG5cdCAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cblx0ICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cblx0ICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuXHQgICAgICAgICAgICBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cblx0ICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcblx0ICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuXHQgICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuXHQgICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuXHQgICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG5cdCAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG5cdCAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuXHQgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKHdpZHRoKSB7XG5cdCAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG5cdCAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuXHQgICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG5cdCAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcblx0ICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuXHQgICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3Rcblx0ICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG5cdCAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cblx0ICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG5cdCAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0ICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuXHQgICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuXHQgICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG5cdCAgICAgICAgICA5MjogXCJcXFxcXCIsXG5cdCAgICAgICAgICAzNDogJ1wiJyxcblx0ICAgICAgICAgIDQ3OiBcIi9cIixcblx0ICAgICAgICAgIDk4OiBcIlxcYlwiLFxuXHQgICAgICAgICAgMTE2OiBcIlxcdFwiLFxuXHQgICAgICAgICAgMTEwOiBcIlxcblwiLFxuXHQgICAgICAgICAgMTAyOiBcIlxcZlwiLFxuXHQgICAgICAgICAgMTE0OiBcIlxcclwiXG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cblx0ICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuXHQgICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cblx0ICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG5cdCAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG5cdCAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuXHQgICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG5cdCAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcblx0ICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG5cdCAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuXHQgICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuXHQgICAgICAgICAgICAgICAgSW5kZXgrKztcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcblx0ICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcblx0ICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcblx0ICAgICAgICAgICAgICAgIEluZGV4Kys7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgICAgY2FzZSAzNDpcblx0ICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG5cdCAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG5cdCAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcblx0ICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuXHQgICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcblx0ICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cblx0ICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cblx0ICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG5cdCAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG5cdCAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcblx0ICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG5cdCAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG5cdCAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG5cdCAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cblx0ICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG5cdCAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcblx0ICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuXHQgICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG5cdCAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cblx0ICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cblx0ICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuXHQgICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcblx0ICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cblx0ICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuXHQgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuXHQgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG5cdCAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG5cdCAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cblx0ICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG5cdCAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cblx0ICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG5cdCAgICAgICAgICAgICAgICBhYm9ydCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG5cdCAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cblx0ICAgICAgICAgIHJldHVybiBcIiRcIjtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cblx0ICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcblx0ICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuXHQgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cblx0ICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG5cdCAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuXHQgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcblx0ICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cblx0ICAgICAgICAgICAgICByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG5cdCAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuXHQgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuXHQgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuXHQgICAgICAgICAgICAgICAgLy8gbmV4dC5cblx0ICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuXHQgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG5cdCAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG5cdCAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cblx0ICAgICAgICAgICAgICByZXN1bHRzID0ge307XG5cdCAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG5cdCAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cblx0ICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cblx0ICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cblx0ICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuXHQgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuXHQgICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG5cdCAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cblx0ICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cblx0ICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuXHQgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG5cdCAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuXHQgICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG5cdCAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cblx0ICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG5cdCAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcblx0ICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG5cdCAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cblx0ICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcblx0ICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG5cdCAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcblx0ICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG5cdCAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcblx0ICAgICAgICAgIEluZGV4ID0gMDtcblx0ICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG5cdCAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuXHQgICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG5cdCAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcblx0ICAgICAgICAgICAgYWJvcnQoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG5cdCAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG5cdCAgICByZXR1cm4gZXhwb3J0cztcblx0ICB9XG5cblx0ICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG5cdCAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cblx0ICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG5cdCAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcblx0ICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG5cdCAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG5cdCAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcblx0ICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuXHQgICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cblx0ICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcblx0ICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuXHQgICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcblx0ICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcblx0ICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gSlNPTjM7XG5cdCAgICAgIH1cblx0ICAgIH0pKTtcblxuXHQgICAgcm9vdC5KU09OID0ge1xuXHQgICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuXHQgICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG5cdCAgaWYgKGlzTG9hZGVyKSB7XG5cdCAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gSlNPTjM7XG5cdCAgICB9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXHQgIH1cblx0fSkuY2FsbCh0aGlzKTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg4KShtb2R1bGUpLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbW9kdWxlO1xyXG5cdH1cclxuXG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oX193ZWJwYWNrX2FtZF9vcHRpb25zX18pIHttb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIHt9KSlcblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuXHQgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBFeHBvc2UgYEVtaXR0ZXJgLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuXHQgIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG1peGluKG9iaikge1xuXHQgIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuXHQgICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuXHQgIH1cblx0ICByZXR1cm4gb2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG5cdCAgICAucHVzaChmbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuXHQgKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuXHQgIGZ1bmN0aW9uIG9uKCkge1xuXHQgICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcblx0ICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgb24uZm4gPSBmbjtcblx0ICB0aGlzLm9uKGV2ZW50LCBvbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG5cdCAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub2ZmID1cblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cblx0ICAvLyBhbGxcblx0ICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdCAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIC8vIHNwZWNpZmljIGV2ZW50XG5cdCAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cdCAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG5cdCAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXHQgIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0ICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcblx0ICB2YXIgY2I7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuXHQgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcblx0ICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuXHQgICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG5cdCAgaWYgKGNhbGxiYWNrcykge1xuXHQgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHQgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cblx0LyoqXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHNcblx0ICovXG5cblx0dmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblx0dmFyIGlzQnVmID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG5cdCAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcblx0ICogaGVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcblx0ICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG5cdCAgdmFyIGJ1ZmZlcnMgPSBbXTtcblx0ICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuXG5cdCAgZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcblx0ICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cblx0ICAgIGlmIChpc0J1ZihkYXRhKSkge1xuXHQgICAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuXHQgICAgICBidWZmZXJzLnB1c2goZGF0YSk7XG5cdCAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcblx0ICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuXHQgICAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG5ld0RhdGE7XG5cdCAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG5cdCAgICAgIHZhciBuZXdEYXRhID0ge307XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG5cdCAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG5ld0RhdGE7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9XG5cblx0ICB2YXIgcGFjayA9IHBhY2tldDtcblx0ICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7XG5cdCAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcblx0ICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcblx0ICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcblx0ICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG5cdCAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuXHQgIGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG5cdCAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuXHQgICAgICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuXHQgICAgICByZXR1cm4gYnVmO1xuXHQgICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICB9IGVsc2UgaWYgKGRhdGEgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEpIHtcblx0ICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0ICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH1cblxuXHQgIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcblx0ICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcblx0ICByZXR1cm4gcGFja2V0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcblx0ICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2Rpbmdcblx0ICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG5cdCAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG5cdCAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuXHQgICAgLy8gY29udmVydCBhbnkgYmxvYlxuXHQgICAgaWYgKChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuXHQgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuXHQgICAgICBwZW5kaW5nQmxvYnMrKztcblxuXHQgICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG5cdCAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0ICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcblx0ICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuXHQgICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG5cdCAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuXHQgICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cblx0ICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG5cdCAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3Rcblx0ICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG5cdCAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG5cdCAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG5cdCAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcblx0ICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBpc0J1ZihvYmopIHtcblx0ICByZXR1cm4gKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuXHQgICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcblx0fVxuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgZWlvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdHZhciBTb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblx0dmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXHR2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcblx0dmFyIGluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblx0dmFyIEJhY2tvZmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcblxuXHQvKipcblx0ICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuXHQgKi9cblxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHNcblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG5cdC8qKlxuXHQgKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcblx0ICBpZiAodXJpICYmICdvYmplY3QnID09PSAodHlwZW9mIHVyaSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodXJpKSkpIHtcblx0ICAgIG9wdHMgPSB1cmk7XG5cdCAgICB1cmkgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXHQgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG5cdCAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcblx0ICB0aGlzLm5zcHMgPSB7fTtcblx0ICB0aGlzLnN1YnMgPSBbXTtcblx0ICB0aGlzLm9wdHMgPSBvcHRzO1xuXHQgIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG5cdCAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG5cdCAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuXHQgIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcblx0ICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG5cdCAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcblx0ICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuXHQgICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuXHQgIH0pO1xuXHQgIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICB0aGlzLnVyaSA9IHVyaTtcblx0ICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcblx0ICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcblx0ICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG5cdCAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcblx0ICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcblx0ICB0aGlzLmRlY29kZXIgPSBuZXcgcGFyc2VyLkRlY29kZXIoKTtcblx0ICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG5cdCAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG5cdCAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG5cdCAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcblx0ICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG5cdCAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG5cdCAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5lbmdpbmUuaWQ7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNaXggaW4gYEVtaXR0ZXJgLlxuXHQgKi9cblxuXHRFbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG5cdCAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24gKHYpIHtcblx0ICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG5cdCAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG5cdCAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG5cdCAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuXHQgIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG5cdCAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG5cdCAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG5cdCAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuXHQgIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG5cdCAgdGhpcy5fdGltZW91dCA9IHY7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuXHQgKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3Rpbmdcblx0ICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcblx0ICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3Bcblx0ICAgIHRoaXMucmVjb25uZWN0KCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG5cdCAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub3BlbiA9IE1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoZm4sIG9wdHMpIHtcblx0ICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG5cdCAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuXHQgIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuXHQgIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXHQgIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG5cdCAgLy8gZW1pdCBgb3BlbmBcblx0ICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG5cdCAgICBzZWxmLm9ub3BlbigpO1xuXHQgICAgZm4gJiYgZm4oKTtcblx0ICB9KTtcblxuXHQgIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG5cdCAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcblx0ICAgIHNlbGYuY2xlYW51cCgpO1xuXHQgICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdCAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcblx0ICAgIGlmIChmbikge1xuXHQgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG5cdCAgICAgIGVyci5kYXRhID0gZGF0YTtcblx0ICAgICAgZm4oZXJyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG5cdCAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcblx0ICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcblx0ICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcblx0ICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cblx0ICAgIC8vIHNldCB0aW1lclxuXHQgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cdCAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuXHQgICAgICBzb2NrZXQuY2xvc2UoKTtcblx0ICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgJ3RpbWVvdXQnKTtcblx0ICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcblx0ICAgIH0sIHRpbWVvdXQpO1xuXG5cdCAgICB0aGlzLnN1YnMucHVzaCh7XG5cdCAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdCAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG5cdCAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIGRlYnVnKCdvcGVuJyk7XG5cblx0ICAvLyBjbGVhciBvbGQgc3Vic1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXG5cdCAgLy8gbWFyayBhcyBvcGVuXG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIHRoaXMuZW1pdCgnb3BlbicpO1xuXG5cdCAgLy8gYWRkIG5ldyBzdWJzXG5cdCAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BpbmcnLCBiaW5kKHRoaXMsICdvbnBpbmcnKSkpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZSgpO1xuXHQgIHRoaXMuZW1pdEFsbCgncGluZycpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSgpIC0gdGhpcy5sYXN0UGluZyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aXRoIGRhdGEuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0ICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuXHQgIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uIChuc3AsIG9wdHMpIHtcblx0ICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG5cdCAgaWYgKCFzb2NrZXQpIHtcblx0ICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwLCBvcHRzKTtcblx0ICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcblx0ICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgc29ja2V0LmlkID0gc2VsZi5lbmdpbmUuaWQ7XG5cdCAgICB9KTtcblxuXHQgICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcblx0ICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZuZXQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuXHQgICAgICBvbkNvbm5lY3RpbmcoKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcoKSB7XG5cdCAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuXHQgICAgICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBzb2NrZXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG5cdCAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG5cdCAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG5cdCAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuXHQgIHRoaXMuY2xvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogV3JpdGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cblx0ICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcblx0ICAgIC8vIGVuY29kZSwgdGhlbiB3cml0ZSB0byBlbmdpbmUgd2l0aCByZXN1bHRcblx0ICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuXHQgICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcblx0ICAgICAgfVxuXHQgICAgICBzZWxmLmVuY29kaW5nID0gZmFsc2U7XG5cdCAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG5cdCAgICB9KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcblx0ICAgIHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG5cdCAqIG5leHQgcGFja2V0IGluIGxpbmUuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcblx0ICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcblx0ICAgIHRoaXMucGFja2V0KHBhY2spO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuXHQgIGRlYnVnKCdjbGVhbnVwJyk7XG5cblx0ICB2YXIgc3Vic0xlbmd0aCA9IHRoaXMuc3Vicy5sZW5ndGg7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKTtcblx0ICAgIHN1Yi5kZXN0cm95KCk7XG5cdCAgfVxuXG5cdCAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcblx0ICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG5cdCAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cblx0ICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IE1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZGVidWcoJ2Rpc2Nvbm5lY3QnKTtcblx0ICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuXHQgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG5cdCAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG5cdCAgICB0aGlzLmNsZWFudXAoKTtcblx0ICB9XG5cdCAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdCAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgIGRlYnVnKCdvbmNsb3NlJyk7XG5cblx0ICB0aGlzLmNsZWFudXAoKTtcblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuXHQgIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuXHQgICAgdGhpcy5yZWNvbm5lY3QoKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG5cdCAgICBkZWJ1ZygncmVjb25uZWN0IGZhaWxlZCcpO1xuXHQgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cdCAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcblx0ICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuXHQgICAgZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuXHQgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuXHQgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuXHQgICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcblx0ICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cdCAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuXHQgICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcblx0ICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG5cdCAgICAgIHNlbGYub3BlbihmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgaWYgKGVycikge1xuXHQgICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG5cdCAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuXHQgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcblx0ICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcblx0ICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSwgZGVsYXkpO1xuXG5cdCAgICB0aGlzLnN1YnMucHVzaCh7XG5cdCAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdCAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuXHQgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG5cdCAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cdCAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcblx0ICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG5cdC8qKlxuXHQgKiBFeHBvcnRzIHBhcnNlclxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKlxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMucGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciB0cmFuc3BvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cdHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG5cdHZhciBpbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cdHZhciBwYXJzZXVyaSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBwYXJzZWpzb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblx0dmFyIHBhcnNlcXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG5cdC8qKlxuXHQgKiBOb29wIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbm9vcCgpe31cblxuXHQvKipcblx0ICogU29ja2V0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFNvY2tldCh1cmksIG9wdHMpe1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cblx0ICBpZiAodXJpICYmICdvYmplY3QnID09IHR5cGVvZiB1cmkpIHtcblx0ICAgIG9wdHMgPSB1cmk7XG5cdCAgICB1cmkgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmICh1cmkpIHtcblx0ICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG5cdCAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG5cdCAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PSAnd3NzJztcblx0ICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuXHQgICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcblx0ICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuXHQgICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcblx0ICB9XG5cblx0ICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZSA6XG5cdCAgICAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuXHQgIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcblx0ICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcblx0ICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuXHQgIH1cblxuXHQgIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuXHQgIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG5cdCAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG5cdCAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/XG5cdCAgICAgICBsb2NhdGlvbi5wb3J0IDpcblx0ICAgICAgICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG5cdCAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG5cdCAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG5cdCAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcblx0ICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcblx0ICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcblx0ICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cdCAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcblx0ICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcblx0ICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG5cdCAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG5cdCAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcblx0ICB0aGlzLndyaXRlQnVmZmVyID0gW107XG5cdCAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0Mztcblx0ICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuXHQgIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG5cdCAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcblx0ICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuXHQgIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG5cdCAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuXHQgICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuXHQgIH1cblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG5cdCAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG5cdCAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcblx0ICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcblx0ICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdCAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG5cdCAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcblx0ICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0ICAgIH1cblx0ICB9XG5cblx0ICB0aGlzLm9wZW4oKTtcblx0fVxuXG5cdFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogUHJvdG9jb2wgdmVyc2lvbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG5cdC8qKlxuXHQgKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcblx0ICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG5cdCAqL1xuXG5cdFNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5cdFNvY2tldC5UcmFuc3BvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblx0U29ja2V0LnRyYW5zcG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0U29ja2V0LnBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG5cdCAqIEByZXR1cm4ge1RyYW5zcG9ydH1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuXHQgIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG5cdCAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG5cdCAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG5cdCAgLy8gdHJhbnNwb3J0IG5hbWVcblx0ICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG5cdCAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG5cdCAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cblx0ICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuXHQgICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG5cdCAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcblx0ICAgIHBvcnQ6IHRoaXMucG9ydCxcblx0ICAgIHNlY3VyZTogdGhpcy5zZWN1cmUsXG5cdCAgICBwYXRoOiB0aGlzLnBhdGgsXG5cdCAgICBxdWVyeTogcXVlcnksXG5cdCAgICBmb3JjZUpTT05QOiB0aGlzLmZvcmNlSlNPTlAsXG5cdCAgICBqc29ucDogdGhpcy5qc29ucCxcblx0ICAgIGZvcmNlQmFzZTY0OiB0aGlzLmZvcmNlQmFzZTY0LFxuXHQgICAgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSLFxuXHQgICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG5cdCAgICB0aW1lc3RhbXBQYXJhbTogdGhpcy50aW1lc3RhbXBQYXJhbSxcblx0ICAgIHBvbGljeVBvcnQ6IHRoaXMucG9saWN5UG9ydCxcblx0ICAgIHNvY2tldDogdGhpcyxcblx0ICAgIHBmeDogdGhpcy5wZngsXG5cdCAgICBrZXk6IHRoaXMua2V5LFxuXHQgICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuXHQgICAgY2VydDogdGhpcy5jZXJ0LFxuXHQgICAgY2E6IHRoaXMuY2EsXG5cdCAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG5cdCAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuXHQgICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG5cdCAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzXG5cdCAgfSk7XG5cblx0ICByZXR1cm4gdHJhbnNwb3J0O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGNsb25lIChvYmopIHtcblx0ICB2YXIgbyA9IHt9O1xuXHQgIGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdCAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdCAgICAgIG9baV0gPSBvYmpbaV07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBvO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRTb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHRyYW5zcG9ydDtcblx0ICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT0gLTEpIHtcblx0ICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuXHQgIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuXHQgICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHQgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG5cdCAgICB9LCAwKTtcblx0ICAgIHJldHVybjtcblx0ICB9IGVsc2Uge1xuXHQgICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuXHQgIH1cblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cblx0ICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG5cdCAgdHJ5IHtcblx0ICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG5cdCAgICB0aGlzLm9wZW4oKTtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB0cmFuc3BvcnQub3BlbigpO1xuXHQgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpe1xuXHQgIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICBpZiAodGhpcy50cmFuc3BvcnQpIHtcblx0ICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcblx0ICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHQgIH1cblxuXHQgIC8vIHNldCB1cCB0cmFuc3BvcnRcblx0ICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuXHQgIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG5cdCAgdHJhbnNwb3J0XG5cdCAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG5cdCAgICBzZWxmLm9uRHJhaW4oKTtcblx0ICB9KVxuXHQgIC5vbigncGFja2V0JywgZnVuY3Rpb24ocGFja2V0KXtcblx0ICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcblx0ICB9KVxuXHQgIC5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcblx0ICAgIHNlbGYub25FcnJvcihlKTtcblx0ICB9KVxuXHQgIC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuXHQgICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcblx0ICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcblx0ICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KVxuXHQgICAgLCBmYWlsZWQgPSBmYWxzZVxuXHQgICAgLCBzZWxmID0gdGhpcztcblxuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuXHQgIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe1xuXHQgICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG5cdCAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcblx0ICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcblx0ICAgIH1cblx0ICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuXHQgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG5cdCAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuXHQgICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcblx0ICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXHQgICAgICBpZiAoJ3BvbmcnID09IG1zZy50eXBlICYmICdwcm9iZScgPT0gbXNnLmRhdGEpIHtcblx0ICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG5cdCAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuXHQgICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcblx0ICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuXHQgICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0cmFuc3BvcnQubmFtZTtcblxuXHQgICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuXHQgICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcblx0ICAgICAgICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcblx0ICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuXHQgICAgICAgICAgY2xlYW51cCgpO1xuXG5cdCAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuXHQgICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcblx0ICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG5cdCAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuXHQgICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcblx0ICAgICAgICAgIHNlbGYuZmx1c2goKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcblx0ICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuXHQgICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblx0ICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCgpIHtcblx0ICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuXHQgICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG5cdCAgICBmYWlsZWQgPSB0cnVlO1xuXG5cdCAgICBjbGVhbnVwKCk7XG5cblx0ICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuXHQgICAgdHJhbnNwb3J0ID0gbnVsbDtcblx0ICB9XG5cblx0ICAvL0hhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2Jpbmdcblx0ICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuXHQgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG5cdCAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuXHQgICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cblx0ICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cblx0ICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtcblx0ICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuXHQgIH1cblxuXHQgIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG5cdCAgZnVuY3Rpb24gb25jbG9zZSgpe1xuXHQgICAgb25lcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG5cdCAgfVxuXG5cdCAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuXHQgIGZ1bmN0aW9uIG9udXBncmFkZSh0byl7XG5cdCAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT0gdHJhbnNwb3J0Lm5hbWUpIHtcblx0ICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcblx0ICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy9SZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG5cdCAgZnVuY3Rpb24gY2xlYW51cCgpe1xuXHQgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcblx0ICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblx0ICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cdCAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXHQgIH1cblxuXHQgIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcblx0ICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcblx0ICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuXHQgIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblx0ICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cblx0ICB0cmFuc3BvcnQub3BlbigpO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcblx0ICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdGhpcy50cmFuc3BvcnQubmFtZTtcblx0ICB0aGlzLmVtaXQoJ29wZW4nKTtcblx0ICB0aGlzLmZsdXNoKCk7XG5cblx0ICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG5cdCAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuXHQgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuXHQgICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cblx0ICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuXHQgICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuXHQgICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuXHQgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuXHQgICAgICBjYXNlICdvcGVuJzpcblx0ICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgJ3BvbmcnOlxuXHQgICAgICAgIHRoaXMuc2V0UGluZygpO1xuXHQgICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgJ2Vycm9yJzpcblx0ICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcblx0ICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuXHQgICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuXHQgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcblx0ICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuXHQgIHRoaXMuaWQgPSBkYXRhLnNpZDtcblx0ICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcblx0ICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcblx0ICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuXHQgIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuXHQgIHRoaXMub25PcGVuKCk7XG5cdCAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuXHQgIGlmICAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG5cdCAgdGhpcy5zZXRQaW5nKCk7XG5cblx0ICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcblx0ICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcblx0ICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcblx0fTtcblxuXHQvKipcblx0ICogUmVzZXRzIHBpbmcgdGltZW91dC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuXHQgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcblx0ICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG5cdCAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG5cdCAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcblx0ICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG5cdCAgICBzZWxmLnBpbmcoKTtcblx0ICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG5cdCAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQqIFNlbmRzIGEgcGluZyBwYWNrZXQuXG5cdCpcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblxuXHRTb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uKCl7XG5cdCAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcblx0ICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uKCkge1xuXHQgIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cblx0ICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG5cdCAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG5cdCAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcblx0ICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG5cdCAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdCAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMuZmx1c2goKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcblx0ICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuXHQgICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuXHQgICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcblx0ICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcblx0ICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuXHQgICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG5cdCAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBhIG1lc3NhZ2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLndyaXRlID1cblx0U29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcblx0ICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIG9wdGlvbnMsIGZuKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2VuZHMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBvcHRpb25zLCBmbikge1xuXHQgIGlmKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIHtcblx0ICAgIGZuID0gZGF0YTtcblx0ICAgIGRhdGEgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIG9wdGlvbnMpIHtcblx0ICAgIGZuID0gb3B0aW9ucztcblx0ICAgIG9wdGlvbnMgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmICgnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuXHQgIHZhciBwYWNrZXQgPSB7XG5cdCAgICB0eXBlOiB0eXBlLFxuXHQgICAgZGF0YTogZGF0YSxcblx0ICAgIG9wdGlvbnM6IG9wdGlvbnNcblx0ICB9O1xuXHQgIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcblx0ICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcblx0ICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG5cdCAgdGhpcy5mbHVzaCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcblx0ICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuXHQgICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY2xvc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuXHQgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY2xvc2UoKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjbG9zZSgpIHtcblx0ICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG5cdCAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuXHQgICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG5cdCAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG5cdCAgICBjbG9zZSgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCkge1xuXHQgICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcblx0ICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG5cdCAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXHQgIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICAgIC8vIGNsZWFyIHRpbWVyc1xuXHQgICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuXHQgICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cblx0ICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuXHQgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG5cdCAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuXHQgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuXHQgICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cblx0ICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG5cdCAgICAvLyBzZXQgcmVhZHkgc3RhdGVcblx0ICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG5cdCAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG5cdCAgICB0aGlzLmlkID0gbnVsbDtcblxuXHQgICAgLy8gZW1pdCBjbG9zZSBldmVudFxuXHQgICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cblx0ICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuXHQgICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG5cdCAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG5cdCAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICpcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuXHQgIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG5cdCAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuXHQgIH1cblx0ICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcblx0fTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG5cdCAqL1xuXG5cdHZhciBYTUxIdHRwUmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgWEhSID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cdHZhciBKU09OUCA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXHR2YXIgd2Vic29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cblx0LyoqXG5cdCAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuXHQgKi9cblxuXHRleHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuXHRleHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuXHQvKipcblx0ICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG5cdCAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gcG9sbGluZyhvcHRzKXtcblx0ICB2YXIgeGhyO1xuXHQgIHZhciB4ZCA9IGZhbHNlO1xuXHQgIHZhciB4cyA9IGZhbHNlO1xuXHQgIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG5cdCAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuXHQgICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG5cdCAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cblx0ICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcblx0ICAgIGlmICghcG9ydCkge1xuXHQgICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcblx0ICAgIH1cblxuXHQgICAgeGQgPSBvcHRzLmhvc3RuYW1lICE9IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT0gb3B0cy5wb3J0O1xuXHQgICAgeHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcblx0ICB9XG5cblx0ICBvcHRzLnhkb21haW4gPSB4ZDtcblx0ICBvcHRzLnhzY2hlbWUgPSB4cztcblx0ICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cblx0ICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG5cdCAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuXHQgICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcblx0ICB9XG5cdH1cblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAxOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcblx0dmFyIGhhc0NPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMpIHtcblx0ICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuXHQgIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuXHQgIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcblx0ICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuXHQgIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cblx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG5cdCAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cblx0ICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcblx0ICB0cnkge1xuXHQgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHsgfVxuXG5cdCAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG5cdCAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcblx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcblx0ICB0cnkge1xuXHQgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG5cdCAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcblx0ICAgIH1cblx0ICB9IGNhdGNoIChlKSB7IH1cblxuXHQgIGlmICgheGRvbWFpbikge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuXHQgICAgfSBjYXRjaChlKSB7IH1cblx0ICB9XG5cdH1cblxuXG4vKioqLyB9LFxuLyogMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqXG5cdCAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuXHQgKlxuXHQgKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcblx0ICovXG5cblx0dHJ5IHtcblx0ICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0ICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG5cdCAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblx0fVxuXG5cbi8qKiovIH0sXG4vKiAyMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuXHQgKi9cblxuXHR2YXIgWE1MSHR0cFJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblx0dmFyIFBvbGxpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcblx0dmFyIGluaGVyaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblx0dmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5cdG1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG5cdC8qKlxuXHQgKiBFbXB0eSBmdW5jdGlvblxuXHQgKi9cblxuXHRmdW5jdGlvbiBlbXB0eSgpe31cblxuXHQvKipcblx0ICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFhIUihvcHRzKXtcblx0ICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cblx0ICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG5cdCAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcblx0ICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuXHQgICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuXHQgICAgaWYgKCFwb3J0KSB7XG5cdCAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPSBnbG9iYWwubG9jYXRpb24uaG9zdG5hbWUgfHxcblx0ICAgICAgcG9ydCAhPSBvcHRzLnBvcnQ7XG5cdCAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cblx0ICovXG5cblx0aW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG5cdC8qKlxuXHQgKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG5cdCAqL1xuXG5cdFhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcmVxdWVzdC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0WEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24ob3B0cyl7XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cdCAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuXHQgIG9wdHMueGQgPSB0aGlzLnhkO1xuXHQgIG9wdHMueHMgPSB0aGlzLnhzO1xuXHQgIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuXHQgIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuXHQgIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIG9wdHMucGZ4ID0gdGhpcy5wZng7XG5cdCAgb3B0cy5rZXkgPSB0aGlzLmtleTtcblx0ICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG5cdCAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuXHQgIG9wdHMuY2EgPSB0aGlzLmNhO1xuXHQgIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcblx0ICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG5cdCAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG5cdCAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGZuKXtcblx0ICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuXHQgIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG5cdCAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG5cdCAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcblx0ICB9KTtcblx0ICB0aGlzLnNlbmRYaHIgPSByZXE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRYSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uKCl7XG5cdCAgZGVidWcoJ3hociBwb2xsJyk7XG5cdCAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcblx0ICAgIHNlbGYub25EYXRhKGRhdGEpO1xuXHQgIH0pO1xuXHQgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuXHQgICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG5cdCAgfSk7XG5cdCAgdGhpcy5wb2xsWGhyID0gcmVxO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFJlcXVlc3Qob3B0cyl7XG5cdCAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcblx0ICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuXHQgIHRoaXMueGQgPSAhIW9wdHMueGQ7XG5cdCAgdGhpcy54cyA9ICEhb3B0cy54cztcblx0ICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG5cdCAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG5cdCAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG5cdCAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG5cdCAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5O1xuXHQgIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2E7XG5cdCAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cblx0ICB0aGlzLmNyZWF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50LCB4ZG9tYWluOiB0aGlzLnhkLCB4c2NoZW1lOiB0aGlzLnhzLCBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIgfTtcblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIG9wdHMucGZ4ID0gdGhpcy5wZng7XG5cdCAgb3B0cy5rZXkgPSB0aGlzLmtleTtcblx0ICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG5cdCAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuXHQgIG9wdHMuY2EgPSB0aGlzLmNhO1xuXHQgIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcblx0ICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG5cdCAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIHRyeSB7XG5cdCAgICBkZWJ1ZygneGhyIG9wZW4gJXM6ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcblx0ICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG5cdCAgICB0cnkge1xuXHQgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcblx0ICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcblx0ICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgaWYgKHRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcblx0ICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG5cdCAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoJ1BPU1QnID09IHRoaXMubWV0aG9kKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcblx0ICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgfVxuXG5cdCAgICAvLyBpZTYgY2hlY2tcblx0ICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcblx0ICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG5cdCAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuXHQgICAgICAgIHNlbGYub25Mb2FkKCk7XG5cdCAgICAgIH07XG5cdCAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcblx0ICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcblx0ICAgICAgICBpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHQgICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcblx0ICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuXHQgICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuXHQgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG5cdCAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGRlYnVnKCd4aHIgZGF0YSAlcycsIHRoaXMuZGF0YSk7XG5cdCAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3Jcblx0ICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuXHQgICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHQgICAgICBzZWxmLm9uRXJyb3IoZSk7XG5cdCAgICB9LCAwKTtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG5cdCAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG5cdCAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbigpe1xuXHQgIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG5cdCAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG5cdCAgdGhpcy5vblN1Y2Nlc3MoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gZXJyb3IuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24oZXJyKXtcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICB0aGlzLmNsZWFudXAodHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFucyB1cCBob3VzZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbihmcm9tRXJyb3Ipe1xuXHQgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgLy8geG1saHR0cHJlcXVlc3Rcblx0ICBpZiAodGhpcy5oYXNYRFIoKSkge1xuXHQgICAgdGhpcy54aHIub25sb2FkID0gdGhpcy54aHIub25lcnJvciA9IGVtcHR5O1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcblx0ICB9XG5cblx0ICBpZiAoZnJvbUVycm9yKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICB0aGlzLnhoci5hYm9ydCgpO1xuXHQgICAgfSBjYXRjaChlKSB7fVxuXHQgIH1cblxuXHQgIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcblx0ICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuXHQgIH1cblxuXHQgIHRoaXMueGhyID0gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gbG9hZC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIGRhdGE7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBjb250ZW50VHlwZTtcblx0ICAgIHRyeSB7XG5cdCAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpLnNwbGl0KCc7JylbMF07XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuXHQgICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2U7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSkpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgIHZhciB1aThBcnIgPSBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSk7XG5cdCAgICAgICAgICB2YXIgZGF0YUFycmF5ID0gW107XG5cdCAgICAgICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSB1aThBcnIubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKHVpOEFycltpZHhdKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YUFycmF5KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICB0aGlzLm9uRXJyb3IoZSk7XG5cdCAgfVxuXHQgIGlmIChudWxsICE9IGRhdGEpIHtcblx0ICAgIHRoaXMub25EYXRhKGRhdGEpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcblx0ICB0aGlzLmNsZWFudXAoKTtcblx0fTtcblxuXHQvKipcblx0ICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuXHQgKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG5cdCAqIGVtaXR0ZWQuXG5cdCAqL1xuXG5cdGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcblx0ICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuXHQgIFJlcXVlc3QucmVxdWVzdHMgPSB7fTtcblx0ICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG5cdCAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG5cdCAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuXHQgIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuXHQgICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0ICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDIyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIFRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXHR2YXIgcGFyc2VxcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cdHZhciBpbmhlcml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cdHZhciB5ZWFzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuXHQvKipcblx0ICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG5cdCAqL1xuXG5cdHZhciBoYXNYSFIyID0gKGZ1bmN0aW9uKCkge1xuXHQgIHZhciBYTUxIdHRwUmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHQgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcblx0ICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBQb2xsaW5nIGludGVyZmFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFBvbGxpbmcob3B0cyl7XG5cdCAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG5cdCAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG5cdCAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHQgIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuXHQgKi9cblxuXHRpbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cblx0LyoqXG5cdCAqIFRyYW5zcG9ydCBuYW1lLlxuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG5cdC8qKlxuXHQgKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG5cdCAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcblx0ICB0aGlzLnBvbGwoKTtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIHBvbGxpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbihvblBhdXNlKXtcblx0ICB2YXIgcGVuZGluZyA9IDA7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG5cdCAgZnVuY3Rpb24gcGF1c2UoKXtcblx0ICAgIGRlYnVnKCdwYXVzZWQnKTtcblx0ICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuXHQgICAgb25QYXVzZSgpO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcblx0ICAgIHZhciB0b3RhbCA9IDA7XG5cblx0ICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcblx0ICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcblx0ICAgICAgdG90YWwrKztcblx0ICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuXHQgICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuXHQgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuXHQgICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuXHQgICAgICB0b3RhbCsrO1xuXHQgICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKXtcblx0ICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcblx0ICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBwYXVzZSgpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbigpe1xuXHQgIGRlYnVnKCdwb2xsaW5nJyk7XG5cdCAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcblx0ICB0aGlzLmRvUG9sbCgpO1xuXHQgIHRoaXMuZW1pdCgncG9sbCcpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuXHQgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG5cdCAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG5cdCAgICBpZiAoJ29wZW5pbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuXHQgICAgICBzZWxmLm9uT3BlbigpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG5cdCAgICBpZiAoJ2Nsb3NlJyA9PSBwYWNrZXQudHlwZSkge1xuXHQgICAgICBzZWxmLm9uQ2xvc2UoKTtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG5cdCAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG5cdCAgfTtcblxuXHQgIC8vIGRlY29kZSBwYXlsb2FkXG5cdCAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG5cdCAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3Npbmdcblx0ICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuXHQgICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG5cdCAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG5cdCAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgICB0aGlzLnBvbGwoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIGZ1bmN0aW9uIGNsb3NlKCl7XG5cdCAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcblx0ICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG5cdCAgfVxuXG5cdCAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcblx0ICAgIGNsb3NlKCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG5cdCAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuXHQgICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuXHQgICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblx0ICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG5cdCAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG5cdCAgfTtcblxuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuXHQgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cdCAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcblx0ICB2YXIgcG9ydCA9ICcnO1xuXG5cdCAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcblx0ICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcblx0ICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcblx0ICB9XG5cblx0ICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuXHQgICAgcXVlcnkuYjY0ID0gMTtcblx0ICB9XG5cblx0ICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuXHQgIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG5cdCAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpIHx8XG5cdCAgICAgKCdodHRwJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcblx0ICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG5cdCAgfVxuXG5cdCAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG5cdCAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuXHQgICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcblx0ICB9XG5cblx0ICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcblx0ICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMjMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cdHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuXHQvKipcblx0ICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuXHQgIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcblx0ICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcblx0ICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG5cdCAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcblx0ICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcblx0ICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcblx0ICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcblx0ICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcblx0ICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuXHQgIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMucGZ4ID0gb3B0cy5wZng7XG5cdCAgdGhpcy5rZXkgPSBvcHRzLmtleTtcblx0ICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG5cdCAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuXHQgIHRoaXMuY2EgPSBvcHRzLmNhO1xuXHQgIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcblx0ICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG5cdCAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGFuIGVycm9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcblx0ICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG5cdCAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuXHQgIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG5cdCAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXHQgICAgdGhpcy5kb09wZW4oKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIHRoaXMuZG9DbG9zZSgpO1xuXHQgICAgdGhpcy5vbkNsb3NlKCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuXHQgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gb3BlblxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXHQgIHRoaXMuZW1pdCgnb3BlbicpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2l0aCBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcblx0ICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcblx0ICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBjbG9zZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDI0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cdHZhciBoYXNCaW5hcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblx0dmFyIHNsaWNlQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cdHZhciBiYXNlNjRlbmNvZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cdHZhciBhZnRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuXHR2YXIgdXRmOCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG5cdCAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG5cdCAqXG5cdCAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG5cdCAqL1xuXG5cdHZhciBpc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG5cdCAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBpc1BoYW50b21KUyA9IC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cdC8qKlxuXHQgKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG5cdC8qKlxuXHQgKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG5cdCAqL1xuXG5cdGV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZXMuXG5cdCAqL1xuXG5cdHZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuXHQgICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG5cdCAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3Ncblx0ICAsIHBpbmc6ICAgICAyXG5cdCAgLCBwb25nOiAgICAgM1xuXHQgICwgbWVzc2FnZTogIDRcblx0ICAsIHVwZ3JhZGU6ICA1XG5cdCAgLCBub29wOiAgICAgNlxuXHR9O1xuXG5cdHZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cblx0LyoqXG5cdCAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuXHQgKi9cblxuXHR2YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3Rcblx0ICovXG5cblx0dmFyIEJsb2IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuXHQvKipcblx0ICogRW5jb2RlcyBhIHBhY2tldC5cblx0ICpcblx0ICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiAgICAgNWhlbGxvIHdvcmxkXG5cdCAqICAgICAzXG5cdCAqICAgICA0XG5cdCAqXG5cdCAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN1cHBvcnRzQmluYXJ5KSB7XG5cdCAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuXHQgICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuXHQgICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuXHQgICAgdXRmOGVuY29kZSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcblx0ICAgID8gdW5kZWZpbmVkXG5cdCAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuXHQgIGlmIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdCAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuXHQgIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcblx0ICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cblx0ICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuXHQgICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcblx0ICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG5cdCAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuXHQgIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG5cdCAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuXHQgIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cblx0ICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuXHQgIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuXHQgIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcblx0ICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cblx0ICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0ICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuXHQgICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuXHQgIH07XG5cdCAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcblx0ICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuXHQgIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXHQgIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cblx0ICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcblx0ICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG5cdCAqL1xuXG5cdGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuXHQgIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcblx0ICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG5cdCAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHQgICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcblx0ICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuXHQgIH1cblxuXHQgIHZhciBiNjRkYXRhO1xuXHQgIHRyeSB7XG5cdCAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG5cdCAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG5cdCAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcblx0ICAgIH1cblx0ICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcblx0ICB9XG5cdCAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcblx0ICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcblx0ICAvLyBTdHJpbmcgZGF0YVxuXHQgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHV0ZjhkZWNvZGUpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICByZXR1cm4gZXJyO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG5cdCAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG5cdCAgICAgIHJldHVybiBlcnI7XG5cdCAgICB9XG5cblx0ICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG5cdCAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuXHQgIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG5cdCAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG5cdCAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcblx0ICB9XG5cdCAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcblx0fTtcblxuXHQvKipcblx0ICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcblx0ICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuXHQgIGlmICghZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG5cdCAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG5cdCAgfVxuXG5cdCAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuXHQgIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuXHQgICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cblx0ICpcblx0ICogICAgIDxsZW5ndGg+OmRhdGFcblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICpcblx0ICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuXHQgKlxuXHQgKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuXHQgKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcblx0ICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cblx0ICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcblx0ICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG5cdCAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG5cdCAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuXHQgICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdCAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG5cdCAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuXHQgKi9cblxuXHRmdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcblx0ICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG5cdCAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcblx0ICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcblx0ICAgICAgcmVzdWx0W2ldID0gbXNnO1xuXHQgICAgICBjYihlcnJvciwgcmVzdWx0KTtcblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuXHQgICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuXHQgIH1cblx0fVxuXG5cdC8qXG5cdCAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuXHQgKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2Rcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuXHQgICAgYmluYXJ5VHlwZSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgdmFyIHBhY2tldDtcblx0ICBpZiAoZGF0YSA9PSAnJykge1xuXHQgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuXHQgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgfVxuXG5cdCAgdmFyIGxlbmd0aCA9ICcnXG5cdCAgICAsIG4sIG1zZztcblxuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuXHQgICAgaWYgKCc6JyAhPSBjaHIpIHtcblx0ICAgICAgbGVuZ3RoICs9IGNocjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICgnJyA9PSBsZW5ndGggfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcblx0ICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cblx0ICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG5cdCAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuXHQgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcblx0ICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIHRydWUpO1xuXG5cdCAgICAgICAgaWYgKGVyci50eXBlID09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09IHBhY2tldC5kYXRhKSB7XG5cdCAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG5cdCAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG5cdCAgICAgIGkgKz0gbjtcblx0ICAgICAgbGVuZ3RoID0gJyc7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKGxlbmd0aCAhPSAnJykge1xuXHQgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuXHQgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgfVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cblx0ICpcblx0ICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuXHQgKiAyNTU+PGRhdGE+XG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcblx0ICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG5cdCAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcblx0ICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcblx0ICAgICAgdmFyIGxlbjtcblx0ICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG5cdCAgICAgICAgbGVuID0gcC5sZW5ndGg7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG5cdCAgICB9LCAwKTtcblxuXHQgICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG5cdCAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuXHQgICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG5cdCAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcblx0ICAgICAgdmFyIGFiID0gcDtcblx0ICAgICAgaWYgKGlzU3RyaW5nKSB7XG5cdCAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuXHQgICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcblx0ICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcblx0ICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcblx0ICAgICAgfVxuXHQgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuXHQgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuY29kZSBhcyBCbG9iXG5cdCAqL1xuXG5cdGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG5cdCAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG5cdCAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcblx0ICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcblx0ICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG5cdCAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcblx0ICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuXHQgICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG5cdCAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cblx0ICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuXHQgICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG5cdCAgICAgIH1cblx0ICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG5cdCAgICAgIGlmIChCbG9iKSB7XG5cdCAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcblx0ICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuXHQgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcblx0ICB9KTtcblx0fTtcblxuXHQvKlxuXHQgKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcblx0ICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuXHQgKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG5cdCAgICBiaW5hcnlUeXBlID0gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG5cdCAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuXHQgIHZhciBudW1iZXJUb29Mb25nID0gZmFsc2U7XG5cdCAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcblx0ICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcblx0ICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcblx0ICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuXHQgICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG5cdCAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT0gMjU1KSBicmVhaztcblxuXHQgICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuXHQgICAgICAgIG51bWJlclRvb0xvbmcgPSB0cnVlO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcblx0ICAgIH1cblxuXHQgICAgaWYobnVtYmVyVG9vTG9uZykgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cblx0ICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG5cdCAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG5cdCAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcblx0ICAgIGlmIChpc1N0cmluZykge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcblx0ICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuXHQgICAgICAgIG1zZyA9ICcnO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgYnVmZmVycy5wdXNoKG1zZyk7XG5cdCAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcblx0ICB9XG5cblx0ICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcblx0ICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG5cdCAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG5cdCAgfSk7XG5cdH07XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMjUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKipcblx0ICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuXHQgIHZhciBhcnIgPSBbXTtcblx0ICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHQgIGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdCAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuXHQgICAgICBhcnIucHVzaChpKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGFycjtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMjYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblx0Lypcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50cy5cblx0ICovXG5cblx0dmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuXHQgKlxuXHQgKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuXHQgIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG5cdCAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcblx0ICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcblx0ICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG5cdCAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuXHQgICAgICAgICkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuXHQgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG5cdCAgICAgIGlmIChvYmoudG9KU09OKSB7XG5cdCAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xuXHR9XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG5cdCAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDI4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG5cdCAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcblx0ICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuXHQgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0ICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cblx0ICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cblx0ICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG5cdCAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG5cdCAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cblx0ICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG5cdCAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuXHQgIH1cblxuXHQgIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcblx0ICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG5cdCAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qXG5cdCAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG5cdCAqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXHQgKi9cblx0KGZ1bmN0aW9uKGNoYXJzKXtcblx0ICBcInVzZSBzdHJpY3RcIjtcblxuXHQgIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcblx0ICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcblx0ICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuXHQgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG5cdCAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcblx0ICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG5cdCAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG5cdCAgICB9XG5cblx0ICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcblx0ICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcblx0ICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuXHQgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJhc2U2NDtcblx0ICB9O1xuXG5cdCAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG5cdCAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG5cdCAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcblx0ICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG5cdCAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcblx0ICAgICAgYnVmZmVyTGVuZ3RoLS07XG5cdCAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuXHQgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuXHQgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcblx0ICAgICAgZW5jb2RlZDEgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpXSk7XG5cdCAgICAgIGVuY29kZWQyID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7XG5cdCAgICAgIGVuY29kZWQzID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsyXSk7XG5cdCAgICAgIGVuY29kZWQ0ID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSszXSk7XG5cblx0ICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcblx0ICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG5cdCAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcblx0ICB9O1xuXHR9KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG5cblxuLyoqKi8gfSxcbi8qIDMwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cblx0ZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcblx0ICAgIHZhciBiYWlsID0gZmFsc2Vcblx0ICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG5cdCAgICBwcm94eS5jb3VudCA9IGNvdW50XG5cblx0ICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cblx0ICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG5cdCAgICAgICAgaWYgKHByb3h5LmNvdW50IDw9IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuXHQgICAgICAgIH1cblx0ICAgICAgICAtLXByb3h5LmNvdW50XG5cblx0ICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuXHQgICAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICAgICAgYmFpbCA9IHRydWVcblx0ICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuXHQgICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuXHQgICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYlxuXHQgICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cbi8qKiovIH0sXG4vKiAzMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUsIGdsb2JhbCkgey8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuXHQ7KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHRcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0XHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0XHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0XHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHRcdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdFx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0XHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHRcdH1cblxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdFx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0XHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRcdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdHZhciBleHRyYTtcblx0XHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0XHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdFx0fVxuXHRcdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRcdHJldHVybiBzeW1ib2w7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0XHR2YXIgY29kZVBvaW50O1xuXHRcdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdFx0fVxuXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0XHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0XHRieXRlSW5kZXgrKztcblxuXHRcdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdFx0dmFyIGJ5dGUxO1xuXHRcdFx0dmFyIGJ5dGUyO1xuXHRcdFx0dmFyIGJ5dGUzO1xuXHRcdFx0dmFyIGJ5dGU0O1xuXHRcdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiBieXRlMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0XHR2YXIgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHRcdH1cblxuXHRcdHZhciBieXRlQXJyYXk7XG5cdFx0dmFyIGJ5dGVDb3VudDtcblx0XHR2YXIgYnl0ZUluZGV4O1xuXHRcdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0XHRieXRlSW5kZXggPSAwO1xuXHRcdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHRcdHZhciB0bXA7XG5cdFx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0XHR9XG5cblx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRcdHZhciB1dGY4ID0ge1xuXHRcdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHRcdH07XG5cblx0XHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0XHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdFx0aWYgKFxuXHRcdFx0dHJ1ZVxuXHRcdCkge1xuXHRcdFx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdXRmODtcblx0XHRcdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cdFx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSB1dGY4O1xuXHRcdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRcdHJvb3QudXRmOCA9IHV0Zjg7XG5cdFx0fVxuXG5cdH0odGhpcykpO1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKG1vZHVsZSksIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMzIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3Rcblx0ICovXG5cblx0dmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG5cdCAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG5cdCAgfHwgZ2xvYmFsLk1TQmxvYkJ1aWxkZXJcblx0ICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgc3VwcG9ydGVkXG5cdCAqL1xuXG5cdHZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG5cdCAgICByZXR1cm4gYS5zaXplID09PSAyO1xuXHQgIH0gY2F0Y2goZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fSkoKTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG5cdCAqIEZhaWxzIGluIFNhZmFyaSA2LCBzbyB3ZSBuZWVkIHRvIG1hcCB0byBBcnJheUJ1ZmZlcnMgdGhlcmUuXG5cdCAqL1xuXG5cdHZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcblx0ICB0cnkge1xuXHQgICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG5cdCAgICByZXR1cm4gYi5zaXplID09PSAyO1xuXHQgIH0gY2F0Y2goZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fSkoKTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG5cdCAqL1xuXG5cdHZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG5cdCAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuXHQgICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xuXG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG5cdCAqIFVzZWQgYnkgQmxvYkJ1aWxkZXIgY29uc3RydWN0b3IgYW5kIG9sZCBicm93c2VycyB0aGF0IGRpZG4ndFxuXHQgKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG5cdCAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuXHQgICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcblx0ICAgICAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXG5cdCAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuXHQgICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgY29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XG5cdCAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG5cdCAgICAgIH1cblxuXHQgICAgICBhcnlbaV0gPSBidWY7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHQgIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuXHQgIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBiYi5hcHBlbmQoYXJ5W2ldKTtcblx0ICB9XG5cblx0ICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuXHQgIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblx0ICByZXR1cm4gbmV3IEJsb2IoYXJ5LCBvcHRpb25zIHx8IHt9KTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcblx0ICBpZiAoYmxvYlN1cHBvcnRlZCkge1xuXHQgICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuXHQgIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcblx0ICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH1cblx0fSkoKTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAzMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBFeHBvc2UgYEVtaXR0ZXJgLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuXHQgIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG1peGluKG9iaikge1xuXHQgIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuXHQgICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuXHQgIH1cblx0ICByZXR1cm4gb2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG5cdCAgICAucHVzaChmbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuXHQgKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuXHQgIGZ1bmN0aW9uIG9uKCkge1xuXHQgICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcblx0ICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgb24uZm4gPSBmbjtcblx0ICB0aGlzLm9uKGV2ZW50LCBvbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG5cdCAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub2ZmID1cblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cblx0ICAvLyBhbGxcblx0ICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdCAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIC8vIHNwZWNpZmljIGV2ZW50XG5cdCAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cdCAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG5cdCAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXHQgIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0ICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcblx0ICB2YXIgY2I7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuXHQgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcblx0ICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuXHQgICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG5cdCAgaWYgKGNhbGxiYWNrcykge1xuXHQgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHQgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAzNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdCAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcblx0ICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xuXHQgIHZhciBzdHIgPSAnJztcblxuXHQgIGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdCAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdCAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuXHQgICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHN0cjtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG5cdCAgdmFyIHFyeSA9IHt9O1xuXHQgIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcblx0ICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuXHQgIH1cblx0ICByZXR1cm4gcXJ5O1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAzNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgYil7XG5cdCAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuXHQgIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuXHQgIGEucHJvdG90eXBlID0gbmV3IGZuO1xuXHQgIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDM2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuXHQgICwgbGVuZ3RoID0gNjRcblx0ICAsIG1hcCA9IHt9XG5cdCAgLCBzZWVkID0gMFxuXHQgICwgaSA9IDBcblx0ICAsIHByZXY7XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUobnVtKSB7XG5cdCAgdmFyIGVuY29kZWQgPSAnJztcblxuXHQgIGRvIHtcblx0ICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcblx0ICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcblx0ICB9IHdoaWxlIChudW0gPiAwKTtcblxuXHQgIHJldHVybiBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG5cdCAgdmFyIGRlY29kZWQgPSAwO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGRlY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cblx0ICpcblx0ICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiB5ZWFzdCgpIHtcblx0ICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuXHQgIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcblx0ICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xuXHR9XG5cblx0Ly9cblx0Ly8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cblx0Ly9cblx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKykgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG5cblx0Ly9cblx0Ly8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuXHQvL1xuXHR5ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG5cdHllYXN0LmRlY29kZSA9IGRlY29kZTtcblx0bW9kdWxlLmV4cG9ydHMgPSB5ZWFzdDtcblxuXG4vKioqLyB9LFxuLyogMzcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblx0LyoqXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXG5cdHZhciBQb2xsaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cdHZhciBpbmhlcml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuXHQvKipcblx0ICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG5cdCAqL1xuXG5cdHZhciByTmV3bGluZSA9IC9cXG4vZztcblx0dmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG5cdC8qKlxuXHQgKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuXHQgKi9cblxuXHR2YXIgY2FsbGJhY2tzO1xuXG5cdC8qKlxuXHQgKiBDYWxsYmFja3MgY291bnQuXG5cdCAqL1xuXG5cdHZhciBpbmRleCA9IDA7XG5cblx0LyoqXG5cdCAqIE5vb3AuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG5cdC8qKlxuXHQgKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG5cdCAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG5cdCAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cblx0ICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuXHQgIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG5cdCAgaWYgKCFjYWxsYmFja3MpIHtcblx0ICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG5cdCAgICBpZiAoIWdsb2JhbC5fX19laW8pIGdsb2JhbC5fX19laW8gPSBbXTtcblx0ICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG5cdCAgfVxuXG5cdCAgLy8gY2FsbGJhY2sgaWRlbnRpZmllclxuXHQgIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG5cdCAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG5cdCAgICBzZWxmLm9uRGF0YShtc2cpO1xuXHQgIH0pO1xuXG5cdCAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuXHQgIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cblx0ICAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG5cdCAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG5cdCAgICB9LCBmYWxzZSk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cblx0ICovXG5cblx0aW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG5cdC8qXG5cdCAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3Ncblx0ICovXG5cblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdEpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5zY3JpcHQpIHtcblx0ICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuXHQgICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLmZvcm0pIHtcblx0ICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG5cdCAgICB0aGlzLmZvcm0gPSBudWxsO1xuXHQgICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuXHQgIH1cblxuXHQgIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdEpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cblx0ICBpZiAodGhpcy5zY3JpcHQpIHtcblx0ICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuXHQgICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuXHQgIH1cblxuXHQgIHNjcmlwdC5hc3luYyA9IHRydWU7XG5cdCAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG5cdCAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcblx0ICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG5cdCAgfTtcblxuXHQgIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcblx0ICBpZiAoaW5zZXJ0QXQpIHtcblx0ICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdCAgfVxuXHQgIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG5cdCAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblx0ICBcblx0ICBpZiAoaXNVQWdlY2tvKSB7XG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHQgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdCAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcblx0ICAgIH0sIDEwMCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICBpZiAoIXRoaXMuZm9ybSkge1xuXHQgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG5cdCAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG5cdCAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG5cdCAgICB2YXIgaWZyYW1lO1xuXG5cdCAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG5cdCAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0ICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuXHQgICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuXHQgICAgZm9ybS50YXJnZXQgPSBpZDtcblx0ICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuXHQgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG5cdCAgICBhcmVhLm5hbWUgPSAnZCc7XG5cdCAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuXHQgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuXHQgICAgdGhpcy5mb3JtID0gZm9ybTtcblx0ICAgIHRoaXMuYXJlYSA9IGFyZWE7XG5cdCAgfVxuXG5cdCAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cblx0ICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG5cdCAgICBpbml0SWZyYW1lKCk7XG5cdCAgICBmbigpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuXHQgICAgaWYgKHNlbGYuaWZyYW1lKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuXHQgICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInKyBzZWxmLmlmcmFtZUlkICsnXCI+Jztcblx0ICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdCAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcblx0ICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuXHQgICAgfVxuXG5cdCAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG5cdCAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0ICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuXHQgIH1cblxuXHQgIGluaXRJZnJhbWUoKTtcblxuXHQgIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuXHQgIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcblx0ICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcblx0ICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG5cdCAgdHJ5IHtcblx0ICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcblx0ICB9IGNhdGNoKGUpIHt9XG5cblx0ICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcblx0ICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG5cdCAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcblx0ICAgICAgICBjb21wbGV0ZSgpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcblx0ICB9XG5cdH07XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIFRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cdHZhciBwYXJzZXFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cdHZhciBpbmhlcml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cdHZhciB5ZWFzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXHR2YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxuXHQvKipcblx0ICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuXHQgKiBpbiB0aGUgYnJvd3NlciBvciB0cnkgdG8gcmVzb2x2ZSBXZWJTb2NrZXQtY29tcGF0aWJsZVxuXHQgKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG5cdCAqL1xuXG5cdHZhciBXZWJTb2NrZXQgPSBCcm93c2VyV2ViU29ja2V0O1xuXHRpZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuXHQgIHRyeSB7XG5cdCAgICBXZWJTb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblx0ICB9IGNhdGNoIChlKSB7IH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBXUztcblxuXHQvKipcblx0ICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gV1Mob3B0cyl7XG5cdCAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG5cdCAgaWYgKGZvcmNlQmFzZTY0KSB7XG5cdCAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHQgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuXHQgIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuXHQgKi9cblxuXHRpbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgbmFtZS5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0V1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuXHQvKlxuXHQgKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cblx0LyoqXG5cdCAqIE9wZW5zIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuXHQgIGlmICghdGhpcy5jaGVjaygpKSB7XG5cdCAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgdXJpID0gdGhpcy51cmkoKTtcblx0ICB2YXIgcHJvdG9jb2xzID0gdm9pZCgwKTtcblx0ICB2YXIgb3B0cyA9IHtcblx0ICAgIGFnZW50OiB0aGlzLmFnZW50LFxuXHQgICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcblx0ICB9O1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgb3B0cy5wZnggPSB0aGlzLnBmeDtcblx0ICBvcHRzLmtleSA9IHRoaXMua2V5O1xuXHQgIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcblx0ICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG5cdCAgb3B0cy5jYSA9IHRoaXMuY2E7XG5cdCAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuXHQgIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cdCAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG5cdCAgICBvcHRzLmhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblx0ICB9XG5cblx0ICB0aGlzLndzID0gQnJvd3NlcldlYlNvY2tldCA/IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXG5cdCAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMud3Muc3VwcG9ydHMgJiYgdGhpcy53cy5zdXBwb3J0cy5iaW5hcnkpIHtcblx0ICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXHQgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2J1ZmZlcic7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgfVxuXG5cdCAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24oKXtcblx0ICAgIHNlbGYub25PcGVuKCk7XG5cdCAgfTtcblx0ICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbigpe1xuXHQgICAgc2VsZi5vbkNsb3NlKCk7XG5cdCAgfTtcblx0ICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2KXtcblx0ICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuXHQgIH07XG5cdCAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG5cdCAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuXHQgIH07XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRlIGBvbkRhdGFgIHRvIHVzZSBhIHRpbWVyIG9uIGlPUy5cblx0ICogU2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tbG91Z2hyYW4vMjA1MjAwNlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0aWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3Jcblx0ICAmJiAvaVBhZHxpUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0ICBXUy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdCAgICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhLmNhbGwoc2VsZiwgZGF0YSk7XG5cdCAgICB9LCAwKTtcblx0ICB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cblx0ICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuXHQgIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcblx0ICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAoZnVuY3Rpb24ocGFja2V0KSB7XG5cdCAgICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCBzZWxmLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgaWYgKCFCcm93c2VyV2ViU29ja2V0KSB7XG5cdCAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuXHQgICAgICAgICAgdmFyIG9wdHMgPSB7fTtcblx0ICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuXHQgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG5cdCAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuXHQgICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcblx0ICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvL1NvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3Rcblx0ICAgICAgICAvL2hhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuXHQgICAgICAgIC8vdGhyb3cgYW4gZXJyb3Jcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgaWYgKEJyb3dzZXJXZWJTb2NrZXQpIHtcblx0ICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcblx0ICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gY2F0Y2ggKGUpe1xuXHQgICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9KShwYWNrZXRzW2ldKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkb25lKCl7XG5cdCAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cblx0ICAgIC8vIGZha2UgZHJhaW5cblx0ICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcblx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0ICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG5cdCAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcblx0ICAgIH0sIDApO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gY2xvc2Vcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKXtcblx0ICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2VzIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24oKXtcblx0ICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICB0aGlzLndzLmNsb3NlKCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0V1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblx0ICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG5cdCAgdmFyIHBvcnQgPSAnJztcblxuXHQgIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG5cdCAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKVxuXHQgICAgfHwgKCd3cycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG5cdCAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuXHQgIH1cblxuXHQgIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG5cdCAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcblx0ICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcblx0ICB9XG5cblx0ICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcblx0ICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHF1ZXJ5LmI2NCA9IDE7XG5cdCAgfVxuXG5cdCAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cblx0ICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcblx0ICBpZiAocXVlcnkubGVuZ3RoKSB7XG5cdCAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuXHQgIH1cblxuXHQgIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuXHQgIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0V1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG5cdH07XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMzkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIChpZ25vcmVkKSAqL1xuXG4vKioqLyB9LFxuLyogNDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHR2YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG5cdCAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG5cdCAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuXHQgIH1cblx0ICByZXR1cm4gLTE7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA0MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuXHQgKiBKU09OIHBhcnNlLlxuXHQgKlxuXHQgKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHR2YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcblx0dmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG5cdHZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG5cdHZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG5cdHZhciBydHJpbUxlZnQgPSAvXlxccysvO1xuXHR2YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuXHQgIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSB8fCAhZGF0YSkge1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXG5cdCAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcblxuXHQgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuXHQgIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG5cdCAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcblx0ICB9XG5cblx0ICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXG5cdCAgICAgIC5yZXBsYWNlKHJ2YWxpZHRva2VucywgJ10nKVxuXHQgICAgICAucmVwbGFjZShydmFsaWRicmFjZXMsICcnKSkpIHtcblx0ICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xuXHQgIH1cblx0fTtcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogNDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cdHZhciB0b0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG5cdHZhciBvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXHR2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xuXHR2YXIgaGFzQmluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuXHQgKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdHZhciBldmVudHMgPSB7XG5cdCAgY29ubmVjdDogMSxcblx0ICBjb25uZWN0X2Vycm9yOiAxLFxuXHQgIGNvbm5lY3RfdGltZW91dDogMSxcblx0ICBjb25uZWN0aW5nOiAxLFxuXHQgIGRpc2Nvbm5lY3Q6IDEsXG5cdCAgZXJyb3I6IDEsXG5cdCAgcmVjb25uZWN0OiAxLFxuXHQgIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuXHQgIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG5cdCAgcmVjb25uZWN0X2Vycm9yOiAxLFxuXHQgIHJlY29ubmVjdGluZzogMSxcblx0ICBwaW5nOiAxLFxuXHQgIHBvbmc6IDFcblx0fTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG5cdCAqL1xuXG5cdHZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuXHQvKipcblx0ICogYFNvY2tldGAgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFNvY2tldChpbywgbnNwLCBvcHRzKSB7XG5cdCAgdGhpcy5pbyA9IGlvO1xuXHQgIHRoaXMubnNwID0gbnNwO1xuXHQgIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuXHQgIHRoaXMuaWRzID0gMDtcblx0ICB0aGlzLmFja3MgPSB7fTtcblx0ICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblx0ICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcblx0ICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuXHQgIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcblx0ICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG5cdCAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcblx0ICB9XG5cdCAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cblx0LyoqXG5cdCAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG5cdCAgdmFyIGlvID0gdGhpcy5pbztcblx0ICB0aGlzLnN1YnMgPSBbb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLCBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLCBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKV07XG5cdH07XG5cblx0LyoqXG5cdCAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9wZW4gPSBTb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuXHQgIHRoaXMuc3ViRXZlbnRzKCk7XG5cdCAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG5cdCAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuXHQgIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cblx0ICpcblx0ICogQHJldHVybiB7U29ja2V0fSBzZWxmXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcblx0ICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcblx0ICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRlIGBlbWl0YC5cblx0ICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcblx0ICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuXHQgICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cdCAgdmFyIHBhcnNlclR5cGUgPSBwYXJzZXIuRVZFTlQ7IC8vIGRlZmF1bHRcblx0ICBpZiAoaGFzQmluKGFyZ3MpKSB7XG5cdCAgICBwYXJzZXJUeXBlID0gcGFyc2VyLkJJTkFSWV9FVkVOVDtcblx0ICB9IC8vIGJpbmFyeVxuXHQgIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuXHQgIHBhY2tldC5vcHRpb25zID0ge307XG5cdCAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuXHQgIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuXHQgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG5cdCAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuXHQgICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG5cdCAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXHQgICAgdGhpcy5wYWNrZXQocGFja2V0KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcblx0ICB9XG5cblx0ICBkZWxldGUgdGhpcy5mbGFncztcblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBhIHBhY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuXHQgIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cblx0ICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3Nhcnlcblx0ICBpZiAoJy8nICE9PSB0aGlzLm5zcCkge1xuXHQgICAgaWYgKHRoaXMucXVlcnkpIHtcblx0ICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCwgcXVlcnk6IHRoaXMucXVlcnkgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNUIH0pO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcblx0ICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG5cdCAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcblx0ICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG5cdCAgZGVsZXRlIHRoaXMuaWQ7XG5cdCAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICBpZiAocGFja2V0Lm5zcCAhPT0gdGhpcy5uc3ApIHJldHVybjtcblxuXHQgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcblx0ICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG5cdCAgICAgIHRoaXMub25jb25uZWN0KCk7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIHBhcnNlci5FVkVOVDpcblx0ICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG5cdCAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBwYXJzZXIuQUNLOlxuXHQgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuXHQgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuXHQgICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBwYXJzZXIuRVJST1I6XG5cdCAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG5cdCAgICAgIGJyZWFrO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuXHQgIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG5cdCAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG5cdCAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuXHQgICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXHQgICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbiAoaWQpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdmFyIHNlbnQgPSBmYWxzZTtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG5cdCAgICBpZiAoc2VudCkgcmV0dXJuO1xuXHQgICAgc2VudCA9IHRydWU7XG5cdCAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcblx0ICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG5cdCAgICB2YXIgdHlwZSA9IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSztcblx0ICAgIHNlbGYucGFja2V0KHtcblx0ICAgICAgdHlwZTogdHlwZSxcblx0ICAgICAgaWQ6IGlkLFxuXHQgICAgICBkYXRhOiBhcmdzXG5cdCAgICB9KTtcblx0ICB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG5cdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcblx0ICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG5cdCAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuXHQgICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcblx0ICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuXHQgIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuXHQgIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgaTtcblx0ICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG5cdCAgfVxuXHQgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuXHQgICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcblx0ICB9XG5cdCAgdGhpcy5zZW5kQnVmZmVyID0gW107XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG5cdCAgdGhpcy5kZXN0cm95KCk7XG5cdCAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuXHQgKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuXHQgKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlLlxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMuc3Vicykge1xuXHQgICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5zdWJzID0gbnVsbDtcblx0ICB9XG5cblx0ICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXHQgICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuXHQgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcblx0ICB9XG5cblx0ICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuXHQgIHRoaXMuZGVzdHJveSgpO1xuXG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICAvLyBmaXJlIGV2ZW50c1xuXHQgICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuXHQgIH1cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cblx0ICpcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uIChjb21wcmVzcykge1xuXHQgIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuXHQgIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuLyoqKi8gfSxcbi8qIDQzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcblx0LyoqXG5cdCAqIEV4cG9zZSBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG5cdCAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG5cdCAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG5cdCAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG5cdCAgfVxuXHQgIHJldHVybiBvYmo7XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9uID1cblx0RW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcblx0ICAgIC5wdXNoKGZuKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG5cdCAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICBmdW5jdGlvbiBvbigpIHtcblx0ICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG5cdCAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIG9uLmZuID0gZm47XG5cdCAgdGhpcy5vbihldmVudCwgb24pO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuXHQgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG5cdCAgLy8gYWxsXG5cdCAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuXHQgICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICAvLyBzcGVjaWZpYyBldmVudFxuXHQgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXHQgIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuXHQgIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcblx0ICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdCAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG5cdCAgdmFyIGNiO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBjYiA9IGNhbGxiYWNrc1tpXTtcblx0ICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG5cdCAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge01peGVkfSAuLi5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdCAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblx0ICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuXHQgIGlmIChjYWxsYmFja3MpIHtcblx0ICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdCAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcblx0ICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogNDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5cdGZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcblx0ICAgIHZhciBhcnJheSA9IFtdXG5cblx0ICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG5cdCAgICBmb3IgKHZhciBpID0gaW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYXJyYXlcblx0fVxuXG5cbi8qKiovIH0sXG4vKiA0NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG5cdC8qKlxuXHQgKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG5cdCAgb2JqLm9uKGV2LCBmbik7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdCAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblxuLyoqKi8gfSxcbi8qIDQ2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogU2xpY2UgcmVmZXJlbmNlLlxuXHQgKi9cblxuXHR2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuXHQvKipcblx0ICogQmluZCBgb2JqYCB0byBgZm5gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG5cdCAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuXHQgIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuXHQgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHQgIHJldHVybiBmdW5jdGlvbigpe1xuXHQgICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG5cdCAgfVxuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA0NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuXHQvKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuXHQgKi9cblxuXHR2YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG5cdCAqXG5cdCAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG5cdCAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcblx0ICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG5cdCAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG5cdCAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuXHQgICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcblx0ICAgICAgICApIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpc0FycmF5KG9iaikpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuXHQgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG5cdCAgICAgIGlmIChvYmoudG9KU09OICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai50b0pTT04pIHtcblx0ICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG5cdH1cblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiA0OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcblx0ICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcblx0fTtcblxuXG4vKioqLyB9LFxuLyogNDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKipcblx0ICogRXhwb3NlIGBCYWNrb2ZmYC5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG5cdCAqXG5cdCAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuXHQgKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cblx0ICogLSBgaml0dGVyYCBbMF1cblx0ICogLSBgZmFjdG9yYCBbMl1cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cdCAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcblx0ICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuXHQgIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcblx0ICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuXHQgIHRoaXMuYXR0ZW1wdHMgPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuXHQgIGlmICh0aGlzLmppdHRlcikge1xuXHQgICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcblx0ICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcblx0ICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5hdHRlbXB0cyA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuXHQgIHRoaXMubXMgPSBtaW47XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuXHQgIHRoaXMubWF4ID0gbWF4O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGppdHRlclxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuXHQgIHRoaXMuaml0dGVyID0gaml0dGVyO1xuXHR9O1xuXG5cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuOyIsInZhciBnbG9iYWxzID0ge307XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRnbG9iYWxzLndpbmRvdyA9IHdpbmRvdztcbn1cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0Z2xvYmFscy5kb2N1bWVudCA9IGRvY3VtZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnbG9iYWxzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjb3JlIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQGNvbnN0XG4gKi9cblxubGV0IGNvbXBhdGliaWxpdHlNb2RlRGF0YV87XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCB1bmlxdWVJZENvdW50ZXJfID0gMTtcblxuLyoqXG4gKiBVbmlxdWUgaWQgcHJvcGVydHkgcHJlZml4LlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IFVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKTtcblxuLyoqXG4gKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICogRm9vLnByb3RvdHlwZS5iYXIgPSBhYnN0cmFjdE1ldGhvZFxuICpcbiAqIE5vdyBpZiBhIHN1YmNsYXNzIG9mIEZvbyBmYWlscyB0byBvdmVycmlkZSBiYXIoKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAqXG4gKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJzdHJhY3RNZXRob2QoKSB7XG5cdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xufVxuXG4vKipcbiAqIExvb3BzIGNvbnN0cnVjdG9yIHN1cGVyIGNsYXNzZXMgY29sbGVjdGluZyBpdHMgcHJvcGVydGllcyB2YWx1ZXMuIElmXG4gKiBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzdXBlciBjbGFzcyBgdW5kZWZpbmVkYCB3aWxsIGJlXG4gKiBjb2xsZWN0ZWQgYXMgdmFsdWUgZm9yIHRoZSBjbGFzcyBoaWVyYXJjaHkgcG9zaXRpb24uXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjb25zdHJ1Y3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBjb2xsZWN0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheS48Kj59IEFycmF5IG9mIGNvbGxlY3RlZCB2YWx1ZXMuXG4gKiBUT0RPKCopOiBSZXRoaW5rIHN1cGVyY2xhc3MgbG9vcC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RTdXBlckNsYXNzZXNQcm9wZXJ0eShjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG5cdHZhciBwcm9wZXJ0eVZhbHVlcyA9IFtjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdXTtcblx0d2hpbGUgKGNvbnN0cnVjdG9yLl9fcHJvdG9fXyAmJiAhY29uc3RydWN0b3IuX19wcm90b19fLmlzUHJvdG90eXBlT2YoRnVuY3Rpb24pKSB7XG5cdFx0Y29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvci5fX3Byb3RvX187XG5cdFx0cHJvcGVydHlWYWx1ZXMucHVzaChjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdKTtcblx0fVxuXHRyZXR1cm4gcHJvcGVydHlWYWx1ZXM7XG59XG5cbi8qKlxuICogRGlzYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG5cdGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSBudWxsO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUgd2l0aCB0aGUgZm9sbG93aW5nIGZlYXR1cmVzIGZyb20gcmNcbiAqIGFuZCAxLnggdmVyc2lvbnM6XG4gKiAgICAgLSBVc2luZyBcImtleVwiIHRvIHJlZmVyZW5jZSBjb21wb25lbnQgaW5zdGFuY2VzLiBJbiB0aGUgY3VycmVudCB2ZXJzaW9uXG4gKiAgICAgICB0aGlzIHNob3VsZCBiZSBkb25lIHZpYSBcInJlZlwiIGluc3RlYWQuIFRoaXMgYWxsb3dzIG9sZCBjb2RlIHN0aWxsXG4gKiAgICAgICB1c2luZyBcImtleVwiIHRvIGtlZXAgd29ya2luZyBsaWtlIGJlZm9yZS4gTk9URTogdGhpcyBtYXkgY2F1c2VcbiAqICAgICAgIHByb2JsZW1zLCBzaW5jZSBcImtleVwiIGlzIG1lYW50IHRvIGJlIHVzZWQgZGlmZmVyZW50bHkuIE9ubHkgdXNlIHRoaXNcbiAqICAgICAgIGlmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVwZ3JhZGUgdGhlIGNvZGUgdG8gdXNlIFwicmVmXCIgaW5zdGVhZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2RhdGEgT3B0aW9uYWwgb2JqZWN0IHdpdGggZGF0YSB0byBzcGVjaWZ5IG1vcmVcbiAqICAgICBkZXRhaWxzLCBzdWNoIGFzOlxuICogICAgICAgICAtIHJlbmRlcmVycyB7QXJyYXl9IHRoZSB0ZW1wbGF0ZSByZW5kZXJlcnMgdGhhdCBzaG91bGQgYmUgaW5cbiAqICAgICAgICAgICBjb21wYXRpYmlsaXR5IG1vZGUsIGVpdGhlciB0aGVpciBjb25zdHJ1Y3RvcnMgb3Igc3RyaW5nc1xuICogICAgICAgICAgIHJlcHJlc2VudGluZyB0aGVtIChlLmcuICdzb3knIG9yICdqc3gnKS4gQnkgZGVmYXVsdCwgYWxsIHRoZSBvbmVzXG4gKiAgICAgICAgICAgdGhhdCBleHRlbmQgZnJvbSBJbmNyZW1lbnRhbERvbVJlbmRlcmVyLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKG9wdF9kYXRhID0ge30pIHtcblx0Y29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IG9wdF9kYXRhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRhdGEgdXNlZCBmb3IgY29tcGF0aWJpbGl0eSBtb2RlLCBvciBub3RoaW5nIGlmIGl0IGhhc24ndCBiZWVuXG4gKiBlbmFibGVkLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhKCkge1xuXHQvLyBDb21wYXRpYmlsaXR5IG1vZGUgY2FuIGJlIHNldCB2aWEgdGhlIF9fTUVUQUxfQ09NUEFUSUJJTElUWV9fIGdsb2JhbCB2YXIuXG5cdGlmICghY29tcGF0aWJpbGl0eU1vZGVEYXRhXykge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pIHtcblx0XHRcdGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXyk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjb21wYXRpYmlsaXR5TW9kZURhdGFfO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3RcbiAqIHN1cHBvcnQgdGhlIGBuYW1lYCBwcm9wZXJ0eSwgdGhpcyB3aWxsIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBmdW5jdGlvbidzXG4gKiBjb250ZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcblx0aWYgKCFmbi5uYW1lKSB7XG5cdFx0dmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG5cdFx0Zm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG5cdH1cblx0cmV0dXJuIGZuLm5hbWU7XG59XG5cbi8qKlxuICogR2V0cyBhbiB1bmlxdWUgaWQuIElmIGBvcHRfb2JqZWN0YCBhcmd1bWVudCBpcyBwYXNzZWQsIHRoZSBvYmplY3QgaXNcbiAqIG11dGF0ZWQgd2l0aCBhbiB1bmlxdWUgaWQuIENvbnNlY3V0aXZlIGNhbGxzIHdpdGggdGhlIHNhbWUgb2JqZWN0XG4gKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuICogcmV0dXJucy4gU2VlIHtAbGluayBVSURfUFJPUEVSVFl9LlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0IE9wdGlvbmFsIG9iamVjdCB0byBiZSBtdXRhdGVkIHdpdGggdGhlIHVpZC4gSWZcbiAqICAgICBub3Qgc3BlY2lmaWVkIHRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyB0aGUgdWlkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcbiAqICAgICBvYmplY3QncyB1aWQgcHJvcGVydHkgY2FuIGJlIGluaGVyaXRlZCBmcm9tIHBhcmVudHMgb3Igbm90LlxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWlkKG9wdF9vYmplY3QsIG9wdF9ub0luaGVyaXRhbmNlKSB7XG5cdGlmIChvcHRfb2JqZWN0KSB7XG5cdFx0dmFyIGlkID0gb3B0X29iamVjdFtVSURfUFJPUEVSVFldO1xuXHRcdGlmIChvcHRfbm9Jbmhlcml0YW5jZSAmJiAhb3B0X29iamVjdC5oYXNPd25Qcm9wZXJ0eShVSURfUFJPUEVSVFkpKSB7XG5cdFx0XHRpZCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpZCB8fCAob3B0X29iamVjdFtVSURfUFJPUEVSVFldID0gdW5pcXVlSWRDb3VudGVyXysrKTtcblx0fVxuXHRyZXR1cm4gdW5pcXVlSWRDb3VudGVyXysrO1xufVxuXG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi4gUmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gKiBAcGFyYW0geyo9fSBvcHRfcmV0dXJuVmFsdWUgVGhlIHNpbmdsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZmlyc3QgYXJndW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZih2YWwpIHtcblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmQW5kTm90TnVsbCh2YWwpIHtcblx0cmV0dXJuIGlzRGVmKHZhbCkgJiYgIWlzTnVsbCh2YWwpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RvY3VtZW50KHZhbCkge1xuXHRyZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gOTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb20gZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KHZhbCkge1xuXHRyZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsKSB7XG5cdHJldHVybiB2YWwgPT09IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dpbmRvdyh2YWwpIHtcblx0cmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgPT09IHZhbC53aW5kb3c7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGFycmF5c1xuICogYW5kIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuXHR2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cdHJldHVybiB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBQcm9taXNlLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG5cdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbi8qKlxuICogTWVyZ2VzIHRoZSB2YWx1ZXMgb2YgYSBleHBvcnQgZnVuY3Rpb24gcHJvcGVydHkgYSBjbGFzcyB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhhdFxuICogcHJvcGVydHkgZm9yIGFsbCBpdHMgc3VwZXIgY2xhc3NlcywgYW5kIHN0b3JlcyBpdCBhcyBhIG5ldyBzdGF0aWNcbiAqIHByb3BlcnR5IG9mIHRoYXQgY2xhc3MuIElmIHRoZSBleHBvcnQgZnVuY3Rpb24gcHJvcGVydHkgYWxyZWFkeSBleGlzdGVkLCBpdCB3b24ndFxuICogYmUgcmVjYWxjdWxhdGVkLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY29uc3RydWN0b3IgQ2xhc3MgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgY29sbGVjdGVkLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKToqPX0gb3B0X21lcmdlRm4gRnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhbiBhcnJheSBmaWxsZWRcbiAqICAgd2l0aCB0aGUgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0eSBmb3IgdGhlIGN1cnJlbnQgY2xhc3MgYW5kIGFsbCBpdHMgc3VwZXIgY2xhc3Nlcy5cbiAqICAgU2hvdWxkIHJldHVybiB0aGUgbWVyZ2VkIHZhbHVlIHRvIGJlIHN0b3JlZCBvbiB0aGUgY3VycmVudCBjbGFzcy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBtZXJnZSBoYXBwZW5zLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVN1cGVyQ2xhc3Nlc1Byb3BlcnR5KGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUsIG9wdF9tZXJnZUZuKSB7XG5cdHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuXHRpZiAoY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkobWVyZ2VkTmFtZSkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgbWVyZ2VkID0gY29sbGVjdFN1cGVyQ2xhc3Nlc1Byb3BlcnR5KGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUpO1xuXHRpZiAob3B0X21lcmdlRm4pIHtcblx0XHRtZXJnZWQgPSBvcHRfbWVyZ2VGbihtZXJnZWQpO1xuXHR9XG5cdGNvbnN0cnVjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBOdWxsIGZ1bmN0aW9uIHVzZWQgZm9yIGRlZmF1bHQgdmFsdWVzIG9mIGNhbGxiYWNrcywgZXRjLlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bGxGdW5jdGlvbigpIHt9XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBleGlzdHMganVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIG1ha2luZyBzdXJlIHRoYXQgb2xkXG4vLyBkZWZhdWx0IGltcG9ydHMgZm9yIHRoaXMgZmlsZSBzdGlsbCB3b3JrLiBJdCdzIGJlc3QgdG8gdXNlIHRoZSBuYW1lZCBleHBvcnRzXG4vLyBmb3IgZWFjaCBmdW5jdGlvbiBpbnN0ZWFkIHRob3VnaCwgc2luY2UgdGhhdCBhbGxvd3MgYnVuZGxlcnMgbGlrZSBSb2xsdXAgdG9cbi8vIHJlZHVjZSB0aGUgYnVuZGxlIHNpemUgYnkgcmVtb3ZpbmcgdW51c2VkIGNvZGUuXG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJy4vY29yZU5hbWVkJztcblxuZXhwb3J0IGRlZmF1bHQgY29yZTtcbmV4cG9ydCB7IGNvcmUgfTtcbmV4cG9ydCAqIGZyb20gJy4vY29yZU5hbWVkJztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgaXNEZWYgfSBmcm9tICcuLi9jb3JlJztcblxuY2xhc3MgYXJyYXkge1xuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LlxuXHQgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuXHQgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGVxdWFsKGFycjEsIGFycjIpIHtcblx0XHRpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBpc24ndCB1bmRlZmluZWQuXG5cdCAqIEBwYXJhbSB7IUFycmF5fSBhcnJcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdHN0YXRpYyBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycltpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIGlucHV0IG5lc3RlZCBhcnJheSB0byBiZWNvbWUgZmxhdC5cblx0ICogQHBhcmFtIHtBcnJheS48KnxBcnJheS48Kj4+fSBhcnIgTmVzdGVkIGFycmF5IHRvIGZsYXR0ZW4uXG5cdCAqIEBwYXJhbSB7QXJyYXkuPCo+fSBvcHRfb3V0cHV0IE9wdGlvbmFsIG91dHB1dCBhcnJheS5cblx0ICogQHJldHVybiB7QXJyYXkuPCo+fSBGbGF0IGFycmF5LlxuXHQgKi9cblx0c3RhdGljIGZsYXR0ZW4oYXJyLCBvcHRfb3V0cHV0KSB7XG5cdFx0dmFyIG91dHB1dCA9IG9wdF9vdXRwdXQgfHwgW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcblx0XHRcdFx0YXJyYXkuZmxhdHRlbihhcnJbaV0sIG91dHB1dCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG5cdCAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdHN0YXRpYyByZW1vdmUoYXJyLCBvYmopIHtcblx0XHR2YXIgaSA9IGFyci5pbmRleE9mKG9iaik7XG5cdFx0dmFyIHJ2O1xuXHRcdGlmICggKHJ2ID0gaSA+PSAwKSApIHtcblx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0fVxuXHRcdHJldHVybiBydjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGZyb20gYW4gYXJyYXkgdGhlIGVsZW1lbnQgYXQgaW5kZXggaVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3QgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbmRleCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cblx0ICovXG5cdHN0YXRpYyByZW1vdmVBdChhcnIsIGkpIHtcblx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyciwgaSwgMSkubGVuZ3RoID09PSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNsaWNlcyB0aGUgZ2l2ZW4gYXJyYXksIGp1c3QgbGlrZSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCB0aGlzXG5cdCAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IHRoYXQgc2hvdWxkIHN0YXJ0IHRoZSBzbGljZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG5cdCAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcblx0ICogICBzdGFydCBpbmRleCB3aWxsIGJlIGluY2x1ZGVkLlxuXHQgKiBAcmV0dXJuIHshQXJyYXl9XG5cdCAqL1xuXHRzdGF0aWMgc2xpY2UoYXJyLCBzdGFydCwgb3B0X2VuZCkge1xuXHRcdHZhciBzbGljZWQgPSBbXTtcblx0XHR2YXIgZW5kID0gaXNEZWYob3B0X2VuZCkgPyBvcHRfZW5kIDogYXJyLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0c2xpY2VkLnB1c2goYXJyW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHNsaWNlZDtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheTtcbiIsIi8qIVxuICogUG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKiBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXN5bmMgPSB7fTtcblxuXG4vKipcbiAqIFRocm93IGFuIGl0ZW0gd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICBGb3JcbiAqIGV4YW1wbGUsIGlmIHByb2Nlc3NpbmcgYSBncm91cCBvZiBpdGVtcyBpbiBhIGxvb3AsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAqIHRvIHJlcG9ydCBhbiBlcnJvciB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgcmVzdCBvZiB0aGUgYmF0Y2ggdG8gYmVcbiAqIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7Kn0gZXhjZXB0aW9uXG4gKi9cbmFzeW5jLnRocm93RXhjZXB0aW9uID0gZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG5cdC8vIEVhY2ggdGhyb3cgbmVlZHMgdG8gYmUgaW4gaXRzIG93biBjb250ZXh0LlxuXHRhc3luYy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBleGNlcHRpb247XG5cdH0pO1xufTtcblxuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBjYWxsc3RhY2sgdW53aW5kcywgb3IgYXNcbiAqIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyl9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBPYmplY3QgdG8gdXNlIGFzIHRoZSBcInRoaXMgdmFsdWVcIiB3aGVuIGNhbGxpbmdcbiAqICAgICB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5hc3luYy5ydW4gPSBmdW5jdGlvbihjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0aWYgKCFhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXykge1xuXHRcdC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHNjaGVkdWxlZCwgc2NoZWR1bGUgaXQgbm93LlxuXHRcdGFzeW5jLm5leHRUaWNrKGFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlKTtcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IHRydWU7XG5cdH1cblxuXHRhc3luYy5ydW4ud29ya1F1ZXVlXy5wdXNoKFxuXHRcdG5ldyBhc3luYy5ydW4uV29ya0l0ZW1fKGNhbGxiYWNrLCBvcHRfY29udGV4dCkpO1xufTtcblxuXG4vKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xuXG5cbi8qKiBAcHJpdmF0ZSB7IUFycmF5LjwhYXN5bmMucnVuLldvcmtJdGVtXz59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXG4vKipcbiAqIFJ1biBhbnkgcGVuZGluZyBhc3luYy5ydW4gd29yayBpdGVtcy4gVGhpcyBmdW5jdGlvbiBpcyBub3QgaW50ZW5kZWRcbiAqIGZvciBnZW5lcmFsIHVzZSwgYnV0IGZvciB1c2UgYnkgZW50cnkgcG9pbnQgaGFuZGxlcnMgdG8gcnVuIGl0ZW1zIGFoZWFkIG9mXG4gKiBhc3luYy5uZXh0VGljay5cbiAqL1xuYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUgPSBmdW5jdGlvbigpIHtcblx0Ly8gTk9URTogYWRkaXRpb25hbCB3b3JrIHF1ZXVlIGl0ZW1zIG1heSBiZSBwdXNoZWQgd2hpbGUgcHJvY2Vzc2luZy5cblx0d2hpbGUgKGFzeW5jLnJ1bi53b3JrUXVldWVfLmxlbmd0aCkge1xuXHRcdC8vIERvbid0IGxldCB0aGUgd29yayBxdWV1ZSBncm93IGluZGVmaW5pdGVseS5cblx0XHR2YXIgd29ya0l0ZW1zID0gYXN5bmMucnVuLndvcmtRdWV1ZV87XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHdvcmtJdGVtID0gd29ya0l0ZW1zW2ldO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d29ya0l0ZW0uZm4uY2FsbCh3b3JrSXRlbS5zY29wZSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGFzeW5jLnRocm93RXhjZXB0aW9uKGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoZXJlIGFyZSBubyBtb3JlIHdvcmsgaXRlbXMsIHJlc2V0IHRoZSB3b3JrIHF1ZXVlLlxuXHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzY29wZVxuICovXG5hc3luYy5ydW4uV29ya0l0ZW1fID0gZnVuY3Rpb24oZm4sIHNjb3BlKSB7XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5mbiA9IGZuO1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn07XG5cblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlNcbiAqIGV4ZWN1dGlvbiBjb250ZXh0LiBzZXRUaW1lb3V0KOKApiwgMCkgYWx3YXlzIHRha2VzIGF0IGxlYXN0IDVtcyBmb3IgbGVnYWN5XG4gKiByZWFzb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlNDT1BFKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzXG4gKiAgICAgcG9zc2libGUuXG4gKiBAcGFyYW0ge1NDT1BFPX0gb3B0X2NvbnRleHQgT2JqZWN0IGluIHdob3NlIHNjb3BlIHRvIGNhbGwgdGhlIGxpc3RlbmVyLlxuICogQHRlbXBsYXRlIFNDT1BFXG4gKi9cbmFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdHZhciBjYiA9IGNhbGxiYWNrO1xuXHRpZiAob3B0X2NvbnRleHQpIHtcblx0XHRjYiA9IGNhbGxiYWNrLmJpbmQob3B0X2NvbnRleHQpO1xuXHR9XG5cdGNiID0gYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyhjYik7XG5cdC8vIEludHJvZHVjZWQgYW5kIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBJRTEwLlxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHNldEltbWVkaWF0ZShjYik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIExvb2sgZm9yIGFuZCBjYWNoZSB0aGUgY3VzdG9tIGZhbGxiYWNrIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLlxuXHRpZiAoIWFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8pIHtcblx0XHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfKCk7XG5cdH1cblx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyhjYik7XG59O1xuXG5cbi8qKlxuICogQ2FjaGUgZm9yIHRoZSBzZXRJbW1lZGlhdGUgaW1wbGVtZW50YXRpb24uXG4gKiBAdHlwZSB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9XG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gbnVsbDtcblxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3QgcG9zc2libGUgaW1wbGVtZW50YXRpb24gdG8gcnVuIGEgZnVuY3Rpb24gYXMgc29vbiBhc1xuICogdGhlIEpTIGV2ZW50IGxvb3AgaXMgaWRsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfSBUaGUgXCJzZXRJbW1lZGlhdGVcIiBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyA9IGZ1bmN0aW9uKCkge1xuXHQvLyBDcmVhdGUgYSBwcml2YXRlIG1lc3NhZ2UgY2hhbm5lbCBhbmQgdXNlIGl0IHRvIHBvc3RNZXNzYWdlIGVtcHR5IG1lc3NhZ2VzXG5cdC8vIHRvIG91cnNlbHZlcy5cblx0dmFyIENoYW5uZWw7XG5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdENoYW5uZWwgPSBNZXNzYWdlQ2hhbm5lbDtcblx0fVxuXG5cdC8vIElmIE1lc3NhZ2VDaGFubmVsIGlzIG5vdCBhdmFpbGFibGUgYW5kIHdlIGFyZSBpbiBhIGJyb3dzZXIsIGltcGxlbWVudFxuXHQvLyBhbiBpZnJhbWUgYmFzZWQgcG9seWZpbGwgaW4gYnJvd3NlcnMgdGhhdCBoYXZlIHBvc3RNZXNzYWdlIGFuZFxuXHQvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLiBUaGUgbGF0dGVyIGV4Y2x1ZGVzIElFOCBiZWNhdXNlIGl0IGhhcyBhXG5cdC8vIHN5bmNocm9ub3VzIHBvc3RNZXNzYWdlIGltcGxlbWVudGF0aW9uLlxuXHRpZiAodHlwZW9mIENoYW5uZWwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0d2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRcdENoYW5uZWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdC8vIE1ha2UgYW4gZW1wdHksIGludmlzaWJsZSBpZnJhbWUuXG5cdFx0XHR2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdGlmcmFtZS5zcmMgPSAnJztcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdFx0dmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuXHRcdFx0dmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcblx0XHRcdGRvYy5vcGVuKCk7XG5cdFx0XHRkb2Mud3JpdGUoJycpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cdFx0XHR2YXIgbWVzc2FnZSA9ICdjYWxsSW1tZWRpYXRlJyArIE1hdGgucmFuZG9tKCk7XG5cdFx0XHR2YXIgb3JpZ2luID0gd2luLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbi5sb2NhdGlvbi5ob3N0O1xuXHRcdFx0dmFyIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgb3JpZ2luIGFuZCBtZXNzYWdlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgbWVzc2FnZSB3YXNcblx0XHRcdFx0Ly8gaW50ZW5kZWQgZm9yIHVzLlxuXHRcdFx0XHRpZiAoZS5vcmlnaW4gIT09IG9yaWdpbiAmJiBlLmRhdGEgIT09IG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wb3J0MS5vbm1lc3NhZ2UoKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnBvcnQxID0ge307XG5cdFx0XHR0aGlzLnBvcnQyID0ge1xuXHRcdFx0XHRwb3N0TWVzc2FnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0d2luLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZW9mIENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuXHRcdC8vIFVzZSBhIGZpZm8gbGlua2VkIGxpc3QgdG8gY2FsbCBjYWxsYmFja3MgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdHZhciBoZWFkID0ge307XG5cdFx0dmFyIHRhaWwgPSBoZWFkO1xuXHRcdGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWFkID0gaGVhZC5uZXh0O1xuXHRcdFx0dmFyIGNiID0gaGVhZC5jYjtcblx0XHRcdGhlYWQuY2IgPSBudWxsO1xuXHRcdFx0Y2IoKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbihjYikge1xuXHRcdFx0dGFpbC5uZXh0ID0ge1xuXHRcdFx0XHRjYjogY2Jcblx0XHRcdH07XG5cdFx0XHR0YWlsID0gdGFpbC5uZXh0O1xuXHRcdFx0Y2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcblx0XHR9O1xuXHR9XG5cdC8vIEltcGxlbWVudGF0aW9uIGZvciBJRTYtODogU2NyaXB0IGVsZW1lbnRzIGZpcmUgYW4gYXN5bmNocm9ub3VzXG5cdC8vIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aGVuIGluc2VydGVkIGludG8gdGhlIERPTS5cblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW5cblx0XHRkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXHRcdHJldHVybiBmdW5jdGlvbihjYikge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBDbGVhbiB1cCBhbmQgY2FsbCB0aGUgY2FsbGJhY2suXG5cdFx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0XHRjYiA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fTtcblx0fVxuXHQvLyBGYWxsIGJhY2sgdG8gc2V0VGltZW91dCB3aXRoIDAuIEluIGJyb3dzZXJzIHRoaXMgY3JlYXRlcyBhIGRlbGF5IG9mIDVtc1xuXHQvLyBvciBtb3JlLlxuXHRyZXR1cm4gZnVuY3Rpb24oY2IpIHtcblx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0fTtcbn07XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpcyBvdmVycmlkZWQgdG8gcHJvdGVjdCBjYWxsYmFja3Mgd2l0aCBlbnRyeSBwb2ludFxuICogbW9uaXRvciBpZiB0aGUgYXBwbGljYXRpb24gbW9uaXRvcnMgZW50cnkgcG9pbnRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXMgcG9zc2libGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBUaGUgd3JhcHBlZCBjYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18gPSBmdW5jdGlvbihvcHRfcmV0dXJuVmFsdWUpIHtcblx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpc3Bvc2FibGUgdXRpbGl0eS4gV2hlbiBpbmhlcml0ZWQgcHJvdmlkZXMgdGhlIGBkaXNwb3NlYCBmdW5jdGlvbiB0byBpdHNcbiAqIHN1YmNsYXNzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIGFueSBvYmplY3QgcmVmZXJlbmNlc1xuICogd2hlbiBhbiBpbnN0YW5jZSB3b24ndCBiZSB1c2VkIGFueW1vcmUuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG4gKiBgZGlzcG9zZUludGVybmFsYCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljIGRpc3Bvc2luZyBsb2dpYy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBEaXNwb3NhYmxlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0LyoqXG5cdFx0ICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuIENhbGxzIGBkaXNwb3NlSW50ZXJuYWxgLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblx0XHRpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG5cdFx0XHR0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdFx0dGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljXG5cdCAqIGRpc3Bvc2luZyBsb2dpYyAobGlrZSBjbGVhcmluZyByZWZlcmVuY2VzIGFuZCBjYWxsaW5nIGBkaXNwb3NlYCBvbiBvdGhlclxuXHQgKiBkaXNwb3NhYmxlcykuXG5cdCAqL1xuXHRkaXNwb3NlSW50ZXJuYWwoKSB7fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNEaXNwb3NlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXNwb3NlZF87XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlzcG9zYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3Mgb2JqZWN0IHtcblx0LyoqXG5cdCAqIENvcGllcyBhbGwgdGhlIG1lbWJlcnMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0LlxuXHQgKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgVGhlIG9iamVjdHMgZnJvbSB3aGljaCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2UuXG5cdCAqL1xuXHRzdGF0aWMgbWl4aW4odGFyZ2V0KSB7XG5cdFx0dmFyIGtleSwgc291cmNlO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgZnVsbHkgcXVhbGlmaWVkIGV4dGVybmFsIG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZS5cblx0ICogQHBhcmFtIHtvYmplY3Q9fSBvcHRfb2JqIFRoZSBvYmplY3Qgd2l0aGluIHdoaWNoIHRvIGxvb2s7IGRlZmF1bHQgaXNcblx0ICogICAgIDxjb2RlPndpbmRvdzwvY29kZT4uXG5cdCAqIEByZXR1cm4gez99IFRoZSB2YWx1ZSAob2JqZWN0IG9yIHByaW1pdGl2ZSkgb3IsIGlmIG5vdCBmb3VuZCwgdW5kZWZpbmVkLlxuXHQgKi9cblx0c3RhdGljIGdldE9iamVjdEJ5TmFtZShuYW1lLCBvcHRfb2JqKSB7XG5cdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcdHJldHVybiBwYXJ0cy5yZWR1Y2UoKHBhcnQsIGtleSkgPT4gcGFydFtrZXldLCBzY29wZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG5cdCAqIHRoZWlyIHZhbHVlcyBzZXQgdG8gdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBvYmpcblx0ICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICovXG5cdHN0YXRpYyBtYXAob2JqLCBmbikge1xuXHRcdHZhciBtYXBwZWRPYmogPSB7fTtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXBwZWRPYmpba2V5c1tpXV0gPSBmbihrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFwcGVkT2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgdHdvIGdpdmVuIG9iamVjdHMgYXJlIGVxdWFsLiBUaGlzIGlzIGRvbmUgdmlhIGEgc2hhbGxvd1xuXHQgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgc2hhbGxvd0VxdWFsKG9iajEsIG9iajIpIHtcblx0XHRpZiAob2JqMSA9PT0gb2JqMikge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dmFyIGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG5cdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0aWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3Mgc3RyaW5nIHtcblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGJyZWFraW5nIHNwYWNlcyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc3RyaW5nIGFuZFxuXHQgKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG5cdCAqIFRoZSBvcmlnaW5hbCBhbmQgdGhlIHJlc3VsdCBzdHJpbmdzIHJlbmRlciB0aGUgc2FtZSB3YXkgaW4gSFRNTC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBpbiB3aGljaCB0byBjb2xsYXBzZSBzcGFjZXMuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG5cdCAqL1xuXHRzdGF0aWMgY29sbGFwc2VCcmVha2luZ1NwYWNlcyhzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHRcXHJcXG4gXSsvZywgJyAnKS5yZXBsYWNlKC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG5cdH1cblxuXHQvKipcblx0KiBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0aGF0IGFyZSBub3Qgc2FmZSB0byB1c2UgaW4gYSBSZWdFeHAuXG5cdCogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBlc2NhcGUuIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZSBjYXN0ZWRcblx0KiAgICAgdG8gb25lLlxuXHQqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cblx0Ki9cblx0c3RhdGljIGVzY2FwZVJlZ2V4KHN0cikge1xuXHRcdHJldHVybiBTdHJpbmcoc3RyKVxuXHRcdFx0LnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJylcblx0XHRcdC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXHgwOCcpO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyBhIHN0cmluZyB3aXRoIGF0IGxlYXN0IDY0LWJpdHMgb2YgcmFuZG9tbmVzcy5cblx0KiBAcmV0dXJuIHtzdHJpbmd9IEEgcmFuZG9tIHN0cmluZywgZS5nLiBzbjFzN3ZiNGdjaWMuXG5cdCovXG5cdHN0YXRpYyBnZXRSYW5kb21TdHJpbmcoKSB7XG5cdFx0dmFyIHggPSAyMTQ3NDgzNjQ4O1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KS50b1N0cmluZygzNikgK1xuXHRcdFx0TWF0aC5hYnMoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkgXiBEYXRlLm5vdygpKS50b1N0cmluZygzNik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgaGFzaGNvZGUgZm9yIGEgc3RyaW5nLiBUaGUgaGFzaGNvZGUgdmFsdWUgaXMgY29tcHV0ZWQgYnlcblx0ICogdGhlIHN1bSBhbGdvcml0aG06IHNbMF0qMzFeKG4tMSkgKyBzWzFdKjMxXihuLTIpICsgLi4uICsgc1tuLTFdLiBBIG5pY2Vcblx0ICogcHJvcGVydHkgb2YgdXNpbmcgMzEgcHJpbWUgaXMgdGhhdCB0aGUgbXVsdGlwbGljYXRpb24gY2FuIGJlIHJlcGxhY2VkIGJ5XG5cdCAqIGEgc2hpZnQgYW5kIGEgc3VidHJhY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZTogMzEqaSA9PSAoaTw8NSktaS5cblx0ICogTW9kZXJuIFZNcyBkbyB0aGlzIHNvcnQgb2Ygb3B0aW1pemF0aW9uIGF1dG9tYXRpY2FsbHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGFyZ2V0IHN0cmluZy5cblx0ICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgaGFzaGNvZGUuXG5cdCAqL1xuXHRzdGF0aWMgaGFzaENvZGUodmFsKSB7XG5cdFx0dmFyIGhhc2ggPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGhhc2ggPSAzMSAqIGhhc2ggKyB2YWwuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggJT0gMHgxMDAwMDAwMDA7XG5cdFx0fVxuXHRcdHJldHVybiBoYXNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIGludGVydmFsIGludG8gdGhlIHN0cmluZyB3aXRoIHNwZWNpZmllZCB2YWx1ZSwgZS5nLlxuXHQgKiBgcmVwbGFjZUludGVydmFsKFwiYWJjZGVcIiwgMSwgNCwgXCJcIilgIHJldHVybnMgXCJhZVwiLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbnB1dCBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCByZXBsYWNlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRzdGF0aWMgcmVwbGFjZUludGVydmFsKHN0ciwgc3RhcnQsIGVuZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdGFydCkgKyB2YWx1ZSArIHN0ci5zdWJzdHJpbmcoZW5kKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHN0b3JpbmcgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBwcmludGVkIGFzIEpTT05cbiAqIHdoZW4gdGhlIGB0b1N0cmluZ2AgbWV0aG9kIGlzIGNhbGxlZC5cbiAqL1xuY2xhc3MgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIEVtYm9kaWVkIGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuYm9keV8gPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICovXG5cdGJvZHkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV87XG5cdH1cblxuXHQvKipcblx0ICogSWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBFbWJvZGllZCwgdGhpcyB3aWxsXG5cdCAqIHJldHVybiBpdHMgYm9keSBjb250ZW50LiBPdGhlcndpc2UgdGhpcyB3aWxsIHJldHVybiB0aGVcblx0ICogb3JpZ2luYWwgb2JqZWN0LlxuXHQgKiBAcGFyYW0geyp9IG9ialxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgdG9Cb2R5KG9iaikge1xuXHRcdHJldHVybiAob2JqIGluc3RhbmNlb2YgRW1ib2RpZWQpID8gb2JqLmJvZHkoKSA6IG9iajtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhpcyBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSgpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbWJvZGllZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhbmQgaGFuZGxpbmcgdGhlIGJvZHkgY29udGVudHNcbiAqIG9mIGEgRmlsdGVyIGluc3RhbmNlLlxuICovXG5jbGFzcyBGaWx0ZXJCb2R5IHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgRmlsdGVyQm9keX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IG9wZXJhdG9yT3JWYWx1ZSBJZiBhIHRoaXJkIHBhcmFtIGlzIGdpdmVuLCB0aGlzIHNob3VsZFxuXHQgKiAgIGJlIHRoZSBmaWx0ZXIncyBvcGVyYXRvciAobGlrZSBcIj49XCIpLiBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZVxuXHQgKiAgIHVzZWQgYXMgdGhlIGZpbHRlcidzIHZhbHVlLCBhbmQgdGhlIGZpbHRlcidzIG9wZXJhdG9yIHdpbGwgYmUgXCI9XCIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0dmFyIG9iaiA9IHtcblx0XHRcdG9wZXJhdG9yOiBjb3JlLmlzRGVmKG9wdF92YWx1ZSkgPyBvcGVyYXRvck9yVmFsdWUgOiAnPSdcblx0XHR9O1xuXG5cdFx0dmFyIHZhbHVlID0gY29yZS5pc0RlZihvcHRfdmFsdWUpID8gb3B0X3ZhbHVlIDogb3BlcmF0b3JPclZhbHVlO1xuXG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKHZhbHVlKSkge1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRW1ib2RpZWQpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5ib2R5KCk7XG5cdFx0XHR9XG5cdFx0XHRvYmoudmFsdWUgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwoZmllbGQpKSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUJvZHlfKGZpZWxkLCBvYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUJvZHlfKCdhbmQnLCBbXSk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcG9zZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHdpdGggdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHtGaWx0ZXI9fSBvcHRfZmlsdGVyIEFub3RoZXIgZmlsdGVyIHRvIGNvbXBvc2UgdGhpcyBmaWx0ZXIgd2l0aCxcblx0ICogICBpZiB0aGUgb3BlcmF0b3IgaXMgbm90IHVuYXJ5LlxuXHQgKi9cblx0YWRkKG9wZXJhdG9yLCBvcHRfZmlsdGVyKSB7XG5cdFx0aWYgKG9wdF9maWx0ZXIpIHtcblx0XHRcdHRoaXMuYWRkQXJyYXlPcGVyYXRvcl8ob3BlcmF0b3IsIG9wdF9maWx0ZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUJvZHlfKG9wZXJhdG9yLCB0aGlzLmJvZHlfKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ29tcG9zZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHdpdGggYW4gb3BlcmF0b3IgdGhhdCBzdG9yZXMgaXRzIHZhbHVlcyBpbiBhbiBhcnJheS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7IUZpbHRlcn0gZmlsdGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGFkZEFycmF5T3BlcmF0b3JfKG9wZXJhdG9yLCBmaWx0ZXIpIHtcblx0XHRpZiAoISh0aGlzLmJvZHlfW29wZXJhdG9yXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0dGhpcy5jcmVhdGVCb2R5XyhvcGVyYXRvciwgW3RoaXMuYm9keV9dKTtcblx0XHR9XG5cdFx0dGhpcy5ib2R5X1tvcGVyYXRvcl0ucHVzaChmaWx0ZXIuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciBib2R5IHVzaW5nIHRoZSBnaXZlbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7Li4uKn0gZmlsdGVycyBBIHZhcmlhYmxlIGFtb3VudCBvZiBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkLlxuXHQgKi9cblx0YWRkTWFueShvcGVyYXRvciwgLi4uZmlsdGVycykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5hZGQob3BlcmF0b3IsIGZpbHRlcnNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IGJvZHkgb2JqZWN0LCBzZXR0aW5nIHRoZSByZXF1ZXN0ZCBrZXkgdG8gdGhlIGdpdmVuIHZhbHVlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2V0IGluIHRoZSBuZXcgYm9keSBvYmplY3Rcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIHJlcXVlc3RlZCBrZXkgc2hvdWxkIGhhdmUgaW4gdGhlIG5ldyBib2R5IG9iamVjdC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Y3JlYXRlQm9keV8oa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMuYm9keV8gPSB7fTtcblx0XHR0aGlzLmJvZHlfW2tleV0gPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBmaWx0ZXIncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0Z2V0T2JqZWN0KCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlckJvZHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGdlb21ldHJpY1xuICogc2hhcGVzLlxuICovXG5jbGFzcyBHZW8ge1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQm91bmRpbmdCb3h9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHVwcGVyTGVmdCBUaGUgdXBwZXIgbGVmdCBwb2ludC5cblx0ICogQHBhcmFtIHsqfSBsb3dlclJpZ2h0IFRoZSBsb3dlciByaWdodCBwb2ludC5cblx0ICogQHJldHVybiB7IUJvdW5kaW5nQm94fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYm91bmRpbmdCb3godXBwZXJMZWZ0LCBsb3dlclJpZ2h0KSB7XG5cdFx0cmV0dXJuIG5ldyBHZW8uQm91bmRpbmdCb3godXBwZXJMZWZ0LCBsb3dlclJpZ2h0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBDaXJjbGV9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGNlbnRlciBUaGUgY2lyY2xlJ3MgY2VudGVyIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByYWRpdXMgVGhlIGNpcmNsZSdzIHJhZGl1cy5cblx0ICogQHJldHVybiB7IUNpcmNsZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGNpcmNsZShjZW50ZXIsIHJhZGl1cykge1xuXHRcdHJldHVybiBuZXcgR2VvLkNpcmNsZShjZW50ZXIsIHJhZGl1cyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgTGluZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgbGluZSdzIHBvaW50cy5cblx0ICogQHJldHVybiB7IUxpbmV9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBsaW5lKC4uLnBvaW50cykge1xuXHRcdHJldHVybiBuZXcgR2VvLkxpbmUoLi4ucG9pbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBQb2ludH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGNvb3JkaW5hdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxvbiBUaGUgbG9uZ2l0dWRlIGNvb3JkaW5hdGVcblx0ICogQHJldHVybiB7IVBvaW50fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcG9pbnQobGF0LCBsb24pIHtcblx0XHRyZXR1cm4gbmV3IEdlby5Qb2ludChsYXQsIGxvbik7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUG9seWdvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgcG9seWdvbidzIHBvaW50cy5cblx0ICogQHJldHVybiB7IVBvbHlnb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBwb2x5Z29uKC4uLnBvaW50cykge1xuXHRcdHJldHVybiBuZXcgR2VvLlBvbHlnb24oLi4ucG9pbnRzKTtcblx0fVxufVxuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvaW50IGNvb3JkaW5hdGUuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFBvaW50IGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBQb2ludH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGNvb3JkaW5hdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxvbiBUaGUgbG9uZ2l0dWRlIGNvb3JkaW5hdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihsYXQsIGxvbikge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IFtsYXQsIGxvbl07XG5cdH1cbn1cbkdlby5Qb2ludCA9IFBvaW50O1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGxpbmUuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIExpbmUgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIExpbmV9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0gey4uLip9IHBvaW50cyBUaGlzIGxpbmUncyBwb2ludHMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0ge1xuXHRcdFx0dHlwZTogJ2xpbmVzdHJpbmcnLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IHBvaW50cy5tYXAocG9pbnQgPT4gRW1ib2RpZWQudG9Cb2R5KHBvaW50KSlcblx0XHR9O1xuXHR9XG59XG5HZW8uTGluZSA9IExpbmU7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgYm91bmRpbmcgYm94LlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBCb3VuZGluZ0JveCBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgQm91bmRpbmdCb3h9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHVwcGVyTGVmdCBUaGUgdXBwZXIgbGVmdCBwb2ludC5cblx0ICogQHBhcmFtIHsqfSBsb3dlclJpZ2h0IFRoZSBsb3dlciByaWdodCBwb2ludC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih1cHBlckxlZnQsIGxvd2VyUmlnaHQpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSB7XG5cdFx0XHR0eXBlOiAnZW52ZWxvcGUnLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IFtFbWJvZGllZC50b0JvZHkodXBwZXJMZWZ0KSwgRW1ib2RpZWQudG9Cb2R5KGxvd2VyUmlnaHQpXVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGJvdW5kaW5nIGJveCdzIHBvaW50cy5cblx0ICogQHJldHVybiB7IUFycmF5fVxuXHQgKi9cblx0Z2V0UG9pbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfLmNvb3JkaW5hdGVzO1xuXHR9XG59XG5HZW8uQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBjaXJjbGUuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIENpcmNsZSBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgQ2lyY2xlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSBjZW50ZXIgVGhlIGNpcmNsZSdzIGNlbnRlciBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcmFkaXVzIFRoZSBjaXJjbGUncyByYWRpdXMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoY2VudGVyLCByYWRpdXMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSB7XG5cdFx0XHR0eXBlOiAnY2lyY2xlJyxcblx0XHRcdGNvb3JkaW5hdGVzOiBFbWJvZGllZC50b0JvZHkoY2VudGVyKSxcblx0XHRcdHJhZGl1czogcmFkaXVzXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgY2lyY2xlJ3MgY2VudGVyIGNvb3JkaW5hdGUuXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRnZXRDZW50ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV8uY29vcmRpbmF0ZXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGNpcmNsZSdzIHJhZGl1cy5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UmFkaXVzKCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfLnJhZGl1cztcblx0fVxufVxuR2VvLkNpcmNsZSA9IENpcmNsZTtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBwb2x5Z29uLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBQb2x5Z29uIGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBQb2x5Z29ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBwb2x5Z29uJ3MgcG9pbnRzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKC4uLnBvaW50cykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IHtcblx0XHRcdHR5cGU6ICdwb2x5Z29uJyxcblx0XHRcdGNvb3JkaW5hdGVzOiBbXVxuXHRcdH07XG5cdFx0dGhpcy5hZGRDb29yZGluYXRlc18oLi4ucG9pbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgY29vcmRpbmF0ZXMgZm9yIHRoaXMgcG9seWdvbi5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkQ29vcmRpbmF0ZXNfKC4uLnBvaW50cykge1xuXHRcdHRoaXMuYm9keV8uY29vcmRpbmF0ZXMucHVzaChwb2ludHMubWFwKHBvaW50ID0+IEVtYm9kaWVkLnRvQm9keShwb2ludCkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgYSBob2xlIGluc2lkZSB0aGlzIHBvbHlnb24uXG5cdCAqIEBwYXJhbSAgey4uLip9IHBvaW50c1xuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0aG9sZSguLi5wb2ludHMpIHtcblx0XHR0aGlzLmFkZENvb3JkaW5hdGVzXyguLi5wb2ludHMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5HZW8uUG9seWdvbiA9IFBvbHlnb247XG5cbmV4cG9ydCBkZWZhdWx0IEdlbztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgcmFuZ2Ugb2JqZWN0cyB0byBiZSB1c2VkIGJ5IGBGaWx0ZXJgLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBSYW5nZSBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHBhcmFtIHsqfSBvcHRfdG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihmcm9tLCBvcHRfdG8pIHtcblx0XHRzdXBlcigpO1xuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmcm9tKSkge1xuXHRcdFx0dGhpcy5ib2R5Xy5mcm9tID0gZnJvbTtcblx0XHR9XG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKG9wdF90bykpIHtcblx0XHRcdHRoaXMuYm9keV8udG8gPSBvcHRfdG87XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZnJvbShmcm9tKSB7XG5cdFx0cmV0dXJuIG5ldyBSYW5nZShmcm9tKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSBmcm9tXG5cdCAqIEBwYXJhbSB7Kn0gdG9cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmFuZ2UoZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSB0b1xuXHQgKiBAcmV0dXJuIHshUmFuZ2V9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0byh0bykge1xuXHRcdHJldHVybiBuZXcgUmFuZ2UobnVsbCwgdG8pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhbmdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuaW1wb3J0IEZpbHRlckJvZHkgZnJvbSAnLi9GaWx0ZXJCb2R5JztcbmltcG9ydCBHZW8gZnJvbSAnLi9HZW8nO1xuaW1wb3J0IFJhbmdlIGZyb20gJy4vUmFuZ2UnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBmaWx0ZXJzLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBGaWx0ZXIgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IG9wZXJhdG9yT3JWYWx1ZSBJZiBhIHRoaXJkIHBhcmFtIGlzIGdpdmVuLCB0aGlzIHNob3VsZFxuXHQgKiAgIGJlIHRoZSBmaWx0ZXIncyBvcGVyYXRvciAobGlrZSBcIj49XCIpLiBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZVxuXHQgKiAgIHVzZWQgYXMgdGhlIGZpbHRlcidzIHZhbHVlLCBhbmQgdGhlIGZpbHRlcidzIG9wZXJhdG9yIHdpbGwgYmUgXCI9XCIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0gbmV3IEZpbHRlckJvZHkoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFkZChvcGVyYXRvciwgZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0dmFyIGZpbHRlciA9IGZpZWxkT3JGaWx0ZXIgPyBGaWx0ZXIudG9GaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSA6IG51bGw7XG5cdFx0dGhpcy5ib2R5Xy5hZGQob3BlcmF0b3IsIGZpbHRlcik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHsuLi4qfSBmaWx0ZXJzIEEgdmFyaWFibGUgYW1vdW50IG9mIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRhZGRNYW55KG9wZXJhdG9yLCAuLi5maWx0ZXJzKSB7XG5cdFx0dGhpcy5ib2R5Xy5hZGRNYW55KG9wZXJhdG9yLCAuLi5maWx0ZXJzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIFwiYW5kXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRhbmQoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCdhbmQnLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiYW55XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyEoQXJyYXl8Li4uKil9IHZhbHVlcyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqICAgdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiAgIHNlcGFyYXRlIHBhcmFtcy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGFueShmaWVsZCkge1xuXHRcdHZhciB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdGlmICh2YWx1ZXMubGVuZ3RoID09PSAxICYmIHZhbHVlc1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR2YWx1ZXMgPSB2YWx1ZXNbMF07XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnYW55JywgdmFsdWVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdwXCIgb3BlcmF0b3IuXG5cdCAqIFRoaXMgaXMgYSBzcGVjaWFsIHVzZSBjYXNlIG9mIGBGaWx0ZXIucG9seWdvbmAgZm9yIGJvdW5kaW5nXG5cdCAqIGJveGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSBib3hPclVwcGVyTGVmdCBFaXRoZXIgYSBgR2VvLkJvdW5kaW5nQm94YCBpbnN0YW5jZSwgb3Jcblx0ICogICBhIGJvdW5kaW5nIGJveCdzIHVwcGVyIGxlZnQgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X2xvd2VyUmlnaHQgQSBib3VuZGluZyBib3gncyBsb3dlciByaWdodCBjb29yZGluYXRlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYm91bmRpbmdCb3goZmllbGQsIGJveE9yVXBwZXJMZWZ0LCBvcHRfbG93ZXJSaWdodCkge1xuXHRcdGlmIChib3hPclVwcGVyTGVmdCBpbnN0YW5jZW9mIEdlby5Cb3VuZGluZ0JveCkge1xuXHRcdFx0cmV0dXJuIEZpbHRlci5wb2x5Z29uKGZpZWxkLCAuLi5ib3hPclVwcGVyTGVmdC5nZXRQb2ludHMoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBGaWx0ZXIucG9seWdvbihmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUganNvbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoaXMgZmlsdGVyLlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0Ym9keSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ib2R5Xy5nZXRPYmplY3QoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdkXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uT3JDaXJjbGUgRWl0aGVyIGEgYEdlby5DaXJjbGVgIGluc3RhbmNlIG9yIGEgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtSYW5nZXxzdHJpbmc9fSBvcHRfcmFuZ2VPckRpc3RhbmNlIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3Jcblx0ICogICB0aGUgZGlzdGFuY2UgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBkaXN0YW5jZShmaWVsZCwgbG9jYXRpb25PckNpcmNsZSwgb3B0X3JhbmdlT3JEaXN0YW5jZSkge1xuXHRcdHZhciBsb2NhdGlvbiA9IGxvY2F0aW9uT3JDaXJjbGU7XG5cdFx0dmFyIHJhbmdlID0gb3B0X3JhbmdlT3JEaXN0YW5jZTtcblx0XHRpZiAobG9jYXRpb25PckNpcmNsZSBpbnN0YW5jZW9mIEdlby5DaXJjbGUpIHtcblx0XHRcdGxvY2F0aW9uID0gbG9jYXRpb25PckNpcmNsZS5nZXRDZW50ZXIoKTtcblx0XHRcdHJhbmdlID0gUmFuZ2UudG8obG9jYXRpb25PckNpcmNsZS5nZXRSYWRpdXMoKSk7XG5cdFx0fSBlbHNlIGlmICghKG9wdF9yYW5nZU9yRGlzdGFuY2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcblx0XHRcdHJhbmdlID0gUmFuZ2UudG8ob3B0X3JhbmdlT3JEaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBGaWx0ZXIuZGlzdGFuY2VJbnRlcm5hbF8oZmllbGQsIGxvY2F0aW9uLCByYW5nZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJnZFwiIG9wZXJhdG9yLiBUaGlzXG5cdCAqIGlzIGp1c3QgYW4gaW50ZXJuYWwgaGVscGVyIHVzZWQgYnkgYEZpbHRlci5kaXN0YW5jZWAuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uIEEgbG9jYXRpb24gY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgQSBgUmFuZ2VgIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBkaXN0YW5jZUludGVybmFsXyhmaWVsZCwgbG9jYXRpb24sIHJhbmdlKSB7XG5cdFx0dmFyIHZhbHVlID0ge1xuXHRcdFx0bG9jYXRpb246IEVtYm9kaWVkLnRvQm9keShsb2NhdGlvbilcblx0XHR9O1xuXHRcdHJhbmdlID0gcmFuZ2UuYm9keSgpO1xuXHRcdGlmIChyYW5nZS5mcm9tKSB7XG5cdFx0XHR2YWx1ZS5taW4gPSByYW5nZS5mcm9tO1xuXHRcdH1cblx0XHRpZiAocmFuZ2UudG8pIHtcblx0XHRcdHZhbHVlLm1heCA9IHJhbmdlLnRvO1xuXHRcdH1cblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnZ2QnLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI9XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGVxdWFsKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPScsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImV4aXN0c1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGV4aXN0cyhmaWVsZCkge1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdleGlzdHMnLCBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImZ1enp5XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSBvcHRfcXVlcnlPckZ1enppbmVzcyBJZiB0aGlzIGlzIGEgc3RyaW5nLCBpdCBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnksIG90aGVyd2lzZSBpdCBzaG91bGQgYmUgdGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnV6emluZXNzIFRoZSBmdXp6aW5lc3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmdXp6eShmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKSB7XG5cdFx0cmV0dXJuIEZpbHRlci5mdXp6eUludGVybmFsXygnZnV6enknLCBmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBnaXZlbiBmdXp6eSBvcGVyYXRvci4gVGhpc1xuXHQgKiBpcyBhbiBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IHRoZSBgRmlsdGVyLmZ1enp5YCBtZXRob2QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgZnV6enkgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSBvcHRfcXVlcnlPckZ1enppbmVzcyBJZiB0aGlzIGlzIGEgc3RyaW5nLCBpdCBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnksIG90aGVyd2lzZSBpdCBzaG91bGQgYmUgdGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnV6emluZXNzIFRoZSBmdXp6aW5lc3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZ1enp5SW50ZXJuYWxfKG9wZXJhdG9yLCBmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKSB7XG5cdFx0dmFyIGFyZzJJc1N0cmluZyA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5T3JGdXp6aW5lc3MpO1xuXG5cdFx0dmFyIHZhbHVlID0ge1xuXHRcdFx0cXVlcnk6IGFyZzJJc1N0cmluZyA/IG9wdF9xdWVyeU9yRnV6emluZXNzIDogZmllbGRPclF1ZXJ5XG5cdFx0fTtcblx0XHR2YXIgZnV6emluZXNzID0gYXJnMklzU3RyaW5nID8gb3B0X2Z1enppbmVzcyA6IG9wdF9xdWVyeU9yRnV6emluZXNzO1xuXHRcdGlmIChmdXp6aW5lc3MpIHtcblx0XHRcdHZhbHVlLmZ1enppbmVzcyA9IGZ1enppbmVzcztcblx0XHR9XG5cblx0XHR2YXIgZmllbGQgPSBhcmcySXNTdHJpbmcgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsIG9wZXJhdG9yLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI+XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGd0KGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPicsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIj49XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGd0ZShmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJz49JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwibWF0Y2hcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3F1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtYXRjaChmaWVsZE9yUXVlcnksIG9wdF9xdWVyeSkge1xuXHRcdHZhciBmaWVsZCA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHF1ZXJ5ID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdtYXRjaCcsIHF1ZXJ5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm1pc3NpbmdcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtaXNzaW5nKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ21pc3NpbmcnLCBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcInBocmFzZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogICBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHBocmFzZShmaWVsZE9yUXVlcnksIG9wdF9xdWVyeSkge1xuXHRcdHZhciBmaWVsZCA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHF1ZXJ5ID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdwaHJhc2UnLCBxdWVyeSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJncFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkLlxuXHQgKiBAcGFyYW0gey4uLiFPYmplY3R9IHBvaW50cyBPYmplY3RzIHJlcHJlc2VudGluZyBwb2ludHMgaW4gdGhlIHBvbHlnb24uXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBwb2x5Z29uKGZpZWxkLCAuLi5wb2ludHMpIHtcblx0XHRwb2ludHMgPSBwb2ludHMubWFwKHBvaW50ID0+IEVtYm9kaWVkLnRvQm9keShwb2ludCkpO1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdncCcsIHBvaW50cyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJwcmVmaXhcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkXG5cdCAqICAgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC4gT3RoZXJ3aXNlLFxuXHQgKiAgIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHByZWZpeChmaWVsZE9yUXVlcnksIG9wdF9xdWVyeSkge1xuXHRcdHZhciBmaWVsZCA9IG9wdF9xdWVyeSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHF1ZXJ5ID0gb3B0X3F1ZXJ5ID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdwcmVmaXgnLCBxdWVyeSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJyYW5nZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yTWluIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3IgYSB0aGUgcmFuZ2UncyBtaW4gdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9tYXggVGhlIHJhbmdlJ3MgbWF4IHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmFuZ2UoZmllbGQsIHJhbmdlT3JNaW4sIG9wdF9tYXgpIHtcblx0XHR2YXIgcmFuZ2UgPSByYW5nZU9yTWluO1xuXHRcdGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG5cdFx0XHRyYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JNaW4sIG9wdF9tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAncmFuZ2UnLCByYW5nZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJ+XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHJlZ2V4KGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnficsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0gey4uLiFPYmplY3R9IHNoYXBlcyBPYmplY3RzIHJlcHJlc2VudGluZyBzaGFwZXMuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzaGFwZShmaWVsZCwgLi4uc2hhcGVzKSB7XG5cdFx0c2hhcGVzID0gc2hhcGVzLm1hcChzaGFwZSA9PiBFbWJvZGllZC50b0JvZHkoc2hhcGUpKTtcblx0XHR2YXIgdmFsdWUgPSB7XG5cdFx0XHR0eXBlOiAnZ2VvbWV0cnljb2xsZWN0aW9uJyxcblx0XHRcdGdlb21ldHJpZXM6IHNoYXBlc1xuXHRcdH07XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ2dzJywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwic2ltaWxhclwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogICBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHs/c3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc2ltaWxhcihmaWVsZE9yUXVlcnksIHF1ZXJ5KSB7XG5cdFx0dmFyIGZpZWxkID0gY29yZS5pc1N0cmluZyhxdWVyeSkgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuXHRcdHZhciB2YWx1ZSA9IHtcblx0XHRcdHF1ZXJ5OiBjb3JlLmlzU3RyaW5nKHF1ZXJ5KSA/IHF1ZXJ5IDogZmllbGRPclF1ZXJ5XG5cdFx0fTtcblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnc2ltaWxhcicsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIjxcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbHQoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc8JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPD1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbHRlKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPD0nLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJub25lXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyEoQXJyYXl8Li4uKil9IHZhbHVlIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiBzZXBhcmF0ZSBwYXJhbXMuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBub25lKGZpZWxkKSB7XG5cdFx0dmFyIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0aWYgKHZhbHVlcy5sZW5ndGggPT09IDEgJiYgdmFsdWVzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHZhbHVlcyA9IHZhbHVlc1swXTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICdub25lJywgdmFsdWVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIiE9XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG5vdEVxdWFsKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnIT0nLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJub3RcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvclxuXHQgKiB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBub3QoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIEZpbHRlci50b0ZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpLmFkZCgnbm90Jyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSBvcGVyYXRvck9yVmFsdWUgSWYgYSB0aGlyZCBwYXJhbSBpcyBnaXZlbiwgdGhpcyBzaG91bGQgYmUgdGhlXG5cdCAqIGZpbHRlcidzIG9wZXJhdG9yIChsaWtlIFwiPj1cIikuIE90aGVyd2lzZSwgdGhpcyB3aWxsIGJlIHVzZWQgYXMgdGhlXG5cdCAqIGZpbHRlcidzIHZhbHVlLCBhbmQgdGhlIGZpbHRlcidzIG9wZXJhdG9yIHdpbGwgYmUgXCI9XCIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmaWVsZChmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgXCJvclwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdG9yKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLmFkZCgnb3InLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBhcmd1bWVudHMgaW50byBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICovXG5cdHN0YXRpYyB0b0ZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgZmlsdGVyID0gZmllbGRPckZpbHRlcjtcblx0XHRpZiAoIShmaWx0ZXIgaW5zdGFuY2VvZiBGaWx0ZXIpKSB7XG5cdFx0XHRmaWx0ZXIgPSBGaWx0ZXIuZmllbGQoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZpbHRlcjtcblx0fVxufVxuXG4vKipcbiAqIFN0cmluZyBjb25zdGFudCB0aGF0IHJlcHJlc2VudHMgYWxsIGZpZWxkcy5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cbkZpbHRlci5BTEwgPSAnKic7XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHVyaSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG4gKiBAcGFyYW0geyo9fSBvcHRfdXJpIE9wdGlvbmFsIHN0cmluZyBVUkkgdG8gcGFyc2VcbiAqL1xuZnVuY3Rpb24gcGFyc2VGcm9tQW5jaG9yKG9wdF91cmkpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdGxpbmsuaHJlZiA9IG9wdF91cmk7XG5cdHJldHVybiB7XG5cdFx0aGFzaDogbGluay5oYXNoLFxuXHRcdGhvc3RuYW1lOiBsaW5rLmhvc3RuYW1lLFxuXHRcdHBhc3N3b3JkOiBsaW5rLnBhc3N3b3JkLFxuXHRcdHBhdGhuYW1lOiBsaW5rLnBhdGhuYW1lWzBdID09PSAnLycgPyBsaW5rLnBhdGhuYW1lIDogJy8nICsgbGluay5wYXRobmFtZSxcblx0XHRwb3J0OiBsaW5rLnBvcnQsXG5cdFx0cHJvdG9jb2w6IGxpbmsucHJvdG9jb2wsXG5cdFx0c2VhcmNoOiBsaW5rLnNlYXJjaCxcblx0XHR1c2VybmFtZTogbGluay51c2VybmFtZVxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZUZyb21BbmNob3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgcGFyc2VGcm9tQW5jaG9yIGZyb20gJy4vcGFyc2VGcm9tQW5jaG9yJztcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHVyaSBzdHJpbmcgaW50byBhbiBvYmplY3QuIFRoZSBVUkwgZnVuY3Rpb24gd2lsbCBiZSB1c2VkXG4gKiB3aGVuIHByZXNlbnQsIG90aGVyd2lzZSB3ZSdsbCBmYWxsIGJhY2sgdG8gdGhlIGFuY2hvciBub2RlIGVsZW1lbnQuXG4gKiBAcGFyYW0geyo9fSBvcHRfdXJpIE9wdGlvbmFsIHN0cmluZyBVUkkgdG8gcGFyc2VcbiAqL1xuZnVuY3Rpb24gcGFyc2Uob3B0X3VyaSkge1xuXHRpZiAoaXNGdW5jdGlvbihVUkwpICYmIFVSTC5sZW5ndGgpIHtcblx0XHRyZXR1cm4gbmV3IFVSTChvcHRfdXJpKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gcGFyc2VGcm9tQW5jaG9yKG9wdF91cmkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIEEgY2FjaGVkIHJlZmVyZW5jZSB0byB0aGUgY3JlYXRlIGZ1bmN0aW9uLlxuICovXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBDYXNlIGluc2Vuc2l0aXZlIHN0cmluZyBNdWx0aW1hcCBpbXBsZW1lbnRhdGlvbi4gQWxsb3dzIG11bHRpcGxlIHZhbHVlcyBmb3JcbiAqIHRoZSBzYW1lIGtleSBuYW1lLlxuICogQGV4dGVuZHMge0Rpc3Bvc2FibGV9XG4gKi9cbmNsYXNzIE11bHRpTWFwIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5rZXlzID0gY3JlYXRlKG51bGwpO1xuXHRcdHRoaXMudmFsdWVzID0gY3JlYXRlKG51bGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdmFsdWUgdG8gYSBrZXkgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhZGQobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5hbWU7XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgW107XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXS5wdXNoKHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgbWFwIG5hbWVzIGFuZCB2YWx1ZXMuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGNsZWFyKCkge1xuXHRcdHRoaXMua2V5cyA9IGNyZWF0ZShudWxsKTtcblx0XHR0aGlzLnZhbHVlcyA9IGNyZWF0ZShudWxsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgbWFwIGNvbnRhaW5zIGEgdmFsdWUgdG8gdGhlIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRjb250YWlucyhuYW1lKSB7XG5cdFx0cmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKSBpbiB0aGlzLnZhbHVlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0ZGlzcG9zZUludGVybmFsKCkge1xuXHRcdHRoaXMudmFsdWVzID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYE11bHRpTWFwYCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG5cdCAqIEByZXR1cm4geyFNdWx0aU1hcH1cblx0ICovXG5cdHN0YXRpYyBmcm9tT2JqZWN0KG9iaikge1xuXHRcdHZhciBtYXAgPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXAuc2V0KGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXA7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZmlyc3QgYWRkZWQgdmFsdWUgZnJvbSBhIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRnZXQobmFtZSkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdHJldHVybiB2YWx1ZXNbMF07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYWxsIHZhbHVlcyBmcm9tIGEga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4ge0FycmF5LjwqPn1cblx0ICovXG5cdGdldEFsbChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBtYXAgaXMgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRW1wdHkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2l6ZSgpID09PSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYXJyYXkgb2Yga2V5IG5hbWVzLlxuXHQgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cblx0ICovXG5cdG5hbWVzKCkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykubWFwKChrZXkpID0+IHRoaXMua2V5c1trZXldKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCB2YWx1ZXMgZnJvbSBhIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRyZW1vdmUobmFtZSkge1xuXHRcdGRlbGV0ZSB0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRkZWxldGUgdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGtleSBuYW1lLiBSZWxldmFudCB0byByZXBsYWNlIHRoZSBjdXJyZW50IHZhbHVlcyB3aXRoXG5cdCAqIGEgbmV3IG9uZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXQobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5hbWU7XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IFt2YWx1ZV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgbWFwIGtleSBuYW1lcy5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5uYW1lcygpLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwYXJzZWQgdmFsdWVzIGFzIGEgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpTWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBhcnJheSB9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBHZW5lcmljIHRyZWUgbm9kZSBkYXRhIHN0cnVjdHVyZSB3aXRoIGFyYml0cmFyeSBudW1iZXIgb2YgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0ge1Z9IHZhbHVlIFZhbHVlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFRyZWVOb2RlIHtcblxuXHRjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB2YWx1ZS5cblx0XHQgKiBAcHJpdmF0ZSB7Vn1cblx0XHQgKi9cblx0XHR0aGlzLnZhbHVlXyA9IHZhbHVlO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgbm9kZSBvciBudWxsIGlmIGl0IGhhcyBubyBwYXJlbnQuXG5cdFx0ICogQHByaXZhdGUge1RyZWVOb2RlfVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyZW50XyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBDaGlsZCBub2RlcyBvciBudWxsIGluIGNhc2Ugb2YgbGVhZiBub2RlLlxuXHRcdCAqIEBwcml2YXRlIHtBcnJheTwhVHJlZU5vZGU+fVxuXHRcdCAqL1xuXHRcdHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIGEgY2hpbGQgbm9kZSB0byB0aGlzIG5vZGUuXG5cdCAqIEBwYXJhbSB7IVRyZWVOb2RlfSBjaGlsZCBPcnBoYW4gY2hpbGQgbm9kZS5cblx0ICovXG5cdGFkZENoaWxkKGNoaWxkKSB7XG5cdFx0YXNzZXJ0Q2hpbGRIYXNOb1BhcmVudChjaGlsZCk7XG5cdFx0Y2hpbGQuc2V0UGFyZW50KHRoaXMpO1xuXHRcdHRoaXMuY2hpbGRyZW5fID0gdGhpcy5jaGlsZHJlbl8gfHwgW107XG5cdFx0dGhpcy5jaGlsZHJlbl8ucHVzaChjaGlsZCk7XG5cdH1cblxuXHQvKipcblx0ICogVGVsbHMgd2hldGhlciB0aGlzIG5vZGUgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBub2RlLlxuXHQgKiBAcGFyYW0geyFUcmVlTm9kZX0gbm9kZSBBIG5vZGUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBub2RlIGlzIHRoZSBhbmNlc3RvciBvZiB7QGNvZGUgbm9kZX0uXG5cdCAqL1xuXHRjb250YWlucyhub2RlKSB7XG5cdFx0bGV0IGN1cnJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXHRcdHdoaWxlIChjdXJyZW50KSB7XG5cdFx0XHRpZiAoY3VycmVudCA9PT0gdGhpcykge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGN1cnJlbnQgPSBjdXJyZW50LmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7IUFycmF5PFRyZWVOb2RlPn0gQWxsIGFuY2VzdG9yIG5vZGVzIGluIGJvdHRvbS11cCBvcmRlci5cblx0ICovXG5cdGdldEFuY2VzdG9ycygpIHtcblx0XHRsZXQgYW5jZXN0b3JzID0gW107XG5cdFx0bGV0IG5vZGUgPSB0aGlzLmdldFBhcmVudCgpO1xuXHRcdHdoaWxlIChub2RlKSB7XG5cdFx0XHRhbmNlc3RvcnMucHVzaChub2RlKTtcblx0XHRcdG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gYW5jZXN0b3JzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGNoaWxkIG5vZGUgb2YgdGhpcyBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IENoaWxkIGluZGV4LlxuXHQgKiBAcmV0dXJuIHs/VHJlZU5vZGV9IFRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBvciBudWxsIGlmIG5vdCBmb3VuZC5cblx0ICovXG5cdGdldENoaWxkQXQoaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpW2luZGV4XSB8fCBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4gez9BcnJheTwhVHJlZU5vZGU+fSBDaGlsZCBub2RlcyBvciBudWxsIGluIGNhc2Ugb2YgbGVhZiBub2RlLlxuXHQgKi9cblx0Z2V0Q2hpbGRyZW4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW5fIHx8IFRyZWVOb2RlLkVNUFRZX0FSUkFZO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cblx0ICovXG5cdGdldENoaWxkQ291bnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oKS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGFuY2VzdG9ycyBvZiB0aGUgbm9kZS5cblx0ICovXG5cdGdldERlcHRoKCkge1xuXHRcdGxldCBkZXB0aCA9IDA7XG5cdFx0bGV0IG5vZGUgPSB0aGlzO1xuXHRcdHdoaWxlIChub2RlLmdldFBhcmVudCgpKSB7XG5cdFx0XHRkZXB0aCsrO1xuXHRcdFx0bm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiBkZXB0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHs/VHJlZU5vZGV9IFBhcmVudCBub2RlIG9yIG51bGwgaWYgaXQgaGFzIG5vIHBhcmVudC5cblx0ICovXG5cdGdldFBhcmVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4geyFUcmVlTm9kZX0gVGhlIHJvb3Qgb2YgdGhlIHRyZWUgc3RydWN0dXJlLCBpLmUuIHRoZSBmYXJ0aGVzdFxuXHQgKiBhbmNlc3RvciBvZiB0aGUgbm9kZSBvciB0aGUgbm9kZSBpdHNlbGYgaWYgaXQgaGFzIG5vIHBhcmVudHMuXG5cdCAqL1xuXHRnZXRSb290KCkge1xuXHRcdGxldCByb290ID0gdGhpcztcblx0XHR3aGlsZSAocm9vdC5nZXRQYXJlbnQoKSkge1xuXHRcdFx0cm9vdCA9IHJvb3QuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiByb290O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtWfSBUaGUgdmFsdWUuXG5cdCAqL1xuXHRnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZV87XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbm9kZSBpcyBhIGxlYWYgbm9kZS5cblx0ICovXG5cdGlzTGVhZigpIHtcblx0XHRyZXR1cm4gIXRoaXMuZ2V0Q2hpbGRDb3VudCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGdpdmVuIGNoaWxkIG5vZGUgb2YgdGhpcyBub2RlLlxuXHQgKiBAcGFyYW0ge1RyZWVOb2RlfSBjaGlsZCBUaGUgbm9kZSB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge1RyZWVOb2RlfSBUaGUgcmVtb3ZlZCBub2RlIGlmIGFueSwgbnVsbCBvdGhlcndpc2UuXG5cdCAqL1xuXHRyZW1vdmVDaGlsZChjaGlsZCkge1xuXHRcdGlmIChhcnJheS5yZW1vdmUodGhpcy5nZXRDaGlsZHJlbigpLCBjaGlsZCkpIHtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGFyZW50IG5vZGUgb2YgdGhpcyBub2RlLiBUaGUgY2FsbGVycyBtdXN0IGVuc3VyZSB0aGF0IHRoZVxuXHQgKiBwYXJlbnQgbm9kZSBhbmQgb25seSB0aGF0IGhhcyB0aGlzIG5vZGUgYW1vbmcgaXRzIGNoaWxkcmVuLlxuXHQgKiBAcGFyYW0ge1RyZWVOb2RlfSBwYXJlbnQgVGhlIHBhcmVudCB0byBzZXQuIElmIG51bGwsIHRoZSBub2RlIHdpbGwgYmVcblx0ICogZGV0YWNoZWQgZnJvbSB0aGUgdHJlZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0UGFyZW50KHBhcmVudCkge1xuXHRcdHRoaXMucGFyZW50XyA9IHBhcmVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmF2ZXJzZXMgdGhlIHN1YnRyZWUuIFRoZSBmaXJzdCBjYWxsYmFjayBzdGFydHMgd2l0aCB0aGlzIG5vZGUsXG5cdCAqIGFuZCB2aXNpdHMgdGhlIGRlc2NlbmRhbnQgbm9kZXMgZGVwdGgtZmlyc3QsIGluIHByZW9yZGVyLlxuXHQgKiBUaGUgc2Vjb25kIGNhbGxiYWNrLCBzdGFydHMgd2l0aCBkZWVwZXN0IGNoaWxkIHRoZW4gdmlzaXRzXG5cdCAqIHRoZSBhbmNlc3RvciBub2RlcyBkZXB0aC1maXJzdCwgaW4gcG9zdG9yZGVyLiBFLmcuXG5cdCAqXG5cdCAqICBcdCBBXG5cdCAqICAgIC8gXFxcblx0ICogICBCICAgQ1xuXHQgKiAgLyAgIC8gXFxcblx0ICogRCAgIEUgICBGXG5cdCAqXG5cdCAqIHByZW9yZGVyIC0+IFsnQScsICdCJywgJ0QnLCAnQycsICdFJywgJ0YnXVxuXHQgKiBwb3N0b3JkZXIgLT4gWydEJywgJ0InLCAnRScsICdGJywgJ0MnLCAnQSddXG5cdCAqXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvcHRfcHJlb3JkZXJGbiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHZpc2l0aW5nIGEgbm9kZS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbj19IG9wdF9wb3N0b3JkZXJGbiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgbGVhdmluZyBhIG5vZGUuXG5cdCAqL1xuXHR0cmF2ZXJzZShvcHRfcHJlb3JkZXJGbiwgb3B0X3Bvc3RvcmRlckZuKSB7XG5cdFx0aWYgKG9wdF9wcmVvcmRlckZuKSB7XG5cdFx0XHRvcHRfcHJlb3JkZXJGbih0aGlzKTtcblx0XHR9XG5cdFx0dGhpcy5nZXRDaGlsZHJlbigpLmZvckVhY2goKGNoaWxkKSA9PiBjaGlsZC50cmF2ZXJzZShvcHRfcHJlb3JkZXJGbiwgb3B0X3Bvc3RvcmRlckZuKSk7XG5cdFx0aWYgKG9wdF9wb3N0b3JkZXJGbikge1xuXHRcdFx0b3B0X3Bvc3RvcmRlckZuKHRoaXMpO1xuXHRcdH1cblx0fVxuXG59XG5cbi8qKlxuICogQ29uc3RhbnQgZm9yIGVtcHR5IGFycmF5IHRvIGF2b2lkIHVubmVjZXNzYXJ5IGFsbG9jYXRpb25zLlxuICogQHByaXZhdGVcbiAqL1xuVHJlZU5vZGUuRU1QVFlfQVJSQVkgPSBbXTtcblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgY2hpbGQgaGFzIG5vIHBhcmVudC5cbiAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkIEEgY2hpbGQuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBhc3NlcnRDaGlsZEhhc05vUGFyZW50ID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0aWYgKGNoaWxkLmdldFBhcmVudCgpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGNoaWxkIHdpdGggcGFyZW50LicpO1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUcmVlTm9kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgaXNEZWYsIHN0cmluZyB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlJztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5cbnZhciBwYXJzZUZuXyA9IHBhcnNlO1xuXG5jbGFzcyBVcmkge1xuXG5cdC8qKlxuXHQgKiBUaGlzIGNsYXNzIGNvbnRhaW5zIHNldHRlcnMgYW5kIGdldHRlcnMgZm9yIHRoZSBwYXJ0cyBvZiB0aGUgVVJJLlxuXHQgKiBUaGUgZm9sbG93aW5nIGZpZ3VyZSBkaXNwbGF5cyBhbiBleGFtcGxlIFVSSXMgYW5kIHRoZWlyIGNvbXBvbmVudCBwYXJ0cy5cblx0ICpcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFxuXHQgKlx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIzilIDilIDilIDilLTilIDilIDilIDilIDilJBcblx0ICpcdCAgYWJjOi8vZXhhbXBsZS5jb206MTIzL3BhdGgvZGF0YT9rZXk9dmFsdWUjZnJhZ2lkMVxuXHQgKlx0ICDilJTilKzilJggICDilJTilIDilIDilIDilIDilKzilIDilIDilIDilIDilJgg4pSU4pSs4pSYICAgICAgICAgICDilJTilIDilIDilIDilKzilIDilIDilIDilJgg4pSU4pSA4pSA4pSs4pSA4pSA4pSYXG5cdCAqIHByb3RvY29sICBob3N0bmFtZSAgcG9ydCAgICAgICAgICAgIHNlYXJjaCAgICBoYXNoXG5cdCAqICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXHQgKiAgICAgICAgICAgICAgICBob3N0XG5cdCAqXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdF91cmkgPSAnJykge1xuXHRcdHRoaXMudXJsID0gVXJpLnBhcnNlKHRoaXMubWF5YmVBZGRQcm90b2NvbEFuZEhvc3RuYW1lXyhvcHRfdXJpKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBwYXJhbWV0ZXJzIHRvIHVyaSBmcm9tIGEgPGNvZGU+TXVsdGlNYXA8L2NvZGU+IGFzIHNvdXJjZS5cblx0ICogQHBhcmFtIHtNdWx0aU1hcH0gbXVsdGltYXAgVGhlIDxjb2RlPk11bHRpTWFwPC9jb2RlPiBjb250YWluaW5nIHRoZVxuXHQgKiAgIHBhcmFtZXRlcnMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcChtdWx0aW1hcCkge1xuXHRcdG11bHRpbWFwLm5hbWVzKCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdFx0bXVsdGltYXAuZ2V0QWxsKG5hbWUpLmZvckVhY2goKHZhbHVlKSA9PiB7XG5cdFx0XHRcdHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS4gV2lsbCBiZSBleHBsaWNpdGx5IGNhc3RlZCB0byBTdHJpbmcuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdGlmIChpc0RlZih2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblx0XHR9XG5cdFx0dGhpcy5xdWVyeS5hZGQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHZhbHVlcyBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFBhcmFtZXRlclZhbHVlcyhuYW1lLCB2YWx1ZXMpIHtcblx0XHR2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFbnN1cmVzIHF1ZXJ5IGludGVybmFsIG1hcCBpcyBpbml0aWFsaXplZCBhbmQgc3luY2VkIHdpdGggaW5pdGlhbCB2YWx1ZVxuXHQgKiBleHRyYWN0ZWQgZnJvbSBVUkkgc2VhcmNoIHBhcnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCkge1xuXHRcdGlmICh0aGlzLnF1ZXJ5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMucXVlcnkgPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR2YXIgc2VhcmNoID0gdGhpcy51cmwuc2VhcmNoO1xuXHRcdGlmIChzZWFyY2gpIHtcblx0XHRcdHNlYXJjaC5zdWJzdHJpbmcoMSkuc3BsaXQoJyYnKS5mb3JFYWNoKChwYXJhbSkgPT4ge1xuXHRcdFx0XHR2YXIgW2tleSwgdmFsdWVdID0gcGFyYW0uc3BsaXQoJz0nKTtcblx0XHRcdFx0aWYgKGlzRGVmKHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhbHVlID0gVXJpLnVybERlY29kZSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRQYXJhbWV0ZXJWYWx1ZShrZXksIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBoYXNoIHBhcnQgb2YgdXJpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRIYXNoKCkge1xuXHRcdHJldHVybiB0aGlzLnVybC5oYXNoIHx8ICcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhvc3QgcGFydCBvZiB1cmkuIEUuZy4gPGNvZGU+W2hvc3RuYW1lXTpbcG9ydF08L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRIb3N0KCkge1xuXHRcdHZhciBob3N0ID0gdGhpcy5nZXRIb3N0bmFtZSgpO1xuXHRcdGlmIChob3N0KSB7XG5cdFx0XHR2YXIgcG9ydCA9IHRoaXMuZ2V0UG9ydCgpO1xuXHRcdFx0aWYgKHBvcnQgJiYgcG9ydCAhPT0gJzgwJykge1xuXHRcdFx0XHRob3N0ICs9ICc6JyArIHBvcnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBob3N0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhvc3RuYW1lIHBhcnQgb2YgdXJpIHdpdGhvdXQgcHJvdG9jb2wgYW5kIHBvcnQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEhvc3RuYW1lKCkge1xuXHRcdHZhciBob3N0bmFtZSA9IHRoaXMudXJsLmhvc3RuYW1lO1xuXHRcdGlmIChob3N0bmFtZSA9PT0gVXJpLkhPU1ROQU1FX1BMQUNFSE9MREVSKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdHJldHVybiBob3N0bmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBvcmlnaW4gcGFydCBvZiB1cmkuIEUuZy4gPGNvZGU+aHR0cDovL1tob3N0bmFtZV06W3BvcnRdPC9jb2RlPi5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0T3JpZ2luKCkge1xuXHRcdHZhciBob3N0ID0gdGhpcy5nZXRIb3N0KCk7XG5cdFx0aWYgKGhvc3QpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFByb3RvY29sKCkgKyAnLy8nICsgaG9zdDtcblx0XHR9XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGZvciBhIGdpdmVuIHBhcmFtZXRlciBvciB1bmRlZmluZWQgaWYgdGhlIGdpdmVuXG5cdCAqIHBhcmFtZXRlciBuYW1lIGRvZXMgbm90IGFwcGVhciBpbiB0aGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lIFVuZXNjYXBlZCBwYXJhbWV0ZXIgbmFtZS5cblx0ICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIGZpcnN0IHZhbHVlIGZvciBhIGdpdmVuIHBhcmFtZXRlciBvclxuXHQgKiAgIHVuZGVmaW5lZCBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUgZG9lcyBub3QgYXBwZWFyIGluIHRoZSBxdWVyeVxuXHQgKiAgIHN0cmluZy5cblx0ICovXG5cdGdldFBhcmFtZXRlclZhbHVlKG5hbWUpIHtcblx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0cmV0dXJuIHRoaXMucXVlcnkuZ2V0KG5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHZhbHVlPGI+czwvYj4gZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIGFzIGEgbGlzdCBvZiBkZWNvZGVkXG5cdCAqIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwYXJhbWV0ZXIgdG8gZ2V0IHZhbHVlcyBmb3IuXG5cdCAqIEByZXR1cm4geyFBcnJheTw/Pn0gVGhlIHZhbHVlcyBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgYXMgYSBsaXN0IG9mIGRlY29kZWRcblx0ICogICBxdWVyeSBwYXJhbWV0ZXIgdmFsdWVzLlxuXHQgKi9cblx0Z2V0UGFyYW1ldGVyVmFsdWVzKG5hbWUpIHtcblx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0cmV0dXJuIHRoaXMucXVlcnkuZ2V0QWxsKG5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5hbWU8Yj5zPC9iPiBvZiB0aGUgcGFyYW1ldGVycy5cblx0ICogQHJldHVybiB7IUFycmF5PHN0cmluZz59IFRoZSBuYW1lcyBmb3IgdGhlIHBhcmFtZXRlcnMgYXMgYSBsaXN0IG9mXG5cdCAqICAgc3RyaW5ncy5cblx0ICovXG5cdGdldFBhcmFtZXRlck5hbWVzKCkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5uYW1lcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGZ1bmN0aW9uIGN1cnJlbnRseSBiZWluZyB1c2VkIHRvIHBhcnNlIFVSSXMuXG5cdCAqIEByZXR1cm4geyFmdW5jdGlvbigpfVxuXHQgKi9cblx0c3RhdGljIGdldFBhcnNlRm4oKSB7XG5cdFx0cmV0dXJuIHBhcnNlRm5fO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBhdGhuYW1lIHBhcnQgb2YgdXJpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRQYXRobmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmwucGF0aG5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9ydCBudW1iZXIgcGFydCBvZiB1cmkgYXMgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRQb3J0KCkge1xuXHRcdHJldHVybiB0aGlzLnVybC5wb3J0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHByb3RvY29sIHBhcnQgb2YgdXJpLiBFLmcuIDxjb2RlPmh0dHA6PC9jb2RlPi5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UHJvdG9jb2woKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsLnByb3RvY29sO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHNlYXJjaCBwYXJ0IG9mIHVyaS4gU2VhcmNoIHZhbHVlIGlzIHJldHJpZXZlZCBmcm9tIHF1ZXJ5XG5cdCAqIHBhcmFtZXRlcnMuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFNlYXJjaCgpIHtcblx0XHR2YXIgc2VhcmNoID0gJyc7XG5cdFx0dmFyIHF1ZXJ5c3RyaW5nID0gJyc7XG5cdFx0dGhpcy5nZXRQYXJhbWV0ZXJOYW1lcygpLmZvckVhY2goKG5hbWUpID0+IHtcblx0XHRcdHRoaXMuZ2V0UGFyYW1ldGVyVmFsdWVzKG5hbWUpLmZvckVhY2goKHZhbHVlKSA9PiB7XG5cdFx0XHRcdHF1ZXJ5c3RyaW5nICs9IG5hbWU7XG5cdFx0XHRcdGlmIChpc0RlZih2YWx1ZSkpIHtcblx0XHRcdFx0XHRxdWVyeXN0cmluZyArPSAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHF1ZXJ5c3RyaW5nICs9ICcmJztcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHF1ZXJ5c3RyaW5nID0gcXVlcnlzdHJpbmcuc2xpY2UoMCwgLTEpO1xuXHRcdGlmIChxdWVyeXN0cmluZykge1xuXHRcdFx0c2VhcmNoICs9ICc/JyArIHF1ZXJ5c3RyaW5nO1xuXHRcdH1cblx0XHRyZXR1cm4gc2VhcmNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB1cmkgY29udGFpbnMgdGhlIHBhcmFtZXRlci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1BhcmFtZXRlcihuYW1lKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdHJldHVybiB0aGlzLnF1ZXJ5LmNvbnRhaW5zKG5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHRoaXMgVVJMIHVuaXF1ZSBieSBhZGRpbmcgYSByYW5kb20gcGFyYW0gdG8gaXQuIFVzZWZ1bCBmb3IgYXZvaWRpbmdcblx0ICogY2FjaGUuXG5cdCAqL1xuXHRtYWtlVW5pcXVlKCkge1xuXHRcdHRoaXMuc2V0UGFyYW1ldGVyVmFsdWUoVXJpLlJBTkRPTV9QQVJBTSwgc3RyaW5nLmdldFJhbmRvbVN0cmluZygpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXliZSBhZGRzIHByb3RvY29sIGFuZCBhIGhvc3RuYW1lIHBsYWNlaG9sZGVyIG9uIGEgcGFyaWFsIFVSSSBpZiBuZWVkZWQuXG5cdCAqIFJlbGV2ZW50IGZvciBjb21wYXRpYmlsaXR5IHdpdGggPGNvZGU+VVJMPC9jb2RlPiBuYXRpdmUgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF91cmlcblx0ICogQHJldHVybiB7c3RyaW5nfSBVUkkgd2l0aCBwcm90b2NvbCBhbmQgaG9zdG5hbWUgcGxhY2Vob2xkZXIuXG5cdCAqL1xuXHRtYXliZUFkZFByb3RvY29sQW5kSG9zdG5hbWVfKG9wdF91cmkpIHtcblx0XHR2YXIgdXJsID0gb3B0X3VyaTtcblx0XHRpZiAob3B0X3VyaS5pbmRleE9mKCc6Ly8nKSA9PT0gLTEgJiZcblx0XHRcdG9wdF91cmkuaW5kZXhPZignamF2YXNjcmlwdDonKSAhPT0gMCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuXHRcdFx0dXJsID0gVXJpLkRFRkFVTFRfUFJPVE9DT0w7XG5cdFx0XHRpZiAob3B0X3VyaVswXSAhPT0gJy8nIHx8IG9wdF91cmlbMV0gIT09ICcvJykge1xuXHRcdFx0XHR1cmwgKz0gJy8vJztcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoIChvcHRfdXJpLmNoYXJBdCgwKSkge1xuXHRcdFx0XHRjYXNlICcuJzpcblx0XHRcdFx0Y2FzZSAnPyc6XG5cdFx0XHRcdGNhc2UgJyMnOlxuXHRcdFx0XHRcdHVybCArPSBVcmkuSE9TVE5BTUVfUExBQ0VIT0xERVI7XG5cdFx0XHRcdFx0dXJsICs9ICcvJztcblx0XHRcdFx0XHR1cmwgKz0gb3B0X3VyaTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnJzpcblx0XHRcdFx0Y2FzZSAnLyc6XG5cdFx0XHRcdFx0aWYgKG9wdF91cmlbMV0gIT09ICcvJykge1xuXHRcdFx0XHRcdFx0dXJsICs9IFVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dXJsICs9IG9wdF91cmk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dXJsICs9IG9wdF91cmk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1cmw7XG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyB0aGUgcGFyc2VkIG9iamVjdCB0byBiZSBpbiB0aGUgZXhwZWN0ZWQgc3RhbmRhcmQuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH1cblx0ICovXG5cdHN0YXRpYyBub3JtYWxpemVPYmplY3QocGFyc2VkKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHBhcnNlZC5wYXRobmFtZSA/IHBhcnNlZC5wYXRobmFtZS5sZW5ndGggOiAwO1xuXHRcdGlmIChsZW5ndGggPiAxICYmIHBhcnNlZC5wYXRobmFtZVtsZW5ndGggLSAxXSA9PT0gJy8nKSB7XG5cdFx0XHRwYXJzZWQucGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWUuc3Vic3RyKDAsIGxlbmd0aCAtIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyc2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3VyaSBPcHRpb25hbCBzdHJpbmcgVVJJIHRvIHBhcnNlXG5cdCAqL1xuXHRzdGF0aWMgcGFyc2Uob3B0X3VyaSkge1xuXHRcdHJldHVybiBVcmkubm9ybWFsaXplT2JqZWN0KHBhcnNlRm5fKG9wdF91cmkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwYXJhbWV0ZXIgdG8gcmVtb3ZlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRyZW1vdmVQYXJhbWV0ZXIobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHR0aGlzLnF1ZXJ5LnJlbW92ZShuYW1lKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHVuaXF1ZW5lc3MgcGFyYW1ldGVyIG9mIHRoZSB1cmkuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHJlbW92ZVVuaXF1ZSgpIHtcblx0XHR0aGlzLnJlbW92ZVBhcmFtZXRlcihVcmkuUkFORE9NX1BBUkFNKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBoYXNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRIYXNoKGhhc2gpIHtcblx0XHR0aGlzLnVybC5oYXNoID0gaGFzaDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBob3N0bmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldEhvc3RuYW1lKGhvc3RuYW1lKSB7XG5cdFx0dGhpcy51cmwuaG9zdG5hbWUgPSBob3N0bmFtZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVycywgY2xlYXJpbmcgcHJldmlvdXMgdmFsdWVzXG5cdCAqIGZvciB0aGF0IGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMucmVtb3ZlUGFyYW1ldGVyKG5hbWUpO1xuXHRcdHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlcyBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVycywgY2xlYXJpbmcgcHJldmlvdXMgdmFsdWVzXG5cdCAqIGZvciB0aGF0IGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSwgdmFsdWVzKSB7XG5cdFx0dGhpcy5yZW1vdmVQYXJhbWV0ZXIobmFtZSk7XG5cdFx0dmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB0aGlzLmFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGF0aG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQYXRobmFtZShwYXRobmFtZSkge1xuXHRcdHRoaXMudXJsLnBhdGhuYW1lID0gcGF0aG5hbWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcG9ydCBudW1iZXIuXG5cdCAqIEBwYXJhbSB7Kn0gcG9ydCBQb3J0IG51bWJlci5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UG9ydChwb3J0KSB7XG5cdFx0dGhpcy51cmwucG9ydCA9IHBvcnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHBhcnNpbmcgdGhlIG9yaWdpbmFsIHN0cmluZyB1cmlcblx0ICogaW50byBhbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHBhcnNlRm5cblx0ICovXG5cdHN0YXRpYyBzZXRQYXJzZUZuKHBhcnNlRm4pIHtcblx0XHRwYXJzZUZuXyA9IHBhcnNlRm47XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcHJvdG9jb2wuIElmIG1pc3NpbmcgPGNvZGU+aHR0cDo8L2NvZGU+IGlzIHVzZWQgYXMgZGVmYXVsdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldFByb3RvY29sKHByb3RvY29sKSB7XG5cdFx0dGhpcy51cmwucHJvdG9jb2wgPSBwcm90b2NvbDtcblx0XHRpZiAodGhpcy51cmwucHJvdG9jb2xbdGhpcy51cmwucHJvdG9jb2wubGVuZ3RoIC0gMV0gIT09ICc6Jykge1xuXHRcdFx0dGhpcy51cmwucHJvdG9jb2wgKz0gJzonO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgdXJsLlxuXHQgKiBAb3ZlcnJpZGVcblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHZhciBocmVmID0gJyc7XG5cdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3QoKTtcblx0XHRpZiAoaG9zdCkge1xuXHRcdFx0aHJlZiArPSB0aGlzLmdldFByb3RvY29sKCkgKyAnLy8nO1xuXHRcdH1cblx0XHRocmVmICs9IGhvc3QgKyB0aGlzLmdldFBhdGhuYW1lKCkgKyB0aGlzLmdldFNlYXJjaCgpICsgdGhpcy5nZXRIYXNoKCk7XG5cdFx0cmV0dXJuIGhyZWY7XG5cdH1cblxuXHQvKipcblx0ICogSm9pbnMgdGhlIGdpdmVuIHBhdGhzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGhcblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IC4uLnBhdGhzIEFueSBudW1iZXIgb2YgcGF0aHMgdG8gYmUgam9pbmVkIHdpdGggdGhlIGJhc2UgdXJsLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgam9pblBhdGhzKGJhc2VQYXRoLCAuLi5wYXRocykge1xuXHRcdGlmIChiYXNlUGF0aC5jaGFyQXQoYmFzZVBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuXHRcdFx0YmFzZVBhdGggPSBiYXNlUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVBhdGgubGVuZ3RoIC0gMSk7XG5cdFx0fVxuXHRcdHBhdGhzID0gcGF0aHMubWFwKHBhdGggPT4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aCk7XG5cdFx0cmV0dXJuIFtiYXNlUGF0aF0uY29uY2F0KHBhdGhzKS5qb2luKCcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVUkwtZGVjb2RlcyB0aGUgc3RyaW5nLiBXZSBuZWVkIHRvIHNwZWNpYWxseSBoYW5kbGUgJysncyBiZWNhdXNlXG5cdCAqIHRoZSBqYXZhc2NyaXB0IGxpYnJhcnkgZG9lc24ndCBjb252ZXJ0IHRoZW0gdG8gc3BhY2VzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdXJsIGRlY29kZS5cblx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGVjb2RlZCB7QGNvZGUgc3RyfS5cblx0ICovXG5cdHN0YXRpYyB1cmxEZWNvZGUoc3RyKSB7XG5cdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuXHR9XG5cbn1cblxuLyoqXG4gKiBEZWZhdWx0IHByb3RvY29sIHZhbHVlLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBkZWZhdWx0IGh0dHA6XG4gKiBAc3RhdGljXG4gKi9cblVyaS5ERUZBVUxUX1BST1RPQ09MID0gJ2h0dHA6JztcblxuLyoqXG4gKiBIb3N0bmFtZSBwbGFjZWhvbGRlci4gUmVsZXZhbnQgdG8gaW50ZXJuYWwgdXNhZ2Ugb25seS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUiA9ICdob3N0bmFtZScgKyBEYXRlLm5vdygpO1xuXG4vKipcbiAqIE5hbWUgdXNlZCBieSB0aGUgcGFyYW0gZ2VuZXJhdGVkIGJ5IGBtYWtlVW5pcXVlYC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblVyaS5SQU5ET01fUEFSQU0gPSAnengnO1xuXG5leHBvcnQgZGVmYXVsdCBVcmk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuXG5mdW5jdGlvbiBhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQoKSB7XG5cdGlmICghZ2xvYmFscy53aW5kb3cpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NpZ24taW4gdHlwZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnREZWZBbmROb3ROdWxsKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKCFjb3JlLmlzRGVmQW5kTm90TnVsbCh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnROb3ROdWxsKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKGNvcmUuaXNOdWxsKHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKCFjb3JlLmlzRnVuY3Rpb24odmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKCFjb3JlLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSB7XG5cdGlmICghcmVzcG9uc2Uuc3VjY2VlZGVkKCkpIHtcblx0XHR0aHJvdyByZXNwb25zZS5ib2R5KCk7XG5cdH1cblx0cmV0dXJuIHJlc3BvbnNlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRVc2VyU2lnbmVkSW4odXNlcikge1xuXHRpZiAoIWNvcmUuaXNEZWZBbmROb3ROdWxsKHVzZXIpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBiZSBzaWduZWQtaW4gdG8gcGVyZm9ybSB0aGlzIG9wZXJhdGlvbicpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVyaVdpdGhOb1BhdGgodXJsLCBtZXNzYWdlKSB7XG5cdHZhciB1cmkgPSBuZXcgVXJpKHVybCk7XG5cdGlmICh1cmkuZ2V0UGF0aG5hbWUoKS5sZW5ndGggPiAxKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHR9XG59XG5cbmV4cG9ydCB7IGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCwgYXNzZXJ0RGVmQW5kTm90TnVsbCwgYXNzZXJ0Tm90TnVsbCwgYXNzZXJ0RnVuY3Rpb24sIGFzc2VydE9iamVjdCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQsIGFzc2VydFVzZXJTaWduZWRJbiwgYXNzZXJ0VXJpV2l0aE5vUGF0aCB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuXG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsLCBhc3NlcnRPYmplY3QsIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkIH0gZnJvbSAnLi4vYXNzZXJ0aW9ucyc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHN0b3JpbmcgYXV0aG9yaXphdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgQXV0aCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRva2VuT3JFbWFpbCBFaXRoZXIgdGhlIGF1dGhvcml6YXRpb24gdG9rZW4sIG9yXG5cdCAqICAgdGhlIHVzZXJuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9wYXNzd29yZCBJZiBhIHVzZXJuYW1lIGlzIGdpdmVuIGFzIHRoZSBmaXJzdCBwYXJhbSxcblx0ICogICB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IodG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQgPSBudWxsKSB7XG5cdFx0dGhpcy50b2tlbiA9IGNvcmUuaXNTdHJpbmcob3B0X3Bhc3N3b3JkKSA/IG51bGwgOiB0b2tlbk9yRW1haWw7XG5cdFx0dGhpcy5lbWFpbCA9IGNvcmUuaXNTdHJpbmcob3B0X3Bhc3N3b3JkKSA/IHRva2VuT3JFbWFpbCA6IG51bGw7XG5cdFx0dGhpcy5wYXNzd29yZCA9IG9wdF9wYXNzd29yZDtcblxuXHRcdHRoaXMuY3JlYXRlZEF0ID0gbnVsbDtcblx0XHR0aGlzLmlkID0gbnVsbDtcblx0XHR0aGlzLm5hbWUgPSBudWxsO1xuXHRcdHRoaXMucGhvdG9VcmwgPSBudWxsO1xuXHRcdHRoaXMud2VkZXBsb3lDbGllbnQgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5PclVzZXJuYW1lIEVpdGhlciB0aGUgYXV0aG9yaXphdGlvbiB0b2tlbiwgb3Jcblx0ICogICB0aGUgdXNlcm5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgdXNlcm5hbWUgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiAgIHRoaXMgc2hvdWxkIGJlIHRoZSBwYXNzd29yZC5cblx0ICogQHJldHVybiB7IUF1dGh9XG5cdCAqL1xuXHRzdGF0aWMgY3JlYXRlKHRva2VuT3JVc2VybmFtZSwgb3B0X3Bhc3N3b3JkKSB7XG5cdFx0cmV0dXJuIG5ldyBBdXRoKHRva2VuT3JVc2VybmFtZSwgb3B0X3Bhc3N3b3JkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjcmVhdGVkIGF0IGRhdGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldENyZWF0ZWRBdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVkQXQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZW1haWwuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEVtYWlsKCkge1xuXHRcdHJldHVybiB0aGlzLmVtYWlsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGlkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRJZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5pZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBuYW1lLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXROYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLm5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBhc3N3b3JkKCkge1xuXHRcdHJldHVybiB0aGlzLnBhc3N3b3JkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBob3RvIHVybC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UGhvdG9VcmwoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGhvdG9Vcmw7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdG9rZW4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFRva2VuKCkge1xuXHRcdHJldHVybiB0aGlzLnRva2VuO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBjcmVhdGVkIGF0IGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc0NyZWF0ZWRBdCgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5jcmVhdGVkQXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZW1haWwgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzRW1haWwoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuZW1haWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgaWQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzSWQoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuaWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgbmFtZSBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNOYW1lKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLm5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGFzc3dvcmQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUGFzc3dvcmQoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucGFzc3dvcmQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGhvdG8gdXJsIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Bob3RvVXJsKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnBob3RvVXJsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHRva2VuIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Rva2VuKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnRva2VuKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGNyZWF0ZWQgYXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjcmVhdGVkQXRcblx0ICovXG5cdHNldENyZWF0ZWRBdChjcmVhdGVkQXQpIHtcblx0XHR0aGlzLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBlbWFpbC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG5cdCAqL1xuXHRzZXRFbWFpbChlbWFpbCkge1xuXHRcdHRoaXMuZW1haWwgPSBlbWFpbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBpZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqL1xuXHRzZXRJZChpZCkge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKi9cblx0c2V0TmFtZShuYW1lKSB7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwYXNzd29yZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG5cdCAqL1xuXHRzZXRQYXNzd29yZChwYXNzd29yZCkge1xuXHRcdHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwaG90byB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwaG90b1VybFxuXHQgKi9cblx0c2V0UGhvdG9VcmwocGhvdG9VcmwpIHtcblx0XHR0aGlzLnBob3RvVXJsID0gcGhvdG9Vcmw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdG9rZW4uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuXHQgKi9cblx0c2V0VG9rZW4odG9rZW4pIHtcblx0XHR0aGlzLnRva2VuID0gdG9rZW47XG5cdH1cblxuXHRzZXRXZWRlcGxveUNsaWVudCh3ZWRlcGxveUNsaWVudCkge1xuXHRcdHRoaXMud2VkZXBsb3lDbGllbnQgPSB3ZWRlcGxveUNsaWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSB1c2VyLlxuXHQgKiBAcGFyYW0geyFvYmplY3R9IGRhdGFcblx0ICogQHJldHVybiB7Q29tcGxldGFibGVGdXR1cmV9XG5cdCAqL1xuXHR1cGRhdGVVc2VyKGRhdGEpIHtcblx0XHRhc3NlcnRPYmplY3QoZGF0YSwgJ1VzZXIgZGF0YSBtdXN0IGJlIHNwZWNpZmllZCBhcyBvYmplY3QnKTtcblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuXHRcdFx0LnBhdGgoJy91c2VycycpXG5cdFx0XHQuYXV0aCh0aGlzKVxuXHRcdFx0LnBhdGNoKGRhdGEpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgdGhlIGN1cnJlbnQgdXNlci5cblx0ICogQHJldHVybiB7Q29tcGxldGFibGVGdXR1cmV9XG5cdCAqL1xuXHRkZWxldGVVc2VyKCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwodGhpcy5pZCwgJ0Nhbm5vdCBkZWxldGUgdXNlciB3aXRob3V0IGlkJyk7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvdXNlcnMnLCB0aGlzLmlkKVxuXHRcdFx0LmF1dGgodGhpcylcblx0XHRcdC5kZWxldGUoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdXRoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aCBmcm9tICcuL2F1dGgvQXV0aCc7XG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsIH0gZnJvbSAnLi9hc3NlcnRpb25zJztcblxuY2xhc3MgQXBpSGVscGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwod2VkZXBsb3lDbGllbnQsICdXZURlcGxveSBjbGllbnQgcmVmZXJlbmNlIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYXV0aG9yaXphdGlvbiBpbmZvcm1hdGlvbiB0byB0aGlzIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7IUF1dGh8c3RyaW5nfSBhdXRoT3JUb2tlbk9yRW1haWwgRWl0aGVyIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZSxcblx0ICogYW4gYXV0aG9yaXphdGlvbiB0b2tlbiwgb3IgdGhlIGVtYWlsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9wYXNzd29yZCBJZiBhIGVtYWlsIGlzIGdpdmVuIGFzIHRoZSBmaXJzdCBwYXJhbSxcblx0ICogdGhpcyBzaG91bGQgYmUgdGhlIHBhc3N3b3JkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhdXRoKGF1dGhPclRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkKSB7XG5cdFx0dGhpcy5oZWxwZXJBdXRoU2NvcGUgPSBhdXRoT3JUb2tlbk9yRW1haWw7XG5cdFx0aWYgKCEodGhpcy5oZWxwZXJBdXRoU2NvcGUgaW5zdGFuY2VvZiBBdXRoKSkge1xuXHRcdFx0dGhpcy5oZWxwZXJBdXRoU2NvcGUgPSBBdXRoLmNyZWF0ZShhdXRoT3JUb2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBpSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNhcHN1bGF0ZSBwcm92aWRlciBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgQXV0aFByb3ZpZGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5wcm92aWRlciA9IG51bGw7XG5cdFx0dGhpcy5wcm92aWRlclNjb3BlID0gbnVsbDtcblx0XHR0aGlzLnJlZGlyZWN0VXJpID0gbnVsbDtcblx0XHR0aGlzLnNjb3BlID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcHJvdmlkZXIgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNQcm92aWRlcigpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5wcm92aWRlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHNjb3BlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUHJvdmlkZXJTY29wZSgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5wcm92aWRlclNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcmVkaXJlY3QgdXJpIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUmVkaXJlY3RVcmkoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucmVkaXJlY3RVcmkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBzY29wZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Njb3BlKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlcyBhdXRob3JpemF0aW9uIHVybC5cblx0ICogQHJldHVybiB7c3RyaW5nPX0gQXV0aG9yaXphdGlvbiB1cmwuXG5cdCAqL1xuXHRtYWtlQXV0aG9yaXphdGlvblVybChvcHRfYXV0aFVybCkge1xuXHRcdHZhciB1cmkgPSBuZXcgVXJpKG9wdF9hdXRoVXJsKTtcblxuXHRcdHVyaS5zZXRQYXRobmFtZSgnL29hdXRoL2F1dGhvcml6ZScpO1xuXG5cdFx0aWYgKHRoaXMuaGFzUHJvdmlkZXIoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdwcm92aWRlcicsIHRoaXMuZ2V0UHJvdmlkZXIoKSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmhhc1Byb3ZpZGVyU2NvcGUoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdwcm92aWRlcl9zY29wZScsIHRoaXMuZ2V0UHJvdmlkZXJTY29wZSgpKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaGFzUmVkaXJlY3RVcmkoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdyZWRpcmVjdF91cmknLCB0aGlzLmdldFJlZGlyZWN0VXJpKCkpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5oYXNTY29wZSgpKSB7XG5cdFx0XHR1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3Njb3BlJywgdGhpcy5nZXRTY29wZSgpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBwcm92aWRlciBuYW1lLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fSBQcm92aWRlciBuYW1lLlxuXHQgKi9cblx0Z2V0UHJvdmlkZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvdmlkZXI7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBwcm92aWRlciBzY29wZS5cblx0ICogQHJldHVybiB7c3RyaW5nPX0gU3RyaW5nIHdpdGggc2NvcGVzLlxuXHQgKi9cblx0Z2V0UHJvdmlkZXJTY29wZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm92aWRlclNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fS5cblx0ICovXG5cdGdldFJlZGlyZWN0VXJpKCkge1xuXHRcdHJldHVybiB0aGlzLnJlZGlyZWN0VXJpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgc2NvcGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZz19IFN0cmluZyB3aXRoIHNjb3Blcy5cblx0ICovXG5cdGdldFNjb3BlKCkge1xuXHRcdHJldHVybiB0aGlzLnNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgcHJvdmlkZXIgc2NvcGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2NvcGUgU2NvcGUgc3RyaW5nLiBTZXBhcmF0ZSBieSBzcGFjZSBmb3IgbXVsdGlwbGVcblx0ICogICBzY29wZXMsIGUuZy4gXCJzY29wZTEgc2NvcGUyXCIuXG5cdCAqL1xuXHRzZXRQcm92aWRlclNjb3BlKHByb3ZpZGVyU2NvcGUpIHtcblx0XHRhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwocHJvdmlkZXJTY29wZSwgJ1Byb3ZpZGVyIHNjb3BlIG11c3QgYmUgYSBzdHJpbmcnKTtcblx0XHR0aGlzLnByb3ZpZGVyU2NvcGUgPSBwcm92aWRlclNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IHJlZGlyZWN0VXJpLlxuXHQgKi9cblx0c2V0UmVkaXJlY3RVcmkocmVkaXJlY3RVcmkpIHtcblx0XHRhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwocmVkaXJlY3RVcmksICdSZWRpcmVjdCB1cmkgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdHRoaXMucmVkaXJlY3RVcmkgPSByZWRpcmVjdFVyaTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHNjb3BlLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IHNjb3BlIFNjb3BlIHN0cmluZy4gU2VwYXJhdGUgYnkgc3BhY2UgZm9yIG11bHRpcGxlXG5cdCAqICAgc2NvcGVzLCBlLmcuIFwic2NvcGUxIHNjb3BlMlwiLlxuXHQgKi9cblx0c2V0U2NvcGUoc2NvcGUpIHtcblx0XHRhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwoc2NvcGUsICdTY29wZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ0lmRGVmQW5kTm90TnVsbCh2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG5cdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbCh2YWx1ZSkgJiYgIWNvcmUuaXNTdHJpbmcodmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aFByb3ZpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aFByb3ZpZGVyIGZyb20gJy4vQXV0aFByb3ZpZGVyJztcblxuLyoqXG4gKiBGYWNlYm9vayBhdXRoIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBGYWNlYm9va0F1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBGYWNlYm9va0F1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnByb3ZpZGVyID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVI7XG5cdH1cbn1cblxuRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZmFjZWJvb2snO1xuXG5leHBvcnQgZGVmYXVsdCBGYWNlYm9va0F1dGhQcm92aWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGhQcm92aWRlciBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5cbi8qKlxuICogR2l0aHViIGF1dGggcHJvdmlkZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIEdpdGh1YkF1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBHaXRodWJBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5wcm92aWRlciA9IEdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUjtcblx0fVxufVxuXG5HaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZ2l0aHViJztcblxuZXhwb3J0IGRlZmF1bHQgR2l0aHViQXV0aFByb3ZpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aFByb3ZpZGVyIGZyb20gJy4vQXV0aFByb3ZpZGVyJztcblxuLyoqXG4gKiBHb29nbGUgYXV0aCBwcm92aWRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgR29vZ2xlQXV0aFByb3ZpZGVyIGV4dGVuZHMgQXV0aFByb3ZpZGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEdvb2dsZUF1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnByb3ZpZGVyID0gR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSO1xuXHR9XG59XG5cbkdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUiA9ICdnb29nbGUnO1xuXG5leHBvcnQgZGVmYXVsdCBHb29nbGVBdXRoUHJvdmlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZGF0YSB1c2luZyBzb21lIHBlcnNpc3RlbmNlXG4gKiBtZWNoYW5pc20uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3RvcmFnZU1lY2hhbmlzbSB7XG5cdC8qKlxuXHQgKiBDbGVhciBhbGwgaXRlbXMgZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhbiBpdGVtIGluIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlcmlhbGl6ZSB0byBhIHN0cmluZyBhbmQgc2F2ZS5cblx0ICovXG5cdHNldChrZXksIHZhbHVlKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGdldC5cblx0ICogQHJldHVybiB7Kn0gRGVzZXJpYWxpemVkIHZhbHVlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoaXMgbWVjaGFuaXNtIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyB3aGVuIG5lY2Vzc2FyeS5cblx0ICovXG5cdHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0ga2V5c1xuXHQgKi9cblx0a2V5cygpIHtcblx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlLlxuXHQgKi9cblx0cmVtb3ZlKGtleSkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXRhIGl0ZW1zIHN0b3JlZCBpbiB0aGUgU3RvcmFnZSBvYmplY3QuXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdHNpemUoKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZU1lY2hhbmlzbTtcblxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnbWV0YWwnO1xuaW1wb3J0IFN0b3JhZ2VNZWNoYW5pc20gZnJvbSAnLi9tZWNoYW5pc20vU3RvcmFnZU1lY2hhbmlzbSc7XG5cbmNsYXNzIFN0b3JhZ2Uge1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNvbnZlbmllbnQgQVBJIGZvciBkYXRhIHBlcnNpc3RlbmNlIHVzaW5nIGEgc2VsZWN0ZWQgZGF0YVxuXHQgKiBzdG9yYWdlIG1lY2hhbmlzbS5cblx0ICogQHBhcmFtIHshU3RvcmFnZU1lY2hhbmlzbX0gbWVjaGFuaXNtIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgbWVjaGFuaXNtLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKG1lY2hhbmlzbSkge1xuXHRcdGFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwobWVjaGFuaXNtKTtcblx0XHRhc3NlcnRNZWNoYW5pc21JbnRhbmNlT2YobWVjaGFuaXNtKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtZWNoYW5pc20gdXNlZCB0byBwZXJzaXN0IGtleS12YWx1ZSBwYWlycy5cblx0XHQgKiBAdHlwZSB7U3RvcmFnZU1lY2hhbmlzbX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5tZWNoYW5pc20gPSBtZWNoYW5pc207XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXIgYWxsIGl0ZW1zIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICovXG5cdGNsZWFyKCkge1xuXHRcdHRoaXMubWVjaGFuaXNtLmNsZWFyKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhbiBpdGVtIGluIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlcmlhbGl6ZSB0byBhIHN0cmluZyBhbmQgc2F2ZS5cblx0ICovXG5cdHNldChrZXksIHZhbHVlKSB7XG5cdFx0aWYgKCFjb3JlLmlzRGVmKHZhbHVlKSkge1xuXHRcdFx0dGhpcy5tZWNoYW5pc20ucmVtb3ZlKGtleSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMubWVjaGFuaXNtLnNldChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGdldC5cblx0ICogQHJldHVybiB7Kn0gRGVzZXJpYWxpemVkIHZhbHVlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0dmFyIGpzb247XG5cdFx0dHJ5IHtcblx0XHRcdGpzb24gPSB0aGlzLm1lY2hhbmlzbS5nZXQoa2V5KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoY29yZS5pc051bGwoanNvbikpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aHJvdyBTdG9yYWdlLkVycm9yQ29kZS5JTlZBTElEX1ZBTFVFO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0ga2V5c1xuXHQgKi9cblx0a2V5cygpIHtcblx0XHRyZXR1cm4gdGhpcy5tZWNoYW5pc20ua2V5cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG5cdCAqL1xuXHRyZW1vdmUoa2V5KSB7XG5cdFx0dGhpcy5tZWNoYW5pc20ucmVtb3ZlKGtleSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgaXRlbXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5tZWNoYW5pc20uc2l6ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxpc3Qgb2YgdmFsdWVzIHN0b3JlZCBpbiB0aGUgU3RvcmFnZSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IHZhbHVlc1xuXHQgKi9cblx0dmFsdWVzKCkge1xuXHRcdHJldHVybiB0aGlzLmtleXMoKS5tYXAoKGtleSkgPT4gdGhpcy5nZXQoa2V5KSk7XG5cdH1cbn1cblxuLyoqXG4gKiBFcnJvcnMgdGhyb3duIGJ5IHRoZSBzdG9yYWdlLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuU3RvcmFnZS5FcnJvckNvZGUgPSB7XG5cdElOVkFMSURfVkFMVUU6ICdTdG9yYWdlOiBJbnZhbGlkIHZhbHVlIHdhcyBlbmNvdW50ZXJlZCdcbn07XG5cbmZ1bmN0aW9uIGFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwobWVjaGFuaXNtKSB7XG5cdGlmICghY29yZS5pc0RlZkFuZE5vdE51bGwobWVjaGFuaXNtKSkge1xuXHRcdHRocm93IEVycm9yKCdTdG9yYWdlIG1lY2hhbmlzbSBpcyByZXF1aXJlZCcpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1lY2hhbmlzbUludGFuY2VPZihtZWNoYW5pc20pIHtcblx0aWYgKCEobWVjaGFuaXNtIGluc3RhbmNlb2YgU3RvcmFnZU1lY2hhbmlzbSkpIHtcblx0XHR0aHJvdyBFcnJvcignU3RvcmFnZSBtZWNoYW5pc20gbXVzdCBtZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBTdG9yYWdlTWVjaGFuaXNtJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFN0b3JhZ2VNZWNoYW5pc20gZnJvbSAnLi9TdG9yYWdlTWVjaGFuaXNtJztcblxuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZGF0YSB1c2luZyBzb21lIHBlcnNpc3RlbmNlXG4gKiBtZWNoYW5pc20uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTG9jYWxTdG9yYWdlTWVjaGFuaXNtIGV4dGVuZHMgU3RvcmFnZU1lY2hhbmlzbSB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJlZmVyZW5jZSBmb3IgZ2xvYmFsIGxvY2FsIHN0b3JhZ2UuIGJ5IGRlZmF1bHRcblx0ICovXG5cdHN0b3JhZ2UoKSB7XG5cdFx0cmV0dXJuIExvY2FsU3RvcmFnZU1lY2hhbmlzbS5nbG9iYWxzLmxvY2FsU3RvcmFnZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5zdG9yYWdlKCkuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0a2V5cygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RvcmFnZSgpLmdldEl0ZW0oa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0c3RhdGljIGlzU3VwcG9ydGVkKCkge1xuXHRcdHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0cmVtb3ZlKGtleSkge1xuXHRcdHRoaXMuc3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0c2V0KGtleSwgdmFsdWUpIHtcblx0XHR0aGlzLnN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLnN0b3JhZ2UoKS5sZW5ndGg7XG5cdH1cbn1cblxuaWYgKExvY2FsU3RvcmFnZU1lY2hhbmlzbS5pc1N1cHBvcnRlZCgpKSB7XG5cdExvY2FsU3RvcmFnZU1lY2hhbmlzbS5nbG9iYWxzID0ge1xuXHRcdGxvY2FsU3RvcmFnZTogd2luZG93LmxvY2FsU3RvcmFnZVxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBMb2NhbFN0b3JhZ2VNZWNoYW5pc207XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBdXRoIGZyb20gJy4vQXV0aCc7XG5pbXBvcnQgQXBpSGVscGVyIGZyb20gJy4uL0FwaUhlbHBlcic7XG5pbXBvcnQgRmFjZWJvb2tBdXRoUHJvdmlkZXIgZnJvbSAnLi9GYWNlYm9va0F1dGhQcm92aWRlcic7XG5pbXBvcnQgR2l0aHViQXV0aFByb3ZpZGVyIGZyb20gJy4vR2l0aHViQXV0aFByb3ZpZGVyJztcbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgR29vZ2xlQXV0aFByb3ZpZGVyIGZyb20gJy4vR29vZ2xlQXV0aFByb3ZpZGVyJztcbmltcG9ydCB7IFN0b3JhZ2UsIExvY2FsU3RvcmFnZU1lY2hhbmlzbSB9IGZyb20gJ21ldGFsLXN0b3JhZ2UnO1xuXG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsLCBhc3NlcnRGdW5jdGlvbiwgYXNzZXJ0T2JqZWN0LCBhc3NlcnRVc2VyU2lnbmVkSW4sIGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQgfSBmcm9tICcuLi9hc3NlcnRpb25zJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGUgYXV0aCBhcGkgY2FsbHMuXG4gKi9cbmNsYXNzIEF1dGhBcGlIZWxwZXIgZXh0ZW5kcyBBcGlIZWxwZXIge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXV0aEFwaUhlbHBlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3Iod2VkZXBsb3lDbGllbnQpIHtcblx0XHRzdXBlcih3ZWRlcGxveUNsaWVudCk7XG5cblx0XHR0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcblx0XHR0aGlzLm9uU2lnbkluQ2FsbGJhY2sgPSBudWxsO1xuXHRcdHRoaXMub25TaWduT3V0Q2FsbGJhY2sgPSBudWxsO1xuXHRcdGlmIChMb2NhbFN0b3JhZ2VNZWNoYW5pc20uaXNTdXBwb3J0ZWQoKSkge1xuXHRcdFx0dGhpcy5zdG9yYWdlID0gbmV3IFN0b3JhZ2UobmV3IExvY2FsU3RvcmFnZU1lY2hhbmlzbSgpKTtcblx0XHR9XG5cblx0XHR0aGlzLnByb2Nlc3NTaWduSW5fKCk7XG5cblx0XHR0aGlzLnByb3ZpZGVyID0ge1xuXHRcdFx0RmFjZWJvb2s6IEZhY2Vib29rQXV0aFByb3ZpZGVyLFxuXHRcdFx0R29vZ2xlOiBHb29nbGVBdXRoUHJvdmlkZXIsXG5cdFx0XHRHaXRodWI6IEdpdGh1YkF1dGhQcm92aWRlclxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyB1c2VyLlxuXHQgKiBAcGFyYW0geyFvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdXNlZCB0byBjcmVhdGUgdGhlIHVzZXIuXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGNyZWF0ZVVzZXIoZGF0YSkge1xuXHRcdGFzc2VydE9iamVjdChkYXRhLCAnVXNlciBkYXRhIG11c3QgYmUgc3BlY2lmaWVkIGFzIG9iamVjdCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJylcblx0XHRcdC5wb3N0KGRhdGEpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB0aGlzLm1ha2VVc2VyQXV0aEZyb21EYXRhKHJlc3BvbnNlLmJvZHkoKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnQgYnJvd3NlciB1cmwgd2l0aG91dCB0aGUgZnJhZ21lbnQgcGFydC5cblx0ICogQHJldHVybiB7IXN0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0SHJlZldpdGhvdXRGcmFnbWVudF8oKSB7XG5cdFx0dmFyIGxvY2F0aW9uID0gZ2xvYmFscy53aW5kb3cubG9jYXRpb247XG5cdFx0cmV0dXJuIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QgKyBsb2NhdGlvbi5wYXRobmFtZSArIChsb2NhdGlvbi5zZWFyY2ggPyBsb2NhdGlvbi5zZWFyY2ggOiAnJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgYWNjZXNzIHRva2VuIGZyb20gdGhlIHVybCBmcmFnbWVudCBhbmQgcmVtb3ZlcyBpdC5cblx0ICogQHJldHVybiB7P3N0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0UmVkaXJlY3RBY2Nlc3NUb2tlbl8oKSB7XG5cdFx0aWYgKGdsb2JhbHMud2luZG93KSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0aWYgKGZyYWdtZW50LmluZGV4T2YoJyNhY2Nlc3NfdG9rZW49JykgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIGZyYWdtZW50LnN1YnN0cmluZygxNCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdXNlciBieSBpZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB1c2VySWRcblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0Z2V0VXNlcih1c2VySWQpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKHVzZXJJZCwgJ1VzZXIgdXNlcklkIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0YXNzZXJ0VXNlclNpZ25lZEluKHRoaXMuY3VycmVudFVzZXIpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJywgdXNlcklkKVxuXHRcdFx0LmF1dGgodGhpcy5yZXNvbHZlQXV0aFNjb3BlKCkudG9rZW4pXG5cdFx0XHQuZ2V0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHRoaXMubWFrZVVzZXJBdXRoRnJvbURhdGEocmVzcG9uc2UuYm9keSgpKSk7XG5cdH1cblxuXHQvKipcblx0ICogTG9hZHMgY3VycmVudCB1c2VyLiBSZXF1aXJlcyBhIHVzZXIgdG9rZW4gYXMgYXJndW1lbnQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdG9rZW5cblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0bG9hZEN1cnJlbnRVc2VyKHRva2VuKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbCh0b2tlbiwgJ1VzZXIgdG9rZW4gbXVzdCBiZSBzcGVjaWZpZWQnKTtcblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuXHRcdFx0LnBhdGgoJy91c2VyJylcblx0XHRcdC5hdXRoKHRva2VuKVxuXHRcdFx0LmdldCgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRcdHZhciBkYXRhID0gcmVzcG9uc2UuYm9keSgpO1xuXHRcdFx0XHRkYXRhLnRva2VuID0gdG9rZW47XG5cdFx0XHRcdHRoaXMuY3VycmVudFVzZXIgPSB0aGlzLm1ha2VVc2VyQXV0aEZyb21EYXRhKGRhdGEpO1xuXHRcdFx0XHRpZiAodGhpcy5zdG9yYWdlKSB7XG5cdFx0XHRcdFx0dGhpcy5zdG9yYWdlLnNldCgnY3VycmVudFVzZXInLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VXNlcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHVzZXIgQXV0aCBmcm9tIGRhdGEgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtBdXRofVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRtYWtlVXNlckF1dGhGcm9tRGF0YShkYXRhKSB7XG5cdFx0dmFyIGF1dGggPSBuZXcgQXV0aCgpO1xuXHRcdGF1dGguc2V0V2VkZXBsb3lDbGllbnQodGhpcy53ZWRlcGxveUNsaWVudCk7XG5cdFx0YXV0aC5zZXRDcmVhdGVkQXQoZGF0YS5jcmVhdGVkQXQpO1xuXHRcdGF1dGguc2V0RW1haWwoZGF0YS5lbWFpbCk7XG5cdFx0YXV0aC5zZXRJZChkYXRhLmlkKTtcblx0XHRhdXRoLnNldE5hbWUoZGF0YS5uYW1lKTtcblx0XHRhdXRoLnNldFBob3RvVXJsKGRhdGEucGhvdG9VcmwpO1xuXHRcdGF1dGguc2V0VG9rZW4oZGF0YS50b2tlbik7XG5cdFx0cmV0dXJuIGF1dGg7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIG9uIHNpZ24gaW4gY2FsbGJhY2sgaWYgc2V0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRtYXliZUNhbGxPblNpZ25JbkNhbGxiYWNrXygpIHtcblx0XHRpZiAodGhpcy5vblNpZ25JbkNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLm9uU2lnbkluQ2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRVc2VyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIG9uIHNpZ24gb3V0IGNhbGxiYWNrIGlmIHNldC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0bWF5YmVDYWxsT25TaWduT3V0Q2FsbGJhY2tfKCkge1xuXHRcdGlmICh0aGlzLm9uU2lnbk91dENhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLm9uU2lnbk91dENhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5jdXJyZW50VXNlcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEZpcmVzIHBhc3NlZCBjYWxsYmFjayB3aGVuIGEgdXNlciBzaWduLWluLiBOb3RlIHRoYXQgaXQga2VlcHMgb25seSB0aGVcblx0ICogbGFzdCBjYWxsYmFjayBwYXNzZWQuXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFja1xuXHQgKi9cblx0b25TaWduSW4oY2FsbGJhY2spIHtcblx0XHRhc3NlcnRGdW5jdGlvbihjYWxsYmFjaywgJ1NpZ24taW4gY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0dGhpcy5vblNpZ25JbkNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdH1cblxuXHQvKipcblx0ICogRmlyZXMgcGFzc2VkIGNhbGxiYWNrIHdoZW4gYSB1c2VyIHNpZ24tb3V0LiBOb3RlIHRoYXQgaXQga2VlcHMgb25seSB0aGVcblx0ICogbGFzdCBjYWxsYmFjayBwYXNzZWQuXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFja1xuXHQgKi9cblx0b25TaWduT3V0KGNhbGxiYWNrKSB7XG5cdFx0YXNzZXJ0RnVuY3Rpb24oY2FsbGJhY2ssICdTaWduLW91dCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHR0aGlzLm9uU2lnbk91dENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2Vzc2VzIHNpZ24taW4gYnkgZGV0ZWN0aW5nIGEgcHJlc2VuY2Ugb2YgYSBmcmFnbWVudFxuXHQgKiA8Y29kZT4jYWNjZXNzX3Rva2VuPTwvY29kZT4gaW4gdGhlIHVybCBvciwgYWx0ZXJuYXRpdmVseSwgYnkgbG9jYWxcblx0ICogc3RvcmFnZSBjdXJyZW50IHVzZXIuXG5cdCAqL1xuXHRwcm9jZXNzU2lnbkluXygpIHtcblx0XHR2YXIgcmVkaXJlY3RBY2Nlc3NUb2tlbiA9IHRoaXMuZ2V0UmVkaXJlY3RBY2Nlc3NUb2tlbl8oKTtcblx0XHRpZiAocmVkaXJlY3RBY2Nlc3NUb2tlbikge1xuXHRcdFx0dGhpcy5yZW1vdmVVcmxGcmFnbWVudENvbXBsZXRlbHlfKCk7XG5cdFx0XHR0aGlzLmxvYWRDdXJyZW50VXNlcihyZWRpcmVjdEFjY2Vzc1Rva2VuKVxuXHRcdFx0XHQudGhlbigoKSA9PiB0aGlzLm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgY3VycmVudFVzZXIgPSB0aGlzLnN0b3JhZ2UgJiYgdGhpcy5zdG9yYWdlLmdldCgnY3VycmVudFVzZXInKTtcblx0XHRpZiAoY3VycmVudFVzZXIpIHtcblx0XHRcdHRoaXMuY3VycmVudFVzZXIgPSB0aGlzLm1ha2VVc2VyQXV0aEZyb21EYXRhKGN1cnJlbnRVc2VyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBmcmFnbWVudCBmcm9tIHVybCBieSBwZXJmb3JtaW5nIGEgcHVzaCBzdGF0ZSB0byB0aGUgY3VycmVudCBwYXRoLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRyZW1vdmVVcmxGcmFnbWVudENvbXBsZXRlbHlfKCkge1xuXHRcdGdsb2JhbHMud2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCBkb2N1bWVudC50aXRsZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVzb2x2ZXMgYXV0aCBzY29wZSBmcm9tIGxhc3QgbG9naW4gb3IgYXBpIGhlbHBlci5cblx0ICogQHJldHVybiB7QXV0aH1cblx0ICovXG5cdHJlc29sdmVBdXRoU2NvcGUoKSB7XG5cdFx0aWYgKHRoaXMuaGVscGVyQXV0aFNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oZWxwZXJBdXRoU2NvcGU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRVc2VyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIHBhc3N3b3JkIHJlc2V0IGVtYWlsIHRvIHRoZSBzcGVjaWZpZWQgZW1haWwgaWYgZm91bmQgaW4gZGF0YWJhc2UuXG5cdCAqIEZvciBzZWN1cml0eSByZWFzb25zIGNhbGwgZG8gbm90IGZhaWwgaWYgZW1haWwgbm90IGZvdW5kLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IGVtYWlsXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHNlbmRQYXNzd29yZFJlc2V0RW1haWwoZW1haWwpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGVtYWlsLCAnU2VuZCBwYXNzd29yZCByZXNldCBlbWFpbCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXIvcmVjb3ZlcicpXG5cdFx0XHQucGFyYW0oJ2VtYWlsJywgZW1haWwpXG5cdFx0XHQucG9zdCgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpZ25zIGluIHVzaW5nIGVtYWlsIGFuZCBwYXNzd29yZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBlbWFpbFxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHBhc3N3b3JkXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkKGVtYWlsLCBwYXNzd29yZCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoZW1haWwsICdTaWduLWluIGVtYWlsIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChwYXNzd29yZCwgJ1NpZ24taW4gcGFzc3dvcmQgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL29hdXRoL3Rva2VuJylcblx0XHRcdC5wYXJhbSgnZ3JhbnRfdHlwZScsICdwYXNzd29yZCcpXG5cdFx0XHQucGFyYW0oJ3VzZXJuYW1lJywgZW1haWwpXG5cdFx0XHQucGFyYW0oJ3Bhc3N3b3JkJywgcGFzc3dvcmQpXG5cdFx0XHQuZ2V0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHRoaXMubG9hZEN1cnJlbnRVc2VyKHJlc3BvbnNlLmJvZHkoKS5hY2Nlc3NfdG9rZW4pKVxuXHRcdFx0LnRoZW4oKHVzZXIpID0+IHtcblx0XHRcdFx0dGhpcy5tYXliZUNhbGxPblNpZ25JbkNhbGxiYWNrXygpO1xuXHRcdFx0XHRyZXR1cm4gdXNlcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpZ25zIGluIHdpdGggcmVkaXJlY3QuIFNvbWUgcHJvdmlkZXJzIGFuZCBlbnZpcm9ubWVudCBtYXkgbm90IHN1cHBvcnRcblx0ICogdGhpcyBmbG93LlxuXHQgKiBAcGFyYW0ge0F1dGhQcm92aWRlcn0gcHJvdmlkZXJcblx0ICovXG5cdHNpZ25JbldpdGhSZWRpcmVjdChwcm92aWRlcikge1xuXHRcdGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCgpO1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwocHJvdmlkZXIsICdTaWduLWluIHByb3ZpZGVyIG11c3QgYmUgZGVmaW5lZCcpO1xuXHRcdGFzc2VydFN1cHBvcnRlZFByb3ZpZGVyKHByb3ZpZGVyKTtcblxuXHRcdGlmICghcHJvdmlkZXIuaGFzUmVkaXJlY3RVcmkoKSkge1xuXHRcdFx0cHJvdmlkZXIuc2V0UmVkaXJlY3RVcmkodGhpcy5nZXRIcmVmV2l0aG91dEZyYWdtZW50XygpKTtcblx0XHR9XG5cdFx0Z2xvYmFscy53aW5kb3cubG9jYXRpb24uaHJlZiA9IHByb3ZpZGVyLm1ha2VBdXRob3JpemF0aW9uVXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpZ25zIG91dCA8Y29kZT5jdXJyZW50VXNlcjwvY29kZT4gYW5kIHJlbW92ZXMgZnJvbSA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdHNpZ25PdXQoKSB7XG5cdFx0YXNzZXJ0VXNlclNpZ25lZEluKHRoaXMuY3VycmVudFVzZXIpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL29hdXRoL3Jldm9rZScpXG5cdFx0XHQucGFyYW0oJ3Rva2VuJywgdGhpcy5jdXJyZW50VXNlci50b2tlbilcblx0XHRcdC5nZXQoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXHRcdFx0XHR0aGlzLm1heWJlQ2FsbE9uU2lnbk91dENhbGxiYWNrXygpO1xuXHRcdFx0XHR0aGlzLnVubG9hZEN1cnJlbnRVc2VyXygpO1xuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVbmxvYWRzIGFsbCBpbmZvcm1hdGlvbiBmb3IgPGNvZGU+Y3VycmVudFVzZXI8L2NvZGU+IGFuZCByZW1vdmVzIGZyb21cblx0ICogPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBpZiBwcmVzZW50LlxuXHQgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdHVubG9hZEN1cnJlbnRVc2VyXygpIHtcblx0XHR0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcblx0XHRpZiAodGhpcy5zdG9yYWdlKSB7XG5cdFx0XHR0aGlzLnN0b3JhZ2UucmVtb3ZlKCdjdXJyZW50VXNlcicpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTdXBwb3J0ZWRQcm92aWRlcihwcm92aWRlcikge1xuXHRzd2l0Y2ggKHByb3ZpZGVyLmNvbnN0cnVjdG9yLlBST1ZJREVSKSB7XG5cdFx0Y2FzZSBGYWNlYm9va0F1dGhQcm92aWRlci5QUk9WSURFUjpcblx0XHRjYXNlIEdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUjpcblx0XHRjYXNlIEdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUjpcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NpZ24taW4gcHJvdmlkZXIgbm90IHN1cHBvcnRlZCcpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhBcGlIZWxwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcbmltcG9ydCBSYW5nZSBmcm9tICcuL1JhbmdlJztcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBzZWFyY2ggYWdncmVnYXRpb24uXG4gKi9cbmNsYXNzIEFnZ3JlZ2F0aW9uIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBhZ2dyZWdhdGlvbiB2YWx1ZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmaWVsZCwgb3BlcmF0b3IsIG9wdF92YWx1ZSkge1xuXHRcdHRoaXMuZmllbGRfID0gZmllbGQ7XG5cdFx0dGhpcy5vcGVyYXRvcl8gPSBvcGVyYXRvcjtcblx0XHR0aGlzLnZhbHVlXyA9IG9wdF92YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJhdmdcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYXZnKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnYXZnJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiY291bnRcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgY291bnQoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdjb3VudCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIERpc3RhbmNlQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiZ2VvRGlzdGFuY2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHsqfSBsb2NhdGlvbiBUaGUgYWdncmVnYXRpb24gbG9jYXRpb24uXG5cdCAqIEBwYXJhbSB7Li4uIVJhbmdlfSByYW5nZXMgVGhlIGFnZ3JlZ2F0aW9uIHJhbmdlcy5cblx0ICogQHJldHVybiB7IURpc3RhbmNlQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBkaXN0YW5jZShmaWVsZCwgbG9jYXRpb24sIC4uLnJhbmdlcykge1xuXHRcdHJldHVybiBuZXcgQWdncmVnYXRpb24uRGlzdGFuY2VBZ2dyZWdhdGlvbihmaWVsZCwgbG9jYXRpb24sIC4uLnJhbmdlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiZXh0ZW5kZWRTdGF0c1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBleHRlbmRlZFN0YXRzKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnZXh0ZW5kZWRTdGF0cycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhpcyBhZ2dyZWdhdGlvbidzIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRGaWVsZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5maWVsZF87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3Mgb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldE9wZXJhdG9yKCkge1xuXHRcdHJldHVybiB0aGlzLm9wZXJhdG9yXztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgYWdncmVnYXRpb24ncyB2YWx1ZS5cblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlXztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJoaXN0b2dyYW1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsIFRoZSBoaXN0b2dyYW0ncyBpbnRlcnZhbC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgaGlzdG9ncmFtKGZpZWxkLCBpbnRlcnZhbCkge1xuXHRcdHJldHVybiBuZXcgQWdncmVnYXRpb24oZmllbGQsICdoaXN0b2dyYW0nLCBpbnRlcnZhbCk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwibWF4XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1heChmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ21heCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcIm1pblwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtaW4oZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdtaW4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJtaXNzaW5nXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1pc3NpbmcoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdtaXNzaW5nJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmaWVsZChmaWVsZCwgb3BlcmF0b3IpIHtcblx0XHRyZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uKGZpZWxkLCBvcGVyYXRvcik7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgUmFuZ2VBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJyYW5nZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEByZXR1cm4geyFSYW5nZUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmFuZ2UoZmllbGQsIC4uLnJhbmdlcykge1xuXHRcdHJldHVybiBuZXcgQWdncmVnYXRpb24uUmFuZ2VBZ2dyZWdhdGlvbihmaWVsZCwgLi4ucmFuZ2VzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJzdGF0c1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzdGF0cyhmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ3N0YXRzJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwic3VtXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHN1bShmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ3N1bScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcInRlcm1zXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHRlcm1zKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAndGVybXMnKTtcblx0fVxufVxuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGRpc3RhbmNlIGFnZ3JlZ2F0aW9uLlxuICogQGV4dGVuZHMge0FnZ3JlZ2F0aW9ufVxuICovXG5jbGFzcyBEaXN0YW5jZUFnZ3JlZ2F0aW9uIGV4dGVuZHMgQWdncmVnYXRpb24ge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgRGlzdGFuY2VBZ2dyZWdhdGlvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb24gVGhlIGFnZ3JlZ2F0aW9uIGxvY2F0aW9uLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIGxvY2F0aW9uLCAuLi5yYW5nZXMpIHtcblx0XHRzdXBlcihmaWVsZCwgJ2dlb0Rpc3RhbmNlJywge30pO1xuXHRcdHRoaXMudmFsdWVfLmxvY2F0aW9uID0gRW1ib2RpZWQudG9Cb2R5KGxvY2F0aW9uKTtcblx0XHR0aGlzLnZhbHVlXy5yYW5nZXMgPSByYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHJhbmdlIHRvIHRoaXMgYWdncmVnYXRpb24uXG5cdCAqIEBwYXJhbSB7Kn0gcmFuZ2VPckZyb21cblx0ICogQHBhcmFtIHsqPX0gb3B0X3RvXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRyYW5nZShyYW5nZU9yRnJvbSwgb3B0X3RvKSB7XG5cdFx0dmFyIHJhbmdlID0gcmFuZ2VPckZyb207XG5cdFx0aWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcblx0XHRcdHJhbmdlID0gUmFuZ2UucmFuZ2UocmFuZ2VPckZyb20sIG9wdF90byk7XG5cdFx0fVxuXHRcdHRoaXMudmFsdWVfLnJhbmdlcy5wdXNoKHJhbmdlLmJvZHkoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3MgdW5pdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVuaXRcblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHVuaXQodW5pdCkge1xuXHRcdHRoaXMudmFsdWVfLnVuaXQgPSB1bml0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5BZ2dyZWdhdGlvbi5EaXN0YW5jZUFnZ3JlZ2F0aW9uID0gRGlzdGFuY2VBZ2dyZWdhdGlvbjtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSByYW5nZSBhZ2dyZWdhdGlvbi5cbiAqIEBleHRlbmRzIHtBZ2dyZWdhdGlvbn1cbiAqL1xuY2xhc3MgUmFuZ2VBZ2dyZWdhdGlvbiBleHRlbmRzIEFnZ3JlZ2F0aW9uIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIFJhbmdlQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIC4uLnJhbmdlcykge1xuXHRcdHN1cGVyKGZpZWxkLCAncmFuZ2UnKTtcblx0XHR0aGlzLnZhbHVlXyA9IHJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgcmFuZ2UgdG8gdGhpcyBhZ2dyZWdhdGlvbi5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yRnJvbVxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdG9cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHJhbmdlKHJhbmdlT3JGcm9tLCBvcHRfdG8pIHtcblx0XHR2YXIgcmFuZ2UgPSByYW5nZU9yRnJvbTtcblx0XHRpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuXHRcdFx0cmFuZ2UgPSBSYW5nZS5yYW5nZShyYW5nZU9yRnJvbSwgb3B0X3RvKTtcblx0XHR9XG5cdFx0dGhpcy52YWx1ZV8ucHVzaChyYW5nZS5ib2R5KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5BZ2dyZWdhdGlvbi5SYW5nZUFnZ3JlZ2F0aW9uID0gUmFuZ2VBZ2dyZWdhdGlvbjtcblxuZXhwb3J0IGRlZmF1bHQgQWdncmVnYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi9FbWJvZGllZCc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCBBZ2dyZWdhdGlvbiBmcm9tICcuL0FnZ3JlZ2F0aW9uJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgcXVlcmllcy5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgUXVlcnkgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFnZ3JlZ2F0aW9uIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGFnZ3JlZ2F0aW9uIG5hbWUuXG5cdCAqIEBwYXJhbSB7IUFnZ3JlZ2F0aW9ufHN0cmluZ30gYWdncmVnYXRpb25PckZpZWxkIEVpdGhlciBhblxuXHQgKiAgIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugb3IgdGhlIG5hbWUgb2YgdGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9vcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcikge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5hZ2dyZWdhdGUobmFtZSwgYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJjb3VudFwiLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBjb3VudCgpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkudHlwZSgnY291bnQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiZmV0Y2hcIi5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZmV0Y2goKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnR5cGUoJ2ZldGNoJyk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byB0aGlzIFF1ZXJ5LlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLmZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IG9mZnNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlIHJldHVybmVkXG5cdCAqICAgYnkgdGhpcyBxdWVyeS5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgb2Zmc2V0KG9mZnNldCkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5vZmZzZXQob2Zmc2V0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGhpZ2hsaWdodChmaWVsZCkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5oaWdobGlnaHQoZmllbGQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IGxpbWl0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG1heCBhbW91bnQgb2YgZW50cmllcyB0aGF0IHRoaXMgcXVlcnkgc2hvdWxkIHJldHVybi5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbGltaXQobGltaXQpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkubGltaXQobGltaXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzZWFyY2ggdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWx0ZXJPclRleHRPckZpZWxkIElmIG5vIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIGFyZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgZWl0aGVyIGEge0BsaW5rIEZpbHRlcn1cblx0ICogICBpbnN0YW5jZSBvciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhIG1hdGNoIGZpbHRlci4gSW4gYm90aCBjYXNlc1xuXHQgKiAgIHRoZSBmaWx0ZXIgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBmaWVsZHMuIEFub3RoZXIgb3B0aW9uIGlzIHRvXG5cdCAqICAgcGFzcyB0aGlzIGFzIGEgZmllbGQgbmFtZSBpbnN0ZWFkLCB0b2dldGhlciB3aXRoIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIHNvIHRoZSBmaWx0ZXIgY2FuIGJlIGNyZWF0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3RleHRPck9wZXJhdG9yIEVpdGhlciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhXG5cdCAqICAgbWF0Y2ggZmlsdGVyLCBvciB0aGUgb3BlcmF0b3IgdGhhdCBzaG91bGQgYmUgdXNlZC5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSB2YWx1ZSB0byBiZSB1c2VkIGJ5IHRoZSBmaWx0ZXIuIFNob3VsZFxuXHQgKiAgIG9ubHkgYmUgcGFzc2VkIGlmIGFuIG9wZXJhdG9yIHdhcyBwYXNzZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc2VhcmNoKGZpbHRlck9yVGV4dE9yRmllbGQsIG9wdF90ZXh0T3JPcGVyYXRvciwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnNlYXJjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNvcnQgZW50cnkgdG8gdGhpcyBxdWVyeSwgc3BlY2lmeWluZyB0aGUgZmllbGQgdGhpcyBxdWVyeSBzaG91bGQgYmVcblx0ICogc29ydGVkIGJ5IGFuZCwgb3B0aW9uYWxseSwgdGhlIHNvcnQgZGlyZWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgdGhlIHF1ZXJ5IHNob3VsZCBiZSBzb3J0ZWQgYnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBzb3J0IG9wZXJhdGlvbiBzaG91bGQgdXNlLlxuXHQgKiAgIElmIG5vbmUgaXMgZ2l2ZW4sIFwiYXNjXCIgaXMgdXNlZCBieSBkZWZhdWx0LlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzb3J0KGZpZWxkLCBvcHRfZGlyZWN0aW9uKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IHR5cGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBxdWVyeSdzIHR5cGUuIEZvciBleGFtcGxlOiBcImNvdW50XCIsIFwiZmV0Y2hcIi5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgdHlwZSh0eXBlKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnR5cGUodHlwZSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBhZ2dyZWdhdGlvbiB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhZ2dyZWdhdGlvbiBuYW1lLlxuXHQgKiBAcGFyYW0geyFBZ2dyZWdhdGlvbnxzdHJpbmd9IGFnZ3JlZ2F0aW9uT3JGaWVsZCBFaXRoZXIgYW5cblx0ICogICB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIG9yIHRoZSBuYW1lIG9mIHRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfb3BlcmF0b3IgVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0YWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG5cdFx0dmFyIGFnZ3JlZ2F0aW9uID0gYWdncmVnYXRpb25PckZpZWxkO1xuXHRcdGlmICghKGFnZ3JlZ2F0aW9uIGluc3RhbmNlb2YgQWdncmVnYXRpb24pKSB7XG5cdFx0XHRhZ2dyZWdhdGlvbiA9IEFnZ3JlZ2F0aW9uLmZpZWxkKGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKTtcblx0XHR9XG5cblx0XHR2YXIgZmllbGQgPSBhZ2dyZWdhdGlvbi5nZXRGaWVsZCgpO1xuXHRcdHZhciB2YWx1ZSA9IHt9O1xuXHRcdHZhbHVlW2ZpZWxkXSA9IHtcblx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRvcGVyYXRvcjogYWdncmVnYXRpb24uZ2V0T3BlcmF0b3IoKVxuXHRcdH07XG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGFnZ3JlZ2F0aW9uLmdldFZhbHVlKCkpKSB7XG5cdFx0XHR2YWx1ZVtmaWVsZF0udmFsdWUgPSBhZ2dyZWdhdGlvbi5nZXRWYWx1ZSgpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbikge1xuXHRcdFx0dGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbiA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLmJvZHlfLmFnZ3JlZ2F0aW9uLnB1c2godmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJjb3VudFwiLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0Y291bnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHlwZSgnY291bnQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiZmV0Y2hcIi5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGZldGNoKCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUoJ2ZldGNoJyk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byB0aGlzIFF1ZXJ5LlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0ZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdGxldCBmaWx0ZXIgPSBGaWx0ZXIudG9GaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0XHRpZiAoIXRoaXMuYm9keV8uZmlsdGVyKSB7XG5cdFx0XHR0aGlzLmJvZHlfLmZpbHRlciA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLmJvZHlfLmZpbHRlci5wdXNoKGZpbHRlci5ib2R5KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IG9mZnNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlIHJldHVybmVkXG5cdCAqICAgYnkgdGhpcyBxdWVyeS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdG9mZnNldChvZmZzZXQpIHtcblx0XHR0aGlzLmJvZHlfLm9mZnNldCA9IG9mZnNldDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRoaWdobGlnaHQoZmllbGQpIHtcblx0XHRpZiAoIXRoaXMuYm9keV8uaGlnaGxpZ2h0KSB7XG5cdFx0XHR0aGlzLmJvZHlfLmhpZ2hsaWdodCA9IFtdO1xuXHRcdH1cblxuXHRcdHRoaXMuYm9keV8uaGlnaGxpZ2h0LnB1c2goZmllbGQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IGxpbWl0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG1heCBhbW91bnQgb2YgZW50cmllcyB0aGF0IHRoaXMgcXVlcnkgc2hvdWxkIHJldHVybi5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGxpbWl0KGxpbWl0KSB7XG5cdFx0dGhpcy5ib2R5Xy5saW1pdCA9IGxpbWl0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzZWFyY2ggdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWx0ZXJPclRleHRPckZpZWxkIElmIG5vIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIGFyZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgZWl0aGVyIGEge0BsaW5rIEZpbHRlcn1cblx0ICogICBpbnN0YW5jZSBvciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhIG1hdGNoIGZpbHRlci4gSW4gYm90aCBjYXNlc1xuXHQgKiAgIHRoZSBmaWx0ZXIgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBmaWVsZHMuIEFub3RoZXIgb3B0aW9uIGlzIHRvXG5cdCAqICAgcGFzcyB0aGlzIGFzIGEgZmllbGQgbmFtZSBpbnN0ZWFkLCB0b2dldGhlciB3aXRoIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIHNvIHRoZSBmaWx0ZXIgY2FuIGJlIGNyZWF0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3RleHRPck9wZXJhdG9yIEVpdGhlciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhXG5cdCAqICAgbWF0Y2ggZmlsdGVyLCBvciB0aGUgb3BlcmF0b3IgdGhhdCBzaG91bGQgYmUgdXNlZC5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSB2YWx1ZSB0byBiZSB1c2VkIGJ5IHRoZSBmaWx0ZXIuIFNob3VsZFxuXHQgKiAgIG9ubHkgYmUgcGFzc2VkIGlmIGFuIG9wZXJhdG9yIHdhcyBwYXNzZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHNlYXJjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSkge1xuXHRcdHZhciBmaWx0ZXIgPSBmaWx0ZXJPclRleHRPckZpZWxkO1xuXG5cdFx0aWYgKG9wdF92YWx1ZSkge1xuXHRcdFx0ZmlsdGVyID0gRmlsdGVyLmZpZWxkKGZpbHRlck9yVGV4dE9yRmllbGQsIG9wdF90ZXh0T3JPcGVyYXRvciwgb3B0X3ZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKG9wdF90ZXh0T3JPcGVyYXRvcikge1xuXHRcdFx0ZmlsdGVyID0gRmlsdGVyLm1hdGNoKGZpbHRlck9yVGV4dE9yRmllbGQsIG9wdF90ZXh0T3JPcGVyYXRvcik7XG5cdFx0fSBlbHNlIGlmICghKGZpbHRlciBpbnN0YW5jZW9mIEZpbHRlcikpIHtcblx0XHRcdGZpbHRlciA9IEZpbHRlci5tYXRjaChmaWx0ZXJPclRleHRPckZpZWxkKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuYm9keV8uc2VhcmNoKSB7XG5cdFx0XHR0aGlzLmJvZHlfLnNlYXJjaCA9IFtdO1xuXHRcdH1cblxuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmaWx0ZXJPclRleHRPckZpZWxkKSkge1xuXHRcdFx0dGhpcy5ib2R5Xy5zZWFyY2gucHVzaChmaWx0ZXIuYm9keSgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5ib2R5Xy5zZWFyY2gucHVzaCh7fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNvcnQgZW50cnkgdG8gdGhpcyBxdWVyeSwgc3BlY2lmeWluZyB0aGUgZmllbGQgdGhpcyBxdWVyeSBzaG91bGQgYmVcblx0ICogc29ydGVkIGJ5IGFuZCwgb3B0aW9uYWxseSwgdGhlIHNvcnQgZGlyZWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgdGhlIHF1ZXJ5IHNob3VsZCBiZSBzb3J0ZWQgYnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBzb3J0IG9wZXJhdGlvbiBzaG91bGQgdXNlLlxuXHQgKiAgIElmIG5vbmUgaXMgZ2l2ZW4sIFwiYXNjXCIgaXMgdXNlZCBieSBkZWZhdWx0LlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0c29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbikge1xuXHRcdGlmICghdGhpcy5ib2R5Xy5zb3J0KSB7XG5cdFx0XHR0aGlzLmJvZHlfLnNvcnQgPSBbXTtcblx0XHR9XG5cdFx0dmFyIHNvcnRFbnRyeSA9IHt9O1xuXHRcdHNvcnRFbnRyeVtmaWVsZF0gPSBvcHRfZGlyZWN0aW9uIHx8ICdhc2MnO1xuXHRcdHRoaXMuYm9keV8uc29ydC5wdXNoKHNvcnRFbnRyeSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgdHlwZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHF1ZXJ5J3MgdHlwZS4gRm9yIGV4YW1wbGU6IFwiY291bnRcIiwgXCJmZXRjaFwiLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0dHlwZSh0eXBlKSB7XG5cdFx0dGhpcy5ib2R5Xy50eXBlID0gdHlwZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBRdWVyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFwaUhlbHBlciBmcm9tICcuLi9BcGlIZWxwZXInO1xuaW1wb3J0IFF1ZXJ5IGZyb20gJy4uLy4uL2FwaS1xdWVyeS9RdWVyeSc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uLy4uL2FwaS1xdWVyeS9GaWx0ZXInO1xuaW1wb3J0IHsgYXNzZXJ0RGVmQW5kTm90TnVsbCwgYXNzZXJ0T2JqZWN0LCBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZCB9IGZyb20gJy4uL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGUgZGF0YSBhcGkgY2FsbHMuXG4gKi9cbmNsYXNzIERhdGFBcGlIZWxwZXIgZXh0ZW5kcyBBcGlIZWxwZXIge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7QGxpbmsgV2VEZXBsb3l9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHdlZGVwbG95Q2xpZW50KSB7XG5cdFx0c3VwZXIod2VkZXBsb3lDbGllbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSBGaWx0ZXIgaW5zdGFuY2Ugb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHdoZXJlKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCkuYW5kKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIHRoZSBcIm9yXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogICB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRvcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRpZiAodGhpcy5nZXRPckNyZWF0ZUZpbHRlcl8oKS5ib2R5KCkuYW5kLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0l0XFwncyByZXF1aXJlZCB0byBoYXZlIGEgY29uZGl0aW9uIGJlZm9yZSB1c2luZyBhbiBcXCdvcigpXFwnIGZvciB0aGUgZmlyc3QgdGltZS4nKTtcblx0XHR9XG5cdFx0dGhpcy5nZXRPckNyZWF0ZUZpbHRlcl8oKS5vcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwibm9uZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHshKEFycmF5fC4uLiopfSBhcmdzIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiBzZXBhcmF0ZSBwYXJhbXMuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRub25lKGZpZWxkLCAuLi5hcmdzKSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLm5vbmUoZmllbGQsIGFyZ3MpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcIm1hdGNoXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3F1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRtYXRjaChmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubWF0Y2goZmllbGQsIHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJzaW1pbGFyXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHNpbWlsYXIoZmllbGRPclF1ZXJ5LCBxdWVyeSkge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5zaW1pbGFyKGZpZWxkT3JRdWVyeSwgcXVlcnkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIjxcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRsdChmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubHQoZmllbGQsIHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG4gICAqIEBzdGF0aWNcblx0ICovXG5cdGx0ZShmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubHRlKGZpZWxkLCB2YWx1ZSkpO1xuXHR9XG5cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJhbnlcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwuLi4qKX0gYXJncyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqIHRoZSBcIm5vbmVcIiBvcGVyYXRvci4gQ2FuIGJlIHBhc3NlZCBlaXRoZXIgYXMgYSBzaW5nbGUgYXJyYXkgb3IgYXNcblx0ICogc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0YW55KGZpZWxkLCAuLi5hcmdzKSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLmFueShmaWVsZCwgYXJncykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwiZ3BcIiBvcGVyYXRvci4gVGhpcyBpcyBhXG5cdCAqIHNwZWNpYWwgdXNlIGNhc2Ugb2YgYEZpbHRlci5wb2x5Z29uYCBmb3IgYm91bmRpbmcgYm94ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGJveE9yVXBwZXJMZWZ0IEVpdGhlciBhIGBHZW8uQm91bmRpbmdCb3hgIGluc3RhbmNlLCBvciBhXG5cdCAqIGJvdW5kaW5nIGJveCdzIHVwcGVyIGxlZnQgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X2xvd2VyUmlnaHQgQSBib3VuZGluZyBib3gncyBsb3dlciByaWdodCBjb29yZGluYXRlLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0Ym91bmRpbmdCb3goZmllbGQsIGJveE9yVXBwZXJMZWZ0LCBvcHRfbG93ZXJSaWdodCkge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5ib3VuZGluZ0JveChmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJnZFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSBsb2NhdGlvbk9yQ2lyY2xlIEVpdGhlciBhIGBHZW8uQ2lyY2xlYCBpbnN0YW5jZSBvciBhXG5cdCAqIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7UmFuZ2V8c3RyaW5nPX0gb3B0X3JhbmdlT3JEaXN0YW5jZSBFaXRoZXIgYSBgUmFuZ2VgIGluc3RhbmNlIG9yXG5cdCAqIHRoZSBkaXN0YW5jZSB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbk9yQ2lyY2xlLCBvcHRfcmFuZ2VPckRpc3RhbmNlKSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLmRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbk9yQ2lyY2xlLCBvcHRfcmFuZ2VPckRpc3RhbmNlKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJyYW5nZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yTWluIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3IgYSB0aGUgcmFuZ2UncyBtaW5cblx0ICogdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9tYXggVGhlIHJhbmdlJ3MgbWF4IHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0cmFuZ2UoZmllbGQsIHJhbmdlT3JNaW4sIG9wdF9tYXgpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIucmFuZ2UoZmllbGQsIHJhbmdlT3JNaW4sIG9wdF9tYXgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsaW1pdCBmb3IgdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IFRoZSBtYXggYW1vdW50IG9mIGVudHJpZXMgdGhhdCB0aGlzIHJlcXVlc3Qgc2hvdWxkIHJldHVybi5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0bGltaXQobGltaXQpIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkubGltaXQobGltaXQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG9mZnNldCBmb3IgdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlXG5cdCAqIHJldHVybmVkIGJ5IHRoaXMgcXVlcnkuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdG9mZnNldChvZmZzZXQpIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkub2Zmc2V0KG9mZnNldCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGhpZ2hsaWdodCBlbnRyeSB0byB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0aGlnaGxpZ2h0KGZpZWxkKSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLmhpZ2hsaWdodChmaWVsZCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBhZ2dyZWdhdGlvbiB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhZ2dyZWdhdGlvbiBuYW1lLlxuXHQgKiBAcGFyYW0geyFBZ2dyZWdhdGlvbnxzdHJpbmd9IGFnZ3JlZ2F0aW9uT3JGaWVsZCBFaXRoZXIgYW4ge0BsaW5rXG5cdCAqIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSBvciB0aGUgbmFtZSBvZiB0aGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X29wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLmFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHJlcXVlc3QncyBxdWVyeSB0eXBlIHRvICdjb3VudCcuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRjb3VudCgpIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkudHlwZSgnY291bnQnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc29ydCBxdWVyeSB0byB0aGlzIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgdGhlIHF1ZXJ5IHNob3VsZCBiZSBzb3J0ZWQgYnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBzb3J0IG9wZXJhdGlvbiBzaG91bGRcblx0ICogdXNlLiBJZiBub25lIGlzIGdpdmVuLCAnYXNjJyBpcyB1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRvcmRlckJ5KGZpZWxkLCBvcHRfZGlyZWN0aW9uKSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLnNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBhbmQgc2F2ZXMgaXQgdG8gV2VEZXBsb3kgZGF0YS4gSWZcblx0ICogdGhlcmUncyBhIHZhbGlkYXRpb24gcmVnaXN0ZXJlZCBpbiB0aGUgY29sbGVjdGlvbiBhbmQgdGhlIHJlcXVlc3QgaXNcblx0ICogc3VjY2Vzc2Z1bCwgdGhlIHJlc3VsdGluZyBvYmplY3QgKG9yIGFycmF5IG9mIG9iamVjdHMpIGlzIHJldHVybmVkLiBUaGVcblx0ICogZGF0YSBwYXJhbWV0ZXIgY2FuIGJlIGVpdGhlciBhbiBPYmplY3Qgb3IgYW4gQXJyYXkgb2YgT2JqZWN0cy5cblx0ICogVGhlc2UgT2JqZWN0cyBkZXNjcmliZSB0aGUgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0cyB0aGF0IGFyZSB0byBiZSBjcmVhdGVkLlxuXHQgKiBgYGBqYXZhc2NyaXB0XG5cdCAqIHZhciBkYXRhID0gV2VEZXBsb3kuZGF0YSgnaHR0cDovL2RlbW9kYXRhLndlZGVwbG95LmlvJyk7XG5cdCAqXG5cdCAqIGRhdGEuY3JlYXRlKCdtb3ZpZXMnLCB7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSSDigJMgVGhlIFBoYW50b20gTWVuYWNlJ30pXG5cdCAqIFx0XHQgLnRoZW4oZnVuY3Rpb24obW92aWUpe1xuXHQgKiBcdFx0XHQgY29uc29sZS5sb2cobW92aWUpXG5cdCAqICAgICB9KTtcblx0ICpcblx0ICogZGF0YS5jcmVhdGUoJ21vdmllcycsIFt7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSUkg4oCTIEF0dGFjayBvZiB0aGUgQ2xvbmVzJ30sXG5cdCAqIFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsndGl0bGUnPT4gJ1N0YXIgV2FyczogRXBpc29kZSBJSUkg4oCTIFJldmVuZ2Ugb2YgdGhlIFNpdGgnfSlcblx0ICogXHRcdCAudGhlbihmdW5jdGlvbihtb3ZpZXMpe1xuXHQgKiBcdFx0XHQgY29uc29sZS5sb2cobW92aWVzKVxuXHQgKiAgICAgfSk7XG5cdCAqIGBgYFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbiBDb2xsZWN0aW9uIChrZXkpIHVzZWQgdG8gY3JlYXRlIHRoZSBuZXcgZGF0YS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0IHRoYXQgaXMgdG8gYmUgY3JlYXRlZC5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGNyZWF0ZShjb2xsZWN0aW9uLCBkYXRhKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChjb2xsZWN0aW9uLCAnQ29sbGVjdGlvbiBrZXkgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG5cdFx0YXNzZXJ0T2JqZWN0KGRhdGEsICdEYXRhIGNhblxcJ3QgYmUgZW1wdHkuJyk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LmF1dGgodGhpcy5oZWxwZXJBdXRoU2NvcGUpXG5cdFx0XHQucGF0aChjb2xsZWN0aW9uKVxuXHRcdFx0LnBvc3QoZGF0YSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIGEgZG9jdW1lbnQgZm9ybSB0aGUgcGFzc2VkLWluIG9iamVjdCBhbmQgc2F2ZXNcblx0ICogdGhlIHJlY29yZC4gSWYgdGhlIG9iamVjdCBpcyBpbnZhbGlkLCB0aGUgc2F2aW5nIHdpbGwgZmFpbCBhbmQgYW4gZXJyb3Jcblx0ICogb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqXG5cdCAqIGBgYGphdmFzY3JpcHRcblx0ICogdmFyIGRhdGEgPSBXZURlcGxveS5kYXRhKCdodHRwOi8vZGVtb2RhdGEud2VkZXBsb3kuaW8nKTtcblx0ICpcblx0ICogZGF0YS51cGRhdGUoJ21vdmllcy8xMDE5MTEyMzUzJywgeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIEknfSlcblx0ICogXHRcdCAudGhlbihmdW5jdGlvbihtb3ZpZSl7XG5cdCAqIFx0XHRcdCBjb25zb2xlLmxvZyhtb3ZpZSlcblx0ICogICAgIH0pO1xuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50IEtleSB1c2VkIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCB0aGF0IGlzIHRvIGJlIHVwZGF0ZWQuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHR1cGRhdGUoZG9jdW1lbnQsIGRhdGEpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGRvY3VtZW50LCAnRG9jdW1lbnQga2V5IG11c3QgYmUgc3BlY2lmaWVkLicpO1xuXHRcdGFzc2VydE9iamVjdChkYXRhLCAnRGF0YSBtdXN0IGJlIHNwZWNpZmllZC4nKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuZGF0YVVybF8pXG5cdFx0XHQuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSlcblx0XHRcdC5wYXRoKGRvY3VtZW50KVxuXHRcdFx0LnB1dChkYXRhKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGEgW2RvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb25dLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSB1c2VkIHRvIGRlbGV0ZSB0aGVcblx0ICogZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbi5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGRlbGV0ZShrZXkpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGtleSwgJ0RvY3VtZW50L0ZpZWxkL0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LmF1dGgodGhpcy5oZWxwZXJBdXRoU2NvcGUpXG5cdFx0XHQucGF0aChrZXkpXG5cdFx0XHQuZGVsZXRlKClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmUgZGF0YSBmcm9tIGEgW2RvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb25dLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSB1c2VkIHRvIGRlbGV0ZSB0aGUgZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbi5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGdldChrZXkpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGtleSwgJ0RvY3VtZW50L0ZpZWxkL0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cblx0XHR0aGlzLmFkZEZpbHRlcnNUb1F1ZXJ5XygpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKVxuXHRcdFx0LnBhdGgoa2V5KVxuXHRcdFx0LmdldCh0aGlzLnF1ZXJ5Xylcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmUgZGF0YSBmcm9tIGEgW2RvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb25dIGFuZCBwdXQgaXQgaW4gYSBzZWFyY2hcblx0ICogZm9ybWF0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSB1c2VkIHRvIGRlbGV0ZSB0aGUgZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbi5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHNlYXJjaChrZXkpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGtleSwgJ0RvY3VtZW50L0ZpZWxkL0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cblx0XHR0aGlzLm9uU2VhcmNoXygpO1xuXG5cdFx0dGhpcy5hZGRGaWx0ZXJzVG9RdWVyeV8oKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuZGF0YVVybF8pXG5cdFx0XHQuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSlcblx0XHRcdC5wYXRoKGtleSlcblx0XHRcdC5nZXQodGhpcy5xdWVyeV8pXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgbmV3IHNvY2tldC5pbyBpbnN0YW5jZS4gTW9uaXRvciB0aGUgYXJyaXZhbCBvZiBuZXcgYnJvYWRjYXN0ZWRcblx0ICogZGF0YS5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBjb2xsZWN0aW9uIGtleS9jb2xsZWN0aW9uIHVzZWQgdG8gZmluZCBvcmdhbml6ZWQgZGF0YS5cblx0ICogQHBhcmFtICB7T2JqZWN0PX0gb3B0X29wdGlvbnMgT2JqZWN0IHdpdGggU29ja2V0IElPIG9wdGlvbnMuXG5cdCAqIEByZXR1cm4geyFpb30gU29ja2V0IElPIHJlZmVyZW5jZS4gU2VydmVyIGV2ZW50cyBjYW4gYmUgbGlzdGVuZWQgb24gaXQuXG5cdCAqL1xuXHR3YXRjaChjb2xsZWN0aW9uLCBvcHRfb3B0aW9ucykge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoY29sbGVjdGlvbiwgJ0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cblx0XHR0aGlzLmFkZEZpbHRlcnNUb1F1ZXJ5XygpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKVxuXHRcdFx0LnBhdGgoY29sbGVjdGlvbilcblx0XHRcdC53YXRjaCh0aGlzLnF1ZXJ5Xywgb3B0X29wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnRsIHVzZWQgbWFpbiB7QGxpbmsgRmlsdGVyfSBvYmplY3QuIElmIG5vbmUgZXhpc3RzIHlldCwgYVxuXHQgKiBuZXcgb25lIGlzIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0T3JDcmVhdGVGaWx0ZXJfKCkge1xuXHRcdGlmICghdGhpcy5maWx0ZXJfKSB7XG5cdFx0XHR0aGlzLmZpbHRlcl8gPSBuZXcgRmlsdGVyKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmZpbHRlcl87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY3VycmVudGx5IHVzZWQge0BsaW5rIFF1ZXJ5fSBvYmplY3QuIElmIG5vbmUgZXhpc3RzIHlldCxcblx0ICogYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0T3JDcmVhdGVRdWVyeV8oKSB7XG5cdFx0aWYgKCF0aGlzLnF1ZXJ5Xykge1xuXHRcdFx0dGhpcy5xdWVyeV8gPSBuZXcgUXVlcnkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucXVlcnlfO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIGN1cnJlbnRseSB1c2VkIG1haW4ge0BsaW5rIEZpbHRlcn0gb2JqZWN0IGludG8gdGhlIGN1cnJlbnRseVxuXHQgKiB1c2VkIHtAbGluayBRdWVyeX0uXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkRmlsdGVyc1RvUXVlcnlfKCkge1xuXHRcdGlmIChjb3JlLmlzRGVmKHRoaXMuZmlsdGVyXykgJiYgdGhpcy50b1NlYXJjaF8gIT09IHRydWUpIHtcblx0XHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5maWx0ZXIodGhpcy5maWx0ZXJfKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNlYXJjaCB0byB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG9uU2VhcmNoXygpIHtcblx0XHRpZiAoY29yZS5pc0RlZih0aGlzLmZpbHRlcl8pKSB7XG5cdFx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuc2VhcmNoKHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSXRcXCdzIHJlcXVpcmVkIHRvIGhhdmUgYSBjb25kaXRpb24gYmVmb3JlIHVzaW5nIGFuIFxcJ3NlYXJjaCgpXFwnIGZvciB0aGUgZmlyc3QgdGltZS4nKTtcblx0XHR9XG5cdFx0dGhpcy50b1NlYXJjaF8gPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YUFwaUhlbHBlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBsYXllciBmb3Igc3RyaW5nIHRvIGJhc2U2NCBjb252ZXJzaW9uXG4gKiByZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzQ2MlxuICovXG5jbGFzcyBCYXNlNjQge1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGJhc2UtNjQgZW5jb2RlZCBBU0NJSSBzdHJpbmcgZnJvbSBhIFwic3RyaW5nXCIgb2YgYmluYXJ5IGRhdGEuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gYmUgZW5jb2RlZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlU3RyaW5nKHN0cmluZykge1xuXHRcdGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGJ0b2Eoc3RyaW5nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEJ1ZmZlcihzdHJpbmcudG9TdHJpbmcoKSwgJ2JpbmFyeScpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U2NDtcbiIsIi8qIVxuICogUHJvbWlzZXMgcG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKlxuICogICAgICBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTk9URShlZHVhcmRvKTogUHJvbWlzZSBzdXBwb3J0IGlzIG5vdCByZWFkeSBvbiBhbGwgc3VwcG9ydGVkIGJyb3dzZXJzLFxuICogdGhlcmVmb3JlIG1ldGFsLXByb21pc2UgaXMgdGVtcG9yYXJpbHkgdXNpbmcgR29vZ2xlJ3MgcHJvbWlzZXMgYXMgcG9seWZpbGwuXG4gKiBJdCBzdXBwb3J0cyBjYW5jZWxsYWJsZSBwcm9taXNlcyBhbmQgaGFzIGNsZWFuIGFuZCBmYXN0IGltcGxlbWVudGF0aW9uLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgaXNEZWYsIGlzRnVuY3Rpb24sIGlzT2JqZWN0IH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHsgYXN5bmMgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBtb3JlIHN0cmljdCBpbnRlcmZhY2UgZm9yIFRoZW5hYmxlcyBpbiB0ZXJtcyBvZlxuICogaHR0cDovL3Byb21pc2VzYXBsdXMuY29tIGZvciBpbnRlcm9wIHdpdGgge0BzZWUgQ2FuY2VsbGFibGVQcm9taXNlfS5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyB7SVRoZW5hYmxlLjxUWVBFPn1cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbnZhciBUaGVuYWJsZSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQWRkcyBjYWxsYmFja3MgdGhhdCB3aWxsIG9wZXJhdGUgb24gdGhlIHJlc3VsdCBvZiB0aGUgVGhlbmFibGUsIHJldHVybmluZyBhXG4gKiBuZXcgY2hpbGQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgVGhlbmFibGUgaXMgZnVsZmlsbGVkLCB0aGUge0Bjb2RlIG9uRnVsZmlsbGVkfSBjYWxsYmFjayB3aWxsIGJlXG4gKiBpbnZva2VkIHdpdGggdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbFxuICogYmUgZnVsZmlsbGVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2suIElmIHRoZSBjYWxsYmFjayB0aHJvd3NcbiAqIGFuIGV4Y2VwdGlvbiwgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSB0aHJvd24gdmFsdWVcbiAqIGluc3RlYWQuXG4gKlxuICogSWYgdGhlIFRoZW5hYmxlIGlzIHJlamVjdGVkLCB0aGUge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWRcbiAqIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2sgb3IgdGhyb3duIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7PyhmdW5jdGlvbih0aGlzOlRISVMsIFRZUEUpOlxuICogICAgICAgICAgICAgKFJFU1VMVHxJVGhlbmFibGUuPFJFU1VMVD58VGhlbmFibGUpKT19IG9wdF9vbkZ1bGZpbGxlZCBBXG4gKiAgICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaWYgdGhlIFByb21pc2VcbiAqICAgICBpcyBmdWxsZmlsbGVkLlxuICogQHBhcmFtIHs/KGZ1bmN0aW9uKCopOiAqKT19IG9wdF9vblJlamVjdGVkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAqICAgICB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZVxuICogICAgIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLiBCeSBkZWZhdWx0LCBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkXG4gKiAgICAgd2l0aCB0aGUgZGVmYXVsdCB0aGlzLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48UkVTVUxUPn0gQSBuZXcgUHJvbWlzZSB0aGF0IHdpbGwgcmVjZWl2ZSB0aGVcbiAqICAgICByZXN1bHQgb2YgdGhlIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBjYWxsYmFjay5cbiAqIEB0ZW1wbGF0ZSBSRVNVTFQsVEhJU1xuICovXG5UaGVuYWJsZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBBbiBleHBhbmRvIHByb3BlcnR5IHRvIGluZGljYXRlIHRoYXQgYW4gb2JqZWN0IGltcGxlbWVudHNcbiAqIHtAY29kZSBUaGVuYWJsZX0uXG4gKlxuICoge0BzZWUgYWRkSW1wbGVtZW50YXRpb259LlxuICpcbiAqIEBjb25zdFxuICovXG5UaGVuYWJsZS5JTVBMRU1FTlRFRF9CWV9QUk9QID0gJyRnb29nX1RoZW5hYmxlJztcblxuXG4vKipcbiAqIE1hcmtzIGEgZ2l2ZW4gY2xhc3MgKGNvbnN0cnVjdG9yKSBhcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBUaGVuYWJsZSwgc29cbiAqIHRoYXQgd2UgY2FuIHF1ZXJ5IHRoYXQgZmFjdCBhdCBydW50aW1lLiBUaGUgY2xhc3MgbXVzdCBoYXZlIGFscmVhZHlcbiAqIGltcGxlbWVudGVkIHRoZSBpbnRlcmZhY2UuXG4gKiBFeHBvcnRzIGEgJ3RoZW4nIG1ldGhvZCBvbiB0aGUgY29uc3RydWN0b3IgcHJvdG90eXBlLCBzbyB0aGF0IHRoZSBvYmplY3RzXG4gKiBhbHNvIGltcGxlbWVudCB0aGUgZXh0ZXJuIHtAc2VlIFRoZW5hYmxlfSBpbnRlcmZhY2UgZm9yIGludGVyb3Agd2l0aFxuICogb3RoZXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpUaGVuYWJsZSwuLi5bP10pfSBjdG9yIFRoZSBjbGFzcyBjb25zdHJ1Y3Rvci4gVGhlXG4gKiAgICAgY29ycmVzcG9uZGluZyBjbGFzcyBtdXN0IGhhdmUgYWxyZWFkeSBpbXBsZW1lbnRlZCB0aGUgaW50ZXJmYWNlLlxuICovXG5UaGVuYWJsZS5hZGRJbXBsZW1lbnRhdGlvbiA9IGZ1bmN0aW9uKGN0b3IpIHtcbiAgY3Rvci5wcm90b3R5cGUudGhlbiA9IGN0b3IucHJvdG90eXBlLnRoZW47XG4gIGN0b3IucHJvdG90eXBlLiRnb29nX1RoZW5hYmxlID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBhIGdpdmVuIGluc3RhbmNlIGltcGxlbWVudHMge0Bjb2RlIFRoZW5hYmxlfS5cbiAqICAgICBUaGUgY2xhc3Mvc3VwZXJjbGFzcyBvZiB0aGUgaW5zdGFuY2UgbXVzdCBjYWxsIHtAY29kZSBhZGRJbXBsZW1lbnRhdGlvbn0uXG4gKi9cblRoZW5hYmxlLmlzSW1wbGVtZW50ZWRCeSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiAhIW9iamVjdC4kZ29vZ19UaGVuYWJsZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFByb3BlcnR5IGFjY2VzcyBzZWVtcyB0byBiZSBmb3JiaWRkZW4uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbi8qKlxuICogTGlrZSBiaW5kKCksIGV4Y2VwdCB0aGF0IGEgJ3RoaXMgb2JqZWN0JyBpcyBub3QgcmVxdWlyZWQuIFVzZWZ1bCB3aGVuIHRoZVxuICogdGFyZ2V0IGZ1bmN0aW9uIGlzIGFscmVhZHkgYm91bmQuXG4gKlxuICogVXNhZ2U6XG4gKiB2YXIgZyA9IHBhcnRpYWwoZiwgYXJnMSwgYXJnMik7XG4gKiBnKGFyZzMsIGFyZzQpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXJ0aWFsbHkgYXBwbGllZCB0byBmbi5cbiAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBiaW5kKCkgd2FzXG4gKiAgICAgaW52b2tlZCBhcyBhIG1ldGhvZCBvZi5cbiAqL1xudmFyIHBhcnRpYWwgPSBmdW5jdGlvbihmbikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgKHdpdGggc2xpY2UoKSkgYW5kIGFwcGVuZCBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgIC8vIHRvIHRoZSBleGlzdGluZyBhcmd1bWVudHMuXG4gICAgdmFyIG5ld0FyZ3MgPSBhcmdzLnNsaWNlKCk7XG4gICAgbmV3QXJncy5wdXNoLmFwcGx5KG5ld0FyZ3MsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICB9O1xufTtcblxuLyoqXG4gKiBQcm9taXNlcyBwcm92aWRlIGEgcmVzdWx0IHRoYXQgbWF5IGJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5LiBBIFByb21pc2UgbWF5XG4gKiBiZSByZXNvbHZlZCBieSBiZWluZyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCB3aWxsIGJlIGtub3duXG4gKiBhcyB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgb3IgdGhlIHJlamVjdGlvbiByZWFzb24uIFdoZXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZCwgdGhlIFByb21pc2UgcmVzdWx0IGlzIGltbXV0YWJsZSBvbmNlIGl0IGlzIHNldC5cbiAqXG4gKiBQcm9taXNlcyBtYXkgcmVwcmVzZW50IHJlc3VsdHMgb2YgYW55IHR5cGUsIGluY2x1ZGluZyB1bmRlZmluZWQuIFJlamVjdGlvblxuICogcmVhc29ucyBhcmUgdHlwaWNhbGx5IEVycm9ycywgYnV0IG1heSBhbHNvIGJlIG9mIGFueSB0eXBlLiBDbG9zdXJlIFByb21pc2VzXG4gKiBhbGxvdyBmb3Igb3B0aW9uYWwgdHlwZSBhbm5vdGF0aW9ucyB0aGF0IGVuZm9yY2UgdGhhdCBmdWxmaWxsbWVudCB2YWx1ZXMgYXJlXG4gKiBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZXMgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIFRoZSByZXN1bHQgb2YgYSBQcm9taXNlIGlzIGFjY2Vzc2libGUgYnkgY2FsbGluZyB7QGNvZGUgdGhlbn0gYW5kIHJlZ2lzdGVyaW5nXG4gKiB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzLiBPbmNlIHRoZSBQcm9taXNlXG4gKiByZXNvbHZlcywgdGhlIHJlbGV2YW50IGNhbGxiYWNrcyBhcmUgaW52b2tlZCB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBvclxuICogcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudC4gQ2FsbGJhY2tzIGFyZSBhbHdheXMgaW52b2tlZCBpbiB0aGUgb3JkZXIgdGhleVxuICogd2VyZSByZWdpc3RlcmVkLCBldmVuIHdoZW4gYWRkaXRpb25hbCB7QGNvZGUgdGhlbn0gY2FsbHMgYXJlIG1hZGUgZnJvbSBpbnNpZGVcbiAqIGFub3RoZXIgY2FsbGJhY2suIEEgY2FsbGJhY2sgaXMgYWx3YXlzIHJ1biBhc3luY2hyb25vdXNseSBzb21ldGltZSBhZnRlciB0aGVcbiAqIHNjb3BlIGNvbnRhaW5pbmcgdGhlIHJlZ2lzdGVyaW5nIHtAY29kZSB0aGVufSBpbnZvY2F0aW9uIGhhcyByZXR1cm5lZC5cbiAqXG4gKiBJZiBhIFByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBhbm90aGVyIFByb21pc2UsIHRoZSBmaXJzdCBQcm9taXNlIHdpbGwgYmxvY2tcbiAqIHVudGlsIHRoZSBzZWNvbmQgaXMgcmVzb2x2ZWQsIGFuZCB0aGVuIGFzc3VtZXMgdGhlIHNhbWUgcmVzdWx0IGFzIHRoZSBzZWNvbmRcbiAqIFByb21pc2UuIFRoaXMgYWxsb3dzIFByb21pc2VzIHRvIGRlcGVuZCBvbiB0aGUgcmVzdWx0cyBvZiBvdGhlciBQcm9taXNlcyxcbiAqIGxpbmtpbmcgdG9nZXRoZXIgbXVsdGlwbGUgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBjb21wYXRpYmxlIHdpdGggdGhlIFByb21pc2VzL0ErIHNwZWNpZmljYXRpb24gYW5kXG4gKiBwYXNzZXMgdGhhdCBzcGVjaWZpY2F0aW9uJ3MgY29uZm9ybWFuY2UgdGVzdCBzdWl0ZS4gQSBDbG9zdXJlIFByb21pc2UgbWF5IGJlXG4gKiByZXNvbHZlZCB3aXRoIGEgUHJvbWlzZSBpbnN0YW5jZSAob3Igc3VmZmljaWVudGx5IGNvbXBhdGlibGUgUHJvbWlzZS1saWtlXG4gKiBvYmplY3QpIGNyZWF0ZWQgYnkgb3RoZXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMuIEZyb20gdGhlIHNwZWNpZmljYXRpb24sXG4gKiBQcm9taXNlLWxpa2Ugb2JqZWN0cyBhcmUga25vd24gYXMgXCJUaGVuYWJsZXNcIi5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS9cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFxuICogICAgICAgICAgICAgdGhpczpSRVNPTFZFUl9DT05URVhULFxuICogICAgICAgICAgICAgZnVuY3Rpb24oKFRZUEV8SVRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSkpLFxuICogICAgICAgICAgICAgZnVuY3Rpb24oKikpOiB2b2lkfSByZXNvbHZlclxuICogICAgIEluaXRpYWxpemF0aW9uIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseSB3aXRoIHtAY29kZSByZXNvbHZlfVxuICogICAgIGFuZCB7QGNvZGUgcmVqZWN0fSBmdW5jdGlvbnMgYXMgYXJndW1lbnRzLiBUaGUgUHJvbWlzZSBpcyByZXNvbHZlZCBvclxuICogICAgIHJlamVjdGVkIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBlaXRoZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1JFU09MVkVSX0NPTlRFWFQ9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IGZvciBleGVjdXRpbmcgdGhlXG4gKiAgICAgcmVzb2x2ZXIgZnVuY3Rpb24uIElmIHVuc3BlY2lmaWVkLCB0aGUgcmVzb2x2ZXIgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZFxuICogICAgIGluIHRoZSBkZWZhdWx0IHNjb3BlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAZmluYWxcbiAqIEBpbXBsZW1lbnRzIHtUaGVuYWJsZS48VFlQRT59XG4gKiBAdGVtcGxhdGUgVFlQRSxSRVNPTFZFUl9DT05URVhUXG4gKi9cbnZhciBDYW5jZWxsYWJsZVByb21pc2UgPSBmdW5jdGlvbihyZXNvbHZlciwgb3B0X2NvbnRleHQpIHtcbiAgLyoqXG4gICAqIFRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGlzIFByb21pc2UuIEVpdGhlciBQRU5ESU5HLCBGVUxGSUxMRUQsIFJFSkVDVEVELCBvclxuICAgKiBCTE9DS0VELlxuICAgKiBAcHJpdmF0ZSB7Q2FuY2VsbGFibGVQcm9taXNlLlN0YXRlX31cbiAgICovXG4gIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgcmVzdWx0IG9mIHRoZSBQcm9taXNlLiBJbW11dGFibGUgb25jZSBzZXQgd2l0aCBlaXRoZXIgYVxuICAgKiBmdWxmaWxsbWVudCB2YWx1ZSBvciByZWplY3Rpb24gcmVhc29uLlxuICAgKiBAcHJpdmF0ZSB7Kn1cbiAgICovXG4gIHRoaXMucmVzdWx0XyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRm9yIFByb21pc2VzIGNyZWF0ZWQgYnkgY2FsbGluZyB7QGNvZGUgdGhlbigpfSwgdGhlIG9yaWdpbmF0aW5nIHBhcmVudC5cbiAgICogQHByaXZhdGUge0NhbmNlbGxhYmxlUHJvbWlzZX1cbiAgICovXG4gIHRoaXMucGFyZW50XyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHtAY29kZSBvbkZ1bGZpbGxlZH0gYW5kIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgYWRkZWQgdG9cbiAgICogdGhpcyBQcm9taXNlIGJ5IGNhbGxzIHRvIHtAY29kZSB0aGVuKCl9LlxuICAgKiBAcHJpdmF0ZSB7QXJyYXkuPENhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5Xz59XG4gICAqL1xuICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBQcm9taXNlIGlzIGluIHRoZSBxdWV1ZSBvZiBQcm9taXNlcyB0byBleGVjdXRlLlxuICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuZXhlY3V0aW5nXyA9IGZhbHNlO1xuXG4gIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA+IDApIHtcbiAgICAvKipcbiAgICAgKiBBIHRpbWVvdXQgSUQgdXNlZCB3aGVuIHRoZSB7QGNvZGUgVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWX0gaXMgZ3JlYXRlclxuICAgICAqIHRoYW4gMCBtaWxsaXNlY29uZHMuIFRoZSBJRCBpcyBzZXQgd2hlbiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgYW5kXG4gICAgICogY2xlYXJlZCBvbmx5IGlmIGFuIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBpcyBpbnZva2VkIGZvciB0aGVcbiAgICAgKiBQcm9taXNlIChvciBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzKSBiZWZvcmUgdGhlIGRlbGF5IGlzIGV4Y2VlZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIHJlamVjdGlvbiBpcyBub3QgaGFuZGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQgY29tcGxldGVzLCB0aGVcbiAgICAgKiByZWplY3Rpb24gcmVhc29uIGlzIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25JZF8gPSAwO1xuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUge0Bjb2RlIFVOSEFORExFRF9SRUpFQ1RJT05fREVMQVl9IGlzIHNldCB0byAwIG1pbGxpc2Vjb25kcywgYVxuICAgICAqIGJvb2xlYW4gdGhhdCBpcyBzZXQgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGFuZCByZXNldCB0byBmYWxzZSBpZiBhblxuICAgICAqIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBpcyBpbnZva2VkIGZvciB0aGUgUHJvbWlzZSAob3Igb25lIG9mIGl0c1xuICAgICAqIGRlc2NlbmRhbnRzKS4gSWYgdGhlIHJlamVjdGlvbiBpcyBub3QgaGFuZGxlZCBiZWZvcmUgdGhlIG5leHQgdGltZXN0ZXAsXG4gICAgICogdGhlIHJlamVjdGlvbiByZWFzb24gaXMgcGFzc2VkIHRvIHRoZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGhhbmRsZXIuXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXNvbHZlci5jYWxsKFxuICAgICAgb3B0X2NvbnRleHQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHNlbGYucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQsIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBzZWxmLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIHJlYXNvbik7XG4gICAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgZSk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgYSByZWplY3RlZCBQcm9taXNlJ3MgcmVhc29uIGlzIHBhc3NlZCB0b1xuICogdGhlIHJlamVjdGlvbiBoYW5kbGVyLiBCeSBkZWZhdWx0LCB0aGUgcmVqZWN0aW9uIGhhbmRsZXIgcmV0aHJvd3MgdGhlXG4gKiByZWplY3Rpb24gcmVhc29uIHNvIHRoYXQgaXQgYXBwZWFycyBpbiB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUgb3JcbiAqIHtAY29kZSB3aW5kb3cub25lcnJvcn0gaGFuZGxlci5cbiAqIFJlamVjdGlvbnMgYXJlIHJldGhyb3duIGFzIHF1aWNrbHkgYXMgcG9zc2libGUgYnkgZGVmYXVsdC4gQSBuZWdhdGl2ZSB2YWx1ZVxuICogZGlzYWJsZXMgcmVqZWN0aW9uIGhhbmRsaW5nIGVudGlyZWx5LlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPSAwO1xuXG5cbi8qKlxuICogVGhlIHBvc3NpYmxlIGludGVybmFsIHN0YXRlcyBmb3IgYSBQcm9taXNlLiBUaGVzZSBzdGF0ZXMgYXJlIG5vdCBkaXJlY3RseVxuICogb2JzZXJ2YWJsZSB0byBleHRlcm5hbCBjYWxsZXJzLlxuICogQGVudW0ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8gPSB7XG4gIC8qKiBUaGUgUHJvbWlzZSBpcyB3YWl0aW5nIGZvciByZXNvbHV0aW9uLiAqL1xuICBQRU5ESU5HOiAwLFxuXG4gIC8qKiBUaGUgUHJvbWlzZSBpcyBibG9ja2VkIHdhaXRpbmcgZm9yIHRoZSByZXN1bHQgb2YgYW5vdGhlciBUaGVuYWJsZS4gKi9cbiAgQkxPQ0tFRDogMSxcblxuICAvKiogVGhlIFByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWQgd2l0aCBhIGZ1bGZpbGxtZW50IHZhbHVlLiAqL1xuICBGVUxGSUxMRUQ6IDIsXG5cbiAgLyoqIFRoZSBQcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggYSByZWplY3Rpb24gcmVhc29uLiAqL1xuICBSRUpFQ1RFRDogM1xufTtcblxuXG4vKipcbiAqIFR5cGVkZWYgZm9yIGVudHJpZXMgaW4gdGhlIGNhbGxiYWNrIGNoYWluLiBFYWNoIGNhbGwgdG8ge0Bjb2RlIHRoZW59LFxuICoge0Bjb2RlIHRoZW5DYXRjaH0sIG9yIHtAY29kZSB0aGVuQWx3YXlzfSBjcmVhdGVzIGFuIGVudHJ5IGNvbnRhaW5pbmcgdGhlXG4gKiBmdW5jdGlvbnMgdGhhdCBtYXkgYmUgaW52b2tlZCBvbmNlIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkLlxuICpcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGNoaWxkOiBDYW5jZWxsYWJsZVByb21pc2UsXG4gKiAgIG9uRnVsZmlsbGVkOiBmdW5jdGlvbigqKSxcbiAqICAgb25SZWplY3RlZDogZnVuY3Rpb24oKilcbiAqIH19XG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV8gPSBudWxsO1xuXG5cbi8qKlxuICogQHBhcmFtIHsoVFlQRXxUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPX0gb3B0X3ZhbHVlXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxUWVBFPn0gQSBuZXcgUHJvbWlzZSB0aGF0IGlzIGltbWVkaWF0ZWx5IHJlc29sdmVkXG4gKiAgICAgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKG9wdF92YWx1ZSkge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKG9wdF92YWx1ZSk7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHsqPX0gb3B0X3JlYXNvblxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gQSBuZXcgUHJvbWlzZSB0aGF0IGlzIGltbWVkaWF0ZWx5IHJlamVjdGVkIHdpdGggdGhlXG4gKiAgICAgZ2l2ZW4gcmVhc29uLlxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24ob3B0X3JlYXNvbikge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlamVjdChvcHRfcmVhc29uKTtcbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheS48IShUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPn0gcHJvbWlzZXNcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBBIFByb21pc2UgdGhhdCByZWNlaXZlcyB0aGUgcmVzdWx0IG9mIHRoZVxuICogICAgIGZpcnN0IFByb21pc2UgKG9yIFByb21pc2UtbGlrZSkgaW5wdXQgdG8gY29tcGxldGUuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmFjZSA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKCFwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IChwcm9taXNlID0gcHJvbWlzZXNbaV0pOyBpKyspIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshQXJyYXkuPCEoVGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT59IHByb21pc2VzXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjwhQXJyYXkuPFRZUEU+Pn0gQSBQcm9taXNlIHRoYXQgcmVjZWl2ZXMgYSBsaXN0IG9mXG4gKiAgICAgZXZlcnkgZnVsZmlsbGVkIHZhbHVlIG9uY2UgZXZlcnkgaW5wdXQgUHJvbWlzZSAob3IgUHJvbWlzZS1saWtlKSBpc1xuICogICAgIHN1Y2Nlc3NmdWxseSBmdWxmaWxsZWQsIG9yIGlzIHJlamVjdGVkIGJ5IHRoZSBmaXJzdCByZWplY3Rpb24gcmVzdWx0LlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLmFsbCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHRvRnVsZmlsbCA9IHByb21pc2VzLmxlbmd0aDtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgICAgaWYgKCF0b0Z1bGZpbGwpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvbkZ1bGZpbGwgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdG9GdWxmaWxsLS07XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRvRnVsZmlsbCA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG9uUmVqZWN0ID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IChwcm9taXNlID0gcHJvbWlzZXNbaV0pOyBpKyspIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKHBhcnRpYWwob25GdWxmaWxsLCBpKSwgb25SZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjwhKFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk+fSBwcm9taXNlc1xuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IEEgUHJvbWlzZSB0aGF0IHJlY2VpdmVzIHRoZSB2YWx1ZSBvZlxuICogICAgIHRoZSBmaXJzdCBpbnB1dCB0byBiZSBmdWxmaWxsZWQsIG9yIGlzIHJlamVjdGVkIHdpdGggYSBsaXN0IG9mIGV2ZXJ5XG4gKiAgICAgcmVqZWN0aW9uIHJlYXNvbiBpZiBhbGwgaW5wdXRzIGFyZSByZWplY3RlZC5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5maXJzdEZ1bGZpbGxlZCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHRvUmVqZWN0ID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgdmFyIHJlYXNvbnMgPSBbXTtcblxuICAgICAgaWYgKCF0b1JlamVjdCkge1xuICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9uRnVsZmlsbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9uUmVqZWN0ID0gZnVuY3Rpb24oaW5kZXgsIHJlYXNvbikge1xuICAgICAgICB0b1JlamVjdC0tO1xuICAgICAgICByZWFzb25zW2luZGV4XSA9IHJlYXNvbjtcbiAgICAgICAgaWYgKHRvUmVqZWN0ID09PSAwKSB7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgcHJvbWlzZTsgKHByb21pc2UgPSBwcm9taXNlc1tpXSk7IGkrKykge1xuICAgICAgICBwcm9taXNlLnRoZW4ob25GdWxmaWxsLCBwYXJ0aWFsKG9uUmVqZWN0LCBpKSk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQWRkcyBjYWxsYmFja3MgdGhhdCB3aWxsIG9wZXJhdGUgb24gdGhlIHJlc3VsdCBvZiB0aGUgUHJvbWlzZSwgcmV0dXJuaW5nIGFcbiAqIG5ldyBjaGlsZCBQcm9taXNlLlxuICpcbiAqIElmIHRoZSBQcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHtAY29kZSBvbkZ1bGZpbGxlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmVcbiAqIGZ1bGZpbGxlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrLiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzIGFuXG4gKiBleGNlcHRpb24sIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlIGluc3RlYWQuXG4gKlxuICogSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIHRoZSB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZFxuICogd2l0aCB0aGUgcmV0dXJuIHZhbHVlIChvciB0aHJvd24gdmFsdWUpIG9mIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob3B0X29uRnVsZmlsbGVkLCBvcHRfb25SZWplY3RlZCwgb3B0X2NvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuYWRkQ2hpbGRQcm9taXNlXyhcbiAgICBpc0Z1bmN0aW9uKG9wdF9vbkZ1bGZpbGxlZCkgPyBvcHRfb25GdWxmaWxsZWQgOiBudWxsLFxuICAgIGlzRnVuY3Rpb24ob3B0X29uUmVqZWN0ZWQpID8gb3B0X29uUmVqZWN0ZWQgOiBudWxsLFxuICAgIG9wdF9jb250ZXh0KTtcbn07XG5UaGVuYWJsZS5hZGRJbXBsZW1lbnRhdGlvbihDYW5jZWxsYWJsZVByb21pc2UpO1xuXG5cbi8qKlxuICogQWRkcyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZXRoZXIgdGhlIFByb21pc2UgaXMgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZC4gVGhlIGNhbGxiYWNrIHJlY2VpdmVzIG5vIGFyZ3VtZW50LCBhbmQgbm8gbmV3IGNoaWxkIFByb21pc2UgaXNcbiAqIGNyZWF0ZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGNsZWFudXAgdGFrZXMgcGxhY2UgYWZ0ZXIgY2VydGFpblxuICogYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuIENhbGxiYWNrcyBhZGRlZCB3aXRoIHtAY29kZSB0aGVuQWx3YXlzfSB3aWxsIGJlXG4gKiBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciB3aXRoIG90aGVyIGNhbGxzIHRvIHtAY29kZSB0aGVufSxcbiAqIHtAY29kZSB0aGVuQWx3YXlzfSwgb3Ige0Bjb2RlIHRoZW5DYXRjaH0uXG4gKlxuICogU2luY2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIG5ldyBjaGlsZCBQcm9taXNlLCBjYW5jZWxsYXRpb24gcHJvcGFnYXRpb24gaXNcbiAqIG5vdCBwcmV2ZW50ZWQgYnkgYWRkaW5nIGNhbGxiYWNrcyB3aXRoIHtAY29kZSB0aGVuQWx3YXlzfS4gQSBQcm9taXNlIHRoYXQgaGFzXG4gKiBhIGNsZWFudXAgaGFuZGxlciBhZGRlZCB3aXRoIHtAY29kZSB0aGVuQWx3YXlzfSB3aWxsIGJlIGNhbmNlbGVkIGlmIGFsbCBvZlxuICogaXRzIGNoaWxkcmVuIGNyZWF0ZWQgYnkge0Bjb2RlIHRoZW59IChvciB7QGNvZGUgdGhlbkNhdGNofSkgYXJlIGNhbmNlbGVkLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpUSElTKTogdm9pZH0gb25SZXNvbHZlZCBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkXG4gKiAgICAgd2hlbiB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZC5cbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGNvbnRleHQgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGVcbiAqICAgICBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrcy4gQnkgZGVmYXVsdCwgZnVuY3Rpb25zIGFyZSBleGVjdXRlZFxuICogICAgIGluIHRoZSBnbG9iYWwgc2NvcGUuXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxUWVBFPn0gVGhpcyBQcm9taXNlLCBmb3IgY2hhaW5pbmcgYWRkaXRpb25hbCBjYWxscy5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkFsd2F5cyA9IGZ1bmN0aW9uKG9uUmVzb2x2ZWQsIG9wdF9jb250ZXh0KSB7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byBvblJlc29sdmVkLlxuICAgICAgb25SZXNvbHZlZC5jYWxsKG9wdF9jb250ZXh0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIENhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fLmNhbGwobnVsbCwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5hZGRDYWxsYmFja0VudHJ5Xyh7XG4gICAgY2hpbGQ6IG51bGwsXG4gICAgb25SZWplY3RlZDogY2FsbGJhY2ssXG4gICAgb25GdWxmaWxsZWQ6IGNhbGxiYWNrXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgb25seSBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpc1xuICogaXMgZXF1aXZhbGVudCB0byB7QGNvZGUgdGhlbihudWxsLCBvblJlamVjdGVkKX0uXG4gKlxuICogQHBhcmFtIHshZnVuY3Rpb24odGhpczpUSElTLCAqKTogKn0gb25SZWplY3RlZCBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICAgIGludm9rZWQgd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZC5cbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGNvbnRleHQgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGVcbiAqICAgICBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrcy4gQnkgZGVmYXVsdCwgZnVuY3Rpb25zIGFyZSBleGVjdXRlZFxuICogICAgIGluIHRoZSBnbG9iYWwgc2NvcGUuXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfSBBIG5ldyBQcm9taXNlIHRoYXQgd2lsbCByZWNlaXZlIHRoZSByZXN1bHQgb2YgdGhlXG4gKiAgICAgY2FsbGJhY2suXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5DYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmFkZENoaWxkUHJvbWlzZV8obnVsbCwgb25SZWplY3RlZCwgb3B0X2NvbnRleHQpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBvZiB7QGxpbmsgQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQ2F0Y2h9XG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBDYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5DYXRjaDtcblxuXG4vKipcbiAqIENhbmNlbHMgdGhlIFByb21pc2UgaWYgaXQgaXMgc3RpbGwgcGVuZGluZyBieSByZWplY3RpbmcgaXQgd2l0aCBhIGNhbmNlbFxuICogRXJyb3IuIE5vIGFjdGlvbiBpcyBwZXJmb3JtZWQgaWYgdGhlIFByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZC5cbiAqXG4gKiBBbGwgY2hpbGQgUHJvbWlzZXMgb2YgdGhlIGNhbmNlbGVkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gKiBjYW5jZWwgZXJyb3IsIGFzIHdpdGggbm9ybWFsIFByb21pc2UgcmVqZWN0aW9uLiBJZiB0aGUgUHJvbWlzZSB0byBiZSBjYW5jZWxlZFxuICogaXMgdGhlIG9ubHkgY2hpbGQgb2YgYSBwZW5kaW5nIFByb21pc2UsIHRoZSBwYXJlbnQgUHJvbWlzZSB3aWxsIGFsc28gYmVcbiAqIGNhbmNlbGVkLiBDYW5jZWxsYXRpb24gbWF5IHByb3BhZ2F0ZSB1cHdhcmQgdGhyb3VnaCBtdWx0aXBsZSBnZW5lcmF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEFuIG9wdGlvbmFsIGRlYnVnZ2luZyBtZXNzYWdlIGZvciBkZXNjcmliaW5nIHRoZVxuICogICAgIGNhbmNlbGxhdGlvbiByZWFzb24uXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24ob3B0X21lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICBhc3luYy5ydW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IENhbmNlbGxhYmxlUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcihvcHRfbWVzc2FnZSk7XG4gICAgICBlcnIuSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FuY2VsSW50ZXJuYWxfKGVycik7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDYW5jZWxzIHRoaXMgUHJvbWlzZSB3aXRoIHRoZSBnaXZlbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0geyFFcnJvcn0gZXJyIFRoZSBjYW5jZWxsYXRpb24gZXJyb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhbmNlbEludGVybmFsXyA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORykge1xuICAgIGlmICh0aGlzLnBhcmVudF8pIHtcbiAgICAgIC8vIENhbmNlbCB0aGUgUHJvbWlzZSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHBhcmVudCdzIGNoaWxkIGxpc3QuXG4gICAgICB0aGlzLnBhcmVudF8uY2FuY2VsQ2hpbGRfKHRoaXMsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgZXJyKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDYW5jZWxzIGEgY2hpbGQgUHJvbWlzZSBmcm9tIHRoZSBsaXN0IG9mIGNhbGxiYWNrIGVudHJpZXMuIElmIHRoZSBQcm9taXNlIGhhc1xuICogbm90IGFscmVhZHkgYmVlbiByZXNvbHZlZCwgcmVqZWN0IGl0IHdpdGggYSBjYW5jZWwgZXJyb3IuIElmIHRoZXJlIGFyZSBub1xuICogb3RoZXIgY2hpbGRyZW4gaW4gdGhlIGxpc3Qgb2YgY2FsbGJhY2sgZW50cmllcywgcHJvcGFnYXRlIHRoZSBjYW5jZWxsYXRpb25cbiAqIGJ5IGNhbmNlbGluZyB0aGlzIFByb21pc2UgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0geyFDYW5jZWxsYWJsZVByb21pc2V9IGNoaWxkUHJvbWlzZSBUaGUgUHJvbWlzZSB0byBjYW5jZWwuXG4gKiBAcGFyYW0geyFFcnJvcn0gZXJyIFRoZSBjYW5jZWwgZXJyb3IgdG8gdXNlIGZvciByZWplY3RpbmcgdGhlIFByb21pc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhbmNlbENoaWxkXyA9IGZ1bmN0aW9uKGNoaWxkUHJvbWlzZSwgZXJyKSB7XG4gIGlmICghdGhpcy5jYWxsYmFja0VudHJpZXNfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjaGlsZENvdW50ID0gMDtcbiAgdmFyIGNoaWxkSW5kZXggPSAtMTtcblxuICAvLyBGaW5kIHRoZSBjYWxsYmFjayBlbnRyeSBmb3IgdGhlIGNoaWxkUHJvbWlzZSwgYW5kIGNvdW50IHdoZXRoZXIgdGhlcmUgYXJlXG4gIC8vIGFkZGl0aW9uYWwgY2hpbGQgUHJvbWlzZXMuXG4gIGZvciAodmFyIGkgPSAwLCBlbnRyeTsgKGVudHJ5ID0gdGhpcy5jYWxsYmFja0VudHJpZXNfW2ldKTsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gZW50cnkuY2hpbGQ7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjaGlsZENvdW50Kys7XG4gICAgICBpZiAoY2hpbGQgPT09IGNoaWxkUHJvbWlzZSkge1xuICAgICAgICBjaGlsZEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEluZGV4ID49IDAgJiYgY2hpbGRDb3VudCA+IDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIGNoaWxkIFByb21pc2Ugd2FzIHRoZSBvbmx5IGNoaWxkLCBjYW5jZWwgdGhpcyBQcm9taXNlIGFzIHdlbGwuXG4gIC8vIE90aGVyd2lzZSwgcmVqZWN0IG9ubHkgdGhlIGNoaWxkIFByb21pc2Ugd2l0aCB0aGUgY2FuY2VsIGVycm9yLlxuICBpZiAoY2hpbGRJbmRleCA+PSAwKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcgJiYgY2hpbGRDb3VudCA9PT0gMSkge1xuICAgICAgdGhpcy5jYW5jZWxJbnRlcm5hbF8oZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNhbGxiYWNrRW50cnkgPSB0aGlzLmNhbGxiYWNrRW50cmllc18uc3BsaWNlKGNoaWxkSW5kZXgsIDEpWzBdO1xuICAgICAgdGhpcy5leGVjdXRlQ2FsbGJhY2tfKFxuICAgICAgICBjYWxsYmFja0VudHJ5LCBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCBlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEFkZHMgYSBjYWxsYmFjayBlbnRyeSB0byB0aGUgY3VycmVudCBQcm9taXNlLCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gKiBleGVjdXRpb24gaWYgdGhlIFByb21pc2UgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZC5cbiAqXG4gKiBAcGFyYW0ge0NhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5X30gY2FsbGJhY2tFbnRyeSBSZWNvcmQgY29udGFpbmluZ1xuICogICAgIHtAY29kZSBvbkZ1bGZpbGxlZH0gYW5kIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgdG8gZXhlY3V0ZSBhZnRlclxuICogICAgIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5hZGRDYWxsYmFja0VudHJ5XyA9IGZ1bmN0aW9uKGNhbGxiYWNrRW50cnkpIHtcbiAgaWYgKCghdGhpcy5jYWxsYmFja0VudHJpZXNfIHx8ICF0aGlzLmNhbGxiYWNrRW50cmllc18ubGVuZ3RoKSAmJlxuICAgICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQgfHxcbiAgICB0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCkpIHtcbiAgICB0aGlzLnNjaGVkdWxlQ2FsbGJhY2tzXygpO1xuICB9XG4gIGlmICghdGhpcy5jYWxsYmFja0VudHJpZXNfKSB7XG4gICAgdGhpcy5jYWxsYmFja0VudHJpZXNfID0gW107XG4gIH1cbiAgdGhpcy5jYWxsYmFja0VudHJpZXNfLnB1c2goY2FsbGJhY2tFbnRyeSk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNoaWxkIFByb21pc2UgYW5kIGFkZHMgaXQgdG8gdGhlIGNhbGxiYWNrIGVudHJ5IGxpc3QuIFRoZSByZXN1bHQgb2ZcbiAqIHRoZSBjaGlsZCBQcm9taXNlIGlzIGRldGVybWluZWQgYnkgdGhlIHN0YXRlIG9mIHRoZSBwYXJlbnQgUHJvbWlzZSBhbmQgdGhlXG4gKiByZXN1bHQgb2YgdGhlIHtAY29kZSBvbkZ1bGZpbGxlZH0gb3Ige0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcyBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBQcm9taXNlIHJlc29sdXRpb24gcHJvY2VkdXJlLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyN0aGVfX21ldGhvZFxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6VEhJUywgVFlQRSk6XG4gKiAgICAgICAgICAoUkVTVUxUfENhbmNlbGxhYmxlUHJvbWlzZS48UkVTVUxUPnxUaGVuYWJsZSl9IG9uRnVsZmlsbGVkIEEgY2FsbGJhY2sgdGhhdFxuICogICAgIHdpbGwgYmUgaW52b2tlZCBpZiB0aGUgUHJvbWlzZSBpcyBmdWxsZmlsbGVkLCBvciBudWxsLlxuICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpUSElTLCAqKTogKn0gb25SZWplY3RlZCBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZVxuICogICAgIGludm9rZWQgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIG9yIG51bGwuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrcy5cbiAqICAgICBpbiB0aGUgZGVmYXVsdCBjYWxsaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfSBUaGUgY2hpbGQgUHJvbWlzZS5cbiAqIEB0ZW1wbGF0ZSBSRVNVTFQsVEhJU1xuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5hZGRDaGlsZFByb21pc2VfID0gZnVuY3Rpb24oXG5vbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb3B0X2NvbnRleHQpIHtcblxuICB2YXIgY2FsbGJhY2tFbnRyeSA9IHtcbiAgICBjaGlsZDogbnVsbCxcbiAgICBvbkZ1bGZpbGxlZDogbnVsbCxcbiAgICBvblJlamVjdGVkOiBudWxsXG4gIH07XG5cbiAgY2FsbGJhY2tFbnRyeS5jaGlsZCA9IG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gSW52b2tlIG9uRnVsZmlsbGVkLCBvciByZXNvbHZlIHdpdGggdGhlIHBhcmVudCdzIHZhbHVlIGlmIGFic2VudC5cbiAgICBjYWxsYmFja0VudHJ5Lm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9uRnVsZmlsbGVkLmNhbGwob3B0X2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0gOiByZXNvbHZlO1xuXG4gICAgLy8gSW52b2tlIG9uUmVqZWN0ZWQsIG9yIHJlamVjdCB3aXRoIHRoZSBwYXJlbnQncyByZWFzb24gaWYgYWJzZW50LlxuICAgIGNhbGxiYWNrRW50cnkub25SZWplY3RlZCA9IG9uUmVqZWN0ZWQgPyBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBvblJlamVjdGVkLmNhbGwob3B0X2NvbnRleHQsIHJlYXNvbik7XG4gICAgICAgIGlmICghaXNEZWYocmVzdWx0KSAmJiByZWFzb24uSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SKSB7XG4gICAgICAgICAgLy8gUHJvcGFnYXRlIGNhbmNlbGxhdGlvbiB0byBjaGlsZHJlbiBpZiBubyBvdGhlciByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSA6IHJlamVjdDtcbiAgfSk7XG5cbiAgY2FsbGJhY2tFbnRyeS5jaGlsZC5wYXJlbnRfID0gdGhpcztcbiAgdGhpcy5hZGRDYWxsYmFja0VudHJ5XyhcbiAgICAvKiogQHR5cGUge0NhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5X30gKi8gKGNhbGxiYWNrRW50cnkpKTtcbiAgcmV0dXJuIGNhbGxiYWNrRW50cnkuY2hpbGQ7XG59O1xuXG5cbi8qKlxuICogVW5ibG9ja3MgdGhlIFByb21pc2UgYW5kIGZ1bGZpbGxzIGl0IHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7VFlQRX0gdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudW5ibG9ja0FuZEZ1bGZpbGxfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbmNlbGxhYmxlUHJvbWlzZSBpcyBub3QgYmxvY2tlZC4nKTtcbiAgfVxuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcbiAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkZVTEZJTExFRCwgdmFsdWUpO1xufTtcblxuXG4vKipcbiAqIFVuYmxvY2tzIHRoZSBQcm9taXNlIGFuZCByZWplY3RzIGl0IHdpdGggdGhlIGdpdmVuIHJlamVjdGlvbiByZWFzb24uXG4gKlxuICogQHBhcmFtIHsqfSByZWFzb25cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudW5ibG9ja0FuZFJlamVjdF8gPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbmNlbGxhYmxlUHJvbWlzZSBpcyBub3QgYmxvY2tlZC4nKTtcbiAgfVxuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcbiAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCByZWFzb24pO1xufTtcblxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlc29sdmUgYSBQcm9taXNlIHdpdGggYSBnaXZlbiByZXNvbHV0aW9uIHN0YXRlIGFuZCB2YWx1ZS4gVGhpc1xuICogaXMgYSBuby1vcCBpZiB0aGUgZ2l2ZW4gUHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkLlxuICpcbiAqIElmIHRoZSBnaXZlbiByZXN1bHQgaXMgYSBUaGVuYWJsZSAoc3VjaCBhcyBhbm90aGVyIFByb21pc2UpLCB0aGUgUHJvbWlzZSB3aWxsXG4gKiBiZSByZXNvbHZlZCB3aXRoIHRoZSBzYW1lIHN0YXRlIGFuZCByZXN1bHQgYXMgdGhlIFRoZW5hYmxlIG9uY2UgaXQgaXMgaXRzZWxmXG4gKiByZXNvbHZlZC5cbiAqXG4gKiBJZiB0aGUgZ2l2ZW4gcmVzdWx0IGlzIG5vdCBhIFRoZW5hYmxlLCB0aGUgUHJvbWlzZSB3aWxsIGJlIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQgd2l0aCB0aGF0IHJlc3VsdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gc3RhdGUuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vI3RoZV9wcm9taXNlX3Jlc29sdXRpb25fcHJvY2VkdXJlXG4gKlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVffSBzdGF0ZVxuICogQHBhcmFtIHsqfSB4IFRoZSByZXN1bHQgdG8gYXBwbHkgdG8gdGhlIFByb21pc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnJlc29sdmVfID0gZnVuY3Rpb24oc3RhdGUsIHgpIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcyA9PT0geCkge1xuICAgIHN0YXRlID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRDtcbiAgICB4ID0gbmV3IFR5cGVFcnJvcignQ2FuY2VsbGFibGVQcm9taXNlIGNhbm5vdCByZXNvbHZlIHRvIGl0c2VsZicpO1xuXG4gIH0gZWxzZSBpZiAoVGhlbmFibGUuaXNJbXBsZW1lbnRlZEJ5KHgpKSB7XG4gICAgeCA9IC8qKiBAdHlwZSB7IVRoZW5hYmxlfSAqLyAoeCk7XG4gICAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQ7XG4gICAgeC50aGVuKHRoaXMudW5ibG9ja0FuZEZ1bGZpbGxfLCB0aGlzLnVuYmxvY2tBbmRSZWplY3RfLCB0aGlzKTtcbiAgICByZXR1cm47XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdCh4KSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhlbiA9IHgudGhlbjtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgIHRoaXMudHJ5VGhlbl8oeCwgdGhlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdGF0ZSA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQ7XG4gICAgICB4ID0gZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnJlc3VsdF8gPSB4O1xuICB0aGlzLnN0YXRlXyA9IHN0YXRlO1xuICB0aGlzLnNjaGVkdWxlQ2FsbGJhY2tzXygpO1xuXG4gIGlmIChzdGF0ZSA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCAmJiAheC5JU19DQU5DRUxMQVRJT05fRVJST1IpIHtcbiAgICBDYW5jZWxsYWJsZVByb21pc2UuYWRkVW5oYW5kbGVkUmVqZWN0aW9uXyh0aGlzLCB4KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGNhbGwgdGhlIHtAY29kZSB0aGVufSBtZXRob2Qgb24gYW4gb2JqZWN0IGluIHRoZSBob3BlcyB0aGF0IGl0IGlzXG4gKiBhIFByb21pc2UtY29tcGF0aWJsZSBpbnN0YW5jZS4gVGhpcyBhbGxvd3MgaW50ZXJvcGVyYXRpb24gYmV0d2VlbiBkaWZmZXJlbnRcbiAqIFByb21pc2UgaW1wbGVtZW50YXRpb25zLCBob3dldmVyIGEgbm9uLWNvbXBsaWFudCBvYmplY3QgbWF5IGNhdXNlIGEgUHJvbWlzZVxuICogdG8gaGFuZyBpbmRlZmluaXRlbHkuIElmIHRoZSB7QGNvZGUgdGhlbn0gbWV0aG9kIHRocm93cyBhbiBleGNlcHRpb24sIHRoZVxuICogZGVwZW5kZW50IFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSB0aHJvd24gdmFsdWUuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTcwXG4gKlxuICogQHBhcmFtIHtUaGVuYWJsZX0gdGhlbmFibGUgQW4gb2JqZWN0IHdpdGggYSB7QGNvZGUgdGhlbn0gbWV0aG9kIHRoYXQgbWF5IGJlXG4gKiAgICAgY29tcGF0aWJsZSB3aXRoIHRoZSBQcm9taXNlL0ErIHNwZWNpZmljYXRpb24uXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gdGhlbiBUaGUge0Bjb2RlIHRoZW59IG1ldGhvZCBvZiB0aGUgVGhlbmFibGUgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50cnlUaGVuXyA9IGZ1bmN0aW9uKHRoZW5hYmxlLCB0aGVuKSB7XG4gIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEO1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBwcm9taXNlLnVuYmxvY2tBbmRGdWxmaWxsXyh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZWplY3QgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb21pc2UudW5ibG9ja0FuZFJlamVjdF8ocmVhc29uKTtcbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICB0aGVuLmNhbGwodGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QoZSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcGVuZGluZyBjYWxsYmFja3Mgb2YgYSByZXNvbHZlZCBQcm9taXNlIGFmdGVyIGEgdGltZW91dC5cbiAqXG4gKiBTZWN0aW9uIDIuMi40IG9mIHRoZSBQcm9taXNlcy9BKyBzcGVjaWZpY2F0aW9uIHJlcXVpcmVzIHRoYXQgUHJvbWlzZVxuICogY2FsbGJhY2tzIG11c3Qgb25seSBiZSBpbnZva2VkIGZyb20gYSBjYWxsIHN0YWNrIHRoYXQgb25seSBjb250YWlucyBQcm9taXNlXG4gKiBpbXBsZW1lbnRhdGlvbiBjb2RlLCB3aGljaCB3ZSBhY2NvbXBsaXNoIGJ5IGludm9raW5nIGNhbGxiYWNrIGV4ZWN1dGlvbiBhZnRlclxuICogYSB0aW1lb3V0LiBJZiB7QGNvZGUgc3RhcnRFeGVjdXRpb25ffSBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lXG4gKiBQcm9taXNlLCB0aGUgY2FsbGJhY2sgY2hhaW4gd2lsbCBiZSBldmFsdWF0ZWQgb25seSBvbmNlLiBBZGRpdGlvbmFsIGNhbGxiYWNrc1xuICogbWF5IGJlIGFkZGVkIGR1cmluZyB0aGUgZXZhbHVhdGlvbiBwaGFzZSwgYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWVcbiAqIGV2ZW50IGxvb3AuXG4gKlxuICogQWxsIFByb21pc2VzIGFkZGVkIHRvIHRoZSB3YWl0aW5nIGxpc3QgZHVyaW5nIHRoZSBzYW1lIGJyb3dzZXIgZXZlbnQgbG9vcFxuICogd2lsbCBiZSBleGVjdXRlZCBpbiBvbmUgYmF0Y2ggdG8gYXZvaWQgdXNpbmcgYSBzZXBhcmF0ZSB0aW1lb3V0IHBlciBQcm9taXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuc2NoZWR1bGVDYWxsYmFja3NfID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5leGVjdXRpbmdfKSB7XG4gICAgdGhpcy5leGVjdXRpbmdfID0gdHJ1ZTtcbiAgICBhc3luYy5ydW4odGhpcy5leGVjdXRlQ2FsbGJhY2tzXywgdGhpcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBFeGVjdXRlcyBhbGwgcGVuZGluZyBjYWxsYmFja3MgZm9yIHRoaXMgUHJvbWlzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmV4ZWN1dGVDYWxsYmFja3NfID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLmNhbGxiYWNrRW50cmllc18gJiYgdGhpcy5jYWxsYmFja0VudHJpZXNfLmxlbmd0aCkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5jYWxsYmFja0VudHJpZXNfO1xuICAgIHRoaXMuY2FsbGJhY2tFbnRyaWVzXyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVDYWxsYmFja18oZW50cmllc1tpXSwgdGhpcy5zdGF0ZV8sIHRoaXMucmVzdWx0Xyk7XG4gICAgfVxuICB9XG4gIHRoaXMuZXhlY3V0aW5nXyA9IGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcGVuZGluZyBjYWxsYmFjayBmb3IgdGhpcyBQcm9taXNlLiBJbnZva2VzIGFuIHtAY29kZSBvbkZ1bGZpbGxlZH1cbiAqIG9yIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBiYXNlZCBvbiB0aGUgcmVzb2x2ZWQgc3RhdGUgb2YgdGhlIFByb21pc2UuXG4gKlxuICogQHBhcmFtIHshQ2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlffSBjYWxsYmFja0VudHJ5IEFuIGVudHJ5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgb25GdWxmaWxsZWQgYW5kL29yIG9uUmVqZWN0ZWQgY2FsbGJhY2tzIGZvciB0aGlzIHN0ZXAuXG4gKiBAcGFyYW0ge0NhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV99IHN0YXRlIFRoZSByZXNvbHV0aW9uIHN0YXR1cyBvZiB0aGUgUHJvbWlzZSxcbiAqICAgICBlaXRoZXIgRlVMRklMTEVEIG9yIFJFSkVDVEVELlxuICogQHBhcmFtIHsqfSByZXN1bHQgVGhlIHJlc29sdmVkIHJlc3VsdCBvZiB0aGUgUHJvbWlzZS5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuZXhlY3V0ZUNhbGxiYWNrXyA9IGZ1bmN0aW9uKFxuY2FsbGJhY2tFbnRyeSwgc3RhdGUsIHJlc3VsdCkge1xuICBpZiAoc3RhdGUgPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVEKSB7XG4gICAgY2FsbGJhY2tFbnRyeS5vbkZ1bGZpbGxlZChyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVtb3ZlVW5oYW5kbGVkUmVqZWN0aW9uXygpO1xuICAgIGNhbGxiYWNrRW50cnkub25SZWplY3RlZChyZXN1bHQpO1xuICB9XG59O1xuXG5cbi8qKlxuICogTWFya3MgdGhpcyByZWplY3RlZCBQcm9taXNlIGFzIGhhdmluZyBiZWluZyBoYW5kbGVkLiBBbHNvIG1hcmtzIGFueSBwYXJlbnRcbiAqIFByb21pc2VzIGluIHRoZSByZWplY3RlZCBzdGF0ZSBhcyBoYW5kbGVkLiBUaGUgcmVqZWN0aW9uIGhhbmRsZXIgd2lsbCBub1xuICogbG9uZ2VyIGJlIGludm9rZWQgZm9yIHRoaXMgUHJvbWlzZSAoaWYgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBhbHJlYWR5KS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnJlbW92ZVVuaGFuZGxlZFJlamVjdGlvbl8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHA7XG4gIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA+IDApIHtcbiAgICBmb3IgKHAgPSB0aGlzOyBwICYmIHAudW5oYW5kbGVkUmVqZWN0aW9uSWRfOyBwID0gcC5wYXJlbnRfKSB7XG4gICAgICBjbGVhclRpbWVvdXQocC51bmhhbmRsZWRSZWplY3Rpb25JZF8pO1xuICAgICAgcC51bmhhbmRsZWRSZWplY3Rpb25JZF8gPSAwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA9PT0gMCkge1xuICAgIGZvciAocCA9IHRoaXM7IHAgJiYgcC5oYWRVbmhhbmRsZWRSZWplY3Rpb25fOyBwID0gcC5wYXJlbnRfKSB7XG4gICAgICBwLmhhZFVuaGFuZGxlZFJlamVjdGlvbl8gPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBNYXJrcyB0aGlzIHJlamVjdGVkIFByb21pc2UgYXMgdW5oYW5kbGVkLiBJZiBubyB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tcbiAqIGlzIGNhbGxlZCBmb3IgdGhpcyBQcm9taXNlIGJlZm9yZSB0aGUge0Bjb2RlIFVOSEFORExFRF9SRUpFQ1RJT05fREVMQVl9XG4gKiBleHBpcmVzLCB0aGUgcmVhc29uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZVxuICogaGFuZGxlciB0eXBpY2FsbHkgcmV0aHJvd3MgdGhlIHJlamVjdGlvbiByZWFzb24gc28gdGhhdCBpdCBiZWNvbWVzIHZpc2libGUgaW5cbiAqIHRoZSBkZXZlbG9wZXIgY29uc29sZS5cbiAqXG4gKiBAcGFyYW0geyFDYW5jZWxsYWJsZVByb21pc2V9IHByb21pc2UgVGhlIHJlamVjdGVkIFByb21pc2UuXG4gKiBAcGFyYW0geyp9IHJlYXNvbiBUaGUgUHJvbWlzZSByZWplY3Rpb24gcmVhc29uLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLmFkZFVuaGFuZGxlZFJlamVjdGlvbl8gPSBmdW5jdGlvbihwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID4gMCkge1xuICAgIHByb21pc2UudW5oYW5kbGVkUmVqZWN0aW9uSWRfID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIENhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fLmNhbGwobnVsbCwgcmVhc29uKTtcbiAgICB9LCBDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSk7XG5cbiAgfSBlbHNlIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA9PT0gMCkge1xuICAgIHByb21pc2UuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IHRydWU7XG4gICAgYXN5bmMucnVuKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb21pc2UuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXykge1xuICAgICAgICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXy5jYWxsKG51bGwsIHJlYXNvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBIG1ldGhvZCB0aGF0IGlzIGludm9rZWQgd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbnMgZm9yIFByb21pc2VzIHRoYXQgYXJlXG4gKiByZWplY3RlZCBidXQgaGF2ZSBubyB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgeWV0LlxuICogQHR5cGUge2Z1bmN0aW9uKCopfVxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8gPSBhc3luYy50aHJvd0V4Y2VwdGlvbjtcblxuXG4vKipcbiAqIFNldHMgYSBoYW5kbGVyIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCByZWFzb25zIGZyb20gdW5oYW5kbGVkIHJlamVjdGVkXG4gKiBQcm9taXNlcy4gSWYgdGhlIHJlamVjdGVkIFByb21pc2UgKG9yIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMpIGhhcyBhblxuICoge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIHJlZ2lzdGVyZWQsIHRoZSByZWplY3Rpb24gd2lsbCBiZSBjb25zaWRlcmVkXG4gKiBoYW5kbGVkLCBhbmQgdGhlIHJlamVjdGlvbiBoYW5kbGVyIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB1bmhhbmRsZWQgcmVqZWN0aW9ucyBhcmUgcmV0aHJvd24gc28gdGhhdCB0aGUgZXJyb3IgbWF5IGJlXG4gKiBjYXB0dXJlZCBieSB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUgb3IgYSB7QGNvZGUgd2luZG93Lm9uZXJyb3J9IGhhbmRsZXIuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigqKX0gaGFuZGxlciBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCByZWFzb25zIGZyb21cbiAqICAgICByZWplY3RlZCBQcm9taXNlcy4gRGVmYXVsdHMgdG8ge0Bjb2RlIGFzeW5jLnRocm93RXhjZXB0aW9ufS5cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnNldFVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gIENhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fID0gaGFuZGxlcjtcbn07XG5cblxuXG4vKipcbiAqIEVycm9yIHVzZWQgYXMgYSByZWplY3Rpb24gcmVhc29uIGZvciBjYW5jZWxlZCBQcm9taXNlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqIEBmaW5hbFxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0X21lc3NhZ2UpIHtcbiAgICAgc3VwZXIob3B0X21lc3NhZ2UpO1xuXG4gICAgIGlmIChvcHRfbWVzc2FnZSkge1xuICAgICAgIHRoaXMubWVzc2FnZSA9IG9wdF9tZXNzYWdlO1xuICAgICB9XG4gICB9XG59O1xuXG4vKiogQG92ZXJyaWRlICovXG5DYW5jZWxsYWJsZVByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnY2FuY2VsJztcblxuZXhwb3J0IHtDYW5jZWxsYWJsZVByb21pc2V9O1xuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsbGFibGVQcm9taXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBpc0RlZiwgaXNEZWZBbmROb3ROdWxsIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuaW1wb3J0IHsgQ2FuY2VsbGFibGVQcm9taXNlIGFzIFByb21pc2UgfSBmcm9tICdtZXRhbC1wcm9taXNlJztcblxuY2xhc3MgQWpheCB7XG5cblx0LyoqXG5cdCAqIFhtbEh0dHBSZXF1ZXN0J3MgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgbWV0aG9kIHJldHVybnMgYSBzdHJpbmcgb2Zcblx0ICogcmVzcG9uc2UgaGVhZGVycyBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdCBkZXNjcmliZWQgb24gdGhlIHNwZWM6XG5cdCAqIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jdGhlLWdldGFsbHJlc3BvbnNlaGVhZGVycy1tZXRob2R9LlxuXHQgKiBUaGlzIG1ldGhvZCBwYXJzZXMgdGhhdCBzdHJpbmcgaW50byBhIHVzZXItZnJpZW5kbHkgbmFtZS92YWx1ZSBwYWlyXG5cdCAqIG9iamVjdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGFsbEhlYWRlcnMgQWxsIGhlYWRlcnMgYXMgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshQXJyYXkuPE9iamVjdDxzdHJpbmcsIHN0cmluZz4+fVxuXHQgKi9cblx0c3RhdGljIHBhcnNlUmVzcG9uc2VIZWFkZXJzKGFsbEhlYWRlcnMpIHtcblx0XHR2YXIgaGVhZGVycyA9IFtdO1xuXHRcdGlmICghYWxsSGVhZGVycykge1xuXHRcdFx0cmV0dXJuIGhlYWRlcnM7XG5cdFx0fVxuXHRcdHZhciBwYWlycyA9IGFsbEhlYWRlcnMuc3BsaXQoJ1xcdTAwMGRcXHUwMDBhJyk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGluZGV4ID0gcGFpcnNbaV0uaW5kZXhPZignXFx1MDAzYVxcdTAwMjAnKTtcblx0XHRcdGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0dmFyIG5hbWUgPSBwYWlyc1tpXS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYWlyc1tpXS5zdWJzdHJpbmcoaW5kZXggKyAyKTtcblx0XHRcdFx0aGVhZGVycy5wdXNoKHtcblx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGhlYWRlcnM7XG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgdGhlIHVybCB1c2luZyBYTUxIdHRwUmVxdWVzdC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB1cmxcblx0ICogQHBhcmFtIHshc3RyaW5nfSBtZXRob2Rcblx0ICogQHBhcmFtIHs/c3RyaW5nfSBib2R5XG5cdCAqIEBwYXJhbSB7TXVsdGlNYXA9fSBvcHRfaGVhZGVyc1xuXHQgKiBAcGFyYW0ge011bHRpTWFwPX0gb3B0X3BhcmFtc1xuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF90aW1lb3V0XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zeW5jXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF93aXRoQ3JlZGVudGlhbHNcblx0ICogQHJldHVybiB7UHJvbWlzZX0gRGVmZXJyZWQgYWpheCByZXF1ZXN0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzdGF0aWMgcmVxdWVzdCh1cmwsIG1ldGhvZCwgYm9keSwgb3B0X2hlYWRlcnMsIG9wdF9wYXJhbXMsIG9wdF90aW1lb3V0LCBvcHRfc3luYywgb3B0X3dpdGhDcmVkZW50aWFscykge1xuXHRcdHVybCA9IHVybCB8fCAnJztcblx0XHRtZXRob2QgPSBtZXRob2QgfHwgJ0dFVCc7XG5cblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5cdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcblx0XHRcdFx0XHRyZXF1ZXN0Lm9uZXJyb3IoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzb2x2ZShyZXF1ZXN0KTtcblx0XHRcdH07XG5cdFx0XHRyZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCdSZXF1ZXN0IGVycm9yJyk7XG5cdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fTtcblx0XHR9KS50aGVuQ2F0Y2goZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0XHRyZXF1ZXN0LmFib3J0KCk7XG5cdFx0XHR0aHJvdyByZWFzb247XG5cdFx0fSkudGhlbkFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR9KTtcblxuXHRcdGlmIChvcHRfcGFyYW1zKSB7XG5cdFx0XHR1cmwgPSBuZXcgVXJpKHVybCkuYWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcChvcHRfcGFyYW1zKS50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgIW9wdF9zeW5jKTtcblxuXHRcdGlmIChvcHRfd2l0aENyZWRlbnRpYWxzKSB7XG5cdFx0XHRyZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdF9oZWFkZXJzKSB7XG5cdFx0XHRvcHRfaGVhZGVycy5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRyZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIobmFtZSwgb3B0X2hlYWRlcnMuZ2V0QWxsKG5hbWUpLmpvaW4oJywgJykpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmVxdWVzdC5zZW5kKGlzRGVmKGJvZHkpID8gYm9keSA6IG51bGwpO1xuXG5cdFx0aWYgKGlzRGVmQW5kTm90TnVsbChvcHRfdGltZW91dCkpIHtcblx0XHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0cHJvbWlzZS5jYW5jZWwoJ1JlcXVlc3QgdGltZW91dCcpO1xuXHRcdFx0fSwgb3B0X3RpbWVvdXQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcm9taXNlO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWpheDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQcm92aWRlcyBhIGNvbnZlbmllbnQgaW50ZXJmYWNlIGZvciBkYXRhIHRyYW5zcG9ydC5cbiAqIEBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgVHJhbnNwb3J0IHtcblxuXHQvKipcblx0ICogU2VuZHMgYSBtZXNzYWdlIGZvciB0aGUgc3BlY2lmaWVkIGNsaWVudC5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdFxuXHQgKiBAcmV0dXJuIHshUHJvbWlzZX0gRGVmZXJyZWQgcmVxdWVzdC5cblx0ICovXG5cdHNlbmQoKSB7fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zcG9ydDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsaWVudCBtZXNzYWdlIChlLmcuIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlKS5cbiAqL1xuY2xhc3MgQ2xpZW50TWVzc2FnZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuaGVhZGVyc18gPSBuZXcgTXVsdGlNYXAoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlcXVlc3QgYm9keS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X2JvZHkgUmVxdWVzdCBib2R5IHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgYm9keSB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHJlcXVlc3QgYm9keSBpZiBubyBib2R5IHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlXG5cdCAqICAgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0Ym9keShvcHRfYm9keSkge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9ib2R5KSkge1xuXHRcdFx0dGhpcy5ib2R5XyA9IG9wdF9ib2R5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmJvZHlfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBoZWFkZXIuIElmIGEgaGVhZGVyIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBub3QgYmVcblx0ICogb3ZlcndyaXR0ZW4sIGJ1dCB0aGUgbmV3IHZhbHVlIHdpbGwgYmUgc3RvcmVkIGFzIHdlbGwuIFRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRoZWFkZXIobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuXHRcdH1cblx0XHR0aGlzLmhlYWRlcnNfLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IGhlYWRlcnMuXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXB8T2JqZWN0PX0gb3B0X2hlYWRlcnMgUmVxdWVzdCBoZWFkZXJzIGxpc3QgdG9cblx0ICogICBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGhlYWRlcnMgd2lsbFxuXHQgKiAgIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB8Q2xpZW50TWVzc2FnZX0gUmV0dXJucyBtYXAgb2YgcmVxdWVzdCBoZWFkZXJzXG5cdCAqICAgaWYgbm8gbmV3IHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0aGVhZGVycyhvcHRfaGVhZGVycykge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9oZWFkZXJzKSkge1xuXHRcdFx0aWYgKG9wdF9oZWFkZXJzIGluc3RhbmNlb2YgTXVsdGlNYXApIHtcblx0XHRcdFx0dGhpcy5oZWFkZXJzXyA9IG9wdF9oZWFkZXJzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5oZWFkZXJzXy52YWx1ZXMgPSBvcHRfaGVhZGVycztcblx0XHRcdH1cblx0XHRcdHJldHVybiBvcHRfaGVhZGVycztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuaGVhZGVyc187XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgYm9keS5cblx0ICovXG5cdHJlbW92ZUJvZHkoKSB7XG5cdFx0dGhpcy5ib2R5XyA9IHVuZGVmaW5lZDtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRNZXNzYWdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IENsaWVudE1lc3NhZ2UgZnJvbSAnLi9DbGllbnRNZXNzYWdlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xpZW50IHJlc3BvbnNlIG9iamVjdC5cbiAqIEBleHRlbmRzIHtDbGllbnRNZXNzYWdlfVxuICovXG5jbGFzcyBDbGllbnRSZXNwb25zZSBleHRlbmRzIENsaWVudE1lc3NhZ2Uge1xuXHRjb25zdHJ1Y3RvcihjbGllbnRSZXF1ZXN0KSB7XG5cdFx0c3VwZXIoKTtcblx0XHRpZiAoIWNsaWVudFJlcXVlc3QpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjcmVhdGUgcmVzcG9uc2Ugd2l0aG91dCByZXF1ZXN0Jyk7XG5cdFx0fVxuXHRcdHRoaXMuY2xpZW50UmVxdWVzdF8gPSBjbGllbnRSZXF1ZXN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgcmVxdWVzdCB0aGF0IGNyZWF0ZWQgdGhpcyByZXNwb25zZS5cblx0ICogQHJldHVybiB7IUNsaWVudFJlcXVlc3R9XG5cdCAqL1xuXHRyZXF1ZXN0KCkge1xuXHRcdHJldHVybiB0aGlzLmNsaWVudFJlcXVlc3RfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3N0YXR1c0NvZGUgUmVxdWVzdCBzdGF0dXMgY29kZSB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgc3RhdHVzIGNvZGUgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8bnVtYmVyfSBSZXR1cm5zIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlmIG5vIG5ldyB2YWx1ZSB3YXNcblx0ICogICBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0c3RhdHVzQ29kZShvcHRfc3RhdHVzQ29kZSkge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9zdGF0dXNDb2RlKSkge1xuXHRcdFx0dGhpcy5zdGF0dXNDb2RlXyA9IG9wdF9zdGF0dXNDb2RlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnN0YXR1c0NvZGVfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVzcG9uc2Ugc3RhdHVzIHRleHQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3N0YXR1c1RleHQgUmVxdWVzdCBzdGF0dXMgdGV4dCB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgc3RhdHVzIHRleHQgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8bnVtYmVyfSBSZXR1cm5zIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGlmIG5vIG5ldyB2YWx1ZSB3YXNcblx0ICogICBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0c3RhdHVzVGV4dChvcHRfc3RhdHVzVGV4dCkge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9zdGF0dXNUZXh0KSkge1xuXHRcdFx0dGhpcy5zdGF0dXNUZXh0XyA9IG9wdF9zdGF0dXNUZXh0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnN0YXR1c1RleHRfO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiByZXNwb25zZSBzdWNjZWVkZWQuIEFueSBzdGF0dXMgY29kZSAyeHggb3IgM3h4IGlzIGNvbnNpZGVyZWQgdmFsaWQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdWNjZWVkZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdHVzQ29kZSgpID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUoKSA8PSAzOTk7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRSZXNwb25zZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFqYXggZnJvbSAnbWV0YWwtYWpheCc7XG5pbXBvcnQgVHJhbnNwb3J0IGZyb20gJy4uL1RyYW5zcG9ydCc7XG5pbXBvcnQgQ2xpZW50UmVzcG9uc2UgZnJvbSAnLi4vQ2xpZW50UmVzcG9uc2UnO1xuXG4vKipcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhbiBhamF4IHRyYW5zcG9ydCB0byBiZSB1c2VkIHdpdGgge0BsaW5rIFdlRGVwbG95fS5cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnR9XG4gKi9cbmNsYXNzIEFqYXhUcmFuc3BvcnQgZXh0ZW5kcyBUcmFuc3BvcnQge1xuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdHNlbmQoY2xpZW50UmVxdWVzdCkge1xuXHRcdHZhciBkZWZlcnJlZCA9IEFqYXgucmVxdWVzdChcblx0XHRcdGNsaWVudFJlcXVlc3QudXJsKCksIGNsaWVudFJlcXVlc3QubWV0aG9kKCksIGNsaWVudFJlcXVlc3QuYm9keSgpLFxuXHRcdFx0Y2xpZW50UmVxdWVzdC5oZWFkZXJzKCksIGNsaWVudFJlcXVlc3QucGFyYW1zKCksIG51bGwsIGZhbHNlLCBjbGllbnRSZXF1ZXN0LndpdGhDcmVkZW50aWFscygpKTtcblxuXHRcdHJldHVybiBkZWZlcnJlZC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cdFx0XHR2YXIgY2xpZW50UmVzcG9uc2UgPSBuZXcgQ2xpZW50UmVzcG9uc2UoY2xpZW50UmVxdWVzdCk7XG5cdFx0XHRjbGllbnRSZXNwb25zZS5ib2R5KHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRjbGllbnRSZXNwb25zZS5zdGF0dXNDb2RlKHJlc3BvbnNlLnN0YXR1cyk7XG5cdFx0XHRjbGllbnRSZXNwb25zZS5zdGF0dXNUZXh0KHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuXHRcdFx0QWpheC5wYXJzZVJlc3BvbnNlSGVhZGVycyhyZXNwb25zZS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcblx0XHRcdFx0Y2xpZW50UmVzcG9uc2UuaGVhZGVyKGhlYWRlci5uYW1lLCBoZWFkZXIudmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gY2xpZW50UmVzcG9uc2U7XG5cdFx0fSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWpheFRyYW5zcG9ydDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFqYXhUcmFuc3BvcnQgZnJvbSAnLi9icm93c2VyL0FqYXhUcmFuc3BvcnQnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgZmFjdG9yeSBmb3IgZGF0YSB0cmFuc3BvcnQuXG4gKi9cbmNsYXNzIFRyYW5zcG9ydEZhY3Rvcnkge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLnRyYW5zcG9ydHMgPSB7fTtcblx0XHR0aGlzLnRyYW5zcG9ydHNbVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FXSA9IFRyYW5zcG9ydEZhY3RvcnlbVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHtAbGluayBUcmFuc3BvcnRGYWN0b3J5fSBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBpbnN0YW5jZSgpIHtcblx0XHRpZiAoIVRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2VfKSB7XG5cdFx0XHRUcmFuc3BvcnRGYWN0b3J5Lmluc3RhbmNlXyA9IG5ldyBUcmFuc3BvcnRGYWN0b3J5KCk7XG5cdFx0fVxuXHRcdHJldHVybiBUcmFuc3BvcnRGYWN0b3J5Lmluc3RhbmNlXztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFuIGluc3RhbmNlIG9mIHRoZSB0cmFuc3BvcnQgaW1wbGVtZW50YXRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGltcGxlbWVudGF0aW9uTmFtZVxuXHQgKiBAcmV0dXJuIHshVHJhbnNwb3J0fVxuXHQgKi9cblx0Z2V0KGltcGxlbWVudGF0aW9uTmFtZSkge1xuXHRcdHZhciBUcmFuc3BvcnRDbGFzcyA9IHRoaXMudHJhbnNwb3J0c1tpbXBsZW1lbnRhdGlvbk5hbWVdO1xuXG5cdFx0aWYgKCFUcmFuc3BvcnRDbGFzcykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zcG9ydCBuYW1lOiAnICsgaW1wbGVtZW50YXRpb25OYW1lKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIG5ldyAoVHJhbnNwb3J0Q2xhc3MpKCk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY3JlYXRlIHRyYW5zcG9ydCcsIGVycik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcmV0dXJuIHshVHJhbnNwb3J0fVxuXHQgKi9cblx0Z2V0RGVmYXVsdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXQoVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FKTtcblx0fVxufVxuXG5UcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUUgPSAnZGVmYXVsdCc7XG5cblRyYW5zcG9ydEZhY3RvcnlbVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FXSA9IEFqYXhUcmFuc3BvcnQ7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zcG9ydEZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgQ2xpZW50TWVzc2FnZSBmcm9tICcuL0NsaWVudE1lc3NhZ2UnO1xuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tICdtZXRhbC1zdHJ1Y3RzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xpZW50IHJlcXVlc3Qgb2JqZWN0LlxuICogQGV4dGVuZHMge0NsaWVudE1lc3NhZ2V9XG4gKi9cbmNsYXNzIENsaWVudFJlcXVlc3QgZXh0ZW5kcyBDbGllbnRNZXNzYWdlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnBhcmFtc18gPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR0aGlzLndpdGhDcmVkZW50aWFsc18gPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3Igd2l0aCBjcmVkZW50aWFscyBvcHRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF93aXRoQ3JlZGVudGlhbHNcblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdHdpdGhDcmVkZW50aWFscyhvcHRfd2l0aENyZWRlbnRpYWxzKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X3dpdGhDcmVkZW50aWFscykpIHtcblx0XHRcdHRoaXMud2l0aENyZWRlbnRpYWxzXyA9ICEhb3B0X3dpdGhDcmVkZW50aWFscztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy53aXRoQ3JlZGVudGlhbHNfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCBtZXRob2QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21ldGhvZCBSZXF1ZXN0IG1ldGhvZCB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgbWV0aG9kIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfHN0cmluZ30gUmV0dXJucyByZXF1ZXN0IG1ldGhvZCBpZiBubyBuZXcgdmFsdWUgd2FzXG5cdCAqICAgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdG1ldGhvZChvcHRfbWV0aG9kKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYob3B0X21ldGhvZCkpIHtcblx0XHRcdHRoaXMubWV0aG9kXyA9IG9wdF9tZXRob2Q7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMubWV0aG9kXyB8fCBDbGllbnRSZXF1ZXN0LkRFRkFVTFRfTUVUSE9EO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBxdWVyeS4gSWYgYSBxdWVyeSB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90XG5cdCAqIGJlIG92ZXJ3cml0dGVuLCBidXQgbmV3IHZhbHVlIHdpbGwgYmUgc3RvcmVkIGFzIHdlbGwuIFRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwYXJhbShuYW1lLCB2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG5cdFx0fVxuXHRcdHRoaXMucGFyYW1zXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCBxdWVyeXN0cmluZy5cblx0ICogQHBhcmFtIHtNdWx0aU1hcHxPYmplY3Q9fSBvcHRfcGFyYW1zIFJlcXVlc3QgcXVlcnlzdHJpbmcgbWFwIHRvIGJlIHNldC5cblx0ICogICBJZiBub25lIGlzIGdpdmVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwYXJhbXMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IU11bHRpTWFwfENsaWVudE1lc3NhZ2V9IFJldHVybnMgbWFwIG9mIHJlcXVlc3QgcXVlcnlzdHJpbmcgaWZcblx0ICogICBubyBuZXcgdmFsdWUgd2FzIGdpdmVuLiBPdGhlcndpc2UgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9XG5cdCAqICAgb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqL1xuXHRwYXJhbXMob3B0X3BhcmFtcykge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9wYXJhbXMpKSB7XG5cdFx0XHRpZiAob3B0X3BhcmFtcyBpbnN0YW5jZW9mIE11bHRpTWFwKSB7XG5cdFx0XHRcdHRoaXMucGFyYW1zXyA9IG9wdF9wYXJhbXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBhcmFtc18udmFsdWVzID0gb3B0X3BhcmFtcztcblx0XHRcdH1cblx0XHRcdHJldHVybiBvcHRfcGFyYW1zO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJhbXNfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3VybCBSZXF1ZXN0IHVybCB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHVybCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50TWVzc2FnZXxzdHJpbmd9IFJldHVybnMgcmVxdWVzdCB1cmwgaWYgbm8gbmV3IHZhbHVlIHdhcyBnaXZlbi5cblx0ICogICBPdGhlcndpc2UgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGUgQ2hhaW5hYmxlIHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG5cdCAqL1xuXHR1cmwob3B0X3VybCkge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF91cmwpKSB7XG5cdFx0XHR0aGlzLnVybF8gPSBvcHRfdXJsO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnVybF87XG5cdH1cblxufVxuXG5DbGllbnRSZXF1ZXN0LkRFRkFVTFRfTUVUSE9EID0gJ0dFVCc7XG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudFJlcXVlc3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEF1dGggZnJvbSAnLi9hdXRoL0F1dGgnO1xuaW1wb3J0IEF1dGhBcGlIZWxwZXIgZnJvbSAnLi9hdXRoL0F1dGhBcGlIZWxwZXInO1xuaW1wb3J0IERhdGFBcGlIZWxwZXIgZnJvbSAnLi9kYXRhL0RhdGFBcGlIZWxwZXInO1xuaW1wb3J0IEJhc2U2NCBmcm9tICcuLi9jcnlwdC9CYXNlNjQnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4uL2FwaS1xdWVyeS9FbWJvZGllZCc7XG5pbXBvcnQgUXVlcnkgZnJvbSAnLi4vYXBpLXF1ZXJ5L1F1ZXJ5JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vYXBpLXF1ZXJ5L0ZpbHRlcic7XG5pbXBvcnQgVHJhbnNwb3J0RmFjdG9yeSBmcm9tICcuL1RyYW5zcG9ydEZhY3RvcnknO1xuaW1wb3J0IENsaWVudFJlcXVlc3QgZnJvbSAnLi9DbGllbnRSZXF1ZXN0JztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5pbXBvcnQgeyBhc3NlcnRVcmlXaXRoTm9QYXRoIH0gZnJvbSAnLi9hc3NlcnRpb25zJztcblxuXG52YXIgaW87XG5cbi8vIE9wdGltaXN0aWMgaW5pdGlhbGl6YXRpb24gb2YgYGlvYCByZWZlcmVuY2UgZnJvbSBnbG9iYWwgYGdsb2JhbHMud2luZG93LmlvYC5cbmlmICh0eXBlb2YgZ2xvYmFscy53aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdGlvID0gZ2xvYmFscy53aW5kb3cuaW87XG59XG5cbi8qKlxuICogVGhlIG1haW4gY2xhc3MgZm9yIG1ha2luZyBhcGkgcmVxdWVzdHMuIFNlbmRpbmcgcmVxdWVzdHMgcmV0dXJucyBhIHByb21pc2VcbiAqIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgcmVzcG9uc2UgYXJyaXZlcy4gVXNhZ2UgZXhhbXBsZTpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIFdlRGVwbG95XG4gKiAgIC51cmwoJy9kYXRhL3Rhc2tzJylcbiAqICAgLnBvc3Qoe2Rlc2M6ICdCdXkgbWlsa2wnfSlcbiAqICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgICAvLyBIYW5kbGUgcmVzcG9uc2UgaGVyZS5cbiAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZS5ib2R5KCkpXG4gKiAgIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIFdlRGVwbG95IHtcblx0LyoqXG5cdCAqIFdlRGVwbG95IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIHVybC5cblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IHBhdGhzIEFueSBhbW91bnQgb2YgcGF0aHMgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIGJhc2Vcblx0ICogdXJsLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHVybCwgLi4ucGF0aHMpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cywgdHJ5IGBuZXcgV2VEZXBsb3koYmFzZVVybCwgdXJsKWAnKTtcblx0XHR9XG5cblx0XHR0aGlzLmF1dGhfID0gbnVsbDtcblx0XHR0aGlzLmJvZHlfID0gbnVsbDtcblx0XHR0aGlzLnVybF8gPSBVcmkuam9pblBhdGhzKHVybCB8fCAnJywgLi4ucGF0aHMpO1xuXHRcdHRoaXMuaGVhZGVyc18gPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR0aGlzLnBhcmFtc18gPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR0aGlzLndpdGhDcmVkZW50aWFsc18gPSB0cnVlO1xuXG5cdFx0dGhpcy5oZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cdFx0dGhpcy5oZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGF0aWMgZmFjdG9yeSBmb3IgY3JlYXRpbmcgV2VEZXBsb3kgZGF0YSBmb3IgdGhlIGdpdmVuIHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZGF0YVVybCBUaGUgdXJsIHRoYXQgcG9pbnRzIHRvIHRoZSBkYXRhIHNlcnZpY2VzLlxuXHQgKiBAcmV0dXJuIEByZXR1cm4ge2RhdGF9IFdlRGVwbG95IGRhdGEgaW5zdGFuY2UuXG5cdCAqL1xuXHRzdGF0aWMgZGF0YShvcHRfZGF0YVVybCkge1xuXHRcdGFzc2VydFVyaVdpdGhOb1BhdGgob3B0X2RhdGFVcmwsICdUaGUgZGF0YSB1cmwgc2hvdWxkIG5vdCBoYXZlIGEgcGF0aCcpO1xuXG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcob3B0X2RhdGFVcmwpKSB7XG5cdFx0XHRXZURlcGxveS5kYXRhVXJsXyA9IG9wdF9kYXRhVXJsO1xuXHRcdH1cblxuXHRcdGxldCBkYXRhID0gbmV3IERhdGFBcGlIZWxwZXIoV2VEZXBsb3kpO1xuXG5cdFx0ZGF0YS5hdXRoKFdlRGVwbG95LmF1dGgoKS5jdXJyZW50VXNlcik7XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGF1dGhvcml6YXRpb24gaW5mb3JtYXRpb24gdG8gdGhpcyByZXF1ZXN0LlxuXHQgKiBAcGFyYW0geyFBdXRofHN0cmluZ30gYXV0aE9yVG9rZW5PckVtYWlsIEVpdGhlciBhbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2UsXG5cdCAqIGFuIGF1dGhvcml6YXRpb24gdG9rZW4sIG9yIHRoZSBlbWFpbC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcGFzc3dvcmQgSWYgYSBlbWFpbCBpcyBnaXZlbiBhcyB0aGUgZmlyc3QgcGFyYW0sXG5cdCAqIHRoaXMgc2hvdWxkIGJlIHRoZSBwYXNzd29yZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YXV0aChhdXRoT3JUb2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCkge1xuXHRcdHRoaXMuYXV0aF8gPSBhdXRoT3JUb2tlbk9yRW1haWw7XG5cdFx0aWYgKCEodGhpcy5hdXRoXyBpbnN0YW5jZW9mIEF1dGgpKSB7XG5cdFx0XHR0aGlzLmF1dGhfID0gQXV0aC5jcmVhdGUoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGF0aWMgZmFjdG9yeSBmb3IgY3JlYXRpbmcgV2VEZXBsb3kgYXV0aCBmb3IgdGhlIGdpdmVuIHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYXV0aFVybCBUaGUgdXJsIHRoYXQgcG9pbnRzIHRvIHRoZSBhdXRoIHNlcnZpY2UuXG5cdCAqL1xuXHRzdGF0aWMgYXV0aChvcHRfYXV0aFVybCkge1xuXHRcdGlmIChjb3JlLmlzU3RyaW5nKG9wdF9hdXRoVXJsKSkge1xuXHRcdFx0V2VEZXBsb3kuYXV0aFVybF8gPSBvcHRfYXV0aFVybDtcblx0XHR9XG5cdFx0aWYgKCFXZURlcGxveS5hdXRoXykge1xuXHRcdFx0V2VEZXBsb3kuYXV0aF8gPSBuZXcgQXV0aEFwaUhlbHBlcihXZURlcGxveSk7XG5cdFx0fVxuXHRcdHJldHVybiBXZURlcGxveS5hdXRoXztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBib2R5IHRoYXQgd2lsbCBiZSBzZW50IHdpdGggdGhpcyByZXF1ZXN0LlxuXHQgKiBAcGFyYW0geyp9IGJvZHlcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Ym9keShib2R5KSB7XG5cdFx0dGhpcy5ib2R5XyA9IGJvZHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGJvZHkgb2JqZWN0IHRvIHF1ZXJ5IHBhcmFtcy5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdCBDbGllbnQgcmVxdWVzdC5cblx0ICogQHBhcmFtIHsqfSBib2R5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGNvbnZlcnRCb2R5VG9QYXJhbXNfKGNsaWVudFJlcXVlc3QsIGJvZHkpIHtcblx0XHRpZiAoY29yZS5pc1N0cmluZyhib2R5KSkge1xuXHRcdFx0Ym9keSA9IHtcblx0XHRcdFx0Ym9keTogYm9keVxuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuXHRcdFx0Ym9keSA9IGJvZHkuYm9keSgpO1xuXHRcdH1cblx0XHRPYmplY3Qua2V5cyhib2R5IHx8IHt9KS5mb3JFYWNoKG5hbWUgPT4gY2xpZW50UmVxdWVzdC5wYXJhbShuYW1lLCBib2R5W25hbWVdKSk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBjbGllbnQgcmVxdWVzdCBhbmQgZW5jb2RlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH0gQ2xpZW50IHJlcXVlc3QuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGNyZWF0ZUNsaWVudFJlcXVlc3RfKG1ldGhvZCwgYm9keSkge1xuXHRcdGNvbnN0IGNsaWVudFJlcXVlc3QgPSBuZXcgQ2xpZW50UmVxdWVzdCgpO1xuXG5cdFx0Y2xpZW50UmVxdWVzdC5ib2R5KGJvZHkgfHwgdGhpcy5ib2R5Xyk7XG5cblx0XHRpZiAoIWNvcmUuaXNEZWZBbmROb3ROdWxsKGNsaWVudFJlcXVlc3QuYm9keSgpKSkge1xuXHRcdFx0aWYgKHRoaXMuZm9ybURhdGFfKSB7XG5cdFx0XHRcdGNsaWVudFJlcXVlc3QuYm9keSh0aGlzLmZvcm1EYXRhXyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2xpZW50UmVxdWVzdC5tZXRob2QobWV0aG9kKTtcblx0XHRjbGllbnRSZXF1ZXN0LmhlYWRlcnModGhpcy5oZWFkZXJzKCkpO1xuXHRcdGNsaWVudFJlcXVlc3QucGFyYW1zKHRoaXMucGFyYW1zKCkpO1xuXHRcdGNsaWVudFJlcXVlc3QudXJsKHRoaXMudXJsKCkpO1xuXHRcdGNsaWVudFJlcXVlc3Qud2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzXyk7XG5cblx0XHR0aGlzLmVuY29kZShjbGllbnRSZXF1ZXN0KTtcblxuXHRcdHJldHVybiBjbGllbnRSZXF1ZXN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZXMgY2xpZW50UmVzcG9uc2UgYm9keSwgcGFyc2luZyB0aGUgYm9keSBmb3IgZXhhbXBsZS5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVzcG9uc2V9IGNsaWVudFJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3QgdG8gYmVcblx0ICogZGVjb2RlZC5cblx0ICogQHJldHVybiB7IUNsaWVudFJlc3BvbnNlfSBUaGUgZGVjb2RlZCByZXNwb25zZS5cblx0ICovXG5cdGRlY29kZShjbGllbnRSZXNwb25zZSkge1xuXHRcdGlmIChXZURlcGxveS5pc0NvbnRlbnRUeXBlSnNvbihjbGllbnRSZXNwb25zZSkpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNsaWVudFJlc3BvbnNlLmJvZHkoSlNPTi5wYXJzZShjbGllbnRSZXNwb25zZS5ib2R5KCkpKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge31cblx0XHR9XG5cdFx0cmV0dXJuIGNsaWVudFJlc3BvbnNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgREVMRVRFIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0ZGVsZXRlKG9wdF9ib2R5KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdERUxFVEUnLCBvcHRfYm9keSk7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlcyB0aGUgZ2l2ZW4ge0BsaW5rIENsaWVudFJlcXVlc3R9LCBjb252ZXJ0aW5nIGl0cyBib2R5IHRvIGFuXG5cdCAqIGFwcHJvcHJpYXRlIGZvcm1hdCBmb3IgZXhhbXBsZS5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdCBUaGUgcmVxdWVzdCBvYmplY3QgdG8gZW5jb2RlLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH0gVGhlIGVuY29kZWQgcmVxdWVzdC5cblx0ICovXG5cdGVuY29kZShjbGllbnRSZXF1ZXN0KSB7XG5cdFx0bGV0IGJvZHkgPSBjbGllbnRSZXF1ZXN0LmJvZHkoKTtcblxuXHRcdGlmIChjb3JlLmlzRWxlbWVudChib2R5KSkge1xuXHRcdFx0Ym9keSA9IG5ldyBGb3JtRGF0YShib2R5KTtcblx0XHRcdGNsaWVudFJlcXVlc3QuYm9keShib2R5KTtcblx0XHR9XG5cblx0XHRib2R5ID0gdGhpcy5tYXliZVdyYXBXaXRoUXVlcnlfKGJvZHkpO1xuXHRcdGlmIChjbGllbnRSZXF1ZXN0Lm1ldGhvZCgpID09PSAnR0VUJykge1xuXHRcdFx0dGhpcy5jb252ZXJ0Qm9keVRvUGFyYW1zXyhjbGllbnRSZXF1ZXN0LCBib2R5KTtcblx0XHRcdGNsaWVudFJlcXVlc3QucmVtb3ZlQm9keSgpO1xuXHRcdFx0Ym9keSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmhlYWRlcnMoKS5yZW1vdmUoJ2NvbnRlbnQtdHlwZScpO1xuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEVtYm9kaWVkKSB7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmJvZHkoYm9keS50b1N0cmluZygpKTtcblx0XHR9IGVsc2UgaWYgKFdlRGVwbG95LmlzQ29udGVudFR5cGVKc29uKGNsaWVudFJlcXVlc3QpKSB7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmJvZHkoSlNPTi5zdHJpbmdpZnkoY2xpZW50UmVxdWVzdC5ib2R5KCkpKTtcblx0XHR9XG5cblx0XHR0aGlzLmVuY29kZVBhcmFtc18oY2xpZW50UmVxdWVzdCk7XG5cdFx0dGhpcy5yZXNvbHZlQXV0aGVudGljYXRpb25fKGNsaWVudFJlcXVlc3QpO1xuXG5cdFx0cmV0dXJuIGNsaWVudFJlcXVlc3Q7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlcyB0aGUgcGFyYW1zIGZvciB0aGUgZ2l2ZW4gcmVxdWVzdCwgYWNjb3JkaW5nIHRvIHRoZWlyIHR5cGVzLlxuXHQgKiBAcGFyYW0geyFDbGllbnRSZXF1ZXN0fSBjbGllbnRSZXF1ZXN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGVuY29kZVBhcmFtc18oY2xpZW50UmVxdWVzdCkge1xuXHRcdGxldCBwYXJhbXMgPSBjbGllbnRSZXF1ZXN0LnBhcmFtcygpO1xuXHRcdHBhcmFtcy5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0bGV0IHZhbHVlcyA9IHBhcmFtcy5nZXRBbGwobmFtZSk7XG5cdFx0XHR2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRW1ib2RpZWQpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY29yZS5pc09iamVjdCh2YWx1ZSkgfHwgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGtleS92YWx1ZSBwYWlyIHRvIGJlIHNlbnQgdmlhIHRoZSBib2R5IGluIGEgYG11bHRpcGFydC9mb3JtLWRhdGFgIGZvcm1hdC5cblx0ICogSWYgdGhlIGJvZHkgaXMgc2V0IGJ5IG90aGVyIG1lYW5zIChmb3IgZXhhbXBsZSwgdGhyb3VnaCB0aGUgYGJvZHlgIG1ldGhvZCksIHRoaXNcblx0ICogd2lsbCBiZSBpZ25vcmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGZvcm0obmFtZSwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIEZvcm1EYXRhID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdmb3JtKCkgaXMgb25seSBhdmFpbGFibGUgd2hlbiBGb3JtRGF0YSBBUEkgaXMgYXZhaWxhYmxlLicpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5mb3JtRGF0YV8pIHtcblx0XHRcdHRoaXMuZm9ybURhdGFfID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0fVxuXHRcdHRoaXMuZm9ybURhdGFfLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBHRVQgaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfcGFyYW1zIFBhcmFtcyB0byBiZSBhZGRlZCB0byB0aGUgcmVxdWVzdCB1cmwuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRnZXQob3B0X3BhcmFtcykge1xuXHRcdHJldHVybiB0aGlzLnNlbmRBc3luYygnR0VUJywgb3B0X3BhcmFtcyk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGhlYWRlci4gSWYgdGhlIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGxcblx0ICogbm90IGJlIG92ZXJ3cml0dGVuLCBidXQgbmV3IHZhbHVlIHdpbGwgYmUgc3RvcmVkLiBUaGUgb3JkZXIgaXMgcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBIZWFkZXIga2V5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIEhlYWRlciB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0aGVhZGVyKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcblx0XHR9XG5cdFx0dGhpcy5oZWFkZXJzXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhlYWRlcnMuXG5cdCAqIEByZXR1cm4geyFNdWx0aU1hcH1cblx0ICovXG5cdGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGVhZGVyc187XG5cdH1cblxuXHQvKipcblx0ICogV3JhcHMgdGhlIGdpdmVuIGBFbWJvZGllZGAgaW5zdGFuY2Ugd2l0aCBhIHtAbGluayBRdWVyeX0gaW5zdGFuY2UgaWYgbmVlZGVkLlxuXHQgKiBAcGFyYW0ge0VtYm9kaWVkfSBlbWJvZGllZFxuXHQgKiBAcmV0dXJuIHtFbWJvZGllZH1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0bWF5YmVXcmFwV2l0aFF1ZXJ5XyhlbWJvZGllZCkge1xuXHRcdGlmIChlbWJvZGllZCBpbnN0YW5jZW9mIEZpbHRlcikge1xuXHRcdFx0ZW1ib2RpZWQgPSBRdWVyeS5maWx0ZXIoZW1ib2RpZWQpO1xuXHRcdH1cblx0XHRyZXR1cm4gZW1ib2RpZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHF1ZXJ5LiBJZiB0aGUgcXVlcnkgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIG5vdFxuXHQgKiBiZSBvdmVyd3JpdHRlbiwgYnV0IG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZC4gVGhlIG9yZGVyIGlzIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgUGFyYW0ga2V5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFBhcmFtIHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwYXJhbShuYW1lLCB2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG5cdFx0fVxuXHRcdHRoaXMucGFyYW1zXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHF1ZXJ5IHN0cmluZ3MgbWFwLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB9XG5cdCAqL1xuXHRwYXJhbXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyYW1zXztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIFBBVENIIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0cGF0Y2gob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BBVENIJywgb3B0X2JvZHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIHVybCByZXN1bHRpbmcgaW4gdGhlXG5cdCAqIHVuaW9uIG9mIHRoZSBjdXJyZW50IHVybCB3aXRoIHRoZSBnaXZlbiBwYXRocy5cblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IHBhdGhzIEFueSBudW1iZXIgb2YgcGF0aHMuXG5cdCAqIEByZXR1cm4geyFXZURlcGxveX0gQSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIGdpdmVuIHBhdGhzLlxuXHQgKi9cblx0cGF0aCguLi5wYXRocykge1xuXHRcdGxldCB3ZWRlcGxveUNsaWVudCA9IG5ldyBXZURlcGxveSh0aGlzLnVybCgpLCAuLi5wYXRocyk7XG5cblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5hdXRoXykpIHtcblx0XHRcdHdlZGVwbG95Q2xpZW50LmF1dGgodGhpcy5hdXRoXyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHdlZGVwbG95Q2xpZW50LnVzZSh0aGlzLmN1c3RvbVRyYW5zcG9ydF8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgUE9TVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2JvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHBvc3Qob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BPU1QnLCBvcHRfYm9keSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBQVVQgaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9ib2R5IENvbnRlbnQgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRwdXQob3B0X2JvZHkpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BVVCcsIG9wdF9ib2R5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBhdXRoZW50aWNhdGlvbiBpbmZvcm1hdGlvbiB0byB0aGUgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRyZXNvbHZlQXV0aGVudGljYXRpb25fKGNsaWVudFJlcXVlc3QpIHtcblx0XHRpZiAoIXRoaXMuYXV0aF8pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuYXV0aF8uaGFzVG9rZW4oKSkge1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5oZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB0aGlzLmF1dGhfLnRva2VuKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgY3JlZGVudGlhbHMgPSB0aGlzLmF1dGhfLmVtYWlsICsgJzonICsgdGhpcy5hdXRoXy5wYXNzd29yZDtcblx0XHRcdGNsaWVudFJlcXVlc3QuaGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBCYXNlNjQuZW5jb2RlU3RyaW5nKGNyZWRlbnRpYWxzKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVzZXMgdHJhbnNwb3J0IHRvIHNlbmQgcmVxdWVzdCB3aXRoIGdpdmVuIG1ldGhvZCBuYW1lIGFuZCBib2R5XG5cdCAqIGFzeW5jaHJvbm91c2x5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBIVFRQIG1ldGhvZCB0byBiZSB1c2VkIHdoZW4gc2VuZGluZyBkYXRhLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfSBEZWZlcnJlZCByZXF1ZXN0LlxuXHQgKi9cblx0c2VuZEFzeW5jKG1ldGhvZCwgYm9keSkge1xuXHRcdGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMuY3VzdG9tVHJhbnNwb3J0XyB8fCBUcmFuc3BvcnRGYWN0b3J5Lmluc3RhbmNlKCkuZ2V0RGVmYXVsdCgpO1xuXG5cdFx0Y29uc3QgY2xpZW50UmVxdWVzdCA9IHRoaXMuY3JlYXRlQ2xpZW50UmVxdWVzdF8obWV0aG9kLCBib2R5KTtcblxuXHRcdHJldHVybiB0cmFuc3BvcnQuc2VuZChjbGllbnRSZXF1ZXN0KS50aGVuKHRoaXMuZGVjb2RlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzb2NrZXQgdHJhbnNwb3J0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXQgaW1wbGVtZW50YXRpb24gb2JqZWN0LlxuXHQgKi9cblx0c3RhdGljIHNvY2tldChzb2NrZXQpIHtcblx0XHRpbyA9IHNvY2tldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGF0aWMgZmFjdG9yeSBmb3IgY3JlYXRpbmcgV2VEZXBsb3kgY2xpZW50IGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdGhhdCB0aGUgY2xpZW50IHNob3VsZCB1c2UgZm9yIHNlbmRpbmcgcmVxdWVzdHMuXG5cdCAqL1xuXHRzdGF0aWMgdXJsKHVybCkge1xuXHRcdHJldHVybiBuZXcgV2VEZXBsb3kodXJsKS51c2UodGhpcy5jdXN0b21UcmFuc3BvcnRfKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBVUkwgdXNlZCBieSB0aGlzIGNsaWVudC5cblx0ICovXG5cdHVybCgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmxfO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyB7QGxpbmsgVHJhbnNwb3J0fSBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHBhcmFtIHshVHJhbnNwb3J0fSB0cmFuc3BvcnQgVGhlIHRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbiB0aGF0IHNob3VsZCBiZVxuXHQgKiB1c2VkLlxuXHQgKi9cblx0dXNlKHRyYW5zcG9ydCkge1xuXHRcdHRoaXMuY3VzdG9tVHJhbnNwb3J0XyA9IHRyYW5zcG9ydDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIG5ldyBzb2NrZXQuaW8gaW5zdGFuY2UuIFRoZSBwYXJhbWV0ZXJzIHBhc3NlZCB0byBzb2NrZXQuaW9cblx0ICogY29uc3RydWN0b3Igd2lsbCBiZSBwcm92aWRlZDpcblx0ICpcblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiBXZURlcGxveS51cmwoJ2h0dHA6Ly9kb21haW46ODA4MC9wYXRoL2EnKS53YXRjaCh7aWQ6ICdteUlkJ30sIHtmb286IHRydWV9KTtcblx0ICogLy8gRXF1YWxzOlxuXHQgKiBpbygnZG9tYWluOjgwODAvP3VybD1wYXRoJTJGYSUzRmlkJTNEbXlJZCcsIHtmb286IHRydWV9KTtcblx0ICogYGBgXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3BhcmFtcyBQYXJhbXMgdG8gYmUgc2VudCB3aXRoIHRoZSBTb2NrZXQgSU8gcmVxdWVzdC5cblx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb3B0aW9ucyBPYmplY3Qgd2l0aCBTb2NrZXQgSU8gb3B0aW9ucy5cblx0ICogQHJldHVybiB7IWlvfSBTb2NrZXQgSU8gcmVmZXJlbmNlLiBTZXJ2ZXIgZXZlbnRzIGNhbiBiZSBsaXN0ZW5lZCBvbiBpdC5cblx0ICovXG5cdHdhdGNoKG9wdF9wYXJhbXMsIG9wdF9vcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBpbyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignU29ja2V0LmlvIGNsaWVudCBub3QgbG9hZGVkJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY2xpZW50UmVxdWVzdCA9IHRoaXMuY3JlYXRlQ2xpZW50UmVxdWVzdF8oJ0dFVCcsIG9wdF9wYXJhbXMpO1xuXHRcdGNvbnN0IHVyaSA9IG5ldyBVcmkoY2xpZW50UmVxdWVzdC51cmwoKSk7XG5cdFx0dXJpLmFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAoY2xpZW50UmVxdWVzdC5wYXJhbXMoKSk7XG5cblx0XHRvcHRfb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHtcblx0XHRcdGZvcmNlTmV3OiB0cnVlXG5cdFx0fTtcblx0XHRvcHRfb3B0aW9ucy5xdWVyeSA9ICd1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1cmkuZ2V0UGF0aG5hbWUoKSArIHVyaS5nZXRTZWFyY2goKSk7XG5cdFx0b3B0X29wdGlvbnMucGF0aCA9IG9wdF9vcHRpb25zLnBhdGggfHwgdXJpLmdldFBhdGhuYW1lKCk7XG5cblx0XHRyZXR1cm4gaW8odXJpLmdldEhvc3QoKSwgb3B0X29wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X3dpdGhDcmVkZW50aWFsc1xuXHQgKi9cblx0d2l0aENyZWRlbnRpYWxzKHdpdGhDcmVkZW50aWFscykge1xuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzXyA9ICEhd2l0aENyZWRlbnRpYWxzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbldlRGVwbG95LmlzQ29udGVudFR5cGVKc29uID0gZnVuY3Rpb24oY2xpZW50TWVzc2FnZSkge1xuXHRjb25zdCBjb250ZW50VHlwZSA9IGNsaWVudE1lc3NhZ2UuaGVhZGVycygpLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG5cdHJldHVybiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPT09IDA7XG59O1xuXG5XZURlcGxveS5hdXRoXyA9IG51bGw7XG5XZURlcGxveS5hdXRoVXJsXyA9ICcnO1xuV2VEZXBsb3kuZGF0YV8gPSBudWxsO1xuV2VEZXBsb3kuZGF0YVVybF8gPSAnJztcblxuZXhwb3J0IGRlZmF1bHQgV2VEZXBsb3k7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uL2FwaS1xdWVyeS9GaWx0ZXInO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9hcGktcXVlcnkvR2VvJztcbmltcG9ydCBXZURlcGxveSBmcm9tICcuLi9hcGkvV2VEZXBsb3knO1xuaW1wb3J0IFF1ZXJ5IGZyb20gJy4uL2FwaS1xdWVyeS9RdWVyeSc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vYXBpLXF1ZXJ5L1JhbmdlJztcblxuZ2xvYmFscy53aW5kb3cuRmlsdGVyID0gRmlsdGVyO1xuZ2xvYmFscy53aW5kb3cuR2VvID0gR2VvO1xuZ2xvYmFscy53aW5kb3cuUXVlcnkgPSBRdWVyeTtcbmdsb2JhbHMud2luZG93LlJhbmdlID0gUmFuZ2U7XG5nbG9iYWxzLndpbmRvdy5XZURlcGxveSA9IFdlRGVwbG95O1xuXG5leHBvcnQgeyBGaWx0ZXIsIEdlbywgUXVlcnksIFJhbmdlLCBXZURlcGxveSB9O1xuZXhwb3J0IGRlZmF1bHQgV2VEZXBsb3k7XG4iXX0=
