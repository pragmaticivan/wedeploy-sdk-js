(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.io = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var parser = _dereq_('socket.io-parser');
var Manager = _dereq_('./manager');
var debug = _dereq_('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_('./manager');
exports.Socket = _dereq_('./socket');

},{"./manager":2,"./socket":4,"./url":5,"debug":14,"socket.io-parser":40}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var eio = _dereq_('engine.io-client');
var Socket = _dereq_('./socket');
var Emitter = _dereq_('component-emitter');
var parser = _dereq_('socket.io-parser');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:manager');
var indexOf = _dereq_('indexof');
var Backoff = _dereq_('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function(){
  this.lastPing = new Date;
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function(){
  this.emitAll('pong', new Date - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function(){
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  debug('cleanup');

  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' == this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":3,"./socket":4,"backo2":8,"component-bind":11,"component-emitter":12,"debug":14,"engine.io-client":16,"indexof":32,"socket.io-parser":40}],3:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],4:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_('socket.io-parser');
var Emitter = _dereq_('component-emitter');
var toArray = _dereq_('to-array');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:socket');
var hasBin = _dereq_('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function(compress){
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":3,"component-bind":11,"component-emitter":12,"debug":14,"has-binary":30,"socket.io-parser":40,"to-array":43}],5:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_('parseuri');
var debug = _dereq_('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"debug":14,"parseuri":38}],6:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],7:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],8:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],9:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();

},{}],10:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],11:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],12:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],13:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],14:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":15}],15:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":35}],16:[function(_dereq_,module,exports){

module.exports =  _dereq_('./lib/');

},{"./lib/":17}],17:[function(_dereq_,module,exports){

module.exports = _dereq_('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_('engine.io-parser');

},{"./socket":18,"engine.io-parser":27}],18:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_('./transports');
var Emitter = _dereq_('component-emitter');
var debug = _dereq_('debug')('engine.io-client:socket');
var index = _dereq_('indexof');
var parser = _dereq_('engine.io-parser');
var parseuri = _dereq_('parseuri');
var parsejson = _dereq_('parsejson');
var parseqs = _dereq_('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

  // other options for Node.js client
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }
  }

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_('./transport');
Socket.transports = _dereq_('./transports');
Socket.parser = _dereq_('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function(){
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if('function' == typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' == typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./transport":19,"./transports":20,"component-emitter":26,"debug":14,"engine.io-parser":27,"indexof":32,"parsejson":36,"parseqs":37,"parseuri":38}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_('engine.io-parser');
var Emitter = _dereq_('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":26,"engine.io-parser":27}],20:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
var XHR = _dereq_('./polling-xhr');
var JSONP = _dereq_('./polling-jsonp');
var websocket = _dereq_('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling-jsonp":21,"./polling-xhr":22,"./websocket":24,"xmlhttprequest-ssl":25}],21:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_('./polling');
var inherit = _dereq_('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  }
  else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling":23,"component-inherit":13}],22:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
var Polling = _dereq_('./polling');
var Emitter = _dereq_('component-emitter');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./polling":23,"component-emitter":26,"component-inherit":13,"debug":14,"xmlhttprequest-ssl":25}],23:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parseqs = _dereq_('parseqs');
var parser = _dereq_('engine.io-parser');
var inherit = _dereq_('component-inherit');
var yeast = _dereq_('yeast');
var debug = _dereq_('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":19,"component-inherit":13,"debug":14,"engine.io-parser":27,"parseqs":37,"xmlhttprequest-ssl":25,"yeast":45}],24:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parser = _dereq_('engine.io-parser');
var parseqs = _dereq_('parseqs');
var inherit = _dereq_('component-inherit');
var yeast = _dereq_('yeast');
var debug = _dereq_('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  try {
    WebSocket = _dereq_('ws');
  } catch (e) { }
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'buffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function(packet) {
      parser.encodePacket(packet, self.supportsBinary, function(data) {
        if (!BrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        //Sometimes the websocket has already been closed but the browser didn't
        //have a chance of informing us about it yet, in that case send will
        //throw an error
        try {
          if (BrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e){
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done(){
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function(){
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"../transport":19,"component-inherit":13,"debug":14,"engine.io-parser":27,"parseqs":37,"ws":undefined,"yeast":45}],25:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":31}],26:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],27:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_('./keys');
var hasBinary = _dereq_('has-binary');
var sliceBuffer = _dereq_('arraybuffer.slice');
var base64encoder = _dereq_('base64-arraybuffer');
var after = _dereq_('after');
var utf8 = _dereq_('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./keys":28,"after":6,"arraybuffer.slice":7,"base64-arraybuffer":9,"blob":10,"has-binary":29,"utf8":44}],28:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],29:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"isarray":33}],30:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"isarray":33}],31:[function(_dereq_,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],32:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],33:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],34:[function(_dereq_,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],35:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],36:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],37:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],38:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],39:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_('isarray');
var isBuf = _dereq_('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{"./is-buffer":41,"isarray":33}],40:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_('debug')('socket.io-parser');
var json = _dereq_('json3');
var isArray = _dereq_('isarray');
var Emitter = _dereq_('component-emitter');
var binary = _dereq_('./binary');
var isBuf = _dereq_('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":39,"./is-buffer":41,"component-emitter":42,"debug":14,"isarray":33,"json3":34}],41:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],42:[function(_dereq_,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],43:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],44:[function(_dereq_,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {})
},{}],45:[function(_dereq_,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}]},{},[1])(1)
});

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (factory());
}(this, (function () { 'use strict';

var globals = {};

if (typeof window !== 'undefined') {
	globals.window = window;
}

if (typeof document !== 'undefined') {
	globals.document = document;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/**
 * A collection of core utility functions.
 * @const
 */

var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Loops constructor super classes collecting its properties values. If
 * property is not available on the super class `undefined` will be
 * collected as value for the class hierarchy position.
 * @param {!function()} constructor Class constructor.
 * @param {string} propertyName Property name to be collected.
 * @return {Array.<*>} Array of collected values.
 * TODO(*): Rethink superclass loop.
 */
function collectSuperClassesProperty(constructor, propertyName) {
  var propertyValues = [constructor[propertyName]];
  while (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {
    constructor = constructor.__proto__;
    propertyValues.push(constructor[propertyName]);
  }
  return propertyValues;
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = null;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (!compatibilityModeData_) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Merges the values of a export function property a class with the values of that
 * property for all its super classes, and stores it as a new static
 * property of that class. If the export function property already existed, it won't
 * be recalculated.
 * @param {!function()} constructor Class constructor.
 * @param {string} propertyName Property name to be collected.
 * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled
 *   with the values of the property for the current class and all its super classes.
 *   Should return the merged value to be stored on the current class.
 * @return {boolean} Returns true if merge happens, false otherwise.
 */
function mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (constructor.hasOwnProperty(mergedName)) {
    return false;
  }

  var merged = collectSuperClassesProperty(constructor, propertyName);
  if (opt_mergeFn) {
    merged = opt_mergeFn(merged);
  }
  constructor[mergedName] = merged;
  return true;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}



var core$2 = Object.freeze({
	UID_PROPERTY: UID_PROPERTY,
	abstractMethod: abstractMethod,
	collectSuperClassesProperty: collectSuperClassesProperty,
	disableCompatibilityMode: disableCompatibilityMode,
	enableCompatibilityMode: enableCompatibilityMode,
	getCompatibilityModeData: getCompatibilityModeData,
	getFunctionName: getFunctionName,
	getUid: getUid,
	identityFunction: identityFunction,
	isBoolean: isBoolean,
	isDef: isDef,
	isDefAndNotNull: isDefAndNotNull,
	isDocument: isDocument,
	isElement: isElement,
	isFunction: isFunction,
	isNull: isNull,
	isNumber: isNumber,
	isWindow: isWindow,
	isObject: isObject,
	isPromise: isPromise,
	isString: isString,
	mergeSuperClassesProperty: mergeSuperClassesProperty,
	nullFunction: nullFunction
});

// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

var array = function () {
	function array() {
		classCallCheck(this, array);
	}

	createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = isDef(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);
	return array;
}();

/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */

var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

var Disposable = function () {
	function Disposable() {
		classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);
	return Disposable;
}();

var object = function () {
	function object() {
		classCallCheck(this, object);
	}

	createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key, source;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);
	return object;
}();

var string = function () {
	function string() {
		classCallCheck(this, string);
	}

	createClass(string, null, [{
		key: 'collapseBreakingSpaces',

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);
	return string;
}();

/**
 * Class responsible for storing an object that will be printed as JSON
 * when the `toString` method is called.
 */

var Embodied = function () {
	/**
  * Constructs a Embodied instance.
  * @constructor
  */
	function Embodied() {
		classCallCheck(this, Embodied);

		this.body_ = {};
	}

	/**
  * Gets the json object that represents this instance.
  * @return {!Object}
  */


	createClass(Embodied, [{
		key: 'body',
		value: function body() {
			return this.body_;
		}

		/**
   * If the given object is an instance of Embodied, this will
   * return its body content. Otherwise this will return the
   * original object.
   * @param {*} obj
   * @return {*}
   * @static
   */

	}, {
		key: 'toString',


		/**
   * Gets the json string that represents this instance.
   * @return {string}
   */
		value: function toString() {
			return JSON.stringify(this.body());
		}
	}], [{
		key: 'toBody',
		value: function toBody(obj) {
			return obj instanceof Embodied ? obj.body() : obj;
		}
	}]);
	return Embodied;
}();

/**
 * Class responsible for storing and handling the body contents
 * of a Filter instance.
 */

var FilterBody = function () {
	/**
  * Constructs a {@link FilterBody} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
	function FilterBody(field, operatorOrValue, opt_value) {
		classCallCheck(this, FilterBody);

		var obj = {
			operator: isDef(opt_value) ? operatorOrValue : '='
		};

		var value = isDef(opt_value) ? opt_value : operatorOrValue;

		if (isDefAndNotNull(value)) {
			if (value instanceof Embodied) {
				value = value.body();
			}
			obj.value = value;
		}

		if (isDefAndNotNull(field)) {
			this.createBody_(field, obj);
		} else {
			this.createBody_('and', []);
		}
	}

	/**
  * Composes the current filter with the given operator.
  * @param {string} operator
  * @param {Filter=} opt_filter Another filter to compose this filter with,
  *   if the operator is not unary.
  */


	createClass(FilterBody, [{
		key: 'add',
		value: function add(operator, opt_filter) {
			if (opt_filter) {
				this.addArrayOperator_(operator, opt_filter);
			} else {
				this.createBody_(operator, this.body_);
			}
		}

		/**
   * Composes the current filter with an operator that stores its values in an array.
   * @param {string} operator
   * @param {!Filter} filter
   * @protected
   */

	}, {
		key: 'addArrayOperator_',
		value: function addArrayOperator_(operator, filter) {
			if (!(this.body_[operator] instanceof Array)) {
				this.createBody_(operator, [this.body_]);
			}
			this.body_[operator].push(filter.body());
		}

		/**
   * Adds filters to be composed with this filter body using the given operator.
   * @param {string} operator
   * @param {...*} filters A variable amount of filters to be composed.
   */

	}, {
		key: 'addMany',
		value: function addMany(operator) {
			for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				filters[_key - 1] = arguments[_key];
			}

			for (var i = 0; i < filters.length; i++) {
				this.add(operator, filters[i]);
			}
		}

		/**
   * Creates a new body object, setting the requestd key to the given value.
   * @param {string} key The key to set in the new body object
   * @param {*} value The value the requested key should have in the new body object.
   * @protected
   */

	}, {
		key: 'createBody_',
		value: function createBody_(key, value) {
			this.body_ = {};
			this.body_[key] = value;
		}

		/**
   * Gets the json object that represents this filter's body.
   * @return {!Object}
   */

	}, {
		key: 'getObject',
		value: function getObject() {
			return this.body_;
		}
	}]);
	return FilterBody;
}();

/**
 * Class responsible for building different types of geometric
 * shapes.
 */

var Geo = function () {
	function Geo() {
		classCallCheck(this, Geo);
	}

	createClass(Geo, null, [{
		key: 'boundingBox',

		/**
   * Creates a new {@link BoundingBox} instance.
   * @param {*} upperLeft The upper left point.
   * @param {*} lowerRight The lower right point.
   * @return {!BoundingBox}
   * @static
   */
		value: function boundingBox(upperLeft, lowerRight) {
			return new Geo.BoundingBox(upperLeft, lowerRight);
		}

		/**
   * Creates a new {@link Circle} instance.
   * @param {*} center The circle's center coordinate.
   * @param {string} radius The circle's radius.
   * @return {!Circle}
   * @static
   */

	}, {
		key: 'circle',
		value: function circle(center, radius) {
			return new Geo.Circle(center, radius);
		}

		/**
   * Creates a new {@link Line} instance.
   * @param {...*} points This line's points.
   * @return {!Line}
   * @static
   */

	}, {
		key: 'line',
		value: function line() {
			for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
				points[_key] = arguments[_key];
			}

			return new (Function.prototype.bind.apply(Geo.Line, [null].concat(points)))();
		}

		/**
   * Creates a new {@link Point} instance.
   * @param {number} lat The latitude coordinate
   * @param {number} lon The longitude coordinate
   * @return {!Point}
   * @static
   */

	}, {
		key: 'point',
		value: function point(lat, lon) {
			return new Geo.Point(lat, lon);
		}

		/**
   * Creates a new {@link Polygon} instance.
   * @param {...*} points This polygon's points.
   * @return {!Polygon}
   * @static
   */

	}, {
		key: 'polygon',
		value: function polygon() {
			for (var _len2 = arguments.length, points = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				points[_key2] = arguments[_key2];
			}

			return new (Function.prototype.bind.apply(Geo.Polygon, [null].concat(points)))();
		}
	}]);
	return Geo;
}();

/**
 * Class that represents a point coordinate.
 * @extends {Embodied}
 */


var Point = function (_Embodied) {
	inherits(Point, _Embodied);

	/**
  * Constructs a {@link Point} instance.
  * @param {number} lat The latitude coordinate
  * @param {number} lon The longitude coordinate
  * @constructor
  */
	function Point(lat, lon) {
		classCallCheck(this, Point);

		var _this = possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this));

		_this.body_ = [lat, lon];
		return _this;
	}

	return Point;
}(Embodied);

Geo.Point = Point;

/**
 * Class that represents a line.
 * @extends {Embodied}
 */

var Line = function (_Embodied2) {
	inherits(Line, _Embodied2);

	/**
  * Constructs a {@link Line} instance.
  * @param {...*} points This line's points.
  * @constructor
  */
	function Line() {
		classCallCheck(this, Line);

		var _this2 = possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this));

		for (var _len3 = arguments.length, points = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
			points[_key3] = arguments[_key3];
		}

		_this2.body_ = {
			type: 'linestring',
			coordinates: points.map(function (point) {
				return Embodied.toBody(point);
			})
		};
		return _this2;
	}

	return Line;
}(Embodied);

Geo.Line = Line;

/**
 * Class that represents a bounding box.
 * @extends {Embodied}
 */

var BoundingBox = function (_Embodied3) {
	inherits(BoundingBox, _Embodied3);

	/**
  * Constructs a {@link BoundingBox} instance.
  * @param {*} upperLeft The upper left point.
  * @param {*} lowerRight The lower right point.
  * @constructor
  */
	function BoundingBox(upperLeft, lowerRight) {
		classCallCheck(this, BoundingBox);

		var _this3 = possibleConstructorReturn(this, (BoundingBox.__proto__ || Object.getPrototypeOf(BoundingBox)).call(this));

		_this3.body_ = {
			type: 'envelope',
			coordinates: [Embodied.toBody(upperLeft), Embodied.toBody(lowerRight)]
		};
		return _this3;
	}

	/**
  * Gets this bounding box's points.
  * @return {!Array}
  */


	createClass(BoundingBox, [{
		key: 'getPoints',
		value: function getPoints() {
			return this.body_.coordinates;
		}
	}]);
	return BoundingBox;
}(Embodied);

Geo.BoundingBox = BoundingBox;

/**
 * Class that represents a circle.
 * @extends {Embodied}
 */

var Circle = function (_Embodied4) {
	inherits(Circle, _Embodied4);

	/**
  * Constructs a {@link Circle} instance.
  * @param {*} center The circle's center coordinate.
  * @param {string} radius The circle's radius.
  * @constructor
  */
	function Circle(center, radius) {
		classCallCheck(this, Circle);

		var _this4 = possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this));

		_this4.body_ = {
			type: 'circle',
			coordinates: Embodied.toBody(center),
			radius: radius
		};
		return _this4;
	}

	/**
  * Gets this circle's center coordinate.
  * @return {*}
  */


	createClass(Circle, [{
		key: 'getCenter',
		value: function getCenter() {
			return this.body_.coordinates;
		}

		/**
   * Gets this circle's radius.
   * @return {string}
   */

	}, {
		key: 'getRadius',
		value: function getRadius() {
			return this.body_.radius;
		}
	}]);
	return Circle;
}(Embodied);

Geo.Circle = Circle;

/**
 * Class that represents a polygon.
 * @extends {Embodied}
 */

var Polygon = function (_Embodied5) {
	inherits(Polygon, _Embodied5);

	/**
  * Constructs a {@link Polygon} instance.
  * @param {...*} points This polygon's points.
  * @constructor
  */
	function Polygon() {
		classCallCheck(this, Polygon);

		var _this5 = possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this));

		_this5.body_ = {
			type: 'polygon',
			coordinates: []
		};
		_this5.addCoordinates_.apply(_this5, arguments);
		return _this5;
	}

	/**
  * Adds the given points as coordinates for this polygon.
  * @param {...*} points
  * @protected
  */


	createClass(Polygon, [{
		key: 'addCoordinates_',
		value: function addCoordinates_() {
			for (var _len4 = arguments.length, points = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
				points[_key4] = arguments[_key4];
			}

			this.body_.coordinates.push(points.map(function (point) {
				return Embodied.toBody(point);
			}));
		}

		/**
   * Adds the given points as a hole inside this polygon.
   * @param  {...*} points
   * @chainnable
   */

	}, {
		key: 'hole',
		value: function hole() {
			this.addCoordinates_.apply(this, arguments);
			return this;
		}
	}]);
	return Polygon;
}(Embodied);

Geo.Polygon = Polygon;

/**
 * Class responsible for building range objects to be used by `Filter`.
 * @extends {Embodied}
 */

var Range = function (_Embodied) {
	inherits(Range, _Embodied);

	/**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @param {*} opt_to
  * @constructor
  */
	function Range(from, opt_to) {
		classCallCheck(this, Range);

		var _this = possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this));

		if (isDefAndNotNull(from)) {
			_this.body_.from = from;
		}
		if (isDefAndNotNull(opt_to)) {
			_this.body_.to = opt_to;
		}
		return _this;
	}

	/**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @return {!Range}
  * @static
  */


	createClass(Range, null, [{
		key: 'from',
		value: function from(_from) {
			return new Range(_from);
		}

		/**
   * Constructs a {@link Range} instance.
   * @param {*} from
   * @param {*} to
   * @return {!Range}
   * @static
   */

	}, {
		key: 'range',
		value: function range(from, to) {
			return new Range(from, to);
		}

		/**
   * Constructs a {@link Range} instance.
   * @param {*} to
   * @return {!Range}
   * @static
   */

	}, {
		key: 'to',
		value: function to(_to) {
			return new Range(null, _to);
		}
	}]);
	return Range;
}(Embodied);

/**
 * Class responsible for building filters.
 * @extends {Embodied}
 */

var Filter = function (_Embodied) {
	inherits(Filter, _Embodied);

	/**
  * Constructs a {@link Filter} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
	function Filter(field, operatorOrValue, opt_value) {
		classCallCheck(this, Filter);

		var _this = possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).call(this));

		_this.body_ = new FilterBody(field, operatorOrValue, opt_value);
		return _this;
	}

	/**
  * Adds a filter to be composed with this filter using the given operator.
  * @param {string} operator
  * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
  *   name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @chainnable
  */


	createClass(Filter, [{
		key: 'add',
		value: function add(operator, fieldOrFilter, opt_operatorOrValue, opt_value) {
			var filter = fieldOrFilter ? Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) : null;
			this.body_.add(operator, filter);
			return this;
		}

		/**
   * Adds filters to be composed with this filter using the given operator.
   * @param {string} operator
   * @param {...*} filters A variable amount of filters to be composed.
   * @chainnable
   */

	}, {
		key: 'addMany',
		value: function addMany(operator) {
			var _body_;

			for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				filters[_key - 1] = arguments[_key];
			}

			(_body_ = this.body_).addMany.apply(_body_, [operator].concat(filters));
			return this;
		}

		/**
   * Adds a filter to be composed with this filter using the "and" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */

	}, {
		key: 'and',
		value: function and(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return this.add('and', fieldOrFilter, opt_operatorOrValue, opt_value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "any" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} values A variable amount of values to be used with
   *   the "none" operator. Can be passed either as a single array or as
   *   separate params.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'body',


		/**
   * Gets the json object that represents this filter.
   * @return {!Object}
   */
		value: function body() {
			return this.body_.getObject();
		}

		/**
   * Returns a {@link Filter} instance that uses the "gd" operator.
   * @param {string} field The field's name.
   * @param {*} locationOrCircle Either a `Geo.Circle` instance or a coordinate.
   * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
   *   the distance value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'or',


		/**
   * Adds a filter to be composed with this filter using the "or" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   * the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */
		value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return this.add('or', fieldOrFilter, opt_operatorOrValue, opt_value);
		}

		/**
   * Converts the given arguments into a {@link Filter} instance.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   * the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @return {!Filter}
   */

	}], [{
		key: 'any',
		value: function any(field) {
			var values = Array.prototype.slice.call(arguments, 1);
			if (values.length === 1 && values[0] instanceof Array) {
				values = values[0];
			}
			return new Filter(field, 'any', values);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gp" operator.
   * This is a special use case of `Filter.polygon` for bounding
   * boxes.
   * @param {string} field The field's name.
   * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or
   *   a bounding box's upper left coordinate.
   * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'boundingBox',
		value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
			if (boxOrUpperLeft instanceof Geo.BoundingBox) {
				return Filter.polygon.apply(Filter, [field].concat(toConsumableArray(boxOrUpperLeft.getPoints())));
			} else {
				return Filter.polygon(field, boxOrUpperLeft, opt_lowerRight);
			}
		}
	}, {
		key: 'distance',
		value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
			var location = locationOrCircle;
			var range = opt_rangeOrDistance;
			if (locationOrCircle instanceof Geo.Circle) {
				location = locationOrCircle.getCenter();
				range = Range.to(locationOrCircle.getRadius());
			} else if (!(opt_rangeOrDistance instanceof Range)) {
				range = Range.to(opt_rangeOrDistance);
			}
			return Filter.distanceInternal_(field, location, range);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gd" operator. This
   * is just an internal helper used by `Filter.distance`.
   * @param {string} field The field's name.
   * @param {*} location A location coordinate.
   * @param {Range} range A `Range` instance.
   * @return {!Filter}
   * @protected
   * @static
   */

	}, {
		key: 'distanceInternal_',
		value: function distanceInternal_(field, location, range) {
			var value = {
				location: Embodied.toBody(location)
			};
			range = range.body();
			if (range.from) {
				value.min = range.from;
			}
			if (range.to) {
				value.max = range.to;
			}
			return Filter.field(field, 'gd', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'equal',
		value: function equal(field, value) {
			return new Filter(field, '=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "exists" operator.
   * @param {string} field The field's name.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'exists',
		value: function exists(field) {
			return Filter.field(field, 'exists', null);
		}

		/**
   * Returns a {@link Filter} instance that uses the "fuzzy" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
   *   be the query, otherwise it should be the fuzziness value.
   * @param {number=} opt_fuzziness The fuzziness value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'fuzzy',
		value: function fuzzy(fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
			return Filter.fuzzyInternal_('fuzzy', fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness);
		}

		/**
   * Returns a {@link Filter} instance that uses the given fuzzy operator. This
   * is an internal implementation used by the `Filter.fuzzy` method.
   * @param {string} operator The fuzzy operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
   *   be the query, otherwise it should be the fuzziness value.
   * @param {number=} opt_fuzziness The fuzziness value.
   * @return {!Filter}
   * @protected
   * @static
   */

	}, {
		key: 'fuzzyInternal_',
		value: function fuzzyInternal_(operator, fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
			var arg2IsString = isString(opt_queryOrFuzziness);

			var value = {
				query: arg2IsString ? opt_queryOrFuzziness : fieldOrQuery
			};
			var fuzziness = arg2IsString ? opt_fuzziness : opt_queryOrFuzziness;
			if (fuzziness) {
				value.fuzziness = fuzziness;
			}

			var field = arg2IsString ? fieldOrQuery : Filter.ALL;
			return Filter.field(field, operator, value);
		}

		/**
   * Returns a {@link Filter} instance that uses the ">" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'gt',
		value: function gt(field, value) {
			return new Filter(field, '>', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the ">=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'gte',
		value: function gte(field, value) {
			return new Filter(field, '>=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "match" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'match',
		value: function match(fieldOrQuery, opt_query) {
			var field = isString(opt_query) ? fieldOrQuery : Filter.ALL;
			var query = isString(opt_query) ? opt_query : fieldOrQuery;
			return Filter.field(field, 'match', query);
		}

		/**
   * Returns a {@link Filter} instance that uses the "missing" operator.
   * @param {string} field The field's name.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'missing',
		value: function missing(field) {
			return Filter.field(field, 'missing', null);
		}

		/**
   * Returns a {@link Filter} instance that uses the "phrase" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'phrase',
		value: function phrase(fieldOrQuery, opt_query) {
			var field = isString(opt_query) ? fieldOrQuery : Filter.ALL;
			var query = isString(opt_query) ? opt_query : fieldOrQuery;
			return Filter.field(field, 'phrase', query);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gp" operator.
   * @param {string} field The name of the field.
   * @param {...!Object} points Objects representing points in the polygon.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'polygon',
		value: function polygon(field) {
			for (var _len2 = arguments.length, points = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				points[_key2 - 1] = arguments[_key2];
			}

			points = points.map(function (point) {
				return Embodied.toBody(point);
			});
			return Filter.field(field, 'gp', points);
		}

		/**
   * Returns a {@link Filter} instance that uses the "prefix" operator.
   * @param {string} fieldOrQuery If no second argument is given, this should
   *   be the query string, in which case all fields will be matched. Otherwise,
   *   this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'prefix',
		value: function prefix(fieldOrQuery, opt_query) {
			var field = opt_query ? fieldOrQuery : Filter.ALL;
			var query = opt_query ? opt_query : fieldOrQuery;
			return Filter.field(field, 'prefix', query);
		}

		/**
   * Returns a {@link Filter} instance that uses the "range" operator.
   * @param {string} field The field's name.
   * @param {*} rangeOrMin Either a `Range` instance or a the range's min value.
   * @param {*=} opt_max The range's max value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'range',
		value: function range(field, rangeOrMin, opt_max) {
			var range = rangeOrMin;
			if (!(range instanceof Range)) {
				range = Range.range(rangeOrMin, opt_max);
			}
			return Filter.field(field, 'range', range);
		}

		/**
   * Returns a {@link Filter} instance that uses the "~" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'regex',
		value: function regex(field, value) {
			return new Filter(field, '~', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "gs" operator.
   * @param {string} field The field's name.
   * @param {...!Object} shapes Objects representing shapes.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'shape',
		value: function shape(field) {
			for (var _len3 = arguments.length, shapes = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
				shapes[_key3 - 1] = arguments[_key3];
			}

			shapes = shapes.map(function (shape) {
				return Embodied.toBody(shape);
			});
			var value = {
				type: 'geometrycollection',
				geometries: shapes
			};
			return Filter.field(field, 'gs', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "similar" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   *   should be the query string, in which case all fields will be matched.
   *   Otherwise, this should be the name of the field to match.
   * @param {?string} query The query string.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'similar',
		value: function similar(fieldOrQuery, query) {
			var field = isString(query) ? fieldOrQuery : Filter.ALL;
			var value = {
				query: isString(query) ? query : fieldOrQuery
			};
			return Filter.field(field, 'similar', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "<" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lt',
		value: function lt(field, value) {
			return new Filter(field, '<', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "<=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lte',
		value: function lte(field, value) {
			return new Filter(field, '<=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "none" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} value A variable amount of values to be used with
   * the "none" operator. Can be passed either as a single array or as
   * separate params.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'none',
		value: function none(field) {
			var values = Array.prototype.slice.call(arguments, 1);
			if (values.length === 1 && values[0] instanceof Array) {
				values = values[0];
			}
			return new Filter(field, 'none', values);
		}

		/**
   * Returns a {@link Filter} instance that uses the "!=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'notEqual',
		value: function notEqual(field, value) {
			return new Filter(field, '!=', value);
		}

		/**
   * Returns a {@link Filter} instance that uses the "not" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   * the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'not',
		value: function not(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value).add('not');
		}

		/**
   * Returns a {@link Filter} instance.
   * @param {string} field The name of the field to filter by.
   * @param {*} operatorOrValue If a third param is given, this should be the
   * filter's operator (like ">="). Otherwise, this will be used as the
   * filter's value, and the filter's operator will be "=".
   * @param {*=} opt_value The filter's value.
   * @return {!Filter}
   * @static
   */

	}, {
		key: 'field',
		value: function field(_field, operatorOrValue, opt_value) {
			return new Filter(_field, operatorOrValue, opt_value);
		}
	}, {
		key: 'toFilter',
		value: function toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) {
			var filter = fieldOrFilter;
			if (!(filter instanceof Filter)) {
				filter = Filter.field(fieldOrFilter, opt_operatorOrValue, opt_value);
			}
			return filter;
		}
	}]);
	return Filter;
}(Embodied);

/**
 * String constant that represents all fields.
 * @type {string}
 * @static
 */


Filter.ALL = '*';

/**
 * Parses the given uri string into an object.
 * @param {*=} opt_uri Optional string URI to parse
 */

function parseFromAnchor(opt_uri) {
	var link = document.createElement('a');
	link.href = opt_uri;
	return {
		hash: link.hash,
		hostname: link.hostname,
		password: link.password,
		pathname: link.pathname[0] === '/' ? link.pathname : '/' + link.pathname,
		port: link.port,
		protocol: link.protocol,
		search: link.search,
		username: link.username
	};
}

/**
 * Parses the given uri string into an object. The URL function will be used
 * when present, otherwise we'll fall back to the anchor node element.
 * @param {*=} opt_uri Optional string URI to parse
 */
function parse(opt_uri) {
	if (isFunction(URL) && URL.length) {
		return new URL(opt_uri);
	} else {
		return parseFromAnchor(opt_uri);
	}
}

/**
 * A cached reference to the create function.
 */
var create$1 = Object.create;

/**
 * Case insensitive string Multimap implementation. Allows multiple values for
 * the same key name.
 * @extends {Disposable}
 */

var MultiMap = function (_Disposable) {
	inherits(MultiMap, _Disposable);

	function MultiMap() {
		classCallCheck(this, MultiMap);

		var _this = possibleConstructorReturn(this, (MultiMap.__proto__ || Object.getPrototypeOf(MultiMap)).call(this));

		_this.keys = create$1(null);
		_this.values = create$1(null);
		return _this;
	}

	/**
  * Adds value to a key name.
  * @param {string} name
  * @param {*} value
  * @chainable
  */


	createClass(MultiMap, [{
		key: 'add',
		value: function add(name, value) {
			this.keys[name.toLowerCase()] = name;
			this.values[name.toLowerCase()] = this.values[name.toLowerCase()] || [];
			this.values[name.toLowerCase()].push(value);
			return this;
		}

		/**
   * Clears map names and values.
   * @chainable
   */

	}, {
		key: 'clear',
		value: function clear() {
			this.keys = create$1(null);
			this.values = create$1(null);
			return this;
		}

		/**
   * Checks if map contains a value to the key name.
   * @param {string} name
   * @return {boolean}
   * @chainable
   */

	}, {
		key: 'contains',
		value: function contains(name) {
			return name.toLowerCase() in this.values;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.values = null;
		}

		/**
   * Creates a `MultiMap` instance from the given object.
   * @param {!Object} obj
   * @return {!MultiMap}
   */

	}, {
		key: 'get',


		/**
   * Gets the first added value from a key name.
   * @param {string} name
   * @return {*}
   * @chainable
   */
		value: function get(name) {
			var values = this.values[name.toLowerCase()];
			if (values) {
				return values[0];
			}
		}

		/**
   * Gets all values from a key name.
   * @param {string} name
   * @return {Array.<*>}
   */

	}, {
		key: 'getAll',
		value: function getAll(name) {
			return this.values[name.toLowerCase()];
		}

		/**
   * Returns true if the map is empty, false otherwise.
   * @return {boolean}
   */

	}, {
		key: 'isEmpty',
		value: function isEmpty() {
			return this.size() === 0;
		}

		/**
   * Gets array of key names.
   * @return {Array.<string>}
   */

	}, {
		key: 'names',
		value: function names() {
			var _this2 = this;

			return Object.keys(this.values).map(function (key) {
				return _this2.keys[key];
			});
		}

		/**
   * Removes all values from a key name.
   * @param {string} name
   * @chainable
   */

	}, {
		key: 'remove',
		value: function remove(name) {
			delete this.keys[name.toLowerCase()];
			delete this.values[name.toLowerCase()];
			return this;
		}

		/**
   * Sets the value of a key name. Relevant to replace the current values with
   * a new one.
   * @param {string} name
   * @param {*} value
   * @chainable
   */

	}, {
		key: 'set',
		value: function set(name, value) {
			this.keys[name.toLowerCase()] = name;
			this.values[name.toLowerCase()] = [value];
			return this;
		}

		/**
   * Gets the size of the map key names.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			return this.names().length;
		}

		/**
   * Returns the parsed values as a string.
   * @return {string}
   */

	}, {
		key: 'toString',
		value: function toString() {
			return JSON.stringify(this.values);
		}
	}], [{
		key: 'fromObject',
		value: function fromObject(obj) {
			var map = new MultiMap();
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				map.set(keys[i], obj[keys[i]]);
			}
			return map;
		}
	}]);
	return MultiMap;
}(Disposable);

/**
 * Generic tree node data structure with arbitrary number of child nodes.
 * @param {V} value Value.
 * @constructor
 */

var TreeNode = function () {
	function TreeNode(value) {
		classCallCheck(this, TreeNode);

		/**
   * The value.
   * @private {V}
   */
		this.value_ = value;

		/**
   * Reference to the parent node or null if it has no parent.
   * @private {TreeNode}
   */
		this.parent_ = null;

		/**
   * Child nodes or null in case of leaf node.
   * @private {Array<!TreeNode>}
   */
		this.children_ = null;
	}

	/**
  * Appends a child node to this node.
  * @param {!TreeNode} child Orphan child node.
  */


	createClass(TreeNode, [{
		key: 'addChild',
		value: function addChild(child) {
			assertChildHasNoParent(child);
			child.setParent(this);
			this.children_ = this.children_ || [];
			this.children_.push(child);
		}

		/**
   * Tells whether this node is the ancestor of the given node.
   * @param {!TreeNode} node A node.
   * @return {boolean} Whether this node is the ancestor of {@code node}.
   */

	}, {
		key: 'contains',
		value: function contains(node) {
			var current = node.getParent();
			while (current) {
				if (current === this) {
					return true;
				}
				current = current.getParent();
			}
			return false;
		}

		/**
   * @return {!Array<TreeNode>} All ancestor nodes in bottom-up order.
   */

	}, {
		key: 'getAncestors',
		value: function getAncestors() {
			var ancestors = [];
			var node = this.getParent();
			while (node) {
				ancestors.push(node);
				node = node.getParent();
			}
			return ancestors;
		}

		/**
   * Gets the child node of this node at the given index.
   * @param {number} index Child index.
   * @return {?TreeNode} The node at the given index
   * or null if not found.
   */

	}, {
		key: 'getChildAt',
		value: function getChildAt(index) {
			return this.getChildren()[index] || null;
		}

		/**
   * @return {?Array<!TreeNode>} Child nodes or null in case of leaf node.
   */

	}, {
		key: 'getChildren',
		value: function getChildren() {
			return this.children_ || TreeNode.EMPTY_ARRAY;
		}

		/**
   * @return {number} The number of children.
   */

	}, {
		key: 'getChildCount',
		value: function getChildCount() {
			return this.getChildren().length;
		}

		/**
   * @return {number} The number of ancestors of the node.
   */

	}, {
		key: 'getDepth',
		value: function getDepth() {
			var depth = 0;
			var node = this;
			while (node.getParent()) {
				depth++;
				node = node.getParent();
			}
			return depth;
		}

		/**
   * @return {?TreeNode} Parent node or null if it has no parent.
   */

	}, {
		key: 'getParent',
		value: function getParent() {
			return this.parent_;
		}

		/**
   * @return {!TreeNode} The root of the tree structure, i.e. the farthest
   * ancestor of the node or the node itself if it has no parents.
   */

	}, {
		key: 'getRoot',
		value: function getRoot() {
			var root = this;
			while (root.getParent()) {
				root = root.getParent();
			}
			return root;
		}

		/**
   * Gets the value.
   * @return {V} The value.
   */

	}, {
		key: 'getValue',
		value: function getValue() {
			return this.value_;
		}

		/**
   * @return {boolean} Whether the node is a leaf node.
   */

	}, {
		key: 'isLeaf',
		value: function isLeaf() {
			return !this.getChildCount();
		}

		/**
   * Removes the given child node of this node.
   * @param {TreeNode} child The node to remove.
   * @return {TreeNode} The removed node if any, null otherwise.
   */

	}, {
		key: 'removeChild',
		value: function removeChild(child) {
			if (array.remove(this.getChildren(), child)) {
				return child;
			}
			return null;
		}

		/**
   * Sets the parent node of this node. The callers must ensure that the
   * parent node and only that has this node among its children.
   * @param {TreeNode} parent The parent to set. If null, the node will be
   * detached from the tree.
   * @protected
   */

	}, {
		key: 'setParent',
		value: function setParent(parent) {
			this.parent_ = parent;
		}

		/**
   * Traverses the subtree. The first callback starts with this node,
   * and visits the descendant nodes depth-first, in preorder.
   * The second callback, starts with deepest child then visits
   * the ancestor nodes depth-first, in postorder. E.g.
   *
   *  	 A
   *    / \
   *   B   C
   *  /   / \
   * D   E   F
   *
   * preorder -> ['A', 'B', 'D', 'C', 'E', 'F']
   * postorder -> ['D', 'B', 'E', 'F', 'C', 'A']
   *
   * @param {function=} opt_preorderFn The callback to execute when visiting a node.
   * @param {function=} opt_postorderFn The callback to execute before leaving a node.
   */

	}, {
		key: 'traverse',
		value: function traverse(opt_preorderFn, opt_postorderFn) {
			if (opt_preorderFn) {
				opt_preorderFn(this);
			}
			this.getChildren().forEach(function (child) {
				return child.traverse(opt_preorderFn, opt_postorderFn);
			});
			if (opt_postorderFn) {
				opt_postorderFn(this);
			}
		}
	}]);
	return TreeNode;
}();

/**
 * Constant for empty array to avoid unnecessary allocations.
 * @private
 */


TreeNode.EMPTY_ARRAY = [];

/**
 * Asserts that child has no parent.
 * @param {TreeNode} child A child.
 * @private
 */
var assertChildHasNoParent = function assertChildHasNoParent(child) {
	if (child.getParent()) {
		throw new Error('Cannot add child with parent.');
	}
};

var parseFn_ = parse;

var Uri = function () {

	/**
  * This class contains setters and getters for the parts of the URI.
  * The following figure displays an example URIs and their component parts.
  *
  *                                  path
  *	                             
  *	  abc://example.com:123/path/data?key=value#fragid1
  *	                  
  * protocol  hostname  port            search    hash
  *          
  *                host
  *
  * @param {*=} opt_uri Optional string URI to parse
  * @constructor
  */
	function Uri() {
		var opt_uri = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
		classCallCheck(this, Uri);

		this.url = Uri.parse(this.maybeAddProtocolAndHostname_(opt_uri));
	}

	/**
  * Adds parameters to uri from a <code>MultiMap</code> as source.
  * @param {MultiMap} multimap The <code>MultiMap</code> containing the
  *   parameters.
  * @protected
  * @chainable
  */


	createClass(Uri, [{
		key: 'addParametersFromMultiMap',
		value: function addParametersFromMultiMap(multimap) {
			var _this = this;

			multimap.names().forEach(function (name) {
				multimap.getAll(name).forEach(function (value) {
					_this.addParameterValue(name, value);
				});
			});
			return this;
		}

		/**
   * Adds the value of the named query parameters.
   * @param {string} key The parameter to set.
   * @param {*} value The new value. Will be explicitly casted to String.
   * @chainable
   */

	}, {
		key: 'addParameterValue',
		value: function addParameterValue(name, value) {
			this.ensureQueryInitialized_();
			if (isDef(value)) {
				value = String(value);
			}
			this.query.add(name, value);
			return this;
		}

		/**
   * Adds the values of the named query parameter.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'addParameterValues',
		value: function addParameterValues(name, values) {
			var _this2 = this;

			values.forEach(function (value) {
				return _this2.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Ensures query internal map is initialized and synced with initial value
   * extracted from URI search part.
   * @protected
   */

	}, {
		key: 'ensureQueryInitialized_',
		value: function ensureQueryInitialized_() {
			var _this3 = this;

			if (this.query) {
				return;
			}
			this.query = new MultiMap();
			var search = this.url.search;
			if (search) {
				search.substring(1).split('&').forEach(function (param) {
					var _param$split = param.split('=');

					var _param$split2 = slicedToArray(_param$split, 2);

					var key = _param$split2[0];
					var value = _param$split2[1];

					if (isDef(value)) {
						value = Uri.urlDecode(value);
					}
					_this3.addParameterValue(key, value);
				});
			}
		}

		/**
   * Gets the hash part of uri.
   * @return {string}
   */

	}, {
		key: 'getHash',
		value: function getHash() {
			return this.url.hash || '';
		}

		/**
   * Gets the host part of uri. E.g. <code>[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getHost',
		value: function getHost() {
			var host = this.getHostname();
			if (host) {
				var port = this.getPort();
				if (port && port !== '80') {
					host += ':' + port;
				}
			}
			return host;
		}

		/**
   * Gets the hostname part of uri without protocol and port.
   * @return {string}
   */

	}, {
		key: 'getHostname',
		value: function getHostname() {
			var hostname = this.url.hostname;
			if (hostname === Uri.HOSTNAME_PLACEHOLDER) {
				return '';
			}
			return hostname;
		}

		/**
   * Gets the origin part of uri. E.g. <code>http://[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getOrigin',
		value: function getOrigin() {
			var host = this.getHost();
			if (host) {
				return this.getProtocol() + '//' + host;
			}
			return '';
		}

		/**
   * Returns the first value for a given parameter or undefined if the given
   * parameter name does not appear in the query string.
   * @param {string} paramName Unescaped parameter name.
   * @return {string|undefined} The first value for a given parameter or
   *   undefined if the given parameter name does not appear in the query
   *   string.
   */

	}, {
		key: 'getParameterValue',
		value: function getParameterValue(name) {
			this.ensureQueryInitialized_();
			return this.query.get(name);
		}

		/**
   * Returns the value<b>s</b> for a given parameter as a list of decoded
   * query parameter values.
   * @param {string} name The parameter to get values for.
   * @return {!Array<?>} The values for a given parameter as a list of decoded
   *   query parameter values.
   */

	}, {
		key: 'getParameterValues',
		value: function getParameterValues(name) {
			this.ensureQueryInitialized_();
			return this.query.getAll(name);
		}

		/**
   * Returns the name<b>s</b> of the parameters.
   * @return {!Array<string>} The names for the parameters as a list of
   *   strings.
   */

	}, {
		key: 'getParameterNames',
		value: function getParameterNames() {
			this.ensureQueryInitialized_();
			return this.query.names();
		}

		/**
   * Gets the function currently being used to parse URIs.
   * @return {!function()}
   */

	}, {
		key: 'getPathname',


		/**
   * Gets the pathname part of uri.
   * @return {string}
   */
		value: function getPathname() {
			return this.url.pathname;
		}

		/**
   * Gets the port number part of uri as string.
   * @return {string}
   */

	}, {
		key: 'getPort',
		value: function getPort() {
			return this.url.port;
		}

		/**
   * Gets the protocol part of uri. E.g. <code>http:</code>.
   * @return {string}
   */

	}, {
		key: 'getProtocol',
		value: function getProtocol() {
			return this.url.protocol;
		}

		/**
   * Gets the search part of uri. Search value is retrieved from query
   * parameters.
   * @return {string}
   */

	}, {
		key: 'getSearch',
		value: function getSearch() {
			var _this4 = this;

			var search = '';
			var querystring = '';
			this.getParameterNames().forEach(function (name) {
				_this4.getParameterValues(name).forEach(function (value) {
					querystring += name;
					if (isDef(value)) {
						querystring += '=' + encodeURIComponent(value);
					}
					querystring += '&';
				});
			});
			querystring = querystring.slice(0, -1);
			if (querystring) {
				search += '?' + querystring;
			}
			return search;
		}

		/**
   * Checks if uri contains the parameter.
   * @param {string} name
   * @return {boolean}
   */

	}, {
		key: 'hasParameter',
		value: function hasParameter(name) {
			this.ensureQueryInitialized_();
			return this.query.contains(name);
		}

		/**
   * Makes this URL unique by adding a random param to it. Useful for avoiding
   * cache.
   */

	}, {
		key: 'makeUnique',
		value: function makeUnique() {
			this.setParameterValue(Uri.RANDOM_PARAM, string.getRandomString());
			return this;
		}

		/**
   * Maybe adds protocol and a hostname placeholder on a parial URI if needed.
   * Relevent for compatibility with <code>URL</code> native object.
   * @param {string=} opt_uri
   * @return {string} URI with protocol and hostname placeholder.
   */

	}, {
		key: 'maybeAddProtocolAndHostname_',
		value: function maybeAddProtocolAndHostname_(opt_uri) {
			var url = opt_uri;
			if (opt_uri.indexOf('://') === -1 && opt_uri.indexOf('javascript:') !== 0) {
				// jshint ignore:line

				url = Uri.DEFAULT_PROTOCOL;
				if (opt_uri[0] !== '/' || opt_uri[1] !== '/') {
					url += '//';
				}

				switch (opt_uri.charAt(0)) {
					case '.':
					case '?':
					case '#':
						url += Uri.HOSTNAME_PLACEHOLDER;
						url += '/';
						url += opt_uri;
						break;
					case '':
					case '/':
						if (opt_uri[1] !== '/') {
							url += Uri.HOSTNAME_PLACEHOLDER;
						}
						url += opt_uri;
						break;
					default:
						url += opt_uri;
				}
			}
			return url;
		}

		/**
   * Normalizes the parsed object to be in the expected standard.
   * @param {!Object}
   */

	}, {
		key: 'removeParameter',


		/**
   * Removes the named query parameter.
   * @param {string} name The parameter to remove.
   * @chainable
   */
		value: function removeParameter(name) {
			this.ensureQueryInitialized_();
			this.query.remove(name);
			return this;
		}

		/**
   * Removes uniqueness parameter of the uri.
   * @chainable
   */

	}, {
		key: 'removeUnique',
		value: function removeUnique() {
			this.removeParameter(Uri.RANDOM_PARAM);
			return this;
		}

		/**
   * Sets the hash.
   * @param {string} hash
   * @chainable
   */

	}, {
		key: 'setHash',
		value: function setHash(hash) {
			this.url.hash = hash;
			return this;
		}

		/**
   * Sets the hostname.
   * @param {string} hostname
   * @chainable
   */

	}, {
		key: 'setHostname',
		value: function setHostname(hostname) {
			this.url.hostname = hostname;
			return this;
		}

		/**
   * Sets the value of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValue',
		value: function setParameterValue(name, value) {
			this.removeParameter(name);
			this.addParameterValue(name, value);
			return this;
		}

		/**
   * Sets the values of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValues',
		value: function setParameterValues(name, values) {
			var _this5 = this;

			this.removeParameter(name);
			values.forEach(function (value) {
				return _this5.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Sets the pathname.
   * @param {string} pathname
   * @chainable
   */

	}, {
		key: 'setPathname',
		value: function setPathname(pathname) {
			this.url.pathname = pathname;
			return this;
		}

		/**
   * Sets the port number.
   * @param {*} port Port number.
   * @chainable
   */

	}, {
		key: 'setPort',
		value: function setPort(port) {
			this.url.port = port;
			return this;
		}

		/**
   * Sets the function that will be used for parsing the original string uri
   * into an object.
   * @param {!function()} parseFn
   */

	}, {
		key: 'setProtocol',


		/**
   * Sets the protocol. If missing <code>http:</code> is used as default.
   * @param {string} protocol
   * @chainable
   */
		value: function setProtocol(protocol) {
			this.url.protocol = protocol;
			if (this.url.protocol[this.url.protocol.length - 1] !== ':') {
				this.url.protocol += ':';
			}
			return this;
		}

		/**
   * @return {string} The string form of the url.
   * @override
   */

	}, {
		key: 'toString',
		value: function toString() {
			var href = '';
			var host = this.getHost();
			if (host) {
				href += this.getProtocol() + '//';
			}
			href += host + this.getPathname() + this.getSearch() + this.getHash();
			return href;
		}

		/**
   * Joins the given paths.
   * @param {string} basePath
   * @param {...string} ...paths Any number of paths to be joined with the base url.
   * @static
   */

	}], [{
		key: 'getParseFn',
		value: function getParseFn() {
			return parseFn_;
		}
	}, {
		key: 'normalizeObject',
		value: function normalizeObject(parsed) {
			var length = parsed.pathname ? parsed.pathname.length : 0;
			if (length > 1 && parsed.pathname[length - 1] === '/') {
				parsed.pathname = parsed.pathname.substr(0, length - 1);
			}
			return parsed;
		}

		/**
   * Parses the given uri string into an object.
   * @param {*=} opt_uri Optional string URI to parse
   */

	}, {
		key: 'parse',
		value: function parse(opt_uri) {
			return Uri.normalizeObject(parseFn_(opt_uri));
		}
	}, {
		key: 'setParseFn',
		value: function setParseFn(parseFn) {
			parseFn_ = parseFn;
		}
	}, {
		key: 'joinPaths',
		value: function joinPaths(basePath) {
			for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				paths[_key - 1] = arguments[_key];
			}

			if (basePath.charAt(basePath.length - 1) === '/') {
				basePath = basePath.substring(0, basePath.length - 1);
			}
			paths = paths.map(function (path) {
				return path.charAt(0) === '/' ? path.substring(1) : path;
			});
			return [basePath].concat(paths).join('/').replace(/\/$/, '');
		}

		/**
   * URL-decodes the string. We need to specially handle '+'s because
   * the javascript library doesn't convert them to spaces.
   * @param {string} str The string to url decode.
   * @return {string} The decoded {@code str}.
   */

	}, {
		key: 'urlDecode',
		value: function urlDecode(str) {
			return decodeURIComponent(str.replace(/\+/g, ' '));
		}
	}]);
	return Uri;
}();

/**
 * Default protocol value.
 * @type {string}
 * @default http:
 * @static
 */


Uri.DEFAULT_PROTOCOL = 'http:';

/**
 * Hostname placeholder. Relevant to internal usage only.
 * @type {string}
 * @static
 */
Uri.HOSTNAME_PLACEHOLDER = 'hostname' + Date.now();

/**
 * Name used by the param generated by `makeUnique`.
 * @type {string}
 * @static
 */
Uri.RANDOM_PARAM = 'zx';

function assertBrowserEnvironment() {
	if (!globals.window) {
		throw new Error('Sign-in type not supported in this environment');
	}
}

function assertDefAndNotNull(value, errorMessage) {
	if (!isDefAndNotNull(value)) {
		throw new Error(errorMessage);
	}
}

function assertFunction(value, errorMessage) {
	if (!isFunction(value)) {
		throw new Error(errorMessage);
	}
}

function assertObject(value, errorMessage) {
	if (!isObject(value)) {
		throw new Error(errorMessage);
	}
}

function assertResponseSucceeded(response) {
	if (!response.succeeded()) {
		throw response.body();
	}
	return response;
}

function assertUserSignedIn(user) {
	if (!isDefAndNotNull(user)) {
		throw new Error('You must be signed-in to perform this operation');
	}
}

function assertUriWithNoPath(url, message) {
	var uri = new Uri(url);
	if (uri.getPathname().length > 1) {
		throw new Error(message);
	}
}

/**
 * Class responsible for storing authorization information.
 */

var Auth = function () {
	/**
  * Constructs an {@link Auth} instance.
  * @param {string} tokenOrEmail Either the authorization token, or
  *   the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @constructor
  */
	function Auth(tokenOrEmail) {
		var opt_password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
		classCallCheck(this, Auth);

		this.token = isString(opt_password) ? null : tokenOrEmail;
		this.email = isString(opt_password) ? tokenOrEmail : null;
		this.password = opt_password;

		this.createdAt = null;
		this.id = null;
		this.name = null;
		this.photoUrl = null;
		this.wedeployClient = null;
	}

	/**
  * Constructs an {@link Auth} instance.
  * @param {string} tokenOrUsername Either the authorization token, or
  *   the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @return {!Auth}
  */


	createClass(Auth, [{
		key: 'getCreatedAt',


		/**
   * Gets the created at date.
   * @return {string}
   */
		value: function getCreatedAt() {
			return this.createdAt;
		}

		/**
   * Gets the email.
   * @return {string}
   */

	}, {
		key: 'getEmail',
		value: function getEmail() {
			return this.email;
		}

		/**
   * Gets the id.
   * @return {string}
   */

	}, {
		key: 'getId',
		value: function getId() {
			return this.id;
		}

		/**
   * Gets the name.
   * @return {string}
   */

	}, {
		key: 'getName',
		value: function getName() {
			return this.name;
		}

		/**
   * Gets the password.
   * @return {string}
   */

	}, {
		key: 'getPassword',
		value: function getPassword() {
			return this.password;
		}

		/**
   * Gets the photo url.
   * @return {string}
   */

	}, {
		key: 'getPhotoUrl',
		value: function getPhotoUrl() {
			return this.photoUrl;
		}

		/**
   * Gets the token.
   * @return {string}
   */

	}, {
		key: 'getToken',
		value: function getToken() {
			return this.token;
		}

		/**
   * Checks if created at is set.
   * @return {boolean}
   */

	}, {
		key: 'hasCreatedAt',
		value: function hasCreatedAt() {
			return isDefAndNotNull(this.createdAt);
		}

		/**
   * Checks if the email is set.
   * @return {boolean}
   */

	}, {
		key: 'hasEmail',
		value: function hasEmail() {
			return isDefAndNotNull(this.email);
		}

		/**
   * Checks if the id is set.
   * @return {boolean}
   */

	}, {
		key: 'hasId',
		value: function hasId() {
			return isDefAndNotNull(this.id);
		}

		/**
   * Checks if the name is set.
   * @return {boolean}
   */

	}, {
		key: 'hasName',
		value: function hasName() {
			return isDefAndNotNull(this.name);
		}

		/**
   * Checks if the password is set.
   * @return {boolean}
   */

	}, {
		key: 'hasPassword',
		value: function hasPassword() {
			return isDefAndNotNull(this.password);
		}

		/**
   * Checks if the photo url is set.
   * @return {boolean}
   */

	}, {
		key: 'hasPhotoUrl',
		value: function hasPhotoUrl() {
			return isDefAndNotNull(this.photoUrl);
		}

		/**
   * Checks if the token is set.
   * @return {boolean}
   */

	}, {
		key: 'hasToken',
		value: function hasToken() {
			return isDefAndNotNull(this.token);
		}

		/**
   * Sets created at.
   * @param {string} createdAt
   */

	}, {
		key: 'setCreatedAt',
		value: function setCreatedAt(createdAt) {
			this.createdAt = createdAt;
		}

		/**
   * Sets the email.
   * @param {string} email
   */

	}, {
		key: 'setEmail',
		value: function setEmail(email) {
			this.email = email;
		}

		/**
   * Sets the id.
   * @param {string} id
   */

	}, {
		key: 'setId',
		value: function setId(id) {
			this.id = id;
		}

		/**
   * Sets the name.
   * @param {string} name
   */

	}, {
		key: 'setName',
		value: function setName(name) {
			this.name = name;
		}

		/**
   * Sets the password.
   * @param {string} password
   */

	}, {
		key: 'setPassword',
		value: function setPassword(password) {
			this.password = password;
		}

		/**
   * Sets the photo url.
   * @param {string} photoUrl
   */

	}, {
		key: 'setPhotoUrl',
		value: function setPhotoUrl(photoUrl) {
			this.photoUrl = photoUrl;
		}

		/**
   * Sets the token.
   * @param {string} token
   */

	}, {
		key: 'setToken',
		value: function setToken(token) {
			this.token = token;
		}
	}, {
		key: 'setWedeployClient',
		value: function setWedeployClient(wedeployClient) {
			this.wedeployClient = wedeployClient;
		}

		/**
   * Updates the user.
   * @param {!object} data
   * @return {CompletableFuture}
   */

	}, {
		key: 'updateUser',
		value: function updateUser(data) {
			assertObject(data, 'User data must be specified as object');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users').auth(this).patch(data).then(function (response) {
				return assertResponseSucceeded(response);
			});
		}

		/**
   * Deletes the current user.
   * @return {CompletableFuture}
   */

	}, {
		key: 'deleteUser',
		value: function deleteUser() {
			assertDefAndNotNull(this.id, 'Cannot delete user without id');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users', this.id).auth(this).delete().then(function (response) {
				return assertResponseSucceeded(response);
			});
		}
	}], [{
		key: 'create',
		value: function create(tokenOrUsername, opt_password) {
			return new Auth(tokenOrUsername, opt_password);
		}
	}]);
	return Auth;
}();

var ApiHelper = function () {

	/**
  * Constructs an {@link ApiHelper} instance.
  * @constructor
  */
	function ApiHelper(wedeployClient) {
		classCallCheck(this, ApiHelper);

		assertDefAndNotNull(wedeployClient, 'WeDeploy client reference must be specified');
		this.wedeployClient = wedeployClient;
	}

	/**
  * Adds authorization information to this request.
  * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
  * an authorization token, or the email.
  * @param {string=} opt_password If a email is given as the first param,
  * this should be the password.
  * @chainable
  */


	createClass(ApiHelper, [{
		key: 'auth',
		value: function auth(authOrTokenOrEmail, opt_password) {
			this.helperAuthScope = authOrTokenOrEmail;
			if (!(this.helperAuthScope instanceof Auth)) {
				this.helperAuthScope = Auth.create(authOrTokenOrEmail, opt_password);
			}
			return this;
		}
	}]);
	return ApiHelper;
}();

/**
 * Class responsible for encapsulate provider information.
 */

var AuthProvider = function () {
	/**
  * Constructs an {@link AuthProvider} instance.
  * @constructor
  */
	function AuthProvider() {
		classCallCheck(this, AuthProvider);

		this.provider = null;
		this.providerScope = null;
		this.redirectUri = null;
		this.scope = null;
	}

	/**
  * Checks if provider is defined and not null.
  * @return {boolean}
  */


	createClass(AuthProvider, [{
		key: 'hasProvider',
		value: function hasProvider() {
			return isDefAndNotNull(this.provider);
		}

		/**
   * Checks if scope is defined and not null.
   * @return {boolean}
   */

	}, {
		key: 'hasProviderScope',
		value: function hasProviderScope() {
			return isDefAndNotNull(this.providerScope);
		}

		/**
   * Checks if redirect uri is defined and not null.
   * @return {boolean}
   */

	}, {
		key: 'hasRedirectUri',
		value: function hasRedirectUri() {
			return isDefAndNotNull(this.redirectUri);
		}

		/**
   * Checks if scope is defined and not null.
   * @return {boolean}
   */

	}, {
		key: 'hasScope',
		value: function hasScope() {
			return isDefAndNotNull(this.scope);
		}

		/**
   * Makes authorization url.
   * @return {string=} Authorization url.
   */

	}, {
		key: 'makeAuthorizationUrl',
		value: function makeAuthorizationUrl(opt_authUrl) {
			var uri = new Uri(opt_authUrl);

			uri.setPathname('/oauth/authorize');

			if (this.hasProvider()) {
				uri.setParameterValue('provider', this.getProvider());
			}
			if (this.hasProviderScope()) {
				uri.setParameterValue('provider_scope', this.getProviderScope());
			}
			if (this.hasRedirectUri()) {
				uri.setParameterValue('redirect_uri', this.getRedirectUri());
			}
			if (this.hasScope()) {
				uri.setParameterValue('scope', this.getScope());
			}

			return uri.toString();
		}

		/**
   * Gets provider name.
   * @return {string=} Provider name.
   */

	}, {
		key: 'getProvider',
		value: function getProvider() {
			return this.provider;
		}

		/**
   * Gets provider scope.
   * @return {string=} String with scopes.
   */

	}, {
		key: 'getProviderScope',
		value: function getProviderScope() {
			return this.providerScope;
		}

		/**
   * Gets redirect uri.
   * @return {string=}.
   */

	}, {
		key: 'getRedirectUri',
		value: function getRedirectUri() {
			return this.redirectUri;
		}

		/**
   * Gets scope.
   * @return {string=} String with scopes.
   */

	}, {
		key: 'getScope',
		value: function getScope() {
			return this.scope;
		}

		/**
   * Sets provider scope.
   * @param {string=} scope Scope string. Separate by space for multiple
   *   scopes, e.g. "scope1 scope2".
   */

	}, {
		key: 'setProviderScope',
		value: function setProviderScope(providerScope) {
			assertStringIfDefAndNotNull(providerScope, 'Provider scope must be a string');
			this.providerScope = providerScope;
		}

		/**
   * Sets redirect uri.
   * @param {string=} redirectUri.
   */

	}, {
		key: 'setRedirectUri',
		value: function setRedirectUri(redirectUri) {
			assertStringIfDefAndNotNull(redirectUri, 'Redirect uri must be a string');
			this.redirectUri = redirectUri;
		}

		/**
   * Sets scope.
   * @param {string=} scope Scope string. Separate by space for multiple
   *   scopes, e.g. "scope1 scope2".
   */

	}, {
		key: 'setScope',
		value: function setScope(scope) {
			assertStringIfDefAndNotNull(scope, 'Scope must be a string');
			this.scope = scope;
		}
	}]);
	return AuthProvider;
}();

function assertStringIfDefAndNotNull(value, errorMessage) {
	if (isDefAndNotNull(value) && !isString(value)) {
		throw new Error(errorMessage);
	}
}

/**
 * Facebook auth provider implementation.
 */

var FacebookAuthProvider = function (_AuthProvider) {
	inherits(FacebookAuthProvider, _AuthProvider);

	/**
  * Constructs an {@link FacebookAuthProvider} instance.
  * @constructor
  */
	function FacebookAuthProvider() {
		classCallCheck(this, FacebookAuthProvider);

		var _this = possibleConstructorReturn(this, (FacebookAuthProvider.__proto__ || Object.getPrototypeOf(FacebookAuthProvider)).call(this));

		_this.provider = FacebookAuthProvider.PROVIDER;
		return _this;
	}

	return FacebookAuthProvider;
}(AuthProvider);

FacebookAuthProvider.PROVIDER = 'facebook';

/**
 * Github auth provider implementation.
 */

var GithubAuthProvider = function (_AuthProvider) {
	inherits(GithubAuthProvider, _AuthProvider);

	/**
  * Constructs an {@link GithubAuthProvider} instance.
  * @constructor
  */
	function GithubAuthProvider() {
		classCallCheck(this, GithubAuthProvider);

		var _this = possibleConstructorReturn(this, (GithubAuthProvider.__proto__ || Object.getPrototypeOf(GithubAuthProvider)).call(this));

		_this.provider = GithubAuthProvider.PROVIDER;
		return _this;
	}

	return GithubAuthProvider;
}(AuthProvider);

GithubAuthProvider.PROVIDER = 'github';

/**
 * Google auth provider implementation.
 */

var GoogleAuthProvider = function (_AuthProvider) {
	inherits(GoogleAuthProvider, _AuthProvider);

	/**
  * Constructs an {@link GoogleAuthProvider} instance.
  * @constructor
  */
	function GoogleAuthProvider() {
		classCallCheck(this, GoogleAuthProvider);

		var _this = possibleConstructorReturn(this, (GoogleAuthProvider.__proto__ || Object.getPrototypeOf(GoogleAuthProvider)).call(this));

		_this.provider = GoogleAuthProvider.PROVIDER;
		return _this;
	}

	return GoogleAuthProvider;
}(AuthProvider);

GoogleAuthProvider.PROVIDER = 'google';

/* jshint ignore:start */

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */

var StorageMechanism = function () {
	function StorageMechanism() {
		classCallCheck(this, StorageMechanism);
	}

	createClass(StorageMechanism, [{
		key: 'clear',

		/**
   * Clear all items from the data storage.
   */
		value: function clear() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Checks if this mechanism is supported in the current environment.
   * Subclasses should override this when necessary.
   */

	}, {
		key: 'keys',


		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */
		value: function keys() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			throw Error('Unimplemented abstract method');
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return true;
		}
	}]);
	return StorageMechanism;
}();

/* jshint ignore:end */

var Storage = function () {

	/**
  * Provides a convenient API for data persistence using a selected data
  * storage mechanism.
  * @param {!StorageMechanism} mechanism The underlying storage mechanism.
  * @constructor
  */
	function Storage(mechanism) {
		classCallCheck(this, Storage);

		assertMechanismDefAndNotNull(mechanism);
		assertMechanismIntanceOf(mechanism);

		/**
   * The mechanism used to persist key-value pairs.
   * @type {StorageMechanism}
   * @protected
   */
		this.mechanism = mechanism;
	}

	/**
  * Clear all items from the data storage.
  */


	createClass(Storage, [{
		key: 'clear',
		value: function clear() {
			this.mechanism.clear();
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			if (!core$2.isDef(value)) {
				this.mechanism.remove(key);
				return;
			}
			this.mechanism.set(key, JSON.stringify(value));
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			var json;
			try {
				json = this.mechanism.get(key);
			} catch (e) {
				return undefined;
			}
			if (core$2.isNull(json)) {
				return undefined;
			}
			try {
				return JSON.parse(json);
			} catch (e) {
				throw Storage.ErrorCode.INVALID_VALUE;
			}
		}

		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */

	}, {
		key: 'keys',
		value: function keys() {
			return this.mechanism.keys();
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			this.mechanism.remove(key);
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			return this.mechanism.size();
		}

		/**
   * Returns the list of values stored in the Storage object.
   * @param {!Array<string>} values
   */

	}, {
		key: 'values',
		value: function values() {
			var _this = this;

			return this.keys().map(function (key) {
				return _this.get(key);
			});
		}
	}]);
	return Storage;
}();

/**
 * Errors thrown by the storage.
 * @enum {string}
 */


Storage.ErrorCode = {
	INVALID_VALUE: 'Storage: Invalid value was encountered'
};

function assertMechanismDefAndNotNull(mechanism) {
	if (!core$2.isDefAndNotNull(mechanism)) {
		throw Error('Storage mechanism is required');
	}
}

function assertMechanismIntanceOf(mechanism) {
	if (!(mechanism instanceof StorageMechanism)) {
		throw Error('Storage mechanism must me an implementation of StorageMechanism');
	}
}

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */

var LocalStorageMechanism = function (_StorageMechanism) {
	inherits(LocalStorageMechanism, _StorageMechanism);

	function LocalStorageMechanism() {
		classCallCheck(this, LocalStorageMechanism);
		return possibleConstructorReturn(this, (LocalStorageMechanism.__proto__ || Object.getPrototypeOf(LocalStorageMechanism)).apply(this, arguments));
	}

	createClass(LocalStorageMechanism, [{
		key: 'storage',

		/**
   * Returns reference for global local storage. by default
   */
		value: function storage() {
			return LocalStorageMechanism.globals.localStorage;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'clear',
		value: function clear() {
			this.storage().clear();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'keys',
		value: function keys() {
			return Object.keys(this.storage());
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'get',
		value: function get(key) {
			return this.storage().getItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'remove',


		/**
   * @inheritDoc
   */
		value: function remove(key) {
			this.storage().removeItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			this.storage().setItem(key, value);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'size',
		value: function size() {
			return this.storage().length;
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return typeof window !== 'undefined';
		}
	}]);
	return LocalStorageMechanism;
}(StorageMechanism);

if (LocalStorageMechanism.isSupported()) {
	LocalStorageMechanism.globals = {
		localStorage: window.localStorage
	};
}

/**
 * Class responsible for encapsulate auth api calls.
 */

var AuthApiHelper = function (_ApiHelper) {
	inherits(AuthApiHelper, _ApiHelper);

	/**
  * Constructs an {@link AuthApiHelper} instance.
  * @constructor
  */
	function AuthApiHelper(wedeployClient) {
		classCallCheck(this, AuthApiHelper);

		var _this = possibleConstructorReturn(this, (AuthApiHelper.__proto__ || Object.getPrototypeOf(AuthApiHelper)).call(this, wedeployClient));

		_this.currentUser = null;
		_this.onSignInCallback = null;
		_this.onSignOutCallback = null;
		_this.storage = new Storage(new LocalStorageMechanism());

		_this.processSignIn_();

		_this.provider = {
			Facebook: FacebookAuthProvider,
			Google: GoogleAuthProvider,
			Github: GithubAuthProvider
		};
		return _this;
	}

	/**
  * Creates user.
  * @param {!object} data The data to be used to create the user.
  * @return {CancellablePromise}
  */


	createClass(AuthApiHelper, [{
		key: 'createUser',
		value: function createUser(data) {
			var _this2 = this;

			assertObject(data, 'User data must be specified as object');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users').post(data).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return _this2.makeUserAuthFromData(response.body());
			});
		}

		/**
   * Gets the current browser url without the fragment part.
   * @return {!string}
   * @protected
   */

	}, {
		key: 'getHrefWithoutFragment_',
		value: function getHrefWithoutFragment_() {
			var location = globals.window.location;
			return location.protocol + '//' + location.host + location.pathname + (location.search ? location.search : '');
		}

		/**
   * Gets the access token from the url fragment and removes it.
   * @return {?string}
   * @protected
   */

	}, {
		key: 'getRedirectAccessToken_',
		value: function getRedirectAccessToken_() {
			if (globals.window) {
				var fragment = globals.window.location.hash;
				if (fragment.indexOf('#access_token=') === 0) {
					return fragment.substring(14);
				}
			}
			return null;
		}

		/**
   * Gets user by id.
   * @param {!string} userId
   * @return {CancellablePromise}
   */

	}, {
		key: 'getUser',
		value: function getUser(userId) {
			var _this3 = this;

			assertDefAndNotNull(userId, 'User userId must be specified');
			assertUserSignedIn(this.currentUser);
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/users', userId).auth(this.resolveAuthScope().token).get().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return _this3.makeUserAuthFromData(response.body());
			});
		}

		/**
   * Loads current user. Requires a user token as argument.
   * @param {!string} token
   * @return {CancellablePromise}
   */

	}, {
		key: 'loadCurrentUser',
		value: function loadCurrentUser(token) {
			var _this4 = this;

			assertDefAndNotNull(token, 'User token must be specified');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/user').auth(token).get().then(function (response) {
				var data = response.body();
				data.token = token;
				_this4.currentUser = _this4.makeUserAuthFromData(data);
				_this4.storage.set('currentUser', data);
				return _this4.currentUser;
			});
		}

		/**
   * Makes user Auth from data object.
   * @param {object} data
   * @return {Auth}
   * @protected
   */

	}, {
		key: 'makeUserAuthFromData',
		value: function makeUserAuthFromData(data) {
			var auth = new Auth();
			auth.setWedeployClient(this.wedeployClient);
			auth.setCreatedAt(data.createdAt);
			auth.setEmail(data.email);
			auth.setId(data.id);
			auth.setName(data.name);
			auth.setPhotoUrl(data.photoUrl);
			auth.setToken(data.token);
			return auth;
		}

		/**
   * Calls the on sign in callback if set.
   * @protected
   */

	}, {
		key: 'maybeCallOnSignInCallback_',
		value: function maybeCallOnSignInCallback_() {
			if (this.onSignInCallback) {
				this.onSignInCallback.call(this, this.currentUser);
			}
		}

		/**
   * Calls the on sign out callback if set.
   * @protected
   */

	}, {
		key: 'maybeCallOnSignOutCallback_',
		value: function maybeCallOnSignOutCallback_() {
			if (this.onSignOutCallback) {
				this.onSignOutCallback.call(this, this.currentUser);
			}
		}

		/**
   * Fires passed callback when a user sign-in. Note that it keeps only the
   * last callback passed.
   * @param {!Function} callback
   */

	}, {
		key: 'onSignIn',
		value: function onSignIn(callback) {
			assertFunction(callback, 'Sign-in callback must be a function');
			this.onSignInCallback = callback;
		}

		/**
   * Fires passed callback when a user sign-out. Note that it keeps only the
   * last callback passed.
   * @param {!Function} callback
   */

	}, {
		key: 'onSignOut',
		value: function onSignOut(callback) {
			assertFunction(callback, 'Sign-out callback must be a function');
			this.onSignOutCallback = callback;
		}

		/**
   * Processes sign-in by detecting a presence of a fragment
   * <code>#access_token=</code> in the url or, alternatively, by local
   * storage current user.
   */

	}, {
		key: 'processSignIn_',
		value: function processSignIn_() {
			var _this5 = this;

			var redirectAccessToken = this.getRedirectAccessToken_();
			if (redirectAccessToken) {
				this.removeUrlFragmentCompletely_();
				this.loadCurrentUser(redirectAccessToken).then(function () {
					return _this5.maybeCallOnSignInCallback_();
				});
				return;
			}
			var currentUser = this.storage.get('currentUser');
			if (currentUser) {
				this.currentUser = this.makeUserAuthFromData(currentUser);
			}
		}

		/**
   * Removes fragment from url by performing a push state to the current path.
   * @protected
   */

	}, {
		key: 'removeUrlFragmentCompletely_',
		value: function removeUrlFragmentCompletely_() {
			globals.window.history.pushState({}, document.title, window.location.pathname + window.location.search);
		}

		/**
   * Resolves auth scope from last login or api helper.
   * @return {Auth}
   */

	}, {
		key: 'resolveAuthScope',
		value: function resolveAuthScope() {
			if (this.helperAuthScope) {
				return this.helperAuthScope;
			}
			return this.currentUser;
		}

		/**
   * Sends password reset email to the specified email if found in database.
   * For security reasons call do not fail if email not found.
   * @param {!string} email
   * @return {CancellablePromise}
   */

	}, {
		key: 'sendPasswordResetEmail',
		value: function sendPasswordResetEmail(email) {
			assertDefAndNotNull(email, 'Send password reset email must be specified');
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/user/recover').param('email', email).post().then(function (response) {
				return assertResponseSucceeded(response);
			});
		}

		/**
   * Signs in using email and password.
   * @param {!string} email
   * @param {!string} password
   * @return {CancellablePromise}
   */

	}, {
		key: 'signInWithEmailAndPassword',
		value: function signInWithEmailAndPassword(email, password) {
			var _this6 = this;

			assertDefAndNotNull(email, 'Sign-in email must be specified');
			assertDefAndNotNull(password, 'Sign-in password must be specified');

			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/oauth/token').param('grant_type', 'password').param('username', email).param('password', password).get().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return _this6.loadCurrentUser(response.body().access_token);
			}).then(function (user) {
				_this6.maybeCallOnSignInCallback_();
				return user;
			});
		}

		/**
   * Signs in with redirect. Some providers and environment may not support
   * this flow.
   * @param {AuthProvider} provider
   */

	}, {
		key: 'signInWithRedirect',
		value: function signInWithRedirect(provider) {
			assertBrowserEnvironment();
			assertDefAndNotNull(provider, 'Sign-in provider must be defined');
			assertSupportedProvider(provider);

			if (!provider.hasRedirectUri()) {
				provider.setRedirectUri(this.getHrefWithoutFragment_());
			}
			globals.window.location.href = provider.makeAuthorizationUrl(this.wedeployClient.authUrl_);
		}

		/**
   * Signs out <code>currentUser</code> and removes from <code>localStorage</code>.
   * @return {[type]} [description]
   */

	}, {
		key: 'signOut',
		value: function signOut() {
			var _this7 = this;

			assertUserSignedIn(this.currentUser);
			return this.wedeployClient.url(this.wedeployClient.authUrl_).path('/oauth/revoke').param('token', this.currentUser.token).get().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				_this7.maybeCallOnSignOutCallback_();
				_this7.unloadCurrentUser_();
				return response;
			});
		}

		/**
   * Unloads all information for <code>currentUser</code> and removes from
   * <code>localStorage</code> if present.
   * @return {[type]} [description]
   */

	}, {
		key: 'unloadCurrentUser_',
		value: function unloadCurrentUser_() {
			this.currentUser = null;
			this.storage.remove('currentUser');
		}
	}]);
	return AuthApiHelper;
}(ApiHelper);

function assertSupportedProvider(provider) {
	switch (provider.constructor.PROVIDER) {
		case FacebookAuthProvider.PROVIDER:
		case GithubAuthProvider.PROVIDER:
		case GoogleAuthProvider.PROVIDER:
			break;
		default:
			throw new Error('Sign-in provider not supported');
	}
}

/**
 * Class that represents a search aggregation.
 */

var Aggregation = function () {
	/**
  * Constructs an {@link Aggregation} instance.
  * @param {string} field The aggregation field.
  * @param {string} operator The aggregation operator.
  * @param {*=} opt_value The aggregation value.
  * @constructor
  */
	function Aggregation(field, operator, opt_value) {
		classCallCheck(this, Aggregation);

		this.field_ = field;
		this.operator_ = operator;
		this.value_ = opt_value;
	}

	/**
  * Creates an {@link Aggregation} instance with the "avg" operator.
  * @param {string} field The aggregation field.
  * @return {!Aggregation}
  * @static
  */


	createClass(Aggregation, [{
		key: 'getField',


		/**
   * Gets this aggregation's field.
   * @return {string}
   */
		value: function getField() {
			return this.field_;
		}

		/**
   * Gets this aggregation's operator.
   * @return {string}
   */

	}, {
		key: 'getOperator',
		value: function getOperator() {
			return this.operator_;
		}

		/**
   * Gets this aggregation's value.
   * @return {*}
   */

	}, {
		key: 'getValue',
		value: function getValue() {
			return this.value_;
		}

		/**
   * Creates an {@link Aggregation} instance with the "histogram" operator.
   * @param {string} field The aggregation field.
   * @param {number} interval The histogram's interval.
   * @return {!Aggregation}
   * @static
   */

	}], [{
		key: 'avg',
		value: function avg(field) {
			return Aggregation.field(field, 'avg');
		}

		/**
   * Creates an {@link Aggregation} instance with the "count" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'count',
		value: function count(field) {
			return Aggregation.field(field, 'count');
		}

		/**
   * Creates an {@link DistanceAggregation} instance with the "geoDistance" operator.
   * @param {string} field The aggregation field.
   * @param {*} location The aggregation location.
   * @param {...!Range} ranges The aggregation ranges.
   * @return {!DistanceAggregation}
   * @static
   */

	}, {
		key: 'distance',
		value: function distance(field, location) {
			for (var _len = arguments.length, ranges = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
				ranges[_key - 2] = arguments[_key];
			}

			return new (Function.prototype.bind.apply(Aggregation.DistanceAggregation, [null].concat([field, location], ranges)))();
		}

		/**
   * Creates an {@link Aggregation} instance with the "extendedStats" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'extendedStats',
		value: function extendedStats(field) {
			return Aggregation.field(field, 'extendedStats');
		}
	}, {
		key: 'histogram',
		value: function histogram(field, interval) {
			return new Aggregation(field, 'histogram', interval);
		}

		/**
   * Creates an {@link Aggregation} instance with the "max" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'max',
		value: function max(field) {
			return Aggregation.field(field, 'max');
		}

		/**
   * Creates an {@link Aggregation} instance with the "min" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'min',
		value: function min(field) {
			return Aggregation.field(field, 'min');
		}

		/**
   * Creates an {@link Aggregation} instance with the "missing" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'missing',
		value: function missing(field) {
			return Aggregation.field(field, 'missing');
		}

		/**
   * Creates a new {@link Aggregation} instance.
   * @param {string} field The aggregation field.
   * @param {string} operator The aggregation operator.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'field',
		value: function field(_field, operator) {
			return new Aggregation(_field, operator);
		}

		/**
   * Creates an {@link RangeAggregation} instance with the "range" operator.
   * @param {string} field The aggregation field.
   * @param {...!Range} ranges The aggregation ranges.
   * @return {!RangeAggregation}
   * @static
   */

	}, {
		key: 'range',
		value: function range(field) {
			for (var _len2 = arguments.length, ranges = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				ranges[_key2 - 1] = arguments[_key2];
			}

			return new (Function.prototype.bind.apply(Aggregation.RangeAggregation, [null].concat([field], ranges)))();
		}

		/**
   * Creates an {@link Aggregation} instance with the "stats" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'stats',
		value: function stats(field) {
			return Aggregation.field(field, 'stats');
		}

		/**
   * Creates an {@link Aggregation} instance with the "sum" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'sum',
		value: function sum(field) {
			return Aggregation.field(field, 'sum');
		}

		/**
   * Creates an {@link Aggregation} instance with the "terms" operator.
   * @param {string} field The aggregation field.
   * @return {!Aggregation}
   * @static
   */

	}, {
		key: 'terms',
		value: function terms(field) {
			return Aggregation.field(field, 'terms');
		}
	}]);
	return Aggregation;
}();

/**
 * Class that represents a distance aggregation.
 * @extends {Aggregation}
 */


var DistanceAggregation = function (_Aggregation) {
	inherits(DistanceAggregation, _Aggregation);

	/**
  * Constructs an {@link DistanceAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {*} location The aggregation location.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
	function DistanceAggregation(field, location) {
		classCallCheck(this, DistanceAggregation);

		var _this = possibleConstructorReturn(this, (DistanceAggregation.__proto__ || Object.getPrototypeOf(DistanceAggregation)).call(this, field, 'geoDistance', {}));

		_this.value_.location = Embodied.toBody(location);

		for (var _len3 = arguments.length, ranges = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
			ranges[_key3 - 2] = arguments[_key3];
		}

		_this.value_.ranges = ranges.map(function (range) {
			return range.body();
		});
		return _this;
	}

	/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @chainnable
  */


	createClass(DistanceAggregation, [{
		key: 'range',
		value: function range(rangeOrFrom, opt_to) {
			var range = rangeOrFrom;
			if (!(range instanceof Range)) {
				range = Range.range(rangeOrFrom, opt_to);
			}
			this.value_.ranges.push(range.body());
			return this;
		}

		/**
   * Sets this aggregation's unit.
   * @param {string} unit
   * @chainnable
   */

	}, {
		key: 'unit',
		value: function unit(_unit) {
			this.value_.unit = _unit;
			return this;
		}
	}]);
	return DistanceAggregation;
}(Aggregation);

Aggregation.DistanceAggregation = DistanceAggregation;

/**
 * Class that represents a range aggregation.
 * @extends {Aggregation}
 */

var RangeAggregation = function (_Aggregation2) {
	inherits(RangeAggregation, _Aggregation2);

	/**
  * Constructs an {@link RangeAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
	function RangeAggregation(field) {
		classCallCheck(this, RangeAggregation);

		var _this2 = possibleConstructorReturn(this, (RangeAggregation.__proto__ || Object.getPrototypeOf(RangeAggregation)).call(this, field, 'range'));

		for (var _len4 = arguments.length, ranges = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
			ranges[_key4 - 1] = arguments[_key4];
		}

		_this2.value_ = ranges.map(function (range) {
			return range.body();
		});
		return _this2;
	}

	/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @chainnable
  */


	createClass(RangeAggregation, [{
		key: 'range',
		value: function range(rangeOrFrom, opt_to) {
			var range = rangeOrFrom;
			if (!(range instanceof Range)) {
				range = Range.range(rangeOrFrom, opt_to);
			}
			this.value_.push(range.body());
			return this;
		}
	}]);
	return RangeAggregation;
}(Aggregation);

Aggregation.RangeAggregation = RangeAggregation;

/**
 * Class responsible for building queries.
 * @extends {Embodied}
 */

var Query = function (_Embodied) {
	inherits(Query, _Embodied);

	function Query() {
		classCallCheck(this, Query);
		return possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).apply(this, arguments));
	}

	createClass(Query, [{
		key: 'aggregate',


		/**
   * Adds an aggregation to this {@link Query} instance.
   * @param {string} name The aggregation name.
   * @param {!Aggregation|string} aggregationOrField Either an
   *   {@link Aggregation} instance or the name of the aggregation field.
   * @param {string=} opt_operator The aggregation operator.
   * @chainnable
   */
		value: function aggregate(name, aggregationOrField, opt_operator) {
			var aggregation = aggregationOrField;
			if (!(aggregation instanceof Aggregation)) {
				aggregation = Aggregation.field(aggregationOrField, opt_operator);
			}

			var field = aggregation.getField();
			var value = {};
			value[field] = {
				name: name,
				operator: aggregation.getOperator()
			};
			if (isDefAndNotNull(aggregation.getValue())) {
				value[field].value = aggregation.getValue();
			}

			if (!this.body_.aggregation) {
				this.body_.aggregation = [];
			}
			this.body_.aggregation.push(value);
			return this;
		}

		/**
   * Sets this query's type to "count".
   * @chainnable
   */

	}, {
		key: 'count',
		value: function count() {
			return this.type('count');
		}

		/**
   * Sets this query's type to "fetch".
   * @chainnable
   */

	}, {
		key: 'fetch',
		value: function fetch() {
			return this.type('fetch');
		}

		/**
   * Adds a filter to this Query.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */

	}, {
		key: 'filter',
		value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
			var filter = Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value);
			if (!this.body_.filter) {
				this.body_.filter = [];
			}
			this.body_.filter.push(filter.body());
			return this;
		}

		/**
   * Sets the query offset.
   * @param {number} offset The index of the first entry that should be returned
   *   by this query.
   * @chainnable
   */

	}, {
		key: 'offset',
		value: function offset(_offset2) {
			this.body_.offset = _offset2;
			return this;
		}

		/**
   * Adds a highlight entry to this {@link Query} instance.
   * @param {string} field The field's name.
   * @chainnable
   */

	}, {
		key: 'highlight',
		value: function highlight(field) {
			if (!this.body_.highlight) {
				this.body_.highlight = [];
			}

			this.body_.highlight.push(field);
			return this;
		}

		/**
   * Sets the query limit.
   * @param {number} limit The max amount of entries that this query should return.
   * @chainnable
   */

	}, {
		key: 'limit',
		value: function limit(_limit2) {
			this.body_.limit = _limit2;
			return this;
		}

		/**
   * Adds a search to this {@link Query} instance.
   * @param {!Filter|string} filterOrTextOrField If no other arguments
   *   are passed to this function, this should be either a {@link Filter}
   *   instance or a text to be used in a match filter. In both cases
   *   the filter will be applied to all fields. Another option is to
   *   pass this as a field name instead, together with other arguments
   *   so the filter can be created.
   * @param {string=} opt_textOrOperator Either a text to be used in a
   *   match filter, or the operator that should be used.
   * @param {*=} opt_value The value to be used by the filter. Should
   *   only be passed if an operator was passed as the second argument.
   * @chainnable
   */

	}, {
		key: 'search',
		value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
			var filter = filterOrTextOrField;

			if (opt_value) {
				filter = Filter.field(filterOrTextOrField, opt_textOrOperator, opt_value);
			} else if (opt_textOrOperator) {
				filter = Filter.match(filterOrTextOrField, opt_textOrOperator);
			} else if (!(filter instanceof Filter)) {
				filter = Filter.match(filterOrTextOrField);
			}

			if (!this.body_.search) {
				this.body_.search = [];
			}

			if (isDefAndNotNull(filterOrTextOrField)) {
				this.body_.search.push(filter.body());
			} else {
				this.body_.search.push({});
			}

			return this;
		}

		/**
   * Adds a sort entry to this query, specifying the field this query should be
   * sorted by and, optionally, the sort direction.
   * @param {string} field The field that the query should be sorted by.
   * @param {string=} opt_direction The direction the sort operation should use.
   *   If none is given, "asc" is used by default.
   * @chainnable
   */

	}, {
		key: 'sort',
		value: function sort(field, opt_direction) {
			if (!this.body_.sort) {
				this.body_.sort = [];
			}
			var sortEntry = {};
			sortEntry[field] = opt_direction || 'asc';
			this.body_.sort.push(sortEntry);
			return this;
		}

		/**
   * Sets the query type.
   * @param {string} type The query's type. For example: "count", "fetch".
   * @chainnable
   */

	}, {
		key: 'type',
		value: function type(_type2) {
			this.body_.type = _type2;
			return this;
		}
	}], [{
		key: 'aggregate',

		/**
   * Adds an aggregation to this {@link Query} instance.
   * @param {string} name The aggregation name.
   * @param {!Aggregation|string} aggregationOrField Either an
   *   {@link Aggregation} instance or the name of the aggregation field.
   * @param {string=} opt_operator The aggregation operator.
   * @return {!Query}
   * @static
   */
		value: function aggregate(name, aggregationOrField, opt_operator) {
			return new Query().aggregate(name, aggregationOrField, opt_operator);
		}

		/**
   * Sets this query's type to "count".
   * @return {!Query}
   * @static
   */

	}, {
		key: 'count',
		value: function count() {
			return new Query().type('count');
		}

		/**
   * Sets this query's type to "fetch".
   * @return {!Query}
   * @static
   */

	}, {
		key: 'fetch',
		value: function fetch() {
			return new Query().type('fetch');
		}

		/**
   * Adds a filter to this Query.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
   *   name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'filter',
		value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
			return new Query().filter(fieldOrFilter, opt_operatorOrValue, opt_value);
		}

		/**
   * Sets the query offset.
   * @param {number} offset The index of the first entry that should be returned
   *   by this query.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'offset',
		value: function offset(_offset) {
			return new Query().offset(_offset);
		}

		/**
   * Adds a highlight entry to this {@link Query} instance.
   * @param {string} field The field's name.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'highlight',
		value: function highlight(field) {
			return new Query().highlight(field);
		}

		/**
   * Sets the query limit.
   * @param {number} limit The max amount of entries that this query should return.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'limit',
		value: function limit(_limit) {
			return new Query().limit(_limit);
		}

		/**
   * Adds a search to this {@link Query} instance.
   * @param {!Filter|string} filterOrTextOrField If no other arguments
   *   are passed to this function, this should be either a {@link Filter}
   *   instance or a text to be used in a match filter. In both cases
   *   the filter will be applied to all fields. Another option is to
   *   pass this as a field name instead, together with other arguments
   *   so the filter can be created.
   * @param {string=} opt_textOrOperator Either a text to be used in a
   *   match filter, or the operator that should be used.
   * @param {*=} opt_value The value to be used by the filter. Should
   *   only be passed if an operator was passed as the second argument.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'search',
		value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
			return new Query().search(filterOrTextOrField, opt_textOrOperator, opt_value);
		}

		/**
   * Adds a sort entry to this query, specifying the field this query should be
   * sorted by and, optionally, the sort direction.
   * @param {string} field The field that the query should be sorted by.
   * @param {string=} opt_direction The direction the sort operation should use.
   *   If none is given, "asc" is used by default.
   * @return {!Query}
   * @static
   */

	}, {
		key: 'sort',
		value: function sort(field, opt_direction) {
			return new Query().sort(field, opt_direction);
		}

		/**
   * Sets the query type.
   * @param {string} type The query's type. For example: "count", "fetch".
   * @return {!Query}
   * @static
   */

	}, {
		key: 'type',
		value: function type(_type) {
			return new Query().type(_type);
		}
	}]);
	return Query;
}(Embodied);

/**
 * Class responsible for encapsulate data api calls.
 */

var DataApiHelper = function (_ApiHelper) {
	inherits(DataApiHelper, _ApiHelper);

	/**
  * Constructs an {@link DataApiHelper} instance.
  * @param {@link WeDeploy} instance.
  * @constructor
  */
	function DataApiHelper(wedeployClient) {
		classCallCheck(this, DataApiHelper);
		return possibleConstructorReturn(this, (DataApiHelper.__proto__ || Object.getPrototypeOf(DataApiHelper)).call(this, wedeployClient));
	}

	/**
  * Adds a filter to this request's {@link Query}.
  * @param {!Filter|string} fieldOrFilter Either a Filter instance or the
  *   name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @chainable
  */


	createClass(DataApiHelper, [{
		key: 'where',
		value: function where(fieldOrFilter, opt_operatorOrValue, opt_value) {
			this.getOrCreateFilter_().and(fieldOrFilter, opt_operatorOrValue, opt_value);
			return this;
		}

		/**
   * Adds a filter to be composed with this filter using the "or" operator.
   * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
   *   the name of the field to filter by.
   * @param {*=} opt_operatorOrValue Either the field's operator or its value.
   * @param {*=} opt_value The filter's value.
   * @chainnable
   */

	}, {
		key: 'or',
		value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
			if (this.getOrCreateFilter_().body().and.length === 0) {
				throw Error('It\'s required to have a condition before using an \'or()\' for the first time.');
			}
			this.getOrCreateFilter_().or(fieldOrFilter, opt_operatorOrValue, opt_value);
			return this;
		}

		/**
   * Adds a filter to be compose with this filter using "none" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} args A variable amount of values to be used with
   * the "none" operator. Can be passed either as a single array or as
   * separate params.
   * @chainnable
   */

	}, {
		key: 'none',
		value: function none(field) {
			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			return this.where(Filter.none(field, args));
		}

		/**
   * Adds a filter to be compose with this filter using "match" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   * should be the query string, in which case all fields will be matched.
   * Otherwise, this should be the name of the field to match.
   * @param {string=} opt_query The query string.
   * @chainnable
   */

	}, {
		key: 'match',
		value: function match(field, value) {
			return this.where(Filter.match(field, value));
		}

		/**
   * Adds a filter to be compose with this filter using "similar" operator.
   * @param {string} fieldOrQuery If no second string argument is given, this
   * should be the query string, in which case all fields will be matched.
   * Otherwise, this should be the name of the field to match.
   * @param {?string} query The query string.
   * @chainnable
   */

	}, {
		key: 'similar',
		value: function similar(fieldOrQuery, query) {
			return this.where(Filter.similar(fieldOrQuery, query));
		}

		/**
   * Returns a {@link Filter} instance that uses the "<" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lt',
		value: function lt(field, value) {
			return this.where(Filter.lt(field, value));
		}

		/**
   * Returns a {@link Filter} instance that uses the "<=" operator.
   * @param {string} field The name of the field to filter by.
   * @param {*} value The filter's value.
   * @return {!Filter}
    * @static
   */

	}, {
		key: 'lte',
		value: function lte(field, value) {
			return this.where(Filter.lte(field, value));
		}

		/**
   * Adds a filter to be compose with this filter using "any" operator.
   * @param {string} field The name of the field to filter by.
   * @param {!(Array|...*)} args A variable amount of values to be used with
   * the "none" operator. Can be passed either as a single array or as
   * separate params.
   * @chainnable
   */

	}, {
		key: 'any',
		value: function any(field) {
			for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				args[_key2 - 1] = arguments[_key2];
			}

			return this.where(Filter.any(field, args));
		}

		/**
   * Adds a filter to be compose with this filter using "gp" operator. This is a
   * special use case of `Filter.polygon` for bounding boxes.
   * @param {string} field The field's name.
   * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or a
   * bounding box's upper left coordinate.
   * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
   * @chainnable
   */

	}, {
		key: 'boundingBox',
		value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
			return this.where(Filter.boundingBox(field, boxOrUpperLeft, opt_lowerRight));
		}

		/**
   * Adds a filter to be compose with this filter using "gd" operator.
   * @param {string} field The field's name.
   * @param {*} locationOrCircle Either a `Geo.Circle` instance or a
   * coordinate.
   * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
   * the distance value.
   * @return {!Filter}
   * @chainnable
   */

	}, {
		key: 'distance',
		value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
			return this.where(Filter.distance(field, locationOrCircle, opt_rangeOrDistance));
		}

		/**
   * Adds a filter to be compose with this filter using "range" operator.
   * @param {string} field The field's name.
   * @param {*} rangeOrMin Either a `Range` instance or a the range's min
   * value.
   * @param {*=} opt_max The range's max value.
   * @return {!Filter}
   * @chainnable
   */

	}, {
		key: 'range',
		value: function range(field, rangeOrMin, opt_max) {
			return this.where(Filter.range(field, rangeOrMin, opt_max));
		}

		/**
   * Sets the limit for this request's {@link Query}.
   * @param {number} limit The max amount of entries that this request should return.
   * @chainable
   */

	}, {
		key: 'limit',
		value: function limit(_limit) {
			this.getOrCreateQuery_().limit(_limit);
			return this;
		}

		/**
   * Sets the offset for this request's {@link Query}.
   * @param {number} offset The index of the first entry that should be
   * returned by this query.
   * @chainable
   */

	}, {
		key: 'offset',
		value: function offset(_offset) {
			this.getOrCreateQuery_().offset(_offset);
			return this;
		}

		/**
   * Adds a highlight entry to this request's {@link Query} instance.
   * @param {string} field The field's name.
   * @chainable
   */

	}, {
		key: 'highlight',
		value: function highlight(field) {
			this.getOrCreateQuery_().highlight(field);
			return this;
		}

		/**
   * Adds an aggregation to this {@link Query} instance.
   * @param {string} name The aggregation name.
   * @param {!Aggregation|string} aggregationOrField Either an {@link
   * Aggregation} instance or the name of the aggregation field.
   * @param {string=} opt_operator The aggregation operator.
   * @chainable
   */

	}, {
		key: 'aggregate',
		value: function aggregate(name, aggregationOrField, opt_operator) {
			this.getOrCreateQuery_().aggregate(name, aggregationOrField, opt_operator);
			return this;
		}

		/**
   * Sets this request's query type to 'count'.
   * @chainnable
   */

	}, {
		key: 'count',
		value: function count() {
			this.getOrCreateQuery_().type('count');
			return this;
		}

		/**
   * Adds a sort query to this request's body.
   * @param {string} field The field that the query should be sorted by.
   * @param {string=} opt_direction The direction the sort operation should
   * use. If none is given, 'asc' is used by default.
   * @chainnable
   */

	}, {
		key: 'orderBy',
		value: function orderBy(field, opt_direction) {
			this.getOrCreateQuery_().sort(field, opt_direction);
			return this;
		}

		/**
   * Creates an object (or multiple objects) and saves it to WeDeploy data. If
   * there's a validation registered in the collection and the request is
   * successful, the resulting object (or array of objects) is returned. The
   * data parameter can be either an Object or an Array of Objects.
   * These Objects describe the attributes on the objects that are to be created.
   * ```javascript
   * var data = WeDeploy.data('http://demodata.wedeploy.io');
   *
   * data.create('movies', {'title'=> 'Star Wars: Episode I  The Phantom Menace'})
   * 		 .then(function(movie){
   * 			 console.log(movie)
   *     });
   *
   * data.create('movies', [{'title'=> 'Star Wars: Episode II  Attack of the Clones'},
   * 												{'title'=> 'Star Wars: Episode III  Revenge of the Sith'})
   * 		 .then(function(movies){
   * 			 console.log(movies)
   *     });
   * ```
   * @param {string} collection Collection (key) used to create the new data.
   * @param {Object} data Attributes on the object that is to be created.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'create',
		value: function create(collection, data) {
			assertDefAndNotNull(collection, 'Collection key must be specified.');
			assertObject(data, 'Data can\'t be empty.');

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(collection).post(data).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Update the attributes of a document form the passed-in object and saves
   * the record. If the object is invalid, the saving will fail and an error
   * object will be returned.
   *
   * ```javascript
   * var data = WeDeploy.data('http://demodata.wedeploy.io');
   *
   * data.update('movies/1019112353', {'title'=> 'Star Wars: Episode I'})
   * 		 .then(function(movie){
   * 			 console.log(movie)
   *     });
   * ```
   * @param {string} document Key used to update the document.
   * @param {Object} data Attributes on the object that is to be updated.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'update',
		value: function update(document, data) {
			assertDefAndNotNull(document, 'Document key must be specified.');
			assertObject(data, 'Data must be specified.');

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(document).put(data).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Deletes a [document/field/collection].
   * @param {string} key Key used to delete the
   * document/field/collection.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'delete',
		value: function _delete(key) {
			assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(key).delete().then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function () {
				return undefined;
			});
		}

		/**
   * Retrieve data from a [document/field/collection].
   * @param {string} key Key used to delete the document/field/collection.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'get',
		value: function get(key) {
			assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

			this.addFiltersToQuery_();

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(key).get(this.query_).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Retrieve data from a [document/field/collection] and put it in a search
   * format.
   * @param {string} key Key used to delete the document/field/collection.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'search',
		value: function search(key) {
			assertDefAndNotNull(key, 'Document/Field/Collection key must be specified');

			this.onSearch_();

			this.addFiltersToQuery_();

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(key).get(this.query_).then(function (response) {
				return assertResponseSucceeded(response);
			}).then(function (response) {
				return response.body();
			});
		}

		/**
   * Creates new socket.io instance. Monitor the arrival of new broadcasted
   * data.
   * @param  {string} collection key/collection used to find organized data.
   * @param  {Object=} opt_options Object with Socket IO options.
   * @return {!io} Socket IO reference. Server events can be listened on it.
   */

	}, {
		key: 'watch',
		value: function watch(collection, opt_options) {
			assertDefAndNotNull(collection, 'Collection key must be specified');

			this.addFiltersToQuery_();

			return this.wedeployClient.url(this.wedeployClient.dataUrl_).auth(this.helperAuthScope).path(collection).watch(this.query_, opt_options);
		}

		/**
   * Gets the currentl used main {@link Filter} object. If none exists yet, a
   * new one is created.
   * @return {!Query}
   * @protected
   */

	}, {
		key: 'getOrCreateFilter_',
		value: function getOrCreateFilter_() {
			if (!this.filter_) {
				this.filter_ = new Filter();
			}
			return this.filter_;
		}

		/**
   * Gets the currently used {@link Query} object. If none exists yet,
   * a new one is created.
   * @return {!Query}
   * @protected
   */

	}, {
		key: 'getOrCreateQuery_',
		value: function getOrCreateQuery_() {
			if (!this.query_) {
				this.query_ = new Query();
			}
			return this.query_;
		}

		/**
   * Load the currently used main {@link Filter} object into the currently
   * used {@link Query}.
   * @chainable
   * @protected
   */

	}, {
		key: 'addFiltersToQuery_',
		value: function addFiltersToQuery_() {
			if (isDef(this.filter_) && this.toSearch_ !== true) {
				this.getOrCreateQuery_().filter(this.filter_);
			}
			return this;
		}

		/**
   * Adds a search to this request's {@link Query} instance.
   * @chainable
   * @protected
   */

	}, {
		key: 'onSearch_',
		value: function onSearch_() {
			if (isDef(this.filter_)) {
				this.getOrCreateQuery_().search(this.getOrCreateFilter_());
			} else {
				throw Error('It\'s required to have a condition before using an \'search()\' for the first time.');
			}
			this.toSearch_ = true;
			return this;
		}
	}]);
	return DataApiHelper;
}(ApiHelper);

/**
 * Abstraction layer for string to base64 conversion
 * reference: https://github.com/nodejs/node/issues/3462
 */

var Base64 = function () {
	function Base64() {
		classCallCheck(this, Base64);
	}

	createClass(Base64, null, [{
		key: 'encodeString',

		/**
   * Creates a base-64 encoded ASCII string from a "string" of binary data.
   * @param {string} string to be encoded.
   * @return {string}
   * @static
   */
		value: function encodeString(string) {
			if (typeof btoa === 'function') {
				return btoa(string);
			}

			return new Buffer(string.toString(), 'binary');
		}
	}]);
	return Base64;
}();

/*!
 * Promises polyfill from Google's Closure Library.
 *
 *      Copyright 2013 The Closure Library Authors. All Rights Reserved.
 *
 * NOTE(eduardo): Promise support is not ready on all supported browsers,
 * therefore metal-promise is temporarily using Google's promises as polyfill.
 * It supports cancellable promises and has clean and fast implementation.
 */

/**
 * Provides a more strict interface for Thenables in terms of
 * http://promisesaplus.com for interop with {@see CancellablePromise}.
 *
 * @interface
 * @extends {IThenable.<TYPE>}
 * @template TYPE
 */
var Thenable = function Thenable() {};

/**
 * Adds callbacks that will operate on the result of the Thenable, returning a
 * new child Promise.
 *
 * If the Thenable is fulfilled, the {@code onFulfilled} callback will be
 * invoked with the fulfillment value as argument, and the child Promise will
 * be fulfilled with the return value of the callback. If the callback throws
 * an exception, the child Promise will be rejected with the thrown value
 * instead.
 *
 * If the Thenable is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value of the callback or thrown value.
 *
 * @param {?(function(this:THIS, TYPE):
 *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {?(function(*): *)=} opt_onRejected A function that will be invoked
 *     with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 */
Thenable.prototype.then = function () {};

/**
 * An expando property to indicate that an object implements
 * {@code Thenable}.
 *
 * {@see addImplementation}.
 *
 * @const
 */
Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';

/**
 * Marks a given class (constructor) as an implementation of Thenable, so
 * that we can query that fact at runtime. The class must have already
 * implemented the interface.
 * Exports a 'then' method on the constructor prototype, so that the objects
 * also implement the extern {@see Thenable} interface for interop with
 * other Promise implementations.
 * @param {function(new:Thenable,...[?])} ctor The class constructor. The
 *     corresponding class must have already implemented the interface.
 */
Thenable.addImplementation = function (ctor) {
  ctor.prototype.then = ctor.prototype.then;
  ctor.prototype.$goog_Thenable = true;
};

/**
 * @param {*} object
 * @return {boolean} Whether a given instance implements {@code Thenable}.
 *     The class/superclass of the instance must call {@code addImplementation}.
 */
Thenable.isImplementedBy = function (object$$1) {
  if (!object$$1) {
    return false;
  }
  try {
    return !!object$$1.$goog_Thenable;
  } catch (e) {
    // Property access seems to be forbidden.
    return false;
  }
};

/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
var partial = function partial(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function () {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};

/**
 * Promises provide a result that may be resolved asynchronously. A Promise may
 * be resolved by being fulfilled or rejected with a value, which will be known
 * as the fulfillment value or the rejection reason. Whether fulfilled or
 * rejected, the Promise result is immutable once it is set.
 *
 * Promises may represent results of any type, including undefined. Rejection
 * reasons are typically Errors, but may also be of any type. Closure Promises
 * allow for optional type annotations that enforce that fulfillment values are
 * of the appropriate types at compile time.
 *
 * The result of a Promise is accessible by calling {@code then} and registering
 * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise
 * resolves, the relevant callbacks are invoked with the fulfillment value or
 * rejection reason as argument. Callbacks are always invoked in the order they
 * were registered, even when additional {@code then} calls are made from inside
 * another callback. A callback is always run asynchronously sometime after the
 * scope containing the registering {@code then} invocation has returned.
 *
 * If a Promise is resolved with another Promise, the first Promise will block
 * until the second is resolved, and then assumes the same result as the second
 * Promise. This allows Promises to depend on the results of other Promises,
 * linking together multiple asynchronous operations.
 *
 * This implementation is compatible with the Promises/A+ specification and
 * passes that specification's conformance test suite. A Closure Promise may be
 * resolved with a Promise instance (or sufficiently compatible Promise-like
 * object) created by other Promise implementations. From the specification,
 * Promise-like objects are known as "Thenables".
 *
 * @see http://promisesaplus.com/
 *
 * @param {function(
 *             this:RESOLVER_CONTEXT,
 *             function((TYPE|IThenable.<TYPE>|Thenable)),
 *             function(*)): void} resolver
 *     Initialization function that is invoked immediately with {@code resolve}
 *     and {@code reject} functions as arguments. The Promise is resolved or
 *     rejected with the first argument passed to either function.
 * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the
 *     resolver function. If unspecified, the resolver function will be executed
 *     in the default scope.
 * @constructor
 * @struct
 * @final
 * @implements {Thenable.<TYPE>}
 * @template TYPE,RESOLVER_CONTEXT
 */
var CancellablePromise = function CancellablePromise(resolver, opt_context) {
  /**
   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
   * BLOCKED.
   * @private {CancellablePromise.State_}
   */
  this.state_ = CancellablePromise.State_.PENDING;

  /**
   * The resolved result of the Promise. Immutable once set with either a
   * fulfillment value or rejection reason.
   * @private {*}
   */
  this.result_ = undefined;

  /**
   * For Promises created by calling {@code then()}, the originating parent.
   * @private {CancellablePromise}
   */
  this.parent_ = null;

  /**
   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to
   * this Promise by calls to {@code then()}.
   * @private {Array.<CancellablePromise.CallbackEntry_>}
   */
  this.callbackEntries_ = null;

  /**
   * Whether the Promise is in the queue of Promises to execute.
   * @private {boolean}
   */
  this.executing_ = false;

  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    /**
     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater
     * than 0 milliseconds. The ID is set when the Promise is rejected, and
     * cleared only if an {@code onRejected} callback is invoked for the
     * Promise (or one of its descendants) before the delay is exceeded.
     *
     * If the rejection is not handled before the timeout completes, the
     * rejection reason is passed to the unhandled rejection handler.
     * @private {number}
     */
    this.unhandledRejectionId_ = 0;
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    /**
     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a
     * boolean that is set if the Promise is rejected, and reset to false if an
     * {@code onRejected} callback is invoked for the Promise (or one of its
     * descendants). If the rejection is not handled before the next timestep,
     * the rejection reason is passed to the unhandled rejection handler.
     * @private {boolean}
     */
    this.hadUnhandledRejection_ = false;
  }

  try {
    var self = this;
    resolver.call(opt_context, function (value) {
      self.resolve_(CancellablePromise.State_.FULFILLED, value);
    }, function (reason) {
      self.resolve_(CancellablePromise.State_.REJECTED, reason);
    });
  } catch (e) {
    this.resolve_(CancellablePromise.State_.REJECTED, e);
  }
};

/**
 * The delay in milliseconds before a rejected Promise's reason is passed to
 * the rejection handler. By default, the rejection handler rethrows the
 * rejection reason so that it appears in the developer console or
 * {@code window.onerror} handler.
 * Rejections are rethrown as quickly as possible by default. A negative value
 * disables rejection handling entirely.
 * @type {number}
 */
CancellablePromise.UNHANDLED_REJECTION_DELAY = 0;

/**
 * The possible internal states for a Promise. These states are not directly
 * observable to external callers.
 * @enum {number}
 * @private
 */
CancellablePromise.State_ = {
  /** The Promise is waiting for resolution. */
  PENDING: 0,

  /** The Promise is blocked waiting for the result of another Thenable. */
  BLOCKED: 1,

  /** The Promise has been resolved with a fulfillment value. */
  FULFILLED: 2,

  /** The Promise has been resolved with a rejection reason. */
  REJECTED: 3
};

/**
 * Typedef for entries in the callback chain. Each call to {@code then},
 * {@code thenCatch}, or {@code thenAlways} creates an entry containing the
 * functions that may be invoked once the Promise is resolved.
 *
 * @typedef {{
 *   child: CancellablePromise,
 *   onFulfilled: function(*),
 *   onRejected: function(*)
 * }}
 * @private
 */
CancellablePromise.CallbackEntry_ = null;

/**
 * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value
 * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved
 *     with the given value.
 * @template TYPE
 */
CancellablePromise.resolve = function (opt_value) {
  return new CancellablePromise(function (resolve) {
    resolve(opt_value);
  });
};

/**
 * @param {*=} opt_reason
 * @return {!CancellablePromise} A new Promise that is immediately rejected with the
 *     given reason.
 */
CancellablePromise.reject = function (opt_reason) {
  return new CancellablePromise(function (resolve, reject) {
    reject(opt_reason);
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the
 *     first Promise (or Promise-like) input to complete.
 * @template TYPE
 */
CancellablePromise.race = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    if (!promises.length) {
      resolve(undefined);
    }
    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(resolve, reject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of
 *     every fulfilled value once every input Promise (or Promise-like) is
 *     successfully fulfilled, or is rejected by the first rejection result.
 * @template TYPE
 */
CancellablePromise.all = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toFulfill = promises.length;
    var values = [];

    if (!toFulfill) {
      resolve(values);
      return;
    }

    var onFulfill = function onFulfill(index, value) {
      toFulfill--;
      values[index] = value;
      if (toFulfill === 0) {
        resolve(values);
      }
    };

    var onReject = function onReject(reason) {
      reject(reason);
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(partial(onFulfill, i), onReject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of
 *     the first input to be fulfilled, or is rejected with a list of every
 *     rejection reason if all inputs are rejected.
 * @template TYPE
 */
CancellablePromise.firstFulfilled = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toReject = promises.length;
    var reasons = [];

    if (!toReject) {
      resolve(undefined);
      return;
    }

    var onFulfill = function onFulfill(value) {
      resolve(value);
    };

    var onReject = function onReject(index, reason) {
      toReject--;
      reasons[index] = reason;
      if (toReject === 0) {
        reject(reasons);
      }
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(onFulfill, partial(onReject, i));
    }
  });
};

/**
 * Adds callbacks that will operate on the result of the Promise, returning a
 * new child Promise.
 *
 * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked
 * with the fulfillment value as argument, and the child Promise will be
 * fulfilled with the return value of the callback. If the callback throws an
 * exception, the child Promise will be rejected with the thrown value instead.
 *
 * If the Promise is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value (or thrown value) of the callback.
 *
 * @override
 */
CancellablePromise.prototype.then = function (opt_onFulfilled, opt_onRejected, opt_context) {
  return this.addChildPromise_(isFunction(opt_onFulfilled) ? opt_onFulfilled : null, isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);
};
Thenable.addImplementation(CancellablePromise);

/**
 * Adds a callback that will be invoked whether the Promise is fulfilled or
 * rejected. The callback receives no argument, and no new child Promise is
 * created. This is useful for ensuring that cleanup takes place after certain
 * asynchronous operations. Callbacks added with {@code thenAlways} will be
 * executed in the same order with other calls to {@code then},
 * {@code thenAlways}, or {@code thenCatch}.
 *
 * Since it does not produce a new child Promise, cancellation propagation is
 * not prevented by adding callbacks with {@code thenAlways}. A Promise that has
 * a cleanup handler added with {@code thenAlways} will be canceled if all of
 * its children created by {@code then} (or {@code thenCatch}) are canceled.
 *
 * @param {function(this:THIS): void} onResolved A function that will be invoked
 *     when the Promise is resolved.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.
 * @template THIS
 */
CancellablePromise.prototype.thenAlways = function (onResolved, opt_context) {
  var callback = function callback() {
    try {
      // Ensure that no arguments are passed to onResolved.
      onResolved.call(opt_context);
    } catch (err) {
      CancellablePromise.handleRejection_.call(null, err);
    }
  };

  this.addCallbackEntry_({
    child: null,
    onRejected: callback,
    onFulfilled: callback
  });
  return this;
};

/**
 * Adds a callback that will be invoked only if the Promise is rejected. This
 * is equivalent to {@code then(null, onRejected)}.
 *
 * @param {!function(this:THIS, *): *} onRejected A function that will be
 *     invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise} A new Promise that will receive the result of the
 *     callback.
 * @template THIS
 */
CancellablePromise.prototype.thenCatch = function (onRejected, opt_context) {
  return this.addChildPromise_(null, onRejected, opt_context);
};

/**
 * Alias of {@link CancellablePromise.prototype.thenCatch}
 */
CancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;

/**
 * Cancels the Promise if it is still pending by rejecting it with a cancel
 * Error. No action is performed if the Promise is already resolved.
 *
 * All child Promises of the canceled Promise will be rejected with the same
 * cancel error, as with normal Promise rejection. If the Promise to be canceled
 * is the only child of a pending Promise, the parent Promise will also be
 * canceled. Cancellation may propagate upward through multiple generations.
 *
 * @param {string=} opt_message An optional debugging message for describing the
 *     cancellation reason.
 */
CancellablePromise.prototype.cancel = function (opt_message) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    async.run(function () {
      var err = new CancellablePromise.CancellationError(opt_message);
      err.IS_CANCELLATION_ERROR = true;
      this.cancelInternal_(err);
    }, this);
  }
};

/**
 * Cancels this Promise with the given error.
 *
 * @param {!Error} err The cancellation error.
 * @private
 */
CancellablePromise.prototype.cancelInternal_ = function (err) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    if (this.parent_) {
      // Cancel the Promise and remove it from the parent's child list.
      this.parent_.cancelChild_(this, err);
    } else {
      this.resolve_(CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Cancels a child Promise from the list of callback entries. If the Promise has
 * not already been resolved, reject it with a cancel error. If there are no
 * other children in the list of callback entries, propagate the cancellation
 * by canceling this Promise as well.
 *
 * @param {!CancellablePromise} childPromise The Promise to cancel.
 * @param {!Error} err The cancel error to use for rejecting the Promise.
 * @private
 */
CancellablePromise.prototype.cancelChild_ = function (childPromise, err) {
  if (!this.callbackEntries_) {
    return;
  }
  var childCount = 0;
  var childIndex = -1;

  // Find the callback entry for the childPromise, and count whether there are
  // additional child Promises.
  for (var i = 0, entry; entry = this.callbackEntries_[i]; i++) {
    var child = entry.child;
    if (child) {
      childCount++;
      if (child === childPromise) {
        childIndex = i;
      }
      if (childIndex >= 0 && childCount > 1) {
        break;
      }
    }
  }

  // If the child Promise was the only child, cancel this Promise as well.
  // Otherwise, reject only the child Promise with the cancel error.
  if (childIndex >= 0) {
    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {
      this.cancelInternal_(err);
    } else {
      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];
      this.executeCallback_(callbackEntry, CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Adds a callback entry to the current Promise, and schedules callback
 * execution if the Promise has already been resolved.
 *
 * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing
 *     {@code onFulfilled} and {@code onRejected} callbacks to execute after
 *     the Promise is resolved.
 * @private
 */
CancellablePromise.prototype.addCallbackEntry_ = function (callbackEntry) {
  if ((!this.callbackEntries_ || !this.callbackEntries_.length) && (this.state_ === CancellablePromise.State_.FULFILLED || this.state_ === CancellablePromise.State_.REJECTED)) {
    this.scheduleCallbacks_();
  }
  if (!this.callbackEntries_) {
    this.callbackEntries_ = [];
  }
  this.callbackEntries_.push(callbackEntry);
};

/**
 * Creates a child Promise and adds it to the callback entry list. The result of
 * the child Promise is determined by the state of the parent Promise and the
 * result of the {@code onFulfilled} or {@code onRejected} callbacks as
 * specified in the Promise resolution procedure.
 *
 * @see http://promisesaplus.com/#the__method
 *
 * @param {?function(this:THIS, TYPE):
 *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that
 *     will be invoked if the Promise is fullfilled, or null.
 * @param {?function(this:THIS, *): *} onRejected A callback that will be
 *     invoked if the Promise is rejected, or null.
 * @param {THIS=} opt_context An optional execution context for the callbacks.
 *     in the default calling context.
 * @return {!CancellablePromise} The child Promise.
 * @template RESULT,THIS
 * @private
 */
CancellablePromise.prototype.addChildPromise_ = function (onFulfilled, onRejected, opt_context) {

  var callbackEntry = {
    child: null,
    onFulfilled: null,
    onRejected: null
  };

  callbackEntry.child = new CancellablePromise(function (resolve, reject) {
    // Invoke onFulfilled, or resolve with the parent's value if absent.
    callbackEntry.onFulfilled = onFulfilled ? function (value) {
      try {
        var result = onFulfilled.call(opt_context, value);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    } : resolve;

    // Invoke onRejected, or reject with the parent's reason if absent.
    callbackEntry.onRejected = onRejected ? function (reason) {
      try {
        var result = onRejected.call(opt_context, reason);
        if (!isDef(result) && reason.IS_CANCELLATION_ERROR) {
          // Propagate cancellation to children if no other result is returned.
          reject(reason);
        } else {
          resolve(result);
        }
      } catch (err) {
        reject(err);
      }
    } : reject;
  });

  callbackEntry.child.parent_ = this;
  this.addCallbackEntry_(
  /** @type {CancellablePromise.CallbackEntry_} */callbackEntry);
  return callbackEntry.child;
};

/**
 * Unblocks the Promise and fulfills it with the given value.
 *
 * @param {TYPE} value
 * @private
 */
CancellablePromise.prototype.unblockAndFulfill_ = function (value) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.FULFILLED, value);
};

/**
 * Unblocks the Promise and rejects it with the given rejection reason.
 *
 * @param {*} reason
 * @private
 */
CancellablePromise.prototype.unblockAndReject_ = function (reason) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.REJECTED, reason);
};

/**
 * Attempts to resolve a Promise with a given resolution state and value. This
 * is a no-op if the given Promise has already been resolved.
 *
 * If the given result is a Thenable (such as another Promise), the Promise will
 * be resolved with the same state and result as the Thenable once it is itself
 * resolved.
 *
 * If the given result is not a Thenable, the Promise will be fulfilled or
 * rejected with that result based on the given state.
 *
 * @see http://promisesaplus.com/#the_promise_resolution_procedure
 *
 * @param {CancellablePromise.State_} state
 * @param {*} x The result to apply to the Promise.
 * @private
 */
CancellablePromise.prototype.resolve_ = function (state, x) {
  if (this.state_ !== CancellablePromise.State_.PENDING) {
    return;
  }

  if (this === x) {
    state = CancellablePromise.State_.REJECTED;
    x = new TypeError('CancellablePromise cannot resolve to itself');
  } else if (Thenable.isImplementedBy(x)) {
    x = /** @type {!Thenable} */x;
    this.state_ = CancellablePromise.State_.BLOCKED;
    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);
    return;
  } else if (isObject(x)) {
    try {
      var then = x.then;
      if (isFunction(then)) {
        this.tryThen_(x, then);
        return;
      }
    } catch (e) {
      state = CancellablePromise.State_.REJECTED;
      x = e;
    }
  }

  this.result_ = x;
  this.state_ = state;
  this.scheduleCallbacks_();

  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {
    CancellablePromise.addUnhandledRejection_(this, x);
  }
};

/**
 * Attempts to call the {@code then} method on an object in the hopes that it is
 * a Promise-compatible instance. This allows interoperation between different
 * Promise implementations, however a non-compliant object may cause a Promise
 * to hang indefinitely. If the {@code then} method throws an exception, the
 * dependent Promise will be rejected with the thrown value.
 *
 * @see http://promisesaplus.com/#point-70
 *
 * @param {Thenable} thenable An object with a {@code then} method that may be
 *     compatible with the Promise/A+ specification.
 * @param {!Function} then The {@code then} method of the Thenable object.
 * @private
 */
CancellablePromise.prototype.tryThen_ = function (thenable, then) {
  this.state_ = CancellablePromise.State_.BLOCKED;
  var promise = this;
  var called = false;

  var resolve = function resolve(value) {
    if (!called) {
      called = true;
      promise.unblockAndFulfill_(value);
    }
  };

  var reject = function reject(reason) {
    if (!called) {
      called = true;
      promise.unblockAndReject_(reason);
    }
  };

  try {
    then.call(thenable, resolve, reject);
  } catch (e) {
    reject(e);
  }
};

/**
 * Executes the pending callbacks of a resolved Promise after a timeout.
 *
 * Section 2.2.4 of the Promises/A+ specification requires that Promise
 * callbacks must only be invoked from a call stack that only contains Promise
 * implementation code, which we accomplish by invoking callback execution after
 * a timeout. If {@code startExecution_} is called multiple times for the same
 * Promise, the callback chain will be evaluated only once. Additional callbacks
 * may be added during the evaluation phase, and will be executed in the same
 * event loop.
 *
 * All Promises added to the waiting list during the same browser event loop
 * will be executed in one batch to avoid using a separate timeout per Promise.
 *
 * @private
 */
CancellablePromise.prototype.scheduleCallbacks_ = function () {
  if (!this.executing_) {
    this.executing_ = true;
    async.run(this.executeCallbacks_, this);
  }
};

/**
 * Executes all pending callbacks for this Promise.
 *
 * @private
 */
CancellablePromise.prototype.executeCallbacks_ = function () {
  while (this.callbackEntries_ && this.callbackEntries_.length) {
    var entries = this.callbackEntries_;
    this.callbackEntries_ = [];

    for (var i = 0; i < entries.length; i++) {
      this.executeCallback_(entries[i], this.state_, this.result_);
    }
  }
  this.executing_ = false;
};

/**
 * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}
 * or {@code onRejected} callback based on the resolved state of the Promise.
 *
 * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the
 *     onFulfilled and/or onRejected callbacks for this step.
 * @param {CancellablePromise.State_} state The resolution status of the Promise,
 *     either FULFILLED or REJECTED.
 * @param {*} result The resolved result of the Promise.
 * @private
 */
CancellablePromise.prototype.executeCallback_ = function (callbackEntry, state, result) {
  if (state === CancellablePromise.State_.FULFILLED) {
    callbackEntry.onFulfilled(result);
  } else {
    this.removeUnhandledRejection_();
    callbackEntry.onRejected(result);
  }
};

/**
 * Marks this rejected Promise as having being handled. Also marks any parent
 * Promises in the rejected state as handled. The rejection handler will no
 * longer be invoked for this Promise (if it has not been called already).
 *
 * @private
 */
CancellablePromise.prototype.removeUnhandledRejection_ = function () {
  var p;
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {
      clearTimeout(p.unhandledRejectionId_);
      p.unhandledRejectionId_ = 0;
    }
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
      p.hadUnhandledRejection_ = false;
    }
  }
};

/**
 * Marks this rejected Promise as unhandled. If no {@code onRejected} callback
 * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}
 * expires, the reason will be passed to the unhandled rejection handler. The
 * handler typically rethrows the rejection reason so that it becomes visible in
 * the developer console.
 *
 * @param {!CancellablePromise} promise The rejected Promise.
 * @param {*} reason The Promise rejection reason.
 * @private
 */
CancellablePromise.addUnhandledRejection_ = function (promise, reason) {
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    promise.unhandledRejectionId_ = setTimeout(function () {
      CancellablePromise.handleRejection_.call(null, reason);
    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    promise.hadUnhandledRejection_ = true;
    async.run(function () {
      if (promise.hadUnhandledRejection_) {
        CancellablePromise.handleRejection_.call(null, reason);
      }
    });
  }
};

/**
 * A method that is invoked with the rejection reasons for Promises that are
 * rejected but have no {@code onRejected} callbacks registered yet.
 * @type {function(*)}
 * @private
 */
CancellablePromise.handleRejection_ = async.throwException;

/**
 * Sets a handler that will be called with reasons from unhandled rejected
 * Promises. If the rejected Promise (or one of its descendants) has an
 * {@code onRejected} callback registered, the rejection will be considered
 * handled, and the rejection handler will not be called.
 *
 * By default, unhandled rejections are rethrown so that the error may be
 * captured by the developer console or a {@code window.onerror} handler.
 *
 * @param {function(*)} handler A function that will be called with reasons from
 *     rejected Promises. Defaults to {@code async.throwException}.
 */
CancellablePromise.setUnhandledRejectionHandler = function (handler) {
  CancellablePromise.handleRejection_ = handler;
};

/**
 * Error used as a rejection reason for canceled Promises.
 *
 * @param {string=} opt_message
 * @constructor
 * @extends {Error}
 * @final
 */
CancellablePromise.CancellationError = function (_Error) {
  inherits(_class, _Error);

  function _class(opt_message) {
    classCallCheck(this, _class);

    var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, opt_message));

    if (opt_message) {
      _this.message = opt_message;
    }
    return _this;
  }

  return _class;
}(Error);

/** @override */
CancellablePromise.CancellationError.prototype.name = 'cancel';

var Ajax = function () {
	function Ajax() {
		classCallCheck(this, Ajax);
	}

	createClass(Ajax, null, [{
		key: 'parseResponseHeaders',


		/**
   * XmlHttpRequest's getAllResponseHeaders() method returns a string of
   * response headers according to the format described on the spec:
   * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}.
   * This method parses that string into a user-friendly name/value pair
   * object.
   * @param {string} allHeaders All headers as string.
   * @return {!Array.<Object<string, string>>}
   */
		value: function parseResponseHeaders(allHeaders) {
			var headers = [];
			if (!allHeaders) {
				return headers;
			}
			var pairs = allHeaders.split('\r\n');
			for (var i = 0; i < pairs.length; i++) {
				var index = pairs[i].indexOf(': ');
				if (index > 0) {
					var name = pairs[i].substring(0, index);
					var value = pairs[i].substring(index + 2);
					headers.push({
						name: name,
						value: value
					});
				}
			}
			return headers;
		}

		/**
   * Requests the url using XMLHttpRequest.
   * @param {!string} url
   * @param {!string} method
   * @param {?string} body
   * @param {MultiMap=} opt_headers
   * @param {MultiMap=} opt_params
   * @param {number=} opt_timeout
   * @param {boolean=} opt_sync
   * @param {boolean=} opt_withCredentials
   * @return {Promise} Deferred ajax request.
   * @protected
   */

	}, {
		key: 'request',
		value: function request(url, method, body, opt_headers, opt_params, opt_timeout, opt_sync, opt_withCredentials) {
			url = url || '';
			method = method || 'GET';

			var request = new XMLHttpRequest();

			var promise = new CancellablePromise(function (resolve, reject) {
				request.onload = function () {
					if (request.aborted) {
						request.onerror();
						return;
					}
					resolve(request);
				};
				request.onerror = function () {
					var error = new Error('Request error');
					error.request = request;
					reject(error);
				};
			}).thenCatch(function (reason) {
				request.abort();
				throw reason;
			}).thenAlways(function () {
				clearTimeout(timeout);
			});

			if (opt_params) {
				url = new Uri(url).addParametersFromMultiMap(opt_params).toString();
			}

			request.open(method, url, !opt_sync);

			if (opt_withCredentials) {
				request.withCredentials = true;
			}

			if (opt_headers) {
				opt_headers.names().forEach(function (name) {
					request.setRequestHeader(name, opt_headers.getAll(name).join(', '));
				});
			}

			request.send(isDef(body) ? body : null);

			if (isDefAndNotNull(opt_timeout)) {
				var timeout = setTimeout(function () {
					promise.cancel('Request timeout');
				}, opt_timeout);
			}

			return promise;
		}
	}]);
	return Ajax;
}();

/**
 * Provides a convenient interface for data transport.
 * @interface
 */

var Transport = function () {
	function Transport() {
		classCallCheck(this, Transport);
	}

	createClass(Transport, [{
		key: 'send',


		/**
   * Sends a message for the specified client.
   * @param {!ClientRequest} clientRequest
   * @return {!Promise} Deferred request.
   */
		value: function send() {}
	}]);
	return Transport;
}();

/**
 * Represents a client message (e.g. a request or a response).
 */

var ClientMessage = function () {
	function ClientMessage() {
		classCallCheck(this, ClientMessage);

		this.headers_ = new MultiMap();
	}

	/**
  * Fluent getter and setter for request body.
  * @param {*=} opt_body Request body to be set. If none is given,
  *   the current value of the body will be returned.
  * @return {*} Returns request body if no body value was given. Otherwise
  *   returns the {@link ClientMessage} object itself, so calls can be chained.
  * @chainable Chainable when used as setter.
  */


	createClass(ClientMessage, [{
		key: 'body',
		value: function body(opt_body) {
			if (isDef(opt_body)) {
				this.body_ = opt_body;
				return this;
			}
			return this.body_;
		}

		/**
   * Adds a header. If a header with the same name already exists, it will not be
   * overwritten, but the new value will be stored as well. The order is preserved.
   * @param {string} name
   * @param {string} value
   * @chainable
   */

	}, {
		key: 'header',
		value: function header(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.headers_.set(name, value);
			return this;
		}

		/**
   * Fluent getter and setter for request headers.
   * @param {MultiMap|Object=} opt_headers Request headers list to
   *   be set. If none is given the current value of the headers will
   *   be returned.
   * @return {!MultiMap|ClientMessage} Returns map of request headers
   *   if no new value was given. Otherwise returns the {@link ClientMessage}
   *   object itself, so calls can be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'headers',
		value: function headers(opt_headers) {
			if (isDef(opt_headers)) {
				if (opt_headers instanceof MultiMap) {
					this.headers_ = opt_headers;
				} else {
					this.headers_.values = opt_headers;
				}
				return opt_headers;
			}
			return this.headers_;
		}

		/**
   * Removes the body.
   */

	}, {
		key: 'removeBody',
		value: function removeBody() {
			this.body_ = undefined;
		}
	}]);
	return ClientMessage;
}();

/**
 * Represents a client response object.
 * @extends {ClientMessage}
 */

var ClientResponse = function (_ClientMessage) {
	inherits(ClientResponse, _ClientMessage);

	function ClientResponse(clientRequest) {
		classCallCheck(this, ClientResponse);

		var _this = possibleConstructorReturn(this, (ClientResponse.__proto__ || Object.getPrototypeOf(ClientResponse)).call(this));

		if (!clientRequest) {
			throw new Error('Can\'t create response without request');
		}
		_this.clientRequest_ = clientRequest;
		return _this;
	}

	/**
  * Returns request that created this response.
  * @return {!ClientRequest}
  */


	createClass(ClientResponse, [{
		key: 'request',
		value: function request() {
			return this.clientRequest_;
		}

		/**
   * Fluent getter and setter for response status code.
   * @param {number=} opt_statusCode Request status code to be set. If none is given,
   *   the current status code value will be returned.
   * @return {!ClientMessage|number} Returns response status code if no new value was
   *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
   *   be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'statusCode',
		value: function statusCode(opt_statusCode) {
			if (isDef(opt_statusCode)) {
				this.statusCode_ = opt_statusCode;
				return this;
			}
			return this.statusCode_;
		}

		/**
   * Fluent getter and setter for response status text.
   * @param {string=} opt_statusText Request status text to be set. If none is given,
   *   the current status text value will be returned.
   * @return {!ClientMessage|number} Returns response status text if no new value was
   *   given. Otherwise returns the {@link ClientMessage} object itself, so calls can
   *   be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'statusText',
		value: function statusText(opt_statusText) {
			if (isDef(opt_statusText)) {
				this.statusText_ = opt_statusText;
				return this;
			}
			return this.statusText_;
		}

		/**
   * Checks if response succeeded. Any status code 2xx or 3xx is considered valid.
   * @return {boolean}
   */

	}, {
		key: 'succeeded',
		value: function succeeded() {
			return this.statusCode() >= 200 && this.statusCode() <= 399;
		}
	}]);
	return ClientResponse;
}(ClientMessage);

/**
 * The implementation of an ajax transport to be used with {@link WeDeploy}.
 * @extends {Transport}
 */

var AjaxTransport = function (_Transport) {
	inherits(AjaxTransport, _Transport);

	function AjaxTransport() {
		classCallCheck(this, AjaxTransport);
		return possibleConstructorReturn(this, (AjaxTransport.__proto__ || Object.getPrototypeOf(AjaxTransport)).apply(this, arguments));
	}

	createClass(AjaxTransport, [{
		key: 'send',

		/**
   * @inheritDoc
   */
		value: function send(clientRequest) {
			var deferred = Ajax.request(clientRequest.url(), clientRequest.method(), clientRequest.body(), clientRequest.headers(), clientRequest.params(), null, false, clientRequest.withCredentials());

			return deferred.then(function (response) {
				var clientResponse = new ClientResponse(clientRequest);
				clientResponse.body(response.responseText);
				clientResponse.statusCode(response.status);
				clientResponse.statusText(response.statusText);
				Ajax.parseResponseHeaders(response.getAllResponseHeaders()).forEach(function (header) {
					clientResponse.header(header.name, header.value);
				});
				return clientResponse;
			});
		}
	}]);
	return AjaxTransport;
}(Transport);

/**
 * Provides a factory for data transport.
 */

var TransportFactory = function () {
	function TransportFactory() {
		classCallCheck(this, TransportFactory);

		this.transports = {};
		this.transports[TransportFactory.DEFAULT_TRANSPORT_NAME] = TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME];
	}

	/**
  * Returns {@link TransportFactory} instance.
  */


	createClass(TransportFactory, [{
		key: 'get',


		/**
   * Gets an instance of the transport implementation with the given name.
   * @param {string} implementationName
   * @return {!Transport}
   */
		value: function get(implementationName) {
			var TransportClass = this.transports[implementationName];

			if (!TransportClass) {
				throw new Error('Invalid transport name: ' + implementationName);
			}

			try {
				return new TransportClass();
			} catch (err) {
				throw new Error('Can\'t create transport', err);
			}
		}

		/**
   * Returns the default transport implementation.
   * @return {!Transport}
   */

	}, {
		key: 'getDefault',
		value: function getDefault() {
			return this.get(TransportFactory.DEFAULT_TRANSPORT_NAME);
		}
	}], [{
		key: 'instance',
		value: function instance() {
			if (!TransportFactory.instance_) {
				TransportFactory.instance_ = new TransportFactory();
			}
			return TransportFactory.instance_;
		}
	}]);
	return TransportFactory;
}();

TransportFactory.DEFAULT_TRANSPORT_NAME = 'default';

TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME] = AjaxTransport;

/**
 * Represents a client request object.
 * @extends {ClientMessage}
 */

var ClientRequest = function (_ClientMessage) {
	inherits(ClientRequest, _ClientMessage);

	function ClientRequest() {
		classCallCheck(this, ClientRequest);

		var _this = possibleConstructorReturn(this, (ClientRequest.__proto__ || Object.getPrototypeOf(ClientRequest)).call(this));

		_this.params_ = new MultiMap();
		_this.withCredentials_ = true;
		return _this;
	}

	/**
  * Fluent getter and setter for with credentials option.
  * @param {boolean=} opt_withCredentials
  * @chainable Chainable when used as setter.
  */


	createClass(ClientRequest, [{
		key: 'withCredentials',
		value: function withCredentials(opt_withCredentials) {
			if (isDef(opt_withCredentials)) {
				this.withCredentials_ = !!opt_withCredentials;
				return this;
			}
			return this.withCredentials_;
		}

		/**
   * Fluent getter and setter for request method.
   * @param {string=} opt_method Request method to be set. If none is given,
   *   the current method value will be returned.
   * @return {!ClientMessage|string} Returns request method if no new value was
   *   given. Otherwise returns the {@link ClientMessage} object itself, so
   *   calls can be chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'method',
		value: function method(opt_method) {
			if (isDef(opt_method)) {
				this.method_ = opt_method;
				return this;
			}
			return this.method_ || ClientRequest.DEFAULT_METHOD;
		}

		/**
   * Adds a query. If a query with the same name already exists, it will not
   * be overwritten, but new value will be stored as well. The order is preserved.
   * @param {string} name
   * @param {string} value
   * @chainable
   */

	}, {
		key: 'param',
		value: function param(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.params_.set(name, value);
			return this;
		}

		/**
   * Fluent getter and setter for request querystring.
   * @param {MultiMap|Object=} opt_params Request querystring map to be set.
   *   If none is given the current value of the params will be returned.
   * @return {!MultiMap|ClientMessage} Returns map of request querystring if
   *   no new value was given. Otherwise returns the {@link ClientMessage}
   *   object itself, so calls can be chained.
   */

	}, {
		key: 'params',
		value: function params(opt_params) {
			if (isDef(opt_params)) {
				if (opt_params instanceof MultiMap) {
					this.params_ = opt_params;
				} else {
					this.params_.values = opt_params;
				}
				return opt_params;
			}
			return this.params_;
		}

		/**
   * Fluent getter and setter for request url.
   * @param {string=} opt_url Request url to be set. If none is given,
   *   the current value of the url will be returned.
   * @return {!ClientMessage|string} Returns request url if no new value was given.
   *   Otherwise returns the {@link ClientMessage} object itself, so calls can be
   *   chained.
   * @chainable Chainable when used as setter.
   */

	}, {
		key: 'url',
		value: function url(opt_url) {
			if (isDef(opt_url)) {
				this.url_ = opt_url;
				return this;
			}
			return this.url_;
		}
	}]);
	return ClientRequest;
}(ClientMessage);

ClientRequest.DEFAULT_METHOD = 'GET';

var io;

// Optimistic initialization of `io` reference from global `globals.window.io`.
if (typeof globals.window !== 'undefined') {
	io = globals.window.io;
}

/**
 * The main class for making api requests. Sending requests returns a promise
 * that is resolved when the response arrives. Usage example:
 * ```javascript
 * WeDeploy
 *   .url('/data/tasks')
 *   .post({desc: 'Buy milkl'})
 *   .then(function(response) {
 *     // Handle response here.
 *     console.log(response.body())
 *   });
 * ```
 */

var WeDeploy = function () {
	/**
  * WeDeploy constructor function.
  * @param {string} url The base url.
  * @param {...string} paths Any amount of paths to be appended to the base
  * url.
  * @constructor
  */
	function WeDeploy(url) {
		for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			paths[_key - 1] = arguments[_key];
		}

		classCallCheck(this, WeDeploy);

		if (arguments.length === 0) {
			throw new Error('Invalid arguments, try `new WeDeploy(baseUrl, url)`');
		}

		this.auth_ = null;
		this.body_ = null;
		this.url_ = Uri.joinPaths.apply(Uri, [url || ''].concat(paths));
		this.headers_ = new MultiMap();
		this.params_ = new MultiMap();
		this.withCredentials_ = true;

		this.header('Content-Type', 'application/json');
		this.header('X-Requested-With', 'XMLHttpRequest');
	}

	/**
  * Static factory for creating WeDeploy data for the given url.
  * @param {string=} opt_dataUrl The url that points to the data services.
  * @return @return {data} WeDeploy data instance.
  */


	createClass(WeDeploy, [{
		key: 'auth',


		/**
   * Adds authorization information to this request.
   * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
   * an authorization token, or the email.
   * @param {string=} opt_password If a email is given as the first param,
   * this should be the password.
   * @chainable
   */
		value: function auth(authOrTokenOrEmail, opt_password) {
			this.auth_ = authOrTokenOrEmail;
			if (!(this.auth_ instanceof Auth)) {
				this.auth_ = Auth.create(authOrTokenOrEmail, opt_password);
			}
			return this;
		}

		/**
   * Static factory for creating WeDeploy auth for the given url.
   * @param {string=} opt_authUrl The url that points to the auth service.
   */

	}, {
		key: 'body',


		/**
   * Sets the body that will be sent with this request.
   * @param {*} body
   * @chainable
   */
		value: function body(_body) {
			this.body_ = _body;
			return this;
		}

		/**
   * Converts the given body object to query params.
   * @param {!ClientRequest} clientRequest Client request.
   * @param {*} body
   * @protected
   */

	}, {
		key: 'convertBodyToParams_',
		value: function convertBodyToParams_(clientRequest, body) {
			if (isString(body)) {
				body = {
					body: body
				};
			} else if (body instanceof Embodied) {
				body = body.body();
			}
			Object.keys(body || {}).forEach(function (name) {
				return clientRequest.param(name, body[name]);
			});
		}

		/**
   * Creates client request and encode.
   * @param {string} method
   * @param {*} body
   * @return {!ClientRequest} Client request.
   * @protected
   */

	}, {
		key: 'createClientRequest_',
		value: function createClientRequest_(method, body) {
			var clientRequest = new ClientRequest();

			clientRequest.body(body || this.body_);

			if (!isDefAndNotNull(clientRequest.body())) {
				if (this.formData_) {
					clientRequest.body(this.formData_);
				}
			}

			clientRequest.method(method);
			clientRequest.headers(this.headers());
			clientRequest.params(this.params());
			clientRequest.url(this.url());
			clientRequest.withCredentials(this.withCredentials_);

			this.encode(clientRequest);

			return clientRequest;
		}

		/**
   * Decodes clientResponse body, parsing the body for example.
   * @param {!ClientResponse} clientResponse The response object to be
   * decoded.
   * @return {!ClientResponse} The decoded response.
   */

	}, {
		key: 'decode',
		value: function decode(clientResponse) {
			if (WeDeploy.isContentTypeJson(clientResponse)) {
				try {
					clientResponse.body(JSON.parse(clientResponse.body()));
				} catch (err) {}
			}
			return clientResponse;
		}

		/**
   * Sends message with the DELETE http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'delete',
		value: function _delete(opt_body) {
			return this.sendAsync('DELETE', opt_body);
		}

		/**
   * Encodes the given {@link ClientRequest}, converting its body to an
   * appropriate format for example.
   * @param {!ClientRequest} clientRequest The request object to encode.
   * @return {!ClientRequest} The encoded request.
   */

	}, {
		key: 'encode',
		value: function encode(clientRequest) {
			var body = clientRequest.body();

			if (isElement(body)) {
				body = new FormData(body);
				clientRequest.body(body);
			}

			body = this.maybeWrapWithQuery_(body);
			if (clientRequest.method() === 'GET') {
				this.convertBodyToParams_(clientRequest, body);
				clientRequest.removeBody();
				body = null;
			}

			if (typeof FormData !== 'undefined' && body instanceof FormData) {
				clientRequest.headers().remove('content-type');
			} else if (body instanceof Embodied) {
				clientRequest.body(body.toString());
			} else if (WeDeploy.isContentTypeJson(clientRequest)) {
				clientRequest.body(JSON.stringify(clientRequest.body()));
			}

			this.encodeParams_(clientRequest);
			this.resolveAuthentication_(clientRequest);

			return clientRequest;
		}

		/**
   * Encodes the params for the given request, according to their types.
   * @param {!ClientRequest} clientRequest
   * @protected
   */

	}, {
		key: 'encodeParams_',
		value: function encodeParams_(clientRequest) {
			var params = clientRequest.params();
			params.names().forEach(function (name) {
				var values = params.getAll(name);
				values.forEach(function (value, index) {
					if (value instanceof Embodied) {
						value = value.toString();
					} else if (isObject(value) || value instanceof Array) {
						value = JSON.stringify(value);
					}
					values[index] = value;
				});
			});
		}

		/**
   * Adds a key/value pair to be sent via the body in a `multipart/form-data` format.
   * If the body is set by other means (for example, through the `body` method), this
   * will be ignored.
   * @param {string} name
   * @param {*} value
   * @chainable
   */

	}, {
		key: 'form',
		value: function form(name, value) {
			if (typeof FormData === 'undefined') {
				throw new Error('form() is only available when FormData API is available.');
			}

			if (!this.formData_) {
				this.formData_ = new FormData();
			}
			this.formData_.append(name, value);
			return this;
		}

		/**
   * Sends message with the GET http verb.
   * @param {*=} opt_params Params to be added to the request url.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'get',
		value: function get(opt_params) {
			return this.sendAsync('GET', opt_params);
		}

		/**
   * Adds a header. If the header with the same name already exists, it will
   * not be overwritten, but new value will be stored. The order is preserved.
   * @param {string} name Header key.
   * @param {*} value Header value.
   * @chainable
   */

	}, {
		key: 'header',
		value: function header(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.headers_.set(name, value);
			return this;
		}

		/**
   * Gets the headers.
   * @return {!MultiMap}
   */

	}, {
		key: 'headers',
		value: function headers() {
			return this.headers_;
		}

		/**
   * Wraps the given `Embodied` instance with a {@link Query} instance if needed.
   * @param {Embodied} embodied
   * @return {Embodied}
   * @protected
   */

	}, {
		key: 'maybeWrapWithQuery_',
		value: function maybeWrapWithQuery_(embodied) {
			if (embodied instanceof Filter) {
				embodied = Query.filter(embodied);
			}
			return embodied;
		}

		/**
   * Adds a query. If the query with the same name already exists, it will not
   * be overwritten, but new value will be stored. The order is preserved.
   * @param {string} name Param key.
   * @param {*} value Param value.
   * @chainable
   */

	}, {
		key: 'param',
		value: function param(name, value) {
			if (arguments.length !== 2) {
				throw new Error('Invalid arguments');
			}
			this.params_.set(name, value);
			return this;
		}

		/**
   * Gets the query strings map.
   * @return {!MultiMap}
   */

	}, {
		key: 'params',
		value: function params() {
			return this.params_;
		}

		/**
   * Sends message with the PATCH http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'patch',
		value: function patch(opt_body) {
			return this.sendAsync('PATCH', opt_body);
		}

		/**
   * Creates a new {@link WeDeploy} instance for handling the url resulting in the
   * union of the current url with the given paths.
   * @param {...string} paths Any number of paths.
   * @return {!WeDeploy} A new {@link WeDeploy} instance for handling the given paths.
   */

	}, {
		key: 'path',
		value: function path() {
			for (var _len2 = arguments.length, paths = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				paths[_key2] = arguments[_key2];
			}

			return new (Function.prototype.bind.apply(WeDeploy, [null].concat([this.url()], paths)))().use(this.customTransport_);
		}

		/**
   * Sends message with the POST http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'post',
		value: function post(opt_body) {
			return this.sendAsync('POST', opt_body);
		}

		/**
   * Sends message with the PUT http verb.
   * @param {string=} opt_body Content to be sent as the request's body.
   * @return {!CancellablePromise}
   */

	}, {
		key: 'put',
		value: function put(opt_body) {
			return this.sendAsync('PUT', opt_body);
		}

		/**
   * Adds the authentication information to the request.
   * @param {!ClientRequest} clientRequest
   * @protected
   */

	}, {
		key: 'resolveAuthentication_',
		value: function resolveAuthentication_(clientRequest) {
			if (!this.auth_) {
				return;
			}
			if (this.auth_.hasToken()) {
				clientRequest.header('Authorization', 'Bearer ' + this.auth_.token);
			} else {
				var credentials = this.auth_.email + ':' + this.auth_.password;
				clientRequest.header('Authorization', 'Basic ' + Base64.encodeString(credentials));
			}
		}

		/**
   * Uses transport to send request with given method name and body
   * asynchronously.
   * @param {string} method The HTTP method to be used when sending data.
   * @param {string} body Content to be sent as the request's body.
   * @return {!CancellablePromise} Deferred request.
   */

	}, {
		key: 'sendAsync',
		value: function sendAsync(method, body) {
			var transport = this.customTransport_ || TransportFactory.instance().getDefault();

			var clientRequest = this.createClientRequest_(method, body);

			return transport.send(clientRequest).then(this.decode);
		}

		/**
   * Sets the socket transport
   * @param {Object} socket implementation object.
   */

	}, {
		key: 'url',


		/**
   * Returns the URL used by this client.
   */
		value: function url() {
			return this.url_;
		}

		/**
   * Specifies {@link Transport} implementation.
   * @param {!Transport} transport The transport implementation that should be
   * used.
   */

	}, {
		key: 'use',
		value: function use(transport) {
			this.customTransport_ = transport;
			return this;
		}

		/**
   * Creates new socket.io instance. The parameters passed to socket.io
   * constructor will be provided:
   *
   * ```javascript
   * WeDeploy.url('http://domain:8080/path/a').watch({id: 'myId'}, {foo: true});
   * // Equals:
   * io('domain:8080/?url=path%2Fa%3Fid%3DmyId', {foo: true});
   * ```
   *
   * @param {Object=} opt_params Params to be sent with the Socket IO request.
   * @param {Object=} opt_options Object with Socket IO options.
   * @return {!io} Socket IO reference. Server events can be listened on it.
   */

	}, {
		key: 'watch',
		value: function watch(opt_params, opt_options) {
			if (typeof io === 'undefined') {
				throw new Error('Socket.io client not loaded');
			}

			var clientRequest = this.createClientRequest_('GET', opt_params);
			var uri = new Uri(clientRequest.url());
			uri.addParametersFromMultiMap(clientRequest.params());

			opt_options = opt_options || {
				forceNew: true
			};
			opt_options.query = 'url=' + encodeURIComponent(uri.getPathname() + uri.getSearch());
			opt_options.path = opt_options.path || uri.getPathname();

			return io(uri.getHost(), opt_options);
		}

		/**
   * @param {boolean} opt_withCredentials
   */

	}, {
		key: 'withCredentials',
		value: function withCredentials(_withCredentials) {
			this.withCredentials_ = !!_withCredentials;
			return this;
		}
	}], [{
		key: 'data',
		value: function data(opt_dataUrl) {
			assertUriWithNoPath(opt_dataUrl, 'The data url should not have a path');

			if (isString(opt_dataUrl)) {
				WeDeploy.dataUrl_ = opt_dataUrl;
			}

			var data = new DataApiHelper(WeDeploy);

			data.auth(WeDeploy.auth().currentUser);

			return data;
		}
	}, {
		key: 'auth',
		value: function auth(opt_authUrl) {
			if (isString(opt_authUrl)) {
				WeDeploy.authUrl_ = opt_authUrl;
			}
			if (!WeDeploy.auth_) {
				WeDeploy.auth_ = new AuthApiHelper(WeDeploy);
			}
			return WeDeploy.auth_;
		}
	}, {
		key: 'socket',
		value: function socket(_socket) {
			io = _socket;
		}

		/**
   * Static factory for creating WeDeploy client for the given url.
   * @param {string} url The url that the client should use for sending requests.
   */

	}, {
		key: 'url',
		value: function url(_url) {
			return new WeDeploy(_url).use(this.customTransport_);
		}
	}]);
	return WeDeploy;
}();

WeDeploy.isContentTypeJson = function (clientMessage) {
	var contentType = clientMessage.headers().get('content-type') || '';
	return contentType.indexOf('application/json') === 0;
};

WeDeploy.auth_ = null;
WeDeploy.authUrl_ = '';
WeDeploy.data_ = null;
WeDeploy.dataUrl_ = '';

globals.window.Filter = Filter;
globals.window.Geo = Geo;
globals.window.Query = Query;
globals.window.Range = Range;
globals.window.WeDeploy = WeDeploy;

})));



//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNvY2tldC5pby5qcyIsIi9zb3VyY2Uvc3JjL2dsb2JhbHMvZ2xvYmFscy5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsL3NyYy9jb3JlTmFtZWQuanMiLCIvc291cmNlL25vZGVfbW9kdWxlcy9tZXRhbC9zcmMvY29yZS5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsL3NyYy9hcnJheS9hcnJheS5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsL3NyYy9hc3luYy9hc3luYy5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsL3NyYy9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanMiLCIvc291cmNlL25vZGVfbW9kdWxlcy9tZXRhbC9zcmMvb2JqZWN0L29iamVjdC5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsL3NyYy9zdHJpbmcvc3RyaW5nLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L0VtYm9kaWVkLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L0ZpbHRlckJvZHkuanMiLCIvc291cmNlL3NyYy9hcGktcXVlcnkvR2VvLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L1JhbmdlLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L0ZpbHRlci5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXVyaS9zcmMvcGFyc2VGcm9tQW5jaG9yLmpzIiwiL3NvdXJjZS9ub2RlX21vZHVsZXMvbWV0YWwtdXJpL3NyYy9wYXJzZS5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXN0cnVjdHMvc3JjL011bHRpTWFwLmpzIiwiL3NvdXJjZS9ub2RlX21vZHVsZXMvbWV0YWwtc3RydWN0cy9zcmMvVHJlZU5vZGUuanMiLCIvc291cmNlL25vZGVfbW9kdWxlcy9tZXRhbC11cmkvc3JjL1VyaS5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9hc3NlcnRpb25zLmpzIiwiL3NvdXJjZS9zcmMvYXBpL2F1dGgvQXV0aC5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9BcGlIZWxwZXIuanMiLCIvc291cmNlL3NyYy9hcGkvYXV0aC9BdXRoUHJvdmlkZXIuanMiLCIvc291cmNlL3NyYy9hcGkvYXV0aC9GYWNlYm9va0F1dGhQcm92aWRlci5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9hdXRoL0dpdGh1YkF1dGhQcm92aWRlci5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9hdXRoL0dvb2dsZUF1dGhQcm92aWRlci5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXN0b3JhZ2Uvc3JjL21lY2hhbmlzbS9TdG9yYWdlTWVjaGFuaXNtLmpzIiwiL3NvdXJjZS9ub2RlX21vZHVsZXMvbWV0YWwtc3RvcmFnZS9zcmMvU3RvcmFnZS5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXN0b3JhZ2Uvc3JjL21lY2hhbmlzbS9Mb2NhbFN0b3JhZ2VNZWNoYW5pc20uanMiLCIvc291cmNlL3NyYy9hcGkvYXV0aC9BdXRoQXBpSGVscGVyLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L0FnZ3JlZ2F0aW9uLmpzIiwiL3NvdXJjZS9zcmMvYXBpLXF1ZXJ5L1F1ZXJ5LmpzIiwiL3NvdXJjZS9zcmMvYXBpL2RhdGEvRGF0YUFwaUhlbHBlci5qcyIsIi9zb3VyY2Uvc3JjL2NyeXB0L0Jhc2U2NC5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLXByb21pc2Uvc3JjL3Byb21pc2UvUHJvbWlzZS5qcyIsIi9zb3VyY2Uvbm9kZV9tb2R1bGVzL21ldGFsLWFqYXgvc3JjL0FqYXguanMiLCIvc291cmNlL3NyYy9hcGkvVHJhbnNwb3J0LmpzIiwiL3NvdXJjZS9zcmMvYXBpL0NsaWVudE1lc3NhZ2UuanMiLCIvc291cmNlL3NyYy9hcGkvQ2xpZW50UmVzcG9uc2UuanMiLCIvc291cmNlL3NyYy9hcGkvYnJvd3Nlci9BamF4VHJhbnNwb3J0LmpzIiwiL3NvdXJjZS9zcmMvYXBpL1RyYW5zcG9ydEZhY3RvcnkuanMiLCIvc291cmNlL3NyYy9hcGkvQ2xpZW50UmVxdWVzdC5qcyIsIi9zb3VyY2Uvc3JjL2FwaS9XZURlcGxveS5qcyIsIi9zb3VyY2Uvc3JjL2Vudi9icm93c2VyLmpzIl0sIm5hbWVzIjpbImdsb2JhbHMiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNvbXBhdGliaWxpdHlNb2RlRGF0YV8iLCJ1bmlxdWVJZENvdW50ZXJfIiwiVUlEX1BST1BFUlRZIiwiTWF0aCIsInJhbmRvbSIsImFic3RyYWN0TWV0aG9kIiwiRXJyb3IiLCJjb2xsZWN0U3VwZXJDbGFzc2VzUHJvcGVydHkiLCJjb25zdHJ1Y3RvciIsInByb3BlcnR5TmFtZSIsInByb3BlcnR5VmFsdWVzIiwiX19wcm90b19fIiwiaXNQcm90b3R5cGVPZiIsIkZ1bmN0aW9uIiwicHVzaCIsImRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSIsImVuYWJsZUNvbXBhdGliaWxpdHlNb2RlIiwib3B0X2RhdGEiLCJnZXRDb21wYXRpYmlsaXR5TW9kZURhdGEiLCJfX01FVEFMX0NPTVBBVElCSUxJVFlfXyIsImdldEZ1bmN0aW9uTmFtZSIsImZuIiwibmFtZSIsInN0ciIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiaW5kZXhPZiIsImdldFVpZCIsIm9wdF9vYmplY3QiLCJvcHRfbm9Jbmhlcml0YW5jZSIsImlkIiwiaGFzT3duUHJvcGVydHkiLCJpZGVudGl0eUZ1bmN0aW9uIiwib3B0X3JldHVyblZhbHVlIiwiaXNCb29sZWFuIiwidmFsIiwiaXNEZWYiLCJ1bmRlZmluZWQiLCJpc0RlZkFuZE5vdE51bGwiLCJpc051bGwiLCJpc0RvY3VtZW50Iiwibm9kZVR5cGUiLCJpc0VsZW1lbnQiLCJpc0Z1bmN0aW9uIiwiaXNOdW1iZXIiLCJpc1dpbmRvdyIsImlzT2JqZWN0IiwidHlwZSIsImlzUHJvbWlzZSIsInRoZW4iLCJpc1N0cmluZyIsIlN0cmluZyIsIm1lcmdlU3VwZXJDbGFzc2VzUHJvcGVydHkiLCJvcHRfbWVyZ2VGbiIsIm1lcmdlZE5hbWUiLCJtZXJnZWQiLCJudWxsRnVuY3Rpb24iLCJhcnJheSIsImFycjEiLCJhcnIyIiwibGVuZ3RoIiwiaSIsImFyciIsIm9wdF9vdXRwdXQiLCJvdXRwdXQiLCJBcnJheSIsImlzQXJyYXkiLCJmbGF0dGVuIiwib2JqIiwicnYiLCJyZW1vdmVBdCIsInByb3RvdHlwZSIsInNwbGljZSIsImNhbGwiLCJzdGFydCIsIm9wdF9lbmQiLCJzbGljZWQiLCJlbmQiLCJhc3luYyIsInRocm93RXhjZXB0aW9uIiwiZXhjZXB0aW9uIiwibmV4dFRpY2siLCJydW4iLCJjYWxsYmFjayIsIm9wdF9jb250ZXh0Iiwid29ya1F1ZXVlU2NoZWR1bGVkXyIsInByb2Nlc3NXb3JrUXVldWUiLCJ3b3JrUXVldWVfIiwiV29ya0l0ZW1fIiwid29ya0l0ZW1zIiwid29ya0l0ZW0iLCJzY29wZSIsImUiLCJjYiIsImJpbmQiLCJ3cmFwQ2FsbGJhY2tfIiwic2V0SW1tZWRpYXRlIiwic2V0SW1tZWRpYXRlXyIsImdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyIsIkNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvc3RNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImlmcmFtZSIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJzcmMiLCJkb2N1bWVudEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsIndpbiIsImNvbnRlbnRXaW5kb3ciLCJkb2MiLCJvcGVuIiwid3JpdGUiLCJjbG9zZSIsIm1lc3NhZ2UiLCJvcmlnaW4iLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaG9zdCIsIm9ubWVzc2FnZSIsImRhdGEiLCJwb3J0MSIsInBvcnQyIiwiY2hhbm5lbCIsImhlYWQiLCJ0YWlsIiwibmV4dCIsInNjcmlwdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIkRpc3Bvc2FibGUiLCJkaXNwb3NlZF8iLCJkaXNwb3NlSW50ZXJuYWwiLCJvYmplY3QiLCJ0YXJnZXQiLCJrZXkiLCJzb3VyY2UiLCJhcmd1bWVudHMiLCJvcHRfb2JqIiwicGFydHMiLCJzcGxpdCIsInJlZHVjZSIsInBhcnQiLCJtYXBwZWRPYmoiLCJrZXlzIiwiT2JqZWN0Iiwib2JqMSIsIm9iajIiLCJrZXlzMSIsImtleXMyIiwic3RyaW5nIiwicmVwbGFjZSIsIngiLCJmbG9vciIsImFicyIsIkRhdGUiLCJub3ciLCJoYXNoIiwibGVuIiwiY2hhckNvZGVBdCIsInZhbHVlIiwiRW1ib2RpZWQiLCJib2R5XyIsIkpTT04iLCJzdHJpbmdpZnkiLCJib2R5IiwiRmlsdGVyQm9keSIsImZpZWxkIiwib3BlcmF0b3JPclZhbHVlIiwib3B0X3ZhbHVlIiwiY29yZSIsImNyZWF0ZUJvZHlfIiwib3BlcmF0b3IiLCJvcHRfZmlsdGVyIiwiYWRkQXJyYXlPcGVyYXRvcl8iLCJmaWx0ZXIiLCJmaWx0ZXJzIiwiYWRkIiwiR2VvIiwidXBwZXJMZWZ0IiwibG93ZXJSaWdodCIsIkJvdW5kaW5nQm94IiwiY2VudGVyIiwicmFkaXVzIiwiQ2lyY2xlIiwicG9pbnRzIiwiTGluZSIsImxhdCIsImxvbiIsIlBvaW50IiwiUG9seWdvbiIsIm1hcCIsInRvQm9keSIsInBvaW50IiwiY29vcmRpbmF0ZXMiLCJhZGRDb29yZGluYXRlc18iLCJSYW5nZSIsImZyb20iLCJvcHRfdG8iLCJ0byIsIkZpbHRlciIsImZpZWxkT3JGaWx0ZXIiLCJvcHRfb3BlcmF0b3JPclZhbHVlIiwidG9GaWx0ZXIiLCJhZGRNYW55IiwiZ2V0T2JqZWN0IiwidmFsdWVzIiwic2xpY2UiLCJib3hPclVwcGVyTGVmdCIsIm9wdF9sb3dlclJpZ2h0IiwicG9seWdvbiIsImdldFBvaW50cyIsImxvY2F0aW9uT3JDaXJjbGUiLCJvcHRfcmFuZ2VPckRpc3RhbmNlIiwicmFuZ2UiLCJnZXRDZW50ZXIiLCJnZXRSYWRpdXMiLCJkaXN0YW5jZUludGVybmFsXyIsIm1pbiIsIm1heCIsImZpZWxkT3JRdWVyeSIsIm9wdF9xdWVyeU9yRnV6emluZXNzIiwib3B0X2Z1enppbmVzcyIsImZ1enp5SW50ZXJuYWxfIiwiYXJnMklzU3RyaW5nIiwiZnV6emluZXNzIiwiQUxMIiwib3B0X3F1ZXJ5IiwicXVlcnkiLCJyYW5nZU9yTWluIiwib3B0X21heCIsInNoYXBlcyIsInNoYXBlIiwicGFyc2VGcm9tQW5jaG9yIiwib3B0X3VyaSIsImxpbmsiLCJocmVmIiwiaG9zdG5hbWUiLCJwYXNzd29yZCIsInBhdGhuYW1lIiwicG9ydCIsInNlYXJjaCIsInVzZXJuYW1lIiwicGFyc2UiLCJVUkwiLCJjcmVhdGUiLCJNdWx0aU1hcCIsInRvTG93ZXJDYXNlIiwic2l6ZSIsIm5hbWVzIiwic2V0IiwiVHJlZU5vZGUiLCJ2YWx1ZV8iLCJwYXJlbnRfIiwiY2hpbGRyZW5fIiwiY2hpbGQiLCJzZXRQYXJlbnQiLCJub2RlIiwiY3VycmVudCIsImdldFBhcmVudCIsImFuY2VzdG9ycyIsImluZGV4IiwiZ2V0Q2hpbGRyZW4iLCJFTVBUWV9BUlJBWSIsImRlcHRoIiwicm9vdCIsImdldENoaWxkQ291bnQiLCJyZW1vdmUiLCJwYXJlbnQiLCJvcHRfcHJlb3JkZXJGbiIsIm9wdF9wb3N0b3JkZXJGbiIsImZvckVhY2giLCJ0cmF2ZXJzZSIsImFzc2VydENoaWxkSGFzTm9QYXJlbnQiLCJwYXJzZUZuXyIsIlVyaSIsInVybCIsIm1heWJlQWRkUHJvdG9jb2xBbmRIb3N0bmFtZV8iLCJtdWx0aW1hcCIsImdldEFsbCIsImFkZFBhcmFtZXRlclZhbHVlIiwiZW5zdXJlUXVlcnlJbml0aWFsaXplZF8iLCJwYXJhbSIsInVybERlY29kZSIsImdldEhvc3RuYW1lIiwiZ2V0UG9ydCIsIkhPU1ROQU1FX1BMQUNFSE9MREVSIiwiZ2V0SG9zdCIsImdldFByb3RvY29sIiwiZ2V0IiwicXVlcnlzdHJpbmciLCJnZXRQYXJhbWV0ZXJOYW1lcyIsImdldFBhcmFtZXRlclZhbHVlcyIsImVuY29kZVVSSUNvbXBvbmVudCIsImNvbnRhaW5zIiwic2V0UGFyYW1ldGVyVmFsdWUiLCJSQU5ET01fUEFSQU0iLCJnZXRSYW5kb21TdHJpbmciLCJERUZBVUxUX1BST1RPQ09MIiwiY2hhckF0IiwicmVtb3ZlUGFyYW1ldGVyIiwiZ2V0UGF0aG5hbWUiLCJnZXRTZWFyY2giLCJnZXRIYXNoIiwicGFyc2VkIiwic3Vic3RyIiwibm9ybWFsaXplT2JqZWN0IiwicGFyc2VGbiIsImJhc2VQYXRoIiwicGF0aHMiLCJwYXRoIiwiY29uY2F0Iiwiam9pbiIsImRlY29kZVVSSUNvbXBvbmVudCIsImFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCIsImFzc2VydERlZkFuZE5vdE51bGwiLCJlcnJvck1lc3NhZ2UiLCJhc3NlcnRGdW5jdGlvbiIsImFzc2VydE9iamVjdCIsImFzc2VydFJlc3BvbnNlU3VjY2VlZGVkIiwicmVzcG9uc2UiLCJzdWNjZWVkZWQiLCJhc3NlcnRVc2VyU2lnbmVkSW4iLCJ1c2VyIiwiYXNzZXJ0VXJpV2l0aE5vUGF0aCIsInVyaSIsIkF1dGgiLCJ0b2tlbk9yRW1haWwiLCJvcHRfcGFzc3dvcmQiLCJ0b2tlbiIsImVtYWlsIiwiY3JlYXRlZEF0IiwicGhvdG9VcmwiLCJ3ZWRlcGxveUNsaWVudCIsImF1dGhVcmxfIiwiYXV0aCIsInBhdGNoIiwiZGVsZXRlIiwidG9rZW5PclVzZXJuYW1lIiwiQXBpSGVscGVyIiwiYXV0aE9yVG9rZW5PckVtYWlsIiwiaGVscGVyQXV0aFNjb3BlIiwiQXV0aFByb3ZpZGVyIiwicHJvdmlkZXIiLCJwcm92aWRlclNjb3BlIiwicmVkaXJlY3RVcmkiLCJvcHRfYXV0aFVybCIsInNldFBhdGhuYW1lIiwiaGFzUHJvdmlkZXIiLCJnZXRQcm92aWRlciIsImhhc1Byb3ZpZGVyU2NvcGUiLCJnZXRQcm92aWRlclNjb3BlIiwiaGFzUmVkaXJlY3RVcmkiLCJnZXRSZWRpcmVjdFVyaSIsImhhc1Njb3BlIiwiZ2V0U2NvcGUiLCJhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwiLCJGYWNlYm9va0F1dGhQcm92aWRlciIsIlBST1ZJREVSIiwiR2l0aHViQXV0aFByb3ZpZGVyIiwiR29vZ2xlQXV0aFByb3ZpZGVyIiwiU3RvcmFnZU1lY2hhbmlzbSIsIlN0b3JhZ2UiLCJtZWNoYW5pc20iLCJjbGVhciIsImpzb24iLCJFcnJvckNvZGUiLCJJTlZBTElEX1ZBTFVFIiwiYXNzZXJ0TWVjaGFuaXNtRGVmQW5kTm90TnVsbCIsImFzc2VydE1lY2hhbmlzbUludGFuY2VPZiIsIkxvY2FsU3RvcmFnZU1lY2hhbmlzbSIsImxvY2FsU3RvcmFnZSIsInN0b3JhZ2UiLCJnZXRJdGVtIiwicmVtb3ZlSXRlbSIsInNldEl0ZW0iLCJpc1N1cHBvcnRlZCIsIkF1dGhBcGlIZWxwZXIiLCJjdXJyZW50VXNlciIsIm9uU2lnbkluQ2FsbGJhY2siLCJvblNpZ25PdXRDYWxsYmFjayIsInByb2Nlc3NTaWduSW5fIiwicG9zdCIsIm1ha2VVc2VyQXV0aEZyb21EYXRhIiwiZnJhZ21lbnQiLCJ1c2VySWQiLCJyZXNvbHZlQXV0aFNjb3BlIiwic2V0V2VkZXBsb3lDbGllbnQiLCJzZXRDcmVhdGVkQXQiLCJzZXRFbWFpbCIsInNldElkIiwic2V0TmFtZSIsInNldFBob3RvVXJsIiwic2V0VG9rZW4iLCJyZWRpcmVjdEFjY2Vzc1Rva2VuIiwiZ2V0UmVkaXJlY3RBY2Nlc3NUb2tlbl8iLCJyZW1vdmVVcmxGcmFnbWVudENvbXBsZXRlbHlfIiwibG9hZEN1cnJlbnRVc2VyIiwibWF5YmVDYWxsT25TaWduSW5DYWxsYmFja18iLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwidGl0bGUiLCJhY2Nlc3NfdG9rZW4iLCJzZXRSZWRpcmVjdFVyaSIsImdldEhyZWZXaXRob3V0RnJhZ21lbnRfIiwibWFrZUF1dGhvcml6YXRpb25VcmwiLCJtYXliZUNhbGxPblNpZ25PdXRDYWxsYmFja18iLCJ1bmxvYWRDdXJyZW50VXNlcl8iLCJhc3NlcnRTdXBwb3J0ZWRQcm92aWRlciIsIkFnZ3JlZ2F0aW9uIiwiZmllbGRfIiwib3BlcmF0b3JfIiwicmFuZ2VzIiwiRGlzdGFuY2VBZ2dyZWdhdGlvbiIsImludGVydmFsIiwiUmFuZ2VBZ2dyZWdhdGlvbiIsInJhbmdlT3JGcm9tIiwidW5pdCIsIlF1ZXJ5IiwiYWdncmVnYXRpb25PckZpZWxkIiwib3B0X29wZXJhdG9yIiwiYWdncmVnYXRpb24iLCJnZXRGaWVsZCIsImdldE9wZXJhdG9yIiwiZ2V0VmFsdWUiLCJvZmZzZXQiLCJoaWdobGlnaHQiLCJsaW1pdCIsImZpbHRlck9yVGV4dE9yRmllbGQiLCJvcHRfdGV4dE9yT3BlcmF0b3IiLCJtYXRjaCIsIm9wdF9kaXJlY3Rpb24iLCJzb3J0Iiwic29ydEVudHJ5IiwiYWdncmVnYXRlIiwiRGF0YUFwaUhlbHBlciIsImdldE9yQ3JlYXRlRmlsdGVyXyIsImFuZCIsIm9yIiwiYXJncyIsIndoZXJlIiwibm9uZSIsInNpbWlsYXIiLCJsdCIsImx0ZSIsImFueSIsImJvdW5kaW5nQm94IiwiZGlzdGFuY2UiLCJnZXRPckNyZWF0ZVF1ZXJ5XyIsImNvbGxlY3Rpb24iLCJkYXRhVXJsXyIsInB1dCIsImFkZEZpbHRlcnNUb1F1ZXJ5XyIsInF1ZXJ5XyIsIm9uU2VhcmNoXyIsIm9wdF9vcHRpb25zIiwid2F0Y2giLCJmaWx0ZXJfIiwidG9TZWFyY2hfIiwiQmFzZTY0IiwiYnRvYSIsIkJ1ZmZlciIsIlRoZW5hYmxlIiwiSU1QTEVNRU5URURfQllfUFJPUCIsImFkZEltcGxlbWVudGF0aW9uIiwiY3RvciIsIiRnb29nX1RoZW5hYmxlIiwiaXNJbXBsZW1lbnRlZEJ5IiwicGFydGlhbCIsIm5ld0FyZ3MiLCJhcHBseSIsIkNhbmNlbGxhYmxlUHJvbWlzZSIsInJlc29sdmVyIiwic3RhdGVfIiwiU3RhdGVfIiwiUEVORElORyIsInJlc3VsdF8iLCJjYWxsYmFja0VudHJpZXNfIiwiZXhlY3V0aW5nXyIsIlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkiLCJ1bmhhbmRsZWRSZWplY3Rpb25JZF8iLCJoYWRVbmhhbmRsZWRSZWplY3Rpb25fIiwic2VsZiIsInJlc29sdmVfIiwiRlVMRklMTEVEIiwicmVhc29uIiwiUkVKRUNURUQiLCJDYWxsYmFja0VudHJ5XyIsInJlc29sdmUiLCJyZWplY3QiLCJvcHRfcmVhc29uIiwicmFjZSIsInByb21pc2VzIiwicHJvbWlzZSIsImFsbCIsInRvRnVsZmlsbCIsIm9uRnVsZmlsbCIsIm9uUmVqZWN0IiwiZmlyc3RGdWxmaWxsZWQiLCJ0b1JlamVjdCIsInJlYXNvbnMiLCJvcHRfb25GdWxmaWxsZWQiLCJvcHRfb25SZWplY3RlZCIsImFkZENoaWxkUHJvbWlzZV8iLCJ0aGVuQWx3YXlzIiwib25SZXNvbHZlZCIsImVyciIsImhhbmRsZVJlamVjdGlvbl8iLCJhZGRDYWxsYmFja0VudHJ5XyIsInRoZW5DYXRjaCIsIm9uUmVqZWN0ZWQiLCJjYXRjaCIsImNhbmNlbCIsIm9wdF9tZXNzYWdlIiwiQ2FuY2VsbGF0aW9uRXJyb3IiLCJJU19DQU5DRUxMQVRJT05fRVJST1IiLCJjYW5jZWxJbnRlcm5hbF8iLCJjYW5jZWxDaGlsZF8iLCJjaGlsZFByb21pc2UiLCJjaGlsZENvdW50IiwiY2hpbGRJbmRleCIsImVudHJ5IiwiY2FsbGJhY2tFbnRyeSIsImV4ZWN1dGVDYWxsYmFja18iLCJzY2hlZHVsZUNhbGxiYWNrc18iLCJvbkZ1bGZpbGxlZCIsInJlc3VsdCIsInVuYmxvY2tBbmRGdWxmaWxsXyIsIkJMT0NLRUQiLCJ1bmJsb2NrQW5kUmVqZWN0XyIsInN0YXRlIiwiVHlwZUVycm9yIiwidHJ5VGhlbl8iLCJhZGRVbmhhbmRsZWRSZWplY3Rpb25fIiwidGhlbmFibGUiLCJjYWxsZWQiLCJleGVjdXRlQ2FsbGJhY2tzXyIsImVudHJpZXMiLCJyZW1vdmVVbmhhbmRsZWRSZWplY3Rpb25fIiwicCIsInNldFRpbWVvdXQiLCJzZXRVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVyIiwiaGFuZGxlciIsIkFqYXgiLCJhbGxIZWFkZXJzIiwiaGVhZGVycyIsInBhaXJzIiwibWV0aG9kIiwib3B0X2hlYWRlcnMiLCJvcHRfcGFyYW1zIiwib3B0X3RpbWVvdXQiLCJvcHRfc3luYyIsIm9wdF93aXRoQ3JlZGVudGlhbHMiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJQcm9taXNlIiwib25sb2FkIiwiYWJvcnRlZCIsIm9uZXJyb3IiLCJlcnJvciIsImFib3J0IiwidGltZW91dCIsImFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAiLCJ3aXRoQ3JlZGVudGlhbHMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwic2VuZCIsIlRyYW5zcG9ydCIsIkNsaWVudE1lc3NhZ2UiLCJoZWFkZXJzXyIsIm9wdF9ib2R5IiwiQ2xpZW50UmVzcG9uc2UiLCJjbGllbnRSZXF1ZXN0IiwiY2xpZW50UmVxdWVzdF8iLCJvcHRfc3RhdHVzQ29kZSIsInN0YXR1c0NvZGVfIiwib3B0X3N0YXR1c1RleHQiLCJzdGF0dXNUZXh0XyIsInN0YXR1c0NvZGUiLCJBamF4VHJhbnNwb3J0IiwiZGVmZXJyZWQiLCJwYXJhbXMiLCJjbGllbnRSZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJwYXJzZVJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsImhlYWRlciIsIlRyYW5zcG9ydEZhY3RvcnkiLCJ0cmFuc3BvcnRzIiwiREVGQVVMVF9UUkFOU1BPUlRfTkFNRSIsImltcGxlbWVudGF0aW9uTmFtZSIsIlRyYW5zcG9ydENsYXNzIiwiaW5zdGFuY2VfIiwiQ2xpZW50UmVxdWVzdCIsInBhcmFtc18iLCJ3aXRoQ3JlZGVudGlhbHNfIiwib3B0X21ldGhvZCIsIm1ldGhvZF8iLCJERUZBVUxUX01FVEhPRCIsIm9wdF91cmwiLCJ1cmxfIiwiaW8iLCJXZURlcGxveSIsImF1dGhfIiwiam9pblBhdGhzIiwiZm9ybURhdGFfIiwiZW5jb2RlIiwiaXNDb250ZW50VHlwZUpzb24iLCJzZW5kQXN5bmMiLCJGb3JtRGF0YSIsIm1heWJlV3JhcFdpdGhRdWVyeV8iLCJjb252ZXJ0Qm9keVRvUGFyYW1zXyIsInJlbW92ZUJvZHkiLCJlbmNvZGVQYXJhbXNfIiwicmVzb2x2ZUF1dGhlbnRpY2F0aW9uXyIsImFwcGVuZCIsImVtYm9kaWVkIiwidXNlIiwiY3VzdG9tVHJhbnNwb3J0XyIsImhhc1Rva2VuIiwiY3JlZGVudGlhbHMiLCJlbmNvZGVTdHJpbmciLCJ0cmFuc3BvcnQiLCJpbnN0YW5jZSIsImdldERlZmF1bHQiLCJjcmVhdGVDbGllbnRSZXF1ZXN0XyIsImRlY29kZSIsIm9wdF9kYXRhVXJsIiwic29ja2V0IiwiY2xpZW50TWVzc2FnZSIsImNvbnRlbnRUeXBlIiwiZGF0YV8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaGxPQSxJQUFJQSxVQUFVLEVBQWQ7O0FBRUEsSUFBSSxPQUFPQyxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO1NBQzFCQSxNQUFSLEdBQWlCQSxNQUFqQjs7O0FBR0QsSUFBSSxPQUFPQyxRQUFQLEtBQW9CLFdBQXhCLEVBQXFDO1NBQzVCQSxRQUFSLEdBQW1CQSxRQUFuQjtDQUdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1JBOzs7OztBQUtBLElBQUlD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NlEsU0FBUzZCLEtBQVQsR0FBaUIsSUFBakI7QUFDQTdCLFNBQVN6SixRQUFULEdBQW9CLEVBQXBCLENBRUE7O0FDOWRBeGMsUUFBUUMsTUFBUixDQUFlNk0sTUFBZixHQUF3QkEsTUFBeEI7QUFDQTlNLFFBQVFDLE1BQVIsQ0FBZXVMLEdBQWYsR0FBcUJBLEdBQXJCO0FBQ0F4TCxRQUFRQyxNQUFSLENBQWV1YSxLQUFmLEdBQXVCQSxLQUF2QjtBQUNBeGEsUUFBUUMsTUFBUixDQUFleU0sS0FBZixHQUF1QkEsS0FBdkI7QUFDQTFNLFFBQVFDLE1BQVIsQ0FBZWdtQixRQUFmLEdBQTBCQSxRQUExQiIsImZpbGUiOiJhcGkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5pbyA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSBfZGVyZXFfKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IF9kZXJlcV8oJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gX2RlcmVxXygnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuXG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgpO1xufVxuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gX2RlcmVxXygnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IF9kZXJlcV8oJy4vc29ja2V0Jyk7XG5cbn0se1wiLi9tYW5hZ2VyXCI6MixcIi4vc29ja2V0XCI6NCxcIi4vdXJsXCI6NSxcImRlYnVnXCI6MTQsXCJzb2NrZXQuaW8tcGFyc2VyXCI6NDB9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSBfZGVyZXFfKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gX2RlcmVxXygnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSBfZGVyZXFfKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSBfZGVyZXFfKCcuL29uJyk7XG52YXIgYmluZCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gX2RlcmVxXygnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSBfZGVyZXFfKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyKHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbigpe1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmVuZ2luZS5pZDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbigpIHtcbiAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihmbil7XG4gIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuICBkZWJ1Zygnb3BlbmluZyAlcycsIHRoaXMudXJpKTtcbiAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG4gIC8vIGVtaXQgYG9wZW5gXG4gIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbihkYXRhKXtcbiAgICBkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuICAgIHNlbGYuY2xlYW51cCgpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuICAgIGlmIChmbikge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgICAgZm4oZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cbiAgICAvLyBzZXQgdGltZXJcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdvcGVuJyk7XG5cbiAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgLy8gbWFyayBhcyBvcGVuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cbiAgLy8gYWRkIG5ldyBzdWJzXG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BpbmcnLCBiaW5kKHRoaXMsICdvbnBpbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbigpe1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGU7XG4gIHRoaXMuZW1pdEFsbCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBvbmcgPSBmdW5jdGlvbigpe1xuICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24obnNwKXtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5lbmdpbmUuaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZuZXQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nKCkge1xuICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG4gICAgICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oc29ja2V0KXtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzZWxmLmVuY29kaW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnByb2Nlc3NQYWNrZXRRdWV1ZSgpO1xuICAgIH0pO1xuICB9IGVsc2UgeyAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuICAgIHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuICogbmV4dCBwYWNrZXQgaW4gbGluZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG5cbiAgdmFyIHN1YjtcbiAgd2hpbGUgKHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpKSBzdWIuZGVzdHJveSgpO1xuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgZGVidWcoJ29uY2xvc2UnKTtcblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICBkZWJ1ZygncmVjb25uZWN0IGZhaWxlZCcpO1xuICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0X2ZhaWxlZCcpO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuXG59LHtcIi4vb25cIjozLFwiLi9zb2NrZXRcIjo0LFwiYmFja28yXCI6OCxcImNvbXBvbmVudC1iaW5kXCI6MTEsXCJjb21wb25lbnQtZW1pdHRlclwiOjEyLFwiZGVidWdcIjoxNCxcImVuZ2luZS5pby1jbGllbnRcIjoxNixcImluZGV4b2ZcIjozMixcInNvY2tldC5pby1wYXJzZXJcIjo0MH1dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24ob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cblxufSx7fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gX2RlcmVxXygnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSBfZGVyZXFfKCd0by1hcnJheScpO1xudmFyIG9uID0gX2RlcmVxXygnLi9vbicpO1xudmFyIGJpbmQgPSBfZGVyZXFfKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBoYXNCaW4gPSBfZGVyZXFfKCdoYXMtYmluYXJ5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBjb25uZWN0aW5nOiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDEsXG4gIHBpbmc6IDEsXG4gIHBvbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KGlvLCBuc3Ape1xuICB0aGlzLmlvID0gaW87XG4gIHRoaXMubnNwID0gbnNwO1xuICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLmFja3MgPSB7fTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGlmICh0aGlzLmlvLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuc3ViRXZlbnRzKCk7XG4gIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICBpZiAoJ29wZW4nID09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgZW1pdGAuXG4gKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2KXtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhcnNlclR5cGUgPSBwYXJzZXIuRVZFTlQ7IC8vIGRlZmF1bHRcbiAgaWYgKGhhc0JpbihhcmdzKSkgeyBwYXJzZXJUeXBlID0gcGFyc2VyLkJJTkFSWV9FVkVOVDsgfSAvLyBiaW5hcnlcbiAgdmFyIHBhY2tldCA9IHsgdHlwZTogcGFyc2VyVHlwZSwgZGF0YTogYXJncyB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuICAgIHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cblxuICBkZWxldGUgdGhpcy5mbGFncztcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT0gdGhpcy5uc3ApIHtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNUIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBkZWxldGUgdGhpcy5pZDtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgaWYgKHBhY2tldC5uc3AgIT0gdGhpcy5uc3ApIHJldHVybjtcblxuICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uKGlkKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHNlbnQgPSB0cnVlO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgdmFyIHR5cGUgPSBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0s7XG4gICAgc2VsZi5wYWNrZXQoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGFjaykge1xuICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkRJU0NPTk5FQ1QgfSk7XG4gIH1cblxuICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICB0aGlzLmRlc3Ryb3koKTtcblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAvLyBmaXJlIGV2ZW50c1xuICAgIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uKGNvbXByZXNzKXtcbiAgdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfHwge307XG4gIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG59LHtcIi4vb25cIjozLFwiY29tcG9uZW50LWJpbmRcIjoxMSxcImNvbXBvbmVudC1lbWl0dGVyXCI6MTIsXCJkZWJ1Z1wiOjE0LFwiaGFzLWJpbmFyeVwiOjMwLFwic29ja2V0LmlvLXBhcnNlclwiOjQwLFwidG8tYXJyYXlcIjo0M31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNldXJpID0gX2RlcmVxXygncGFyc2V1cmknKTtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHVybCh1cmksIGxvYyl7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgdmFyIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgdmFyIGlwdjYgPSBvYmouaG9zdC5pbmRleE9mKCc6JykgIT09IC0xO1xuICB2YXIgaG9zdCA9IGlwdjYgPyAnWycgKyBvYmouaG9zdCArICddJyA6IG9iai5ob3N0O1xuXG4gIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcImRlYnVnXCI6MTQsXCJwYXJzZXVyaVwiOjM4fV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxufSx7fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuXG59LHt9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuXG59LHt9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbigpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcblxuICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gIHZhciBsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzEpXTtcbiAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMildO1xuICAgICAgZW5jb2RlZDQgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSszKV07XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoKTtcblxufSx7fV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iQnVpbGRlciA9IGdsb2JhbC5CbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLk1TQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLk1vekJsb2JCdWlsZGVyO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JTdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGEgPSBuZXcgQmxvYihbJ2hpJ10pO1xuICAgIHJldHVybiBhLnNpemUgPT09IDI7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3NcbiAqIEZhaWxzIGluIFNhZmFyaSA2LCBzbyB3ZSBuZWVkIHRvIG1hcCB0byBBcnJheUJ1ZmZlcnMgdGhlcmUuXG4gKi9cblxudmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLDJdKV0pO1xuICAgIHJldHVybiBiLnNpemUgPT09IDI7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iQnVpbGRlciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYkJ1aWxkZXJTdXBwb3J0ZWQgPSBCbG9iQnVpbGRlclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcbiAqIFVzZWQgYnkgQmxvYkJ1aWxkZXIgY29uc3RydWN0b3IgYW5kIG9sZCBicm93c2VycyB0aGF0IGRpZG4ndFxuICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cbiAqL1xuXG5mdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaHVuayA9IGFyeVtpXTtcbiAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxuICAgICAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXG4gICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCAhPT0gYnVmLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XG4gICAgICAgIGJ1ZiA9IGNvcHkuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBhcnlbaV0gPSBidWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBiYi5hcHBlbmQoYXJ5W2ldKTtcbiAgfVxuXG4gIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcbn07XG5cbmZ1bmN0aW9uIEJsb2JDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuICByZXR1cm4gbmV3IEJsb2IoYXJ5LCBvcHRpb25zIHx8IHt9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBpZiAoYmxvYlN1cHBvcnRlZCkge1xuICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBnbG9iYWwuQmxvYiA6IEJsb2JDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xuICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn0pKCk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG5cbn0se31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxufSx7fV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTtcbn0se31dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxufSx7XCIuL2RlYnVnXCI6MTV9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gX2RlcmVxXygnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxufSx7XCJtc1wiOjM1fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5tb2R1bGUuZXhwb3J0cyA9ICBfZGVyZXFfKCcuL2xpYi8nKTtcblxufSx7XCIuL2xpYi9cIjoxN31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcblxufSx7XCIuL3NvY2tldFwiOjE4LFwiZW5naW5lLmlvLXBhcnNlclwiOjI3fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gX2RlcmVxXygnLi90cmFuc3BvcnRzJyk7XG52YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gX2RlcmVxXygnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IF9kZXJlcV8oJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gX2RlcmVxXygncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IF9kZXJlcV8oJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBOb29wIGZ1bmN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCh1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmUgOlxuICAgIChnbG9iYWwubG9jYXRpb24gJiYgJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnQgP1xuICAgICAgIGxvY2F0aW9uLnBvcnQgOlxuICAgICAgICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG4gICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IF9kZXJlcV8oJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IF9kZXJlcV8oJy4vdHJhbnNwb3J0cycpO1xuU29ja2V0LnBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgZm9yY2VKU09OUDogdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiB0aGlzLnBvbGljeVBvcnQsXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIHBmeDogdGhpcy5wZngsXG4gICAga2V5OiB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogdGhpcy5jZXJ0LFxuICAgIGNhOiB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgIGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnNcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpe1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbihwYWNrZXQpe1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pXG4gICAgLCBmYWlsZWQgPSBmYWxzZVxuICAgICwgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PSBtc2cudHlwZSAmJiAncHJvYmUnID09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvL0hhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pe1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwKCl7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0YTogZGF0YSxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIGlmIChmbikgdGhpcy5vbmNlKCdmbHVzaCcsIGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG4gICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcIi4vdHJhbnNwb3J0XCI6MTksXCIuL3RyYW5zcG9ydHNcIjoyMCxcImNvbXBvbmVudC1lbWl0dGVyXCI6MjYsXCJkZWJ1Z1wiOjE0LFwiZW5naW5lLmlvLXBhcnNlclwiOjI3LFwiaW5kZXhvZlwiOjMyLFwicGFyc2Vqc29uXCI6MzYsXCJwYXJzZXFzXCI6MzcsXCJwYXJzZXVyaVwiOjM4fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cbn0se1wiY29tcG9uZW50LWVtaXR0ZXJcIjoyNixcImVuZ2luZS5pby1wYXJzZXJcIjoyN31dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IF9kZXJlcV8oJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFhIUiA9IF9kZXJlcV8oJy4vcG9sbGluZy14aHInKTtcbnZhciBKU09OUCA9IF9kZXJlcV8oJy4vcG9sbGluZy1qc29ucCcpO1xudmFyIHdlYnNvY2tldCA9IF9kZXJlcV8oJy4vd2Vic29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0IHRyYW5zcG9ydHMuXG4gKi9cblxuZXhwb3J0cy5wb2xsaW5nID0gcG9sbGluZztcbmV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG4vKipcbiAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9sbGluZyhvcHRzKXtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgeGQgPSBvcHRzLmhvc3RuYW1lICE9IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH1cblxuICBvcHRzLnhkb21haW4gPSB4ZDtcbiAgb3B0cy54c2NoZW1lID0geHM7XG4gIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcblxuICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG4gICAgcmV0dXJuIG5ldyBYSFIob3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcIi4vcG9sbGluZy1qc29ucFwiOjIxLFwiLi9wb2xsaW5nLXhoclwiOjIyLFwiLi93ZWJzb2NrZXRcIjoyNCxcInhtbGh0dHByZXF1ZXN0LXNzbFwiOjI1fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSBfZGVyZXFfKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gX2RlcmVxXygnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIENhbGxiYWNrcyBjb3VudC5cbiAqL1xuXG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfVxuICBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIFxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicrIHNlbGYuaWZyYW1lSWQgKydcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2goZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuL3BvbGxpbmdcIjoyMyxcImNvbXBvbmVudC1pbmhlcml0XCI6MTN9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gX2RlcmVxXygneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IF9kZXJlcV8oJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSBfZGVyZXFfKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSgpe31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIob3B0cyl7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG9wdHMpe1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbihkYXRhLCBmbil7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICB9KTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG9wdHMpe1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmICh0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICBpZiAoJ1BPU1QnID09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oZnJvbUVycm9yKXtcbiAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKS5zcGxpdCgnOycpWzBdO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHZhciB1aThBcnIgPSBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSk7XG4gICAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IHVpOEFyci5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKHVpOEFycltpZHhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhQXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIFJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG4gIFJlcXVlc3QucmVxdWVzdHMgPSB7fTtcbiAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcIi4vcG9sbGluZ1wiOjIzLFwiY29tcG9uZW50LWVtaXR0ZXJcIjoyNixcImNvbXBvbmVudC1pbmhlcml0XCI6MTMsXCJkZWJ1Z1wiOjE0LFwieG1saHR0cHJlcXVlc3Qtc3NsXCI6MjV9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IF9kZXJlcV8oJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSBfZGVyZXFfKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSBfZGVyZXFfKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gX2RlcmVxXygneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbigpIHtcbiAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gX2RlcmVxXygneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcbiAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcbn0pKCk7XG5cbi8qKlxuICogUG9sbGluZyBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFBvbGxpbmcob3B0cyl7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbihvblBhdXNlKXtcbiAgdmFyIHBlbmRpbmcgPSAwO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlKCl7XG4gICAgZGVidWcoJ3BhdXNlZCcpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuICAgIG9uUGF1c2UoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygncG9sbGluZycpO1xuICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuICB0aGlzLmRvUG9sbCgpO1xuICB0aGlzLmVtaXQoJ3BvbGwnKTtcbn07XG5cbi8qKlxuICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24ocGFja2V0LCBpbmRleCwgdG90YWwpIHtcbiAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG4gICAgaWYgKCdvcGVuaW5nJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG4gICAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNsb3NlKCl7XG4gICAgZGVidWcoJ3dyaXRpbmcgY2xvc2UgcGFja2V0Jyk7XG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuICAgIGNsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgIGRlYnVnKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpIHx8XG4gICAgICgnaHR0cCcgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbn0se1wiLi4vdHJhbnNwb3J0XCI6MTksXCJjb21wb25lbnQtaW5oZXJpdFwiOjEzLFwiZGVidWdcIjoxNCxcImVuZ2luZS5pby1wYXJzZXJcIjoyNyxcInBhcnNlcXNcIjozNyxcInhtbGh0dHByZXF1ZXN0LXNzbFwiOjI1LFwieWVhc3RcIjo0NX1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gX2RlcmVxXygnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSBfZGVyZXFfKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSBfZGVyZXFfKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcbnZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5pZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICB0cnkge1xuICAgIFdlYlNvY2tldCA9IF9kZXJlcV8oJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdm9pZCgwKTtcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG5cbiAgdGhpcy53cyA9IEJyb3dzZXJXZWJTb2NrZXQgPyBuZXcgV2ViU29ja2V0KHVyaSkgOiBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdidWZmZXInO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpe1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgb25EYXRhYCB0byB1c2UgYSB0aW1lciBvbiBpT1MuXG4gKiBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21sb3VnaHJhbi8yMDUyMDA2XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3JcbiAgJiYgL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gIFdTLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLCBkYXRhKTtcbiAgICB9LCAwKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG4gICAgKGZ1bmN0aW9uKHBhY2tldCkge1xuICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCFCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEgPyBnbG9iYWwuQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9Tb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lKCl7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKXtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpXG4gICAgfHwgKCd3cycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxufSx7XCIuLi90cmFuc3BvcnRcIjoxOSxcImNvbXBvbmVudC1pbmhlcml0XCI6MTMsXCJkZWJ1Z1wiOjE0LFwiZW5naW5lLmlvLXBhcnNlclwiOjI3LFwicGFyc2Vxc1wiOjM3LFwid3NcIjp1bmRlZmluZWQsXCJ5ZWFzdFwiOjQ1fV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcbnZhciBoYXNDT1JTID0gX2RlcmVxXygnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoKGUpIHsgfVxuICB9XG59XG5cbn0se1wiaGFzLWNvcnNcIjozMX1dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxufSx7fV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gX2RlcmVxXygnLi9rZXlzJyk7XG52YXIgaGFzQmluYXJ5ID0gX2RlcmVxXygnaGFzLWJpbmFyeScpO1xudmFyIHNsaWNlQnVmZmVyID0gX2RlcmVxXygnYXJyYXlidWZmZXIuc2xpY2UnKTtcbnZhciBiYXNlNjRlbmNvZGVyID0gX2RlcmVxXygnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG52YXIgYWZ0ZXIgPSBfZGVyZXFfKCdhZnRlcicpO1xudmFyIHV0ZjggPSBfZGVyZXFfKCd1dGY4Jyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gX2RlcmVxXygnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBzdXBwb3J0c0JpbmFyeSkge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1dGY4ZW5jb2RlKSB7XG4gICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gIGlmIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycgfHwgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG4gIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFnbG9iYWwuQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gIH1cblxuICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG4gIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJydcbiAgICAsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKCc6JyAhPSBjaHIpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnJyA9PSBsZW5ndGggfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCB0cnVlKTtcblxuICAgICAgICBpZiAoZXJyLnR5cGUgPT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgICBpICs9IG47XG4gICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gIH1cblxuICBpZiAobGVuZ3RoICE9ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgdmFyIG51bWJlclRvb0xvbmcgPSBmYWxzZTtcbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PSAyNTUpIGJyZWFrO1xuXG4gICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICBudW1iZXJUb29Mb25nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuXG4gICAgaWYobnVtYmVyVG9vTG9uZykgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcIi4va2V5c1wiOjI4LFwiYWZ0ZXJcIjo2LFwiYXJyYXlidWZmZXIuc2xpY2VcIjo3LFwiYmFzZTY0LWFycmF5YnVmZmVyXCI6OSxcImJsb2JcIjoxMCxcImhhcy1iaW5hcnlcIjoyOSxcInV0ZjhcIjo0NH1dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbn0se31dLDI5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICBpZiAob2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se1wiaXNhcnJheVwiOjMzfV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICAgICAgaWYgKG9iai50b0pTT04gJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se1wiaXNhcnJheVwiOjMzfV0sMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG5cbn0se31dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcbn0se31dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxufSx7fV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se31dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gJycgKyBzdHI7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxufSx7fV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBKU09OIHBhcnNlLlxuICpcbiAqIEBzZWUgQmFzZWQgb24galF1ZXJ5I3BhcnNlSlNPTiAoTUlUKSBhbmQgSlNPTjJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xudmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG52YXIgcnZhbGlkdG9rZW5zID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nO1xudmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbnZhciBydHJpbUxlZnQgPSAvXlxccysvO1xudmFyIHJ0cmltUmlnaHQgPSAvXFxzKyQvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSB8fCAhZGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcblxuICAvLyBBdHRlbXB0IHRvIHBhcnNlIHVzaW5nIHRoZSBuYXRpdmUgSlNPTiBwYXJzZXIgZmlyc3RcbiAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgfVxuXG4gIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsICdAJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZHRva2VucywgJ10nKVxuICAgICAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZGF0YSkpKCk7XG4gIH1cbn07XG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se31dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG4gIHZhciBxcnkgPSB7fTtcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gIH1cbiAgcmV0dXJuIHFyeTtcbn07XG5cbn0se31dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogUGFyc2VzIGFuIFVSSVxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuXG52YXIgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuICAgIHZhciBzcmMgPSBzdHIsXG4gICAgICAgIGIgPSBzdHIuaW5kZXhPZignWycpLFxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcbiAgICAgICAgdXJpID0ge30sXG4gICAgICAgIGkgPSAxNDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJpO1xufTtcblxufSx7fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSBfZGVyZXFfKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuICBmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHZhciBjdXJQbGFjZUhvbGRlciA9IDA7XG5cbiAgZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgICAgIHJldHVybiBidWY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaiAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG59LHtcIi4vaXMtYnVmZmVyXCI6NDEsXCJpc2FycmF5XCI6MzN9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIganNvbiA9IF9kZXJlcV8oJ2pzb24zJyk7XG52YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTtcbnZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSBfZGVyZXFfKCcuL2JpbmFyeScpO1xudmFyIGlzQnVmID0gX2RlcmVxXygnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG5zcCA9IGZhbHNlO1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgc3RyICs9IG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cztcbiAgICBzdHIgKz0gJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcbiAgICBuc3AgPSB0cnVlO1xuICAgIHN0ciArPSBvYmoubnNwO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIGlmIChuc3ApIHtcbiAgICAgIHN0ciArPSAnLCc7XG4gICAgICBuc3AgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG4gICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgcCA9IHt9O1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gbG9vayB1cCB0eXBlXG4gIHAudHlwZSA9IE51bWJlcihzdHIuY2hhckF0KDApKTtcbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHAuZGF0YSA9IGpzb24ucGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBlcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihkYXRhKXtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gIH07XG59XG5cbn0se1wiLi9iaW5hcnlcIjozOSxcIi4vaXMtYnVmZmVyXCI6NDEsXCJjb21wb25lbnQtZW1pdHRlclwiOjQyLFwiZGVidWdcIjoxNCxcImlzYXJyYXlcIjozMyxcImpzb24zXCI6MzR9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se31dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbmFyZ3VtZW50c1s0XVsyNl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXG59LHtcImR1cFwiOjI2fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5XG5cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXVxuXG4gICAgaW5kZXggPSBpbmRleCB8fCAwXG5cbiAgICBmb3IgKHZhciBpID0gaW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaSAtIGluZGV4XSA9IGxpc3RbaV1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbn1cblxufSx7fV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMC4wIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0dmFyIGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdH1cblxuXHR2YXIgYnl0ZUFycmF5O1xuXHR2YXIgYnl0ZUNvdW50O1xuXHR2YXIgYnl0ZUluZGV4O1xuXHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcpIHtcblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woKSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjAuMCcsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcbn0se31dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG5cbn0se31dfSx7fSxbMV0pKDEpXG59KTtcbiIsInZhciBnbG9iYWxzID0ge307XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRnbG9iYWxzLndpbmRvdyA9IHdpbmRvdztcbn1cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0Z2xvYmFscy5kb2N1bWVudCA9IGRvY3VtZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnbG9iYWxzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjb3JlIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQGNvbnN0XG4gKi9cblxubGV0IGNvbXBhdGliaWxpdHlNb2RlRGF0YV87XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCB1bmlxdWVJZENvdW50ZXJfID0gMTtcblxuLyoqXG4gKiBVbmlxdWUgaWQgcHJvcGVydHkgcHJlZml4LlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IFVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKTtcblxuLyoqXG4gKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICogRm9vLnByb3RvdHlwZS5iYXIgPSBhYnN0cmFjdE1ldGhvZFxuICpcbiAqIE5vdyBpZiBhIHN1YmNsYXNzIG9mIEZvbyBmYWlscyB0byBvdmVycmlkZSBiYXIoKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAqXG4gKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJzdHJhY3RNZXRob2QoKSB7XG5cdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xufVxuXG4vKipcbiAqIExvb3BzIGNvbnN0cnVjdG9yIHN1cGVyIGNsYXNzZXMgY29sbGVjdGluZyBpdHMgcHJvcGVydGllcyB2YWx1ZXMuIElmXG4gKiBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzdXBlciBjbGFzcyBgdW5kZWZpbmVkYCB3aWxsIGJlXG4gKiBjb2xsZWN0ZWQgYXMgdmFsdWUgZm9yIHRoZSBjbGFzcyBoaWVyYXJjaHkgcG9zaXRpb24uXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjb25zdHJ1Y3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBjb2xsZWN0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheS48Kj59IEFycmF5IG9mIGNvbGxlY3RlZCB2YWx1ZXMuXG4gKiBUT0RPKCopOiBSZXRoaW5rIHN1cGVyY2xhc3MgbG9vcC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RTdXBlckNsYXNzZXNQcm9wZXJ0eShjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG5cdHZhciBwcm9wZXJ0eVZhbHVlcyA9IFtjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdXTtcblx0d2hpbGUgKGNvbnN0cnVjdG9yLl9fcHJvdG9fXyAmJiAhY29uc3RydWN0b3IuX19wcm90b19fLmlzUHJvdG90eXBlT2YoRnVuY3Rpb24pKSB7XG5cdFx0Y29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvci5fX3Byb3RvX187XG5cdFx0cHJvcGVydHlWYWx1ZXMucHVzaChjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdKTtcblx0fVxuXHRyZXR1cm4gcHJvcGVydHlWYWx1ZXM7XG59XG5cbi8qKlxuICogRGlzYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG5cdGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSBudWxsO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUgd2l0aCB0aGUgZm9sbG93aW5nIGZlYXR1cmVzIGZyb20gcmNcbiAqIGFuZCAxLnggdmVyc2lvbnM6XG4gKiAgICAgLSBVc2luZyBcImtleVwiIHRvIHJlZmVyZW5jZSBjb21wb25lbnQgaW5zdGFuY2VzLiBJbiB0aGUgY3VycmVudCB2ZXJzaW9uXG4gKiAgICAgICB0aGlzIHNob3VsZCBiZSBkb25lIHZpYSBcInJlZlwiIGluc3RlYWQuIFRoaXMgYWxsb3dzIG9sZCBjb2RlIHN0aWxsXG4gKiAgICAgICB1c2luZyBcImtleVwiIHRvIGtlZXAgd29ya2luZyBsaWtlIGJlZm9yZS4gTk9URTogdGhpcyBtYXkgY2F1c2VcbiAqICAgICAgIHByb2JsZW1zLCBzaW5jZSBcImtleVwiIGlzIG1lYW50IHRvIGJlIHVzZWQgZGlmZmVyZW50bHkuIE9ubHkgdXNlIHRoaXNcbiAqICAgICAgIGlmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVwZ3JhZGUgdGhlIGNvZGUgdG8gdXNlIFwicmVmXCIgaW5zdGVhZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2RhdGEgT3B0aW9uYWwgb2JqZWN0IHdpdGggZGF0YSB0byBzcGVjaWZ5IG1vcmVcbiAqICAgICBkZXRhaWxzLCBzdWNoIGFzOlxuICogICAgICAgICAtIHJlbmRlcmVycyB7QXJyYXl9IHRoZSB0ZW1wbGF0ZSByZW5kZXJlcnMgdGhhdCBzaG91bGQgYmUgaW5cbiAqICAgICAgICAgICBjb21wYXRpYmlsaXR5IG1vZGUsIGVpdGhlciB0aGVpciBjb25zdHJ1Y3RvcnMgb3Igc3RyaW5nc1xuICogICAgICAgICAgIHJlcHJlc2VudGluZyB0aGVtIChlLmcuICdzb3knIG9yICdqc3gnKS4gQnkgZGVmYXVsdCwgYWxsIHRoZSBvbmVzXG4gKiAgICAgICAgICAgdGhhdCBleHRlbmQgZnJvbSBJbmNyZW1lbnRhbERvbVJlbmRlcmVyLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKG9wdF9kYXRhID0ge30pIHtcblx0Y29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IG9wdF9kYXRhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRhdGEgdXNlZCBmb3IgY29tcGF0aWJpbGl0eSBtb2RlLCBvciBub3RoaW5nIGlmIGl0IGhhc24ndCBiZWVuXG4gKiBlbmFibGVkLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhKCkge1xuXHQvLyBDb21wYXRpYmlsaXR5IG1vZGUgY2FuIGJlIHNldCB2aWEgdGhlIF9fTUVUQUxfQ09NUEFUSUJJTElUWV9fIGdsb2JhbCB2YXIuXG5cdGlmICghY29tcGF0aWJpbGl0eU1vZGVEYXRhXykge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pIHtcblx0XHRcdGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXyk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjb21wYXRpYmlsaXR5TW9kZURhdGFfO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3RcbiAqIHN1cHBvcnQgdGhlIGBuYW1lYCBwcm9wZXJ0eSwgdGhpcyB3aWxsIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBmdW5jdGlvbidzXG4gKiBjb250ZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcblx0aWYgKCFmbi5uYW1lKSB7XG5cdFx0dmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG5cdFx0Zm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG5cdH1cblx0cmV0dXJuIGZuLm5hbWU7XG59XG5cbi8qKlxuICogR2V0cyBhbiB1bmlxdWUgaWQuIElmIGBvcHRfb2JqZWN0YCBhcmd1bWVudCBpcyBwYXNzZWQsIHRoZSBvYmplY3QgaXNcbiAqIG11dGF0ZWQgd2l0aCBhbiB1bmlxdWUgaWQuIENvbnNlY3V0aXZlIGNhbGxzIHdpdGggdGhlIHNhbWUgb2JqZWN0XG4gKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuICogcmV0dXJucy4gU2VlIHtAbGluayBVSURfUFJPUEVSVFl9LlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0IE9wdGlvbmFsIG9iamVjdCB0byBiZSBtdXRhdGVkIHdpdGggdGhlIHVpZC4gSWZcbiAqICAgICBub3Qgc3BlY2lmaWVkIHRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyB0aGUgdWlkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcbiAqICAgICBvYmplY3QncyB1aWQgcHJvcGVydHkgY2FuIGJlIGluaGVyaXRlZCBmcm9tIHBhcmVudHMgb3Igbm90LlxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWlkKG9wdF9vYmplY3QsIG9wdF9ub0luaGVyaXRhbmNlKSB7XG5cdGlmIChvcHRfb2JqZWN0KSB7XG5cdFx0dmFyIGlkID0gb3B0X29iamVjdFtVSURfUFJPUEVSVFldO1xuXHRcdGlmIChvcHRfbm9Jbmhlcml0YW5jZSAmJiAhb3B0X29iamVjdC5oYXNPd25Qcm9wZXJ0eShVSURfUFJPUEVSVFkpKSB7XG5cdFx0XHRpZCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpZCB8fCAob3B0X29iamVjdFtVSURfUFJPUEVSVFldID0gdW5pcXVlSWRDb3VudGVyXysrKTtcblx0fVxuXHRyZXR1cm4gdW5pcXVlSWRDb3VudGVyXysrO1xufVxuXG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi4gUmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gKiBAcGFyYW0geyo9fSBvcHRfcmV0dXJuVmFsdWUgVGhlIHNpbmdsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZmlyc3QgYXJndW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZih2YWwpIHtcblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmQW5kTm90TnVsbCh2YWwpIHtcblx0cmV0dXJuIGlzRGVmKHZhbCkgJiYgIWlzTnVsbCh2YWwpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RvY3VtZW50KHZhbCkge1xuXHRyZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gOTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb20gZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KHZhbCkge1xuXHRyZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsKSB7XG5cdHJldHVybiB2YWwgPT09IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dpbmRvdyh2YWwpIHtcblx0cmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgPT09IHZhbC53aW5kb3c7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGFycmF5c1xuICogYW5kIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuXHR2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cdHJldHVybiB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBQcm9taXNlLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG5cdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbi8qKlxuICogTWVyZ2VzIHRoZSB2YWx1ZXMgb2YgYSBleHBvcnQgZnVuY3Rpb24gcHJvcGVydHkgYSBjbGFzcyB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhhdFxuICogcHJvcGVydHkgZm9yIGFsbCBpdHMgc3VwZXIgY2xhc3NlcywgYW5kIHN0b3JlcyBpdCBhcyBhIG5ldyBzdGF0aWNcbiAqIHByb3BlcnR5IG9mIHRoYXQgY2xhc3MuIElmIHRoZSBleHBvcnQgZnVuY3Rpb24gcHJvcGVydHkgYWxyZWFkeSBleGlzdGVkLCBpdCB3b24ndFxuICogYmUgcmVjYWxjdWxhdGVkLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY29uc3RydWN0b3IgQ2xhc3MgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgY29sbGVjdGVkLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKToqPX0gb3B0X21lcmdlRm4gRnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhbiBhcnJheSBmaWxsZWRcbiAqICAgd2l0aCB0aGUgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0eSBmb3IgdGhlIGN1cnJlbnQgY2xhc3MgYW5kIGFsbCBpdHMgc3VwZXIgY2xhc3Nlcy5cbiAqICAgU2hvdWxkIHJldHVybiB0aGUgbWVyZ2VkIHZhbHVlIHRvIGJlIHN0b3JlZCBvbiB0aGUgY3VycmVudCBjbGFzcy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBtZXJnZSBoYXBwZW5zLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVN1cGVyQ2xhc3Nlc1Byb3BlcnR5KGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUsIG9wdF9tZXJnZUZuKSB7XG5cdHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuXHRpZiAoY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkobWVyZ2VkTmFtZSkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgbWVyZ2VkID0gY29sbGVjdFN1cGVyQ2xhc3Nlc1Byb3BlcnR5KGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUpO1xuXHRpZiAob3B0X21lcmdlRm4pIHtcblx0XHRtZXJnZWQgPSBvcHRfbWVyZ2VGbihtZXJnZWQpO1xuXHR9XG5cdGNvbnN0cnVjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBOdWxsIGZ1bmN0aW9uIHVzZWQgZm9yIGRlZmF1bHQgdmFsdWVzIG9mIGNhbGxiYWNrcywgZXRjLlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bGxGdW5jdGlvbigpIHt9XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBleGlzdHMganVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIG1ha2luZyBzdXJlIHRoYXQgb2xkXG4vLyBkZWZhdWx0IGltcG9ydHMgZm9yIHRoaXMgZmlsZSBzdGlsbCB3b3JrLiBJdCdzIGJlc3QgdG8gdXNlIHRoZSBuYW1lZCBleHBvcnRzXG4vLyBmb3IgZWFjaCBmdW5jdGlvbiBpbnN0ZWFkIHRob3VnaCwgc2luY2UgdGhhdCBhbGxvd3MgYnVuZGxlcnMgbGlrZSBSb2xsdXAgdG9cbi8vIHJlZHVjZSB0aGUgYnVuZGxlIHNpemUgYnkgcmVtb3ZpbmcgdW51c2VkIGNvZGUuXG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJy4vY29yZU5hbWVkJztcblxuZXhwb3J0IGRlZmF1bHQgY29yZTtcbmV4cG9ydCB7IGNvcmUgfTtcbmV4cG9ydCAqIGZyb20gJy4vY29yZU5hbWVkJztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgaXNEZWYgfSBmcm9tICcuLi9jb3JlJztcblxuY2xhc3MgYXJyYXkge1xuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LlxuXHQgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuXHQgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGVxdWFsKGFycjEsIGFycjIpIHtcblx0XHRpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBpc24ndCB1bmRlZmluZWQuXG5cdCAqIEBwYXJhbSB7IUFycmF5fSBhcnJcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdHN0YXRpYyBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycltpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIGlucHV0IG5lc3RlZCBhcnJheSB0byBiZWNvbWUgZmxhdC5cblx0ICogQHBhcmFtIHtBcnJheS48KnxBcnJheS48Kj4+fSBhcnIgTmVzdGVkIGFycmF5IHRvIGZsYXR0ZW4uXG5cdCAqIEBwYXJhbSB7QXJyYXkuPCo+fSBvcHRfb3V0cHV0IE9wdGlvbmFsIG91dHB1dCBhcnJheS5cblx0ICogQHJldHVybiB7QXJyYXkuPCo+fSBGbGF0IGFycmF5LlxuXHQgKi9cblx0c3RhdGljIGZsYXR0ZW4oYXJyLCBvcHRfb3V0cHV0KSB7XG5cdFx0dmFyIG91dHB1dCA9IG9wdF9vdXRwdXQgfHwgW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcblx0XHRcdFx0YXJyYXkuZmxhdHRlbihhcnJbaV0sIG91dHB1dCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG5cdCAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdHN0YXRpYyByZW1vdmUoYXJyLCBvYmopIHtcblx0XHR2YXIgaSA9IGFyci5pbmRleE9mKG9iaik7XG5cdFx0dmFyIHJ2O1xuXHRcdGlmICggKHJ2ID0gaSA+PSAwKSApIHtcblx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0fVxuXHRcdHJldHVybiBydjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGZyb20gYW4gYXJyYXkgdGhlIGVsZW1lbnQgYXQgaW5kZXggaVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3QgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbmRleCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cblx0ICovXG5cdHN0YXRpYyByZW1vdmVBdChhcnIsIGkpIHtcblx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyciwgaSwgMSkubGVuZ3RoID09PSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNsaWNlcyB0aGUgZ2l2ZW4gYXJyYXksIGp1c3QgbGlrZSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCB0aGlzXG5cdCAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IHRoYXQgc2hvdWxkIHN0YXJ0IHRoZSBzbGljZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG5cdCAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcblx0ICogICBzdGFydCBpbmRleCB3aWxsIGJlIGluY2x1ZGVkLlxuXHQgKiBAcmV0dXJuIHshQXJyYXl9XG5cdCAqL1xuXHRzdGF0aWMgc2xpY2UoYXJyLCBzdGFydCwgb3B0X2VuZCkge1xuXHRcdHZhciBzbGljZWQgPSBbXTtcblx0XHR2YXIgZW5kID0gaXNEZWYob3B0X2VuZCkgPyBvcHRfZW5kIDogYXJyLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0c2xpY2VkLnB1c2goYXJyW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHNsaWNlZDtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheTtcbiIsIi8qIVxuICogUG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKiBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXN5bmMgPSB7fTtcblxuXG4vKipcbiAqIFRocm93IGFuIGl0ZW0gd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICBGb3JcbiAqIGV4YW1wbGUsIGlmIHByb2Nlc3NpbmcgYSBncm91cCBvZiBpdGVtcyBpbiBhIGxvb3AsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAqIHRvIHJlcG9ydCBhbiBlcnJvciB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgcmVzdCBvZiB0aGUgYmF0Y2ggdG8gYmVcbiAqIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7Kn0gZXhjZXB0aW9uXG4gKi9cbmFzeW5jLnRocm93RXhjZXB0aW9uID0gZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG5cdC8vIEVhY2ggdGhyb3cgbmVlZHMgdG8gYmUgaW4gaXRzIG93biBjb250ZXh0LlxuXHRhc3luYy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBleGNlcHRpb247XG5cdH0pO1xufTtcblxuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBjYWxsc3RhY2sgdW53aW5kcywgb3IgYXNcbiAqIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyl9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBPYmplY3QgdG8gdXNlIGFzIHRoZSBcInRoaXMgdmFsdWVcIiB3aGVuIGNhbGxpbmdcbiAqICAgICB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5hc3luYy5ydW4gPSBmdW5jdGlvbihjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0aWYgKCFhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXykge1xuXHRcdC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHNjaGVkdWxlZCwgc2NoZWR1bGUgaXQgbm93LlxuXHRcdGFzeW5jLm5leHRUaWNrKGFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlKTtcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IHRydWU7XG5cdH1cblxuXHRhc3luYy5ydW4ud29ya1F1ZXVlXy5wdXNoKFxuXHRcdG5ldyBhc3luYy5ydW4uV29ya0l0ZW1fKGNhbGxiYWNrLCBvcHRfY29udGV4dCkpO1xufTtcblxuXG4vKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xuXG5cbi8qKiBAcHJpdmF0ZSB7IUFycmF5LjwhYXN5bmMucnVuLldvcmtJdGVtXz59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXG4vKipcbiAqIFJ1biBhbnkgcGVuZGluZyBhc3luYy5ydW4gd29yayBpdGVtcy4gVGhpcyBmdW5jdGlvbiBpcyBub3QgaW50ZW5kZWRcbiAqIGZvciBnZW5lcmFsIHVzZSwgYnV0IGZvciB1c2UgYnkgZW50cnkgcG9pbnQgaGFuZGxlcnMgdG8gcnVuIGl0ZW1zIGFoZWFkIG9mXG4gKiBhc3luYy5uZXh0VGljay5cbiAqL1xuYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUgPSBmdW5jdGlvbigpIHtcblx0Ly8gTk9URTogYWRkaXRpb25hbCB3b3JrIHF1ZXVlIGl0ZW1zIG1heSBiZSBwdXNoZWQgd2hpbGUgcHJvY2Vzc2luZy5cblx0d2hpbGUgKGFzeW5jLnJ1bi53b3JrUXVldWVfLmxlbmd0aCkge1xuXHRcdC8vIERvbid0IGxldCB0aGUgd29yayBxdWV1ZSBncm93IGluZGVmaW5pdGVseS5cblx0XHR2YXIgd29ya0l0ZW1zID0gYXN5bmMucnVuLndvcmtRdWV1ZV87XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHdvcmtJdGVtID0gd29ya0l0ZW1zW2ldO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d29ya0l0ZW0uZm4uY2FsbCh3b3JrSXRlbS5zY29wZSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGFzeW5jLnRocm93RXhjZXB0aW9uKGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoZXJlIGFyZSBubyBtb3JlIHdvcmsgaXRlbXMsIHJlc2V0IHRoZSB3b3JrIHF1ZXVlLlxuXHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzY29wZVxuICovXG5hc3luYy5ydW4uV29ya0l0ZW1fID0gZnVuY3Rpb24oZm4sIHNjb3BlKSB7XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5mbiA9IGZuO1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn07XG5cblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlNcbiAqIGV4ZWN1dGlvbiBjb250ZXh0LiBzZXRUaW1lb3V0KOKApiwgMCkgYWx3YXlzIHRha2VzIGF0IGxlYXN0IDVtcyBmb3IgbGVnYWN5XG4gKiByZWFzb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlNDT1BFKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzXG4gKiAgICAgcG9zc2libGUuXG4gKiBAcGFyYW0ge1NDT1BFPX0gb3B0X2NvbnRleHQgT2JqZWN0IGluIHdob3NlIHNjb3BlIHRvIGNhbGwgdGhlIGxpc3RlbmVyLlxuICogQHRlbXBsYXRlIFNDT1BFXG4gKi9cbmFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdHZhciBjYiA9IGNhbGxiYWNrO1xuXHRpZiAob3B0X2NvbnRleHQpIHtcblx0XHRjYiA9IGNhbGxiYWNrLmJpbmQob3B0X2NvbnRleHQpO1xuXHR9XG5cdGNiID0gYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyhjYik7XG5cdC8vIEludHJvZHVjZWQgYW5kIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBJRTEwLlxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHNldEltbWVkaWF0ZShjYik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIExvb2sgZm9yIGFuZCBjYWNoZSB0aGUgY3VzdG9tIGZhbGxiYWNrIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLlxuXHRpZiAoIWFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8pIHtcblx0XHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfKCk7XG5cdH1cblx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyhjYik7XG59O1xuXG5cbi8qKlxuICogQ2FjaGUgZm9yIHRoZSBzZXRJbW1lZGlhdGUgaW1wbGVtZW50YXRpb24uXG4gKiBAdHlwZSB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9XG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gbnVsbDtcblxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3QgcG9zc2libGUgaW1wbGVtZW50YXRpb24gdG8gcnVuIGEgZnVuY3Rpb24gYXMgc29vbiBhc1xuICogdGhlIEpTIGV2ZW50IGxvb3AgaXMgaWRsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfSBUaGUgXCJzZXRJbW1lZGlhdGVcIiBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyA9IGZ1bmN0aW9uKCkge1xuXHQvLyBDcmVhdGUgYSBwcml2YXRlIG1lc3NhZ2UgY2hhbm5lbCBhbmQgdXNlIGl0IHRvIHBvc3RNZXNzYWdlIGVtcHR5IG1lc3NhZ2VzXG5cdC8vIHRvIG91cnNlbHZlcy5cblx0dmFyIENoYW5uZWw7XG5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdENoYW5uZWwgPSBNZXNzYWdlQ2hhbm5lbDtcblx0fVxuXG5cdC8vIElmIE1lc3NhZ2VDaGFubmVsIGlzIG5vdCBhdmFpbGFibGUgYW5kIHdlIGFyZSBpbiBhIGJyb3dzZXIsIGltcGxlbWVudFxuXHQvLyBhbiBpZnJhbWUgYmFzZWQgcG9seWZpbGwgaW4gYnJvd3NlcnMgdGhhdCBoYXZlIHBvc3RNZXNzYWdlIGFuZFxuXHQvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLiBUaGUgbGF0dGVyIGV4Y2x1ZGVzIElFOCBiZWNhdXNlIGl0IGhhcyBhXG5cdC8vIHN5bmNocm9ub3VzIHBvc3RNZXNzYWdlIGltcGxlbWVudGF0aW9uLlxuXHRpZiAodHlwZW9mIENoYW5uZWwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0d2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRcdENoYW5uZWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdC8vIE1ha2UgYW4gZW1wdHksIGludmlzaWJsZSBpZnJhbWUuXG5cdFx0XHR2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdGlmcmFtZS5zcmMgPSAnJztcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdFx0dmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuXHRcdFx0dmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcblx0XHRcdGRvYy5vcGVuKCk7XG5cdFx0XHRkb2Mud3JpdGUoJycpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cdFx0XHR2YXIgbWVzc2FnZSA9ICdjYWxsSW1tZWRpYXRlJyArIE1hdGgucmFuZG9tKCk7XG5cdFx0XHR2YXIgb3JpZ2luID0gd2luLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbi5sb2NhdGlvbi5ob3N0O1xuXHRcdFx0dmFyIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgb3JpZ2luIGFuZCBtZXNzYWdlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgbWVzc2FnZSB3YXNcblx0XHRcdFx0Ly8gaW50ZW5kZWQgZm9yIHVzLlxuXHRcdFx0XHRpZiAoZS5vcmlnaW4gIT09IG9yaWdpbiAmJiBlLmRhdGEgIT09IG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wb3J0MS5vbm1lc3NhZ2UoKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnBvcnQxID0ge307XG5cdFx0XHR0aGlzLnBvcnQyID0ge1xuXHRcdFx0XHRwb3N0TWVzc2FnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0d2luLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZW9mIENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuXHRcdC8vIFVzZSBhIGZpZm8gbGlua2VkIGxpc3QgdG8gY2FsbCBjYWxsYmFja3MgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdHZhciBoZWFkID0ge307XG5cdFx0dmFyIHRhaWwgPSBoZWFkO1xuXHRcdGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWFkID0gaGVhZC5uZXh0O1xuXHRcdFx0dmFyIGNiID0gaGVhZC5jYjtcblx0XHRcdGhlYWQuY2IgPSBudWxsO1xuXHRcdFx0Y2IoKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbihjYikge1xuXHRcdFx0dGFpbC5uZXh0ID0ge1xuXHRcdFx0XHRjYjogY2Jcblx0XHRcdH07XG5cdFx0XHR0YWlsID0gdGFpbC5uZXh0O1xuXHRcdFx0Y2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcblx0XHR9O1xuXHR9XG5cdC8vIEltcGxlbWVudGF0aW9uIGZvciBJRTYtODogU2NyaXB0IGVsZW1lbnRzIGZpcmUgYW4gYXN5bmNocm9ub3VzXG5cdC8vIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aGVuIGluc2VydGVkIGludG8gdGhlIERPTS5cblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW5cblx0XHRkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXHRcdHJldHVybiBmdW5jdGlvbihjYikge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBDbGVhbiB1cCBhbmQgY2FsbCB0aGUgY2FsbGJhY2suXG5cdFx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0XHRjYiA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fTtcblx0fVxuXHQvLyBGYWxsIGJhY2sgdG8gc2V0VGltZW91dCB3aXRoIDAuIEluIGJyb3dzZXJzIHRoaXMgY3JlYXRlcyBhIGRlbGF5IG9mIDVtc1xuXHQvLyBvciBtb3JlLlxuXHRyZXR1cm4gZnVuY3Rpb24oY2IpIHtcblx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0fTtcbn07XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpcyBvdmVycmlkZWQgdG8gcHJvdGVjdCBjYWxsYmFja3Mgd2l0aCBlbnRyeSBwb2ludFxuICogbW9uaXRvciBpZiB0aGUgYXBwbGljYXRpb24gbW9uaXRvcnMgZW50cnkgcG9pbnRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXMgcG9zc2libGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBUaGUgd3JhcHBlZCBjYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18gPSBmdW5jdGlvbihvcHRfcmV0dXJuVmFsdWUpIHtcblx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpc3Bvc2FibGUgdXRpbGl0eS4gV2hlbiBpbmhlcml0ZWQgcHJvdmlkZXMgdGhlIGBkaXNwb3NlYCBmdW5jdGlvbiB0byBpdHNcbiAqIHN1YmNsYXNzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIGFueSBvYmplY3QgcmVmZXJlbmNlc1xuICogd2hlbiBhbiBpbnN0YW5jZSB3b24ndCBiZSB1c2VkIGFueW1vcmUuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG4gKiBgZGlzcG9zZUludGVybmFsYCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljIGRpc3Bvc2luZyBsb2dpYy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBEaXNwb3NhYmxlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0LyoqXG5cdFx0ICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuIENhbGxzIGBkaXNwb3NlSW50ZXJuYWxgLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblx0XHRpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG5cdFx0XHR0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdFx0dGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljXG5cdCAqIGRpc3Bvc2luZyBsb2dpYyAobGlrZSBjbGVhcmluZyByZWZlcmVuY2VzIGFuZCBjYWxsaW5nIGBkaXNwb3NlYCBvbiBvdGhlclxuXHQgKiBkaXNwb3NhYmxlcykuXG5cdCAqL1xuXHRkaXNwb3NlSW50ZXJuYWwoKSB7fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNEaXNwb3NlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXNwb3NlZF87XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlzcG9zYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3Mgb2JqZWN0IHtcblx0LyoqXG5cdCAqIENvcGllcyBhbGwgdGhlIG1lbWJlcnMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0LlxuXHQgKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgVGhlIG9iamVjdHMgZnJvbSB3aGljaCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2UuXG5cdCAqL1xuXHRzdGF0aWMgbWl4aW4odGFyZ2V0KSB7XG5cdFx0dmFyIGtleSwgc291cmNlO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgZnVsbHkgcXVhbGlmaWVkIGV4dGVybmFsIG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZS5cblx0ICogQHBhcmFtIHtvYmplY3Q9fSBvcHRfb2JqIFRoZSBvYmplY3Qgd2l0aGluIHdoaWNoIHRvIGxvb2s7IGRlZmF1bHQgaXNcblx0ICogICAgIDxjb2RlPndpbmRvdzwvY29kZT4uXG5cdCAqIEByZXR1cm4gez99IFRoZSB2YWx1ZSAob2JqZWN0IG9yIHByaW1pdGl2ZSkgb3IsIGlmIG5vdCBmb3VuZCwgdW5kZWZpbmVkLlxuXHQgKi9cblx0c3RhdGljIGdldE9iamVjdEJ5TmFtZShuYW1lLCBvcHRfb2JqKSB7XG5cdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcdHJldHVybiBwYXJ0cy5yZWR1Y2UoKHBhcnQsIGtleSkgPT4gcGFydFtrZXldLCBzY29wZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG5cdCAqIHRoZWlyIHZhbHVlcyBzZXQgdG8gdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBvYmpcblx0ICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICovXG5cdHN0YXRpYyBtYXAob2JqLCBmbikge1xuXHRcdHZhciBtYXBwZWRPYmogPSB7fTtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXBwZWRPYmpba2V5c1tpXV0gPSBmbihrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFwcGVkT2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgdHdvIGdpdmVuIG9iamVjdHMgYXJlIGVxdWFsLiBUaGlzIGlzIGRvbmUgdmlhIGEgc2hhbGxvd1xuXHQgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgc2hhbGxvd0VxdWFsKG9iajEsIG9iajIpIHtcblx0XHRpZiAob2JqMSA9PT0gb2JqMikge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dmFyIGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG5cdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0aWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3Mgc3RyaW5nIHtcblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGJyZWFraW5nIHNwYWNlcyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc3RyaW5nIGFuZFxuXHQgKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG5cdCAqIFRoZSBvcmlnaW5hbCBhbmQgdGhlIHJlc3VsdCBzdHJpbmdzIHJlbmRlciB0aGUgc2FtZSB3YXkgaW4gSFRNTC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBpbiB3aGljaCB0byBjb2xsYXBzZSBzcGFjZXMuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG5cdCAqL1xuXHRzdGF0aWMgY29sbGFwc2VCcmVha2luZ1NwYWNlcyhzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHRcXHJcXG4gXSsvZywgJyAnKS5yZXBsYWNlKC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG5cdH1cblxuXHQvKipcblx0KiBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0aGF0IGFyZSBub3Qgc2FmZSB0byB1c2UgaW4gYSBSZWdFeHAuXG5cdCogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBlc2NhcGUuIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZSBjYXN0ZWRcblx0KiAgICAgdG8gb25lLlxuXHQqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cblx0Ki9cblx0c3RhdGljIGVzY2FwZVJlZ2V4KHN0cikge1xuXHRcdHJldHVybiBTdHJpbmcoc3RyKVxuXHRcdFx0LnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJylcblx0XHRcdC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXHgwOCcpO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyBhIHN0cmluZyB3aXRoIGF0IGxlYXN0IDY0LWJpdHMgb2YgcmFuZG9tbmVzcy5cblx0KiBAcmV0dXJuIHtzdHJpbmd9IEEgcmFuZG9tIHN0cmluZywgZS5nLiBzbjFzN3ZiNGdjaWMuXG5cdCovXG5cdHN0YXRpYyBnZXRSYW5kb21TdHJpbmcoKSB7XG5cdFx0dmFyIHggPSAyMTQ3NDgzNjQ4O1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KS50b1N0cmluZygzNikgK1xuXHRcdFx0TWF0aC5hYnMoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkgXiBEYXRlLm5vdygpKS50b1N0cmluZygzNik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgaGFzaGNvZGUgZm9yIGEgc3RyaW5nLiBUaGUgaGFzaGNvZGUgdmFsdWUgaXMgY29tcHV0ZWQgYnlcblx0ICogdGhlIHN1bSBhbGdvcml0aG06IHNbMF0qMzFeKG4tMSkgKyBzWzFdKjMxXihuLTIpICsgLi4uICsgc1tuLTFdLiBBIG5pY2Vcblx0ICogcHJvcGVydHkgb2YgdXNpbmcgMzEgcHJpbWUgaXMgdGhhdCB0aGUgbXVsdGlwbGljYXRpb24gY2FuIGJlIHJlcGxhY2VkIGJ5XG5cdCAqIGEgc2hpZnQgYW5kIGEgc3VidHJhY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZTogMzEqaSA9PSAoaTw8NSktaS5cblx0ICogTW9kZXJuIFZNcyBkbyB0aGlzIHNvcnQgb2Ygb3B0aW1pemF0aW9uIGF1dG9tYXRpY2FsbHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGFyZ2V0IHN0cmluZy5cblx0ICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgaGFzaGNvZGUuXG5cdCAqL1xuXHRzdGF0aWMgaGFzaENvZGUodmFsKSB7XG5cdFx0dmFyIGhhc2ggPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGhhc2ggPSAzMSAqIGhhc2ggKyB2YWwuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggJT0gMHgxMDAwMDAwMDA7XG5cdFx0fVxuXHRcdHJldHVybiBoYXNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIGludGVydmFsIGludG8gdGhlIHN0cmluZyB3aXRoIHNwZWNpZmllZCB2YWx1ZSwgZS5nLlxuXHQgKiBgcmVwbGFjZUludGVydmFsKFwiYWJjZGVcIiwgMSwgNCwgXCJcIilgIHJldHVybnMgXCJhZVwiLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbnB1dCBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCByZXBsYWNlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRzdGF0aWMgcmVwbGFjZUludGVydmFsKHN0ciwgc3RhcnQsIGVuZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdGFydCkgKyB2YWx1ZSArIHN0ci5zdWJzdHJpbmcoZW5kKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHN0b3JpbmcgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBwcmludGVkIGFzIEpTT05cbiAqIHdoZW4gdGhlIGB0b1N0cmluZ2AgbWV0aG9kIGlzIGNhbGxlZC5cbiAqL1xuY2xhc3MgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIEVtYm9kaWVkIGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuYm9keV8gPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICovXG5cdGJvZHkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV87XG5cdH1cblxuXHQvKipcblx0ICogSWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBFbWJvZGllZCwgdGhpcyB3aWxsXG5cdCAqIHJldHVybiBpdHMgYm9keSBjb250ZW50LiBPdGhlcndpc2UgdGhpcyB3aWxsIHJldHVybiB0aGVcblx0ICogb3JpZ2luYWwgb2JqZWN0LlxuXHQgKiBAcGFyYW0geyp9IG9ialxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgdG9Cb2R5KG9iaikge1xuXHRcdHJldHVybiAob2JqIGluc3RhbmNlb2YgRW1ib2RpZWQpID8gb2JqLmJvZHkoKSA6IG9iajtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhpcyBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSgpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbWJvZGllZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhbmQgaGFuZGxpbmcgdGhlIGJvZHkgY29udGVudHNcbiAqIG9mIGEgRmlsdGVyIGluc3RhbmNlLlxuICovXG5jbGFzcyBGaWx0ZXJCb2R5IHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgRmlsdGVyQm9keX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IG9wZXJhdG9yT3JWYWx1ZSBJZiBhIHRoaXJkIHBhcmFtIGlzIGdpdmVuLCB0aGlzIHNob3VsZFxuXHQgKiAgIGJlIHRoZSBmaWx0ZXIncyBvcGVyYXRvciAobGlrZSBcIj49XCIpLiBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZVxuXHQgKiAgIHVzZWQgYXMgdGhlIGZpbHRlcidzIHZhbHVlLCBhbmQgdGhlIGZpbHRlcidzIG9wZXJhdG9yIHdpbGwgYmUgXCI9XCIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0dmFyIG9iaiA9IHtcblx0XHRcdG9wZXJhdG9yOiBjb3JlLmlzRGVmKG9wdF92YWx1ZSkgPyBvcGVyYXRvck9yVmFsdWUgOiAnPSdcblx0XHR9O1xuXG5cdFx0dmFyIHZhbHVlID0gY29yZS5pc0RlZihvcHRfdmFsdWUpID8gb3B0X3ZhbHVlIDogb3BlcmF0b3JPclZhbHVlO1xuXG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKHZhbHVlKSkge1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRW1ib2RpZWQpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5ib2R5KCk7XG5cdFx0XHR9XG5cdFx0XHRvYmoudmFsdWUgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwoZmllbGQpKSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUJvZHlfKGZpZWxkLCBvYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUJvZHlfKCdhbmQnLCBbXSk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcG9zZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHdpdGggdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHtGaWx0ZXI9fSBvcHRfZmlsdGVyIEFub3RoZXIgZmlsdGVyIHRvIGNvbXBvc2UgdGhpcyBmaWx0ZXIgd2l0aCxcblx0ICogICBpZiB0aGUgb3BlcmF0b3IgaXMgbm90IHVuYXJ5LlxuXHQgKi9cblx0YWRkKG9wZXJhdG9yLCBvcHRfZmlsdGVyKSB7XG5cdFx0aWYgKG9wdF9maWx0ZXIpIHtcblx0XHRcdHRoaXMuYWRkQXJyYXlPcGVyYXRvcl8ob3BlcmF0b3IsIG9wdF9maWx0ZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUJvZHlfKG9wZXJhdG9yLCB0aGlzLmJvZHlfKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ29tcG9zZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHdpdGggYW4gb3BlcmF0b3IgdGhhdCBzdG9yZXMgaXRzIHZhbHVlcyBpbiBhbiBhcnJheS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7IUZpbHRlcn0gZmlsdGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGFkZEFycmF5T3BlcmF0b3JfKG9wZXJhdG9yLCBmaWx0ZXIpIHtcblx0XHRpZiAoISh0aGlzLmJvZHlfW29wZXJhdG9yXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0dGhpcy5jcmVhdGVCb2R5XyhvcGVyYXRvciwgW3RoaXMuYm9keV9dKTtcblx0XHR9XG5cdFx0dGhpcy5ib2R5X1tvcGVyYXRvcl0ucHVzaChmaWx0ZXIuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciBib2R5IHVzaW5nIHRoZSBnaXZlbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7Li4uKn0gZmlsdGVycyBBIHZhcmlhYmxlIGFtb3VudCBvZiBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkLlxuXHQgKi9cblx0YWRkTWFueShvcGVyYXRvciwgLi4uZmlsdGVycykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5hZGQob3BlcmF0b3IsIGZpbHRlcnNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IGJvZHkgb2JqZWN0LCBzZXR0aW5nIHRoZSByZXF1ZXN0ZCBrZXkgdG8gdGhlIGdpdmVuIHZhbHVlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2V0IGluIHRoZSBuZXcgYm9keSBvYmplY3Rcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIHJlcXVlc3RlZCBrZXkgc2hvdWxkIGhhdmUgaW4gdGhlIG5ldyBib2R5IG9iamVjdC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Y3JlYXRlQm9keV8oa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMuYm9keV8gPSB7fTtcblx0XHR0aGlzLmJvZHlfW2tleV0gPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBmaWx0ZXIncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0Z2V0T2JqZWN0KCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlckJvZHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGdlb21ldHJpY1xuICogc2hhcGVzLlxuICovXG5jbGFzcyBHZW8ge1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQm91bmRpbmdCb3h9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHVwcGVyTGVmdCBUaGUgdXBwZXIgbGVmdCBwb2ludC5cblx0ICogQHBhcmFtIHsqfSBsb3dlclJpZ2h0IFRoZSBsb3dlciByaWdodCBwb2ludC5cblx0ICogQHJldHVybiB7IUJvdW5kaW5nQm94fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYm91bmRpbmdCb3godXBwZXJMZWZ0LCBsb3dlclJpZ2h0KSB7XG5cdFx0cmV0dXJuIG5ldyBHZW8uQm91bmRpbmdCb3godXBwZXJMZWZ0LCBsb3dlclJpZ2h0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBDaXJjbGV9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGNlbnRlciBUaGUgY2lyY2xlJ3MgY2VudGVyIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByYWRpdXMgVGhlIGNpcmNsZSdzIHJhZGl1cy5cblx0ICogQHJldHVybiB7IUNpcmNsZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGNpcmNsZShjZW50ZXIsIHJhZGl1cykge1xuXHRcdHJldHVybiBuZXcgR2VvLkNpcmNsZShjZW50ZXIsIHJhZGl1cyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgTGluZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgbGluZSdzIHBvaW50cy5cblx0ICogQHJldHVybiB7IUxpbmV9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBsaW5lKC4uLnBvaW50cykge1xuXHRcdHJldHVybiBuZXcgR2VvLkxpbmUoLi4ucG9pbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBQb2ludH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGNvb3JkaW5hdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxvbiBUaGUgbG9uZ2l0dWRlIGNvb3JkaW5hdGVcblx0ICogQHJldHVybiB7IVBvaW50fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcG9pbnQobGF0LCBsb24pIHtcblx0XHRyZXR1cm4gbmV3IEdlby5Qb2ludChsYXQsIGxvbik7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUG9seWdvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgcG9seWdvbidzIHBvaW50cy5cblx0ICogQHJldHVybiB7IVBvbHlnb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBwb2x5Z29uKC4uLnBvaW50cykge1xuXHRcdHJldHVybiBuZXcgR2VvLlBvbHlnb24oLi4ucG9pbnRzKTtcblx0fVxufVxuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvaW50IGNvb3JkaW5hdGUuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFBvaW50IGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBQb2ludH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGNvb3JkaW5hdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxvbiBUaGUgbG9uZ2l0dWRlIGNvb3JkaW5hdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihsYXQsIGxvbikge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IFtsYXQsIGxvbl07XG5cdH1cbn1cbkdlby5Qb2ludCA9IFBvaW50O1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGxpbmUuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIExpbmUgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIExpbmV9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0gey4uLip9IHBvaW50cyBUaGlzIGxpbmUncyBwb2ludHMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0ge1xuXHRcdFx0dHlwZTogJ2xpbmVzdHJpbmcnLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IHBvaW50cy5tYXAocG9pbnQgPT4gRW1ib2RpZWQudG9Cb2R5KHBvaW50KSlcblx0XHR9O1xuXHR9XG59XG5HZW8uTGluZSA9IExpbmU7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgYm91bmRpbmcgYm94LlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBCb3VuZGluZ0JveCBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgQm91bmRpbmdCb3h9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHVwcGVyTGVmdCBUaGUgdXBwZXIgbGVmdCBwb2ludC5cblx0ICogQHBhcmFtIHsqfSBsb3dlclJpZ2h0IFRoZSBsb3dlciByaWdodCBwb2ludC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih1cHBlckxlZnQsIGxvd2VyUmlnaHQpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSB7XG5cdFx0XHR0eXBlOiAnZW52ZWxvcGUnLFxuXHRcdFx0Y29vcmRpbmF0ZXM6IFtFbWJvZGllZC50b0JvZHkodXBwZXJMZWZ0KSwgRW1ib2RpZWQudG9Cb2R5KGxvd2VyUmlnaHQpXVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGJvdW5kaW5nIGJveCdzIHBvaW50cy5cblx0ICogQHJldHVybiB7IUFycmF5fVxuXHQgKi9cblx0Z2V0UG9pbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfLmNvb3JkaW5hdGVzO1xuXHR9XG59XG5HZW8uQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBjaXJjbGUuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIENpcmNsZSBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgQ2lyY2xlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSBjZW50ZXIgVGhlIGNpcmNsZSdzIGNlbnRlciBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcmFkaXVzIFRoZSBjaXJjbGUncyByYWRpdXMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoY2VudGVyLCByYWRpdXMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuYm9keV8gPSB7XG5cdFx0XHR0eXBlOiAnY2lyY2xlJyxcblx0XHRcdGNvb3JkaW5hdGVzOiBFbWJvZGllZC50b0JvZHkoY2VudGVyKSxcblx0XHRcdHJhZGl1czogcmFkaXVzXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgY2lyY2xlJ3MgY2VudGVyIGNvb3JkaW5hdGUuXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRnZXRDZW50ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm9keV8uY29vcmRpbmF0ZXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGNpcmNsZSdzIHJhZGl1cy5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UmFkaXVzKCkge1xuXHRcdHJldHVybiB0aGlzLmJvZHlfLnJhZGl1cztcblx0fVxufVxuR2VvLkNpcmNsZSA9IENpcmNsZTtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBwb2x5Z29uLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBQb2x5Z29uIGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBQb2x5Z29ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBwb2x5Z29uJ3MgcG9pbnRzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKC4uLnBvaW50cykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5ib2R5XyA9IHtcblx0XHRcdHR5cGU6ICdwb2x5Z29uJyxcblx0XHRcdGNvb3JkaW5hdGVzOiBbXVxuXHRcdH07XG5cdFx0dGhpcy5hZGRDb29yZGluYXRlc18oLi4ucG9pbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgY29vcmRpbmF0ZXMgZm9yIHRoaXMgcG9seWdvbi5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkQ29vcmRpbmF0ZXNfKC4uLnBvaW50cykge1xuXHRcdHRoaXMuYm9keV8uY29vcmRpbmF0ZXMucHVzaChwb2ludHMubWFwKHBvaW50ID0+IEVtYm9kaWVkLnRvQm9keShwb2ludCkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgYSBob2xlIGluc2lkZSB0aGlzIHBvbHlnb24uXG5cdCAqIEBwYXJhbSAgey4uLip9IHBvaW50c1xuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0aG9sZSguLi5wb2ludHMpIHtcblx0XHR0aGlzLmFkZENvb3JkaW5hdGVzXyguLi5wb2ludHMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5HZW8uUG9seWdvbiA9IFBvbHlnb247XG5cbmV4cG9ydCBkZWZhdWx0IEdlbztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgcmFuZ2Ugb2JqZWN0cyB0byBiZSB1c2VkIGJ5IGBGaWx0ZXJgLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBSYW5nZSBleHRlbmRzIEVtYm9kaWVkIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHBhcmFtIHsqfSBvcHRfdG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihmcm9tLCBvcHRfdG8pIHtcblx0XHRzdXBlcigpO1xuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmcm9tKSkge1xuXHRcdFx0dGhpcy5ib2R5Xy5mcm9tID0gZnJvbTtcblx0XHR9XG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKG9wdF90bykpIHtcblx0XHRcdHRoaXMuYm9keV8udG8gPSBvcHRfdG87XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZnJvbShmcm9tKSB7XG5cdFx0cmV0dXJuIG5ldyBSYW5nZShmcm9tKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSBmcm9tXG5cdCAqIEBwYXJhbSB7Kn0gdG9cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmFuZ2UoZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSB0b1xuXHQgKiBAcmV0dXJuIHshUmFuZ2V9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0byh0bykge1xuXHRcdHJldHVybiBuZXcgUmFuZ2UobnVsbCwgdG8pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhbmdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuaW1wb3J0IEZpbHRlckJvZHkgZnJvbSAnLi9GaWx0ZXJCb2R5JztcbmltcG9ydCBHZW8gZnJvbSAnLi9HZW8nO1xuaW1wb3J0IFJhbmdlIGZyb20gJy4vUmFuZ2UnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBmaWx0ZXJzLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBGaWx0ZXIgZXh0ZW5kcyBFbWJvZGllZCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IG9wZXJhdG9yT3JWYWx1ZSBJZiBhIHRoaXJkIHBhcmFtIGlzIGdpdmVuLCB0aGlzIHNob3VsZFxuXHQgKiAgIGJlIHRoZSBmaWx0ZXIncyBvcGVyYXRvciAobGlrZSBcIj49XCIpLiBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZVxuXHQgKiAgIHVzZWQgYXMgdGhlIGZpbHRlcidzIHZhbHVlLCBhbmQgdGhlIGZpbHRlcidzIG9wZXJhdG9yIHdpbGwgYmUgXCI9XCIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJvZHlfID0gbmV3IEZpbHRlckJvZHkoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFkZChvcGVyYXRvciwgZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0dmFyIGZpbHRlciA9IGZpZWxkT3JGaWx0ZXIgPyBGaWx0ZXIudG9GaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSA6IG51bGw7XG5cdFx0dGhpcy5ib2R5Xy5hZGQob3BlcmF0b3IsIGZpbHRlcik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHsuLi4qfSBmaWx0ZXJzIEEgdmFyaWFibGUgYW1vdW50IG9mIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRhZGRNYW55KG9wZXJhdG9yLCAuLi5maWx0ZXJzKSB7XG5cdFx0dGhpcy5ib2R5Xy5hZGRNYW55KG9wZXJhdG9yLCAuLi5maWx0ZXJzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIFwiYW5kXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRhbmQoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCdhbmQnLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiYW55XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyEoQXJyYXl8Li4uKil9IHZhbHVlcyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqICAgdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiAgIHNlcGFyYXRlIHBhcmFtcy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGFueShmaWVsZCkge1xuXHRcdHZhciB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdGlmICh2YWx1ZXMubGVuZ3RoID09PSAxICYmIHZhbHVlc1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR2YWx1ZXMgPSB2YWx1ZXNbMF07XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnYW55JywgdmFsdWVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdwXCIgb3BlcmF0b3IuXG5cdCAqIFRoaXMgaXMgYSBzcGVjaWFsIHVzZSBjYXNlIG9mIGBGaWx0ZXIucG9seWdvbmAgZm9yIGJvdW5kaW5nXG5cdCAqIGJveGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSBib3hPclVwcGVyTGVmdCBFaXRoZXIgYSBgR2VvLkJvdW5kaW5nQm94YCBpbnN0YW5jZSwgb3Jcblx0ICogICBhIGJvdW5kaW5nIGJveCdzIHVwcGVyIGxlZnQgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X2xvd2VyUmlnaHQgQSBib3VuZGluZyBib3gncyBsb3dlciByaWdodCBjb29yZGluYXRlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgYm91bmRpbmdCb3goZmllbGQsIGJveE9yVXBwZXJMZWZ0LCBvcHRfbG93ZXJSaWdodCkge1xuXHRcdGlmIChib3hPclVwcGVyTGVmdCBpbnN0YW5jZW9mIEdlby5Cb3VuZGluZ0JveCkge1xuXHRcdFx0cmV0dXJuIEZpbHRlci5wb2x5Z29uKGZpZWxkLCAuLi5ib3hPclVwcGVyTGVmdC5nZXRQb2ludHMoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBGaWx0ZXIucG9seWdvbihmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUganNvbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoaXMgZmlsdGVyLlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0Ym9keSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ib2R5Xy5nZXRPYmplY3QoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdkXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uT3JDaXJjbGUgRWl0aGVyIGEgYEdlby5DaXJjbGVgIGluc3RhbmNlIG9yIGEgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtSYW5nZXxzdHJpbmc9fSBvcHRfcmFuZ2VPckRpc3RhbmNlIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3Jcblx0ICogICB0aGUgZGlzdGFuY2UgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBkaXN0YW5jZShmaWVsZCwgbG9jYXRpb25PckNpcmNsZSwgb3B0X3JhbmdlT3JEaXN0YW5jZSkge1xuXHRcdHZhciBsb2NhdGlvbiA9IGxvY2F0aW9uT3JDaXJjbGU7XG5cdFx0dmFyIHJhbmdlID0gb3B0X3JhbmdlT3JEaXN0YW5jZTtcblx0XHRpZiAobG9jYXRpb25PckNpcmNsZSBpbnN0YW5jZW9mIEdlby5DaXJjbGUpIHtcblx0XHRcdGxvY2F0aW9uID0gbG9jYXRpb25PckNpcmNsZS5nZXRDZW50ZXIoKTtcblx0XHRcdHJhbmdlID0gUmFuZ2UudG8obG9jYXRpb25PckNpcmNsZS5nZXRSYWRpdXMoKSk7XG5cdFx0fSBlbHNlIGlmICghKG9wdF9yYW5nZU9yRGlzdGFuY2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcblx0XHRcdHJhbmdlID0gUmFuZ2UudG8ob3B0X3JhbmdlT3JEaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBGaWx0ZXIuZGlzdGFuY2VJbnRlcm5hbF8oZmllbGQsIGxvY2F0aW9uLCByYW5nZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJnZFwiIG9wZXJhdG9yLiBUaGlzXG5cdCAqIGlzIGp1c3QgYW4gaW50ZXJuYWwgaGVscGVyIHVzZWQgYnkgYEZpbHRlci5kaXN0YW5jZWAuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uIEEgbG9jYXRpb24gY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgQSBgUmFuZ2VgIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBkaXN0YW5jZUludGVybmFsXyhmaWVsZCwgbG9jYXRpb24sIHJhbmdlKSB7XG5cdFx0dmFyIHZhbHVlID0ge1xuXHRcdFx0bG9jYXRpb246IEVtYm9kaWVkLnRvQm9keShsb2NhdGlvbilcblx0XHR9O1xuXHRcdHJhbmdlID0gcmFuZ2UuYm9keSgpO1xuXHRcdGlmIChyYW5nZS5mcm9tKSB7XG5cdFx0XHR2YWx1ZS5taW4gPSByYW5nZS5mcm9tO1xuXHRcdH1cblx0XHRpZiAocmFuZ2UudG8pIHtcblx0XHRcdHZhbHVlLm1heCA9IHJhbmdlLnRvO1xuXHRcdH1cblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnZ2QnLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI9XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGVxdWFsKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPScsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImV4aXN0c1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGV4aXN0cyhmaWVsZCkge1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdleGlzdHMnLCBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImZ1enp5XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSBvcHRfcXVlcnlPckZ1enppbmVzcyBJZiB0aGlzIGlzIGEgc3RyaW5nLCBpdCBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnksIG90aGVyd2lzZSBpdCBzaG91bGQgYmUgdGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnV6emluZXNzIFRoZSBmdXp6aW5lc3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmdXp6eShmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKSB7XG5cdFx0cmV0dXJuIEZpbHRlci5mdXp6eUludGVybmFsXygnZnV6enknLCBmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBnaXZlbiBmdXp6eSBvcGVyYXRvci4gVGhpc1xuXHQgKiBpcyBhbiBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IHRoZSBgRmlsdGVyLmZ1enp5YCBtZXRob2QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgZnV6enkgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSBvcHRfcXVlcnlPckZ1enppbmVzcyBJZiB0aGlzIGlzIGEgc3RyaW5nLCBpdCBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnksIG90aGVyd2lzZSBpdCBzaG91bGQgYmUgdGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnV6emluZXNzIFRoZSBmdXp6aW5lc3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZ1enp5SW50ZXJuYWxfKG9wZXJhdG9yLCBmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKSB7XG5cdFx0dmFyIGFyZzJJc1N0cmluZyA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5T3JGdXp6aW5lc3MpO1xuXG5cdFx0dmFyIHZhbHVlID0ge1xuXHRcdFx0cXVlcnk6IGFyZzJJc1N0cmluZyA/IG9wdF9xdWVyeU9yRnV6emluZXNzIDogZmllbGRPclF1ZXJ5XG5cdFx0fTtcblx0XHR2YXIgZnV6emluZXNzID0gYXJnMklzU3RyaW5nID8gb3B0X2Z1enppbmVzcyA6IG9wdF9xdWVyeU9yRnV6emluZXNzO1xuXHRcdGlmIChmdXp6aW5lc3MpIHtcblx0XHRcdHZhbHVlLmZ1enppbmVzcyA9IGZ1enppbmVzcztcblx0XHR9XG5cblx0XHR2YXIgZmllbGQgPSBhcmcySXNTdHJpbmcgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsIG9wZXJhdG9yLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI+XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGd0KGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPicsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIj49XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGd0ZShmaWVsZCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJz49JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwibWF0Y2hcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3F1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtYXRjaChmaWVsZE9yUXVlcnksIG9wdF9xdWVyeSkge1xuXHRcdHZhciBmaWVsZCA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHF1ZXJ5ID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdtYXRjaCcsIHF1ZXJ5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm1pc3NpbmdcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtaXNzaW5nKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ21pc3NpbmcnLCBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcInBocmFzZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogICBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHBocmFzZShmaWVsZE9yUXVlcnksIG9wdF9xdWVyeSkge1xuXHRcdHZhciBmaWVsZCA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHF1ZXJ5ID0gY29yZS5pc1N0cmluZyhvcHRfcXVlcnkpID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdwaHJhc2UnLCBxdWVyeSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJncFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkLlxuXHQgKiBAcGFyYW0gey4uLiFPYmplY3R9IHBvaW50cyBPYmplY3RzIHJlcHJlc2VudGluZyBwb2ludHMgaW4gdGhlIHBvbHlnb24uXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBwb2x5Z29uKGZpZWxkLCAuLi5wb2ludHMpIHtcblx0XHRwb2ludHMgPSBwb2ludHMubWFwKHBvaW50ID0+IEVtYm9kaWVkLnRvQm9keShwb2ludCkpO1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdncCcsIHBvaW50cyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJwcmVmaXhcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkXG5cdCAqICAgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC4gT3RoZXJ3aXNlLFxuXHQgKiAgIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHByZWZpeChmaWVsZE9yUXVlcnksIG9wdF9xdWVyeSkge1xuXHRcdHZhciBmaWVsZCA9IG9wdF9xdWVyeSA/IGZpZWxkT3JRdWVyeSA6IEZpbHRlci5BTEw7XG5cdFx0dmFyIHF1ZXJ5ID0gb3B0X3F1ZXJ5ID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuXHRcdHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdwcmVmaXgnLCBxdWVyeSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJyYW5nZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yTWluIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3IgYSB0aGUgcmFuZ2UncyBtaW4gdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9tYXggVGhlIHJhbmdlJ3MgbWF4IHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgcmFuZ2UoZmllbGQsIHJhbmdlT3JNaW4sIG9wdF9tYXgpIHtcblx0XHR2YXIgcmFuZ2UgPSByYW5nZU9yTWluO1xuXHRcdGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG5cdFx0XHRyYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JNaW4sIG9wdF9tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAncmFuZ2UnLCByYW5nZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJ+XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHJlZ2V4KGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnficsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0gey4uLiFPYmplY3R9IHNoYXBlcyBPYmplY3RzIHJlcHJlc2VudGluZyBzaGFwZXMuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzaGFwZShmaWVsZCwgLi4uc2hhcGVzKSB7XG5cdFx0c2hhcGVzID0gc2hhcGVzLm1hcChzaGFwZSA9PiBFbWJvZGllZC50b0JvZHkoc2hhcGUpKTtcblx0XHR2YXIgdmFsdWUgPSB7XG5cdFx0XHR0eXBlOiAnZ2VvbWV0cnljb2xsZWN0aW9uJyxcblx0XHRcdGdlb21ldHJpZXM6IHNoYXBlc1xuXHRcdH07XG5cdFx0cmV0dXJuIEZpbHRlci5maWVsZChmaWVsZCwgJ2dzJywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwic2ltaWxhclwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogICBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBtYXRjaC5cblx0ICogQHBhcmFtIHs/c3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc2ltaWxhcihmaWVsZE9yUXVlcnksIHF1ZXJ5KSB7XG5cdFx0dmFyIGZpZWxkID0gY29yZS5pc1N0cmluZyhxdWVyeSkgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuXHRcdHZhciB2YWx1ZSA9IHtcblx0XHRcdHF1ZXJ5OiBjb3JlLmlzU3RyaW5nKHF1ZXJ5KSA/IHF1ZXJ5IDogZmllbGRPclF1ZXJ5XG5cdFx0fTtcblx0XHRyZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnc2ltaWxhcicsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIjxcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbHQoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc8JywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPD1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbHRlKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPD0nLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJub25lXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyEoQXJyYXl8Li4uKil9IHZhbHVlIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiBzZXBhcmF0ZSBwYXJhbXMuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBub25lKGZpZWxkKSB7XG5cdFx0dmFyIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0aWYgKHZhbHVlcy5sZW5ndGggPT09IDEgJiYgdmFsdWVzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHZhbHVlcyA9IHZhbHVlc1swXTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICdub25lJywgdmFsdWVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIiE9XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG5vdEVxdWFsKGZpZWxkLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnIT0nLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJub3RcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvclxuXHQgKiB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBub3QoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0cmV0dXJuIEZpbHRlci50b0ZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpLmFkZCgnbm90Jyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSBvcGVyYXRvck9yVmFsdWUgSWYgYSB0aGlyZCBwYXJhbSBpcyBnaXZlbiwgdGhpcyBzaG91bGQgYmUgdGhlXG5cdCAqIGZpbHRlcidzIG9wZXJhdG9yIChsaWtlIFwiPj1cIikuIE90aGVyd2lzZSwgdGhpcyB3aWxsIGJlIHVzZWQgYXMgdGhlXG5cdCAqIGZpbHRlcidzIHZhbHVlLCBhbmQgdGhlIGZpbHRlcidzIG9wZXJhdG9yIHdpbGwgYmUgXCI9XCIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBmaWVsZChmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgXCJvclwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdG9yKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLmFkZCgnb3InLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBhcmd1bWVudHMgaW50byBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICovXG5cdHN0YXRpYyB0b0ZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgZmlsdGVyID0gZmllbGRPckZpbHRlcjtcblx0XHRpZiAoIShmaWx0ZXIgaW5zdGFuY2VvZiBGaWx0ZXIpKSB7XG5cdFx0XHRmaWx0ZXIgPSBGaWx0ZXIuZmllbGQoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZpbHRlcjtcblx0fVxufVxuXG4vKipcbiAqIFN0cmluZyBjb25zdGFudCB0aGF0IHJlcHJlc2VudHMgYWxsIGZpZWxkcy5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cbkZpbHRlci5BTEwgPSAnKic7XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHVyaSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG4gKiBAcGFyYW0geyo9fSBvcHRfdXJpIE9wdGlvbmFsIHN0cmluZyBVUkkgdG8gcGFyc2VcbiAqL1xuZnVuY3Rpb24gcGFyc2VGcm9tQW5jaG9yKG9wdF91cmkpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdGxpbmsuaHJlZiA9IG9wdF91cmk7XG5cdHJldHVybiB7XG5cdFx0aGFzaDogbGluay5oYXNoLFxuXHRcdGhvc3RuYW1lOiBsaW5rLmhvc3RuYW1lLFxuXHRcdHBhc3N3b3JkOiBsaW5rLnBhc3N3b3JkLFxuXHRcdHBhdGhuYW1lOiBsaW5rLnBhdGhuYW1lWzBdID09PSAnLycgPyBsaW5rLnBhdGhuYW1lIDogJy8nICsgbGluay5wYXRobmFtZSxcblx0XHRwb3J0OiBsaW5rLnBvcnQsXG5cdFx0cHJvdG9jb2w6IGxpbmsucHJvdG9jb2wsXG5cdFx0c2VhcmNoOiBsaW5rLnNlYXJjaCxcblx0XHR1c2VybmFtZTogbGluay51c2VybmFtZVxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZUZyb21BbmNob3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgcGFyc2VGcm9tQW5jaG9yIGZyb20gJy4vcGFyc2VGcm9tQW5jaG9yJztcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHVyaSBzdHJpbmcgaW50byBhbiBvYmplY3QuIFRoZSBVUkwgZnVuY3Rpb24gd2lsbCBiZSB1c2VkXG4gKiB3aGVuIHByZXNlbnQsIG90aGVyd2lzZSB3ZSdsbCBmYWxsIGJhY2sgdG8gdGhlIGFuY2hvciBub2RlIGVsZW1lbnQuXG4gKiBAcGFyYW0geyo9fSBvcHRfdXJpIE9wdGlvbmFsIHN0cmluZyBVUkkgdG8gcGFyc2VcbiAqL1xuZnVuY3Rpb24gcGFyc2Uob3B0X3VyaSkge1xuXHRpZiAoaXNGdW5jdGlvbihVUkwpICYmIFVSTC5sZW5ndGgpIHtcblx0XHRyZXR1cm4gbmV3IFVSTChvcHRfdXJpKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gcGFyc2VGcm9tQW5jaG9yKG9wdF91cmkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIEEgY2FjaGVkIHJlZmVyZW5jZSB0byB0aGUgY3JlYXRlIGZ1bmN0aW9uLlxuICovXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBDYXNlIGluc2Vuc2l0aXZlIHN0cmluZyBNdWx0aW1hcCBpbXBsZW1lbnRhdGlvbi4gQWxsb3dzIG11bHRpcGxlIHZhbHVlcyBmb3JcbiAqIHRoZSBzYW1lIGtleSBuYW1lLlxuICogQGV4dGVuZHMge0Rpc3Bvc2FibGV9XG4gKi9cbmNsYXNzIE11bHRpTWFwIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5rZXlzID0gY3JlYXRlKG51bGwpO1xuXHRcdHRoaXMudmFsdWVzID0gY3JlYXRlKG51bGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdmFsdWUgdG8gYSBrZXkgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhZGQobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5hbWU7XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgW107XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXS5wdXNoKHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgbWFwIG5hbWVzIGFuZCB2YWx1ZXMuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGNsZWFyKCkge1xuXHRcdHRoaXMua2V5cyA9IGNyZWF0ZShudWxsKTtcblx0XHR0aGlzLnZhbHVlcyA9IGNyZWF0ZShudWxsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgbWFwIGNvbnRhaW5zIGEgdmFsdWUgdG8gdGhlIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRjb250YWlucyhuYW1lKSB7XG5cdFx0cmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKSBpbiB0aGlzLnZhbHVlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0ZGlzcG9zZUludGVybmFsKCkge1xuXHRcdHRoaXMudmFsdWVzID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYE11bHRpTWFwYCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG5cdCAqIEByZXR1cm4geyFNdWx0aU1hcH1cblx0ICovXG5cdHN0YXRpYyBmcm9tT2JqZWN0KG9iaikge1xuXHRcdHZhciBtYXAgPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXAuc2V0KGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXA7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZmlyc3QgYWRkZWQgdmFsdWUgZnJvbSBhIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRnZXQobmFtZSkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdHJldHVybiB2YWx1ZXNbMF07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYWxsIHZhbHVlcyBmcm9tIGEga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4ge0FycmF5LjwqPn1cblx0ICovXG5cdGdldEFsbChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBtYXAgaXMgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRW1wdHkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2l6ZSgpID09PSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYXJyYXkgb2Yga2V5IG5hbWVzLlxuXHQgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cblx0ICovXG5cdG5hbWVzKCkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykubWFwKChrZXkpID0+IHRoaXMua2V5c1trZXldKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCB2YWx1ZXMgZnJvbSBhIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRyZW1vdmUobmFtZSkge1xuXHRcdGRlbGV0ZSB0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRkZWxldGUgdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGtleSBuYW1lLiBSZWxldmFudCB0byByZXBsYWNlIHRoZSBjdXJyZW50IHZhbHVlcyB3aXRoXG5cdCAqIGEgbmV3IG9uZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXQobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5hbWU7XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IFt2YWx1ZV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgbWFwIGtleSBuYW1lcy5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5uYW1lcygpLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwYXJzZWQgdmFsdWVzIGFzIGEgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpTWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBhcnJheSB9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBHZW5lcmljIHRyZWUgbm9kZSBkYXRhIHN0cnVjdHVyZSB3aXRoIGFyYml0cmFyeSBudW1iZXIgb2YgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0ge1Z9IHZhbHVlIFZhbHVlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFRyZWVOb2RlIHtcblxuXHRjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB2YWx1ZS5cblx0XHQgKiBAcHJpdmF0ZSB7Vn1cblx0XHQgKi9cblx0XHR0aGlzLnZhbHVlXyA9IHZhbHVlO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgbm9kZSBvciBudWxsIGlmIGl0IGhhcyBubyBwYXJlbnQuXG5cdFx0ICogQHByaXZhdGUge1RyZWVOb2RlfVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyZW50XyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBDaGlsZCBub2RlcyBvciBudWxsIGluIGNhc2Ugb2YgbGVhZiBub2RlLlxuXHRcdCAqIEBwcml2YXRlIHtBcnJheTwhVHJlZU5vZGU+fVxuXHRcdCAqL1xuXHRcdHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIGEgY2hpbGQgbm9kZSB0byB0aGlzIG5vZGUuXG5cdCAqIEBwYXJhbSB7IVRyZWVOb2RlfSBjaGlsZCBPcnBoYW4gY2hpbGQgbm9kZS5cblx0ICovXG5cdGFkZENoaWxkKGNoaWxkKSB7XG5cdFx0YXNzZXJ0Q2hpbGRIYXNOb1BhcmVudChjaGlsZCk7XG5cdFx0Y2hpbGQuc2V0UGFyZW50KHRoaXMpO1xuXHRcdHRoaXMuY2hpbGRyZW5fID0gdGhpcy5jaGlsZHJlbl8gfHwgW107XG5cdFx0dGhpcy5jaGlsZHJlbl8ucHVzaChjaGlsZCk7XG5cdH1cblxuXHQvKipcblx0ICogVGVsbHMgd2hldGhlciB0aGlzIG5vZGUgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBub2RlLlxuXHQgKiBAcGFyYW0geyFUcmVlTm9kZX0gbm9kZSBBIG5vZGUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBub2RlIGlzIHRoZSBhbmNlc3RvciBvZiB7QGNvZGUgbm9kZX0uXG5cdCAqL1xuXHRjb250YWlucyhub2RlKSB7XG5cdFx0bGV0IGN1cnJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXHRcdHdoaWxlIChjdXJyZW50KSB7XG5cdFx0XHRpZiAoY3VycmVudCA9PT0gdGhpcykge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGN1cnJlbnQgPSBjdXJyZW50LmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7IUFycmF5PFRyZWVOb2RlPn0gQWxsIGFuY2VzdG9yIG5vZGVzIGluIGJvdHRvbS11cCBvcmRlci5cblx0ICovXG5cdGdldEFuY2VzdG9ycygpIHtcblx0XHRsZXQgYW5jZXN0b3JzID0gW107XG5cdFx0bGV0IG5vZGUgPSB0aGlzLmdldFBhcmVudCgpO1xuXHRcdHdoaWxlIChub2RlKSB7XG5cdFx0XHRhbmNlc3RvcnMucHVzaChub2RlKTtcblx0XHRcdG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gYW5jZXN0b3JzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGNoaWxkIG5vZGUgb2YgdGhpcyBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IENoaWxkIGluZGV4LlxuXHQgKiBAcmV0dXJuIHs/VHJlZU5vZGV9IFRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBvciBudWxsIGlmIG5vdCBmb3VuZC5cblx0ICovXG5cdGdldENoaWxkQXQoaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpW2luZGV4XSB8fCBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4gez9BcnJheTwhVHJlZU5vZGU+fSBDaGlsZCBub2RlcyBvciBudWxsIGluIGNhc2Ugb2YgbGVhZiBub2RlLlxuXHQgKi9cblx0Z2V0Q2hpbGRyZW4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW5fIHx8IFRyZWVOb2RlLkVNUFRZX0FSUkFZO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cblx0ICovXG5cdGdldENoaWxkQ291bnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oKS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGFuY2VzdG9ycyBvZiB0aGUgbm9kZS5cblx0ICovXG5cdGdldERlcHRoKCkge1xuXHRcdGxldCBkZXB0aCA9IDA7XG5cdFx0bGV0IG5vZGUgPSB0aGlzO1xuXHRcdHdoaWxlIChub2RlLmdldFBhcmVudCgpKSB7XG5cdFx0XHRkZXB0aCsrO1xuXHRcdFx0bm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiBkZXB0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHs/VHJlZU5vZGV9IFBhcmVudCBub2RlIG9yIG51bGwgaWYgaXQgaGFzIG5vIHBhcmVudC5cblx0ICovXG5cdGdldFBhcmVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4geyFUcmVlTm9kZX0gVGhlIHJvb3Qgb2YgdGhlIHRyZWUgc3RydWN0dXJlLCBpLmUuIHRoZSBmYXJ0aGVzdFxuXHQgKiBhbmNlc3RvciBvZiB0aGUgbm9kZSBvciB0aGUgbm9kZSBpdHNlbGYgaWYgaXQgaGFzIG5vIHBhcmVudHMuXG5cdCAqL1xuXHRnZXRSb290KCkge1xuXHRcdGxldCByb290ID0gdGhpcztcblx0XHR3aGlsZSAocm9vdC5nZXRQYXJlbnQoKSkge1xuXHRcdFx0cm9vdCA9IHJvb3QuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiByb290O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtWfSBUaGUgdmFsdWUuXG5cdCAqL1xuXHRnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZV87XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbm9kZSBpcyBhIGxlYWYgbm9kZS5cblx0ICovXG5cdGlzTGVhZigpIHtcblx0XHRyZXR1cm4gIXRoaXMuZ2V0Q2hpbGRDb3VudCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGdpdmVuIGNoaWxkIG5vZGUgb2YgdGhpcyBub2RlLlxuXHQgKiBAcGFyYW0ge1RyZWVOb2RlfSBjaGlsZCBUaGUgbm9kZSB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge1RyZWVOb2RlfSBUaGUgcmVtb3ZlZCBub2RlIGlmIGFueSwgbnVsbCBvdGhlcndpc2UuXG5cdCAqL1xuXHRyZW1vdmVDaGlsZChjaGlsZCkge1xuXHRcdGlmIChhcnJheS5yZW1vdmUodGhpcy5nZXRDaGlsZHJlbigpLCBjaGlsZCkpIHtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGFyZW50IG5vZGUgb2YgdGhpcyBub2RlLiBUaGUgY2FsbGVycyBtdXN0IGVuc3VyZSB0aGF0IHRoZVxuXHQgKiBwYXJlbnQgbm9kZSBhbmQgb25seSB0aGF0IGhhcyB0aGlzIG5vZGUgYW1vbmcgaXRzIGNoaWxkcmVuLlxuXHQgKiBAcGFyYW0ge1RyZWVOb2RlfSBwYXJlbnQgVGhlIHBhcmVudCB0byBzZXQuIElmIG51bGwsIHRoZSBub2RlIHdpbGwgYmVcblx0ICogZGV0YWNoZWQgZnJvbSB0aGUgdHJlZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0UGFyZW50KHBhcmVudCkge1xuXHRcdHRoaXMucGFyZW50XyA9IHBhcmVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmF2ZXJzZXMgdGhlIHN1YnRyZWUuIFRoZSBmaXJzdCBjYWxsYmFjayBzdGFydHMgd2l0aCB0aGlzIG5vZGUsXG5cdCAqIGFuZCB2aXNpdHMgdGhlIGRlc2NlbmRhbnQgbm9kZXMgZGVwdGgtZmlyc3QsIGluIHByZW9yZGVyLlxuXHQgKiBUaGUgc2Vjb25kIGNhbGxiYWNrLCBzdGFydHMgd2l0aCBkZWVwZXN0IGNoaWxkIHRoZW4gdmlzaXRzXG5cdCAqIHRoZSBhbmNlc3RvciBub2RlcyBkZXB0aC1maXJzdCwgaW4gcG9zdG9yZGVyLiBFLmcuXG5cdCAqXG5cdCAqICBcdCBBXG5cdCAqICAgIC8gXFxcblx0ICogICBCICAgQ1xuXHQgKiAgLyAgIC8gXFxcblx0ICogRCAgIEUgICBGXG5cdCAqXG5cdCAqIHByZW9yZGVyIC0+IFsnQScsICdCJywgJ0QnLCAnQycsICdFJywgJ0YnXVxuXHQgKiBwb3N0b3JkZXIgLT4gWydEJywgJ0InLCAnRScsICdGJywgJ0MnLCAnQSddXG5cdCAqXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvcHRfcHJlb3JkZXJGbiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHZpc2l0aW5nIGEgbm9kZS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbj19IG9wdF9wb3N0b3JkZXJGbiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgbGVhdmluZyBhIG5vZGUuXG5cdCAqL1xuXHR0cmF2ZXJzZShvcHRfcHJlb3JkZXJGbiwgb3B0X3Bvc3RvcmRlckZuKSB7XG5cdFx0aWYgKG9wdF9wcmVvcmRlckZuKSB7XG5cdFx0XHRvcHRfcHJlb3JkZXJGbih0aGlzKTtcblx0XHR9XG5cdFx0dGhpcy5nZXRDaGlsZHJlbigpLmZvckVhY2goKGNoaWxkKSA9PiBjaGlsZC50cmF2ZXJzZShvcHRfcHJlb3JkZXJGbiwgb3B0X3Bvc3RvcmRlckZuKSk7XG5cdFx0aWYgKG9wdF9wb3N0b3JkZXJGbikge1xuXHRcdFx0b3B0X3Bvc3RvcmRlckZuKHRoaXMpO1xuXHRcdH1cblx0fVxuXG59XG5cbi8qKlxuICogQ29uc3RhbnQgZm9yIGVtcHR5IGFycmF5IHRvIGF2b2lkIHVubmVjZXNzYXJ5IGFsbG9jYXRpb25zLlxuICogQHByaXZhdGVcbiAqL1xuVHJlZU5vZGUuRU1QVFlfQVJSQVkgPSBbXTtcblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgY2hpbGQgaGFzIG5vIHBhcmVudC5cbiAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkIEEgY2hpbGQuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBhc3NlcnRDaGlsZEhhc05vUGFyZW50ID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0aWYgKGNoaWxkLmdldFBhcmVudCgpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGNoaWxkIHdpdGggcGFyZW50LicpO1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUcmVlTm9kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgaXNEZWYsIHN0cmluZyB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlJztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5cbnZhciBwYXJzZUZuXyA9IHBhcnNlO1xuXG5jbGFzcyBVcmkge1xuXG5cdC8qKlxuXHQgKiBUaGlzIGNsYXNzIGNvbnRhaW5zIHNldHRlcnMgYW5kIGdldHRlcnMgZm9yIHRoZSBwYXJ0cyBvZiB0aGUgVVJJLlxuXHQgKiBUaGUgZm9sbG93aW5nIGZpZ3VyZSBkaXNwbGF5cyBhbiBleGFtcGxlIFVSSXMgYW5kIHRoZWlyIGNvbXBvbmVudCBwYXJ0cy5cblx0ICpcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFxuXHQgKlx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIzilIDilIDilIDilLTilIDilIDilIDilIDilJBcblx0ICpcdCAgYWJjOi8vZXhhbXBsZS5jb206MTIzL3BhdGgvZGF0YT9rZXk9dmFsdWUjZnJhZ2lkMVxuXHQgKlx0ICDilJTilKzilJggICDilJTilIDilIDilIDilIDilKzilIDilIDilIDilIDilJgg4pSU4pSs4pSYICAgICAgICAgICDilJTilIDilIDilIDilKzilIDilIDilIDilJgg4pSU4pSA4pSA4pSs4pSA4pSA4pSYXG5cdCAqIHByb3RvY29sICBob3N0bmFtZSAgcG9ydCAgICAgICAgICAgIHNlYXJjaCAgICBoYXNoXG5cdCAqICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXHQgKiAgICAgICAgICAgICAgICBob3N0XG5cdCAqXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdF91cmkgPSAnJykge1xuXHRcdHRoaXMudXJsID0gVXJpLnBhcnNlKHRoaXMubWF5YmVBZGRQcm90b2NvbEFuZEhvc3RuYW1lXyhvcHRfdXJpKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBwYXJhbWV0ZXJzIHRvIHVyaSBmcm9tIGEgPGNvZGU+TXVsdGlNYXA8L2NvZGU+IGFzIHNvdXJjZS5cblx0ICogQHBhcmFtIHtNdWx0aU1hcH0gbXVsdGltYXAgVGhlIDxjb2RlPk11bHRpTWFwPC9jb2RlPiBjb250YWluaW5nIHRoZVxuXHQgKiAgIHBhcmFtZXRlcnMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcChtdWx0aW1hcCkge1xuXHRcdG11bHRpbWFwLm5hbWVzKCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdFx0bXVsdGltYXAuZ2V0QWxsKG5hbWUpLmZvckVhY2goKHZhbHVlKSA9PiB7XG5cdFx0XHRcdHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS4gV2lsbCBiZSBleHBsaWNpdGx5IGNhc3RlZCB0byBTdHJpbmcuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdGlmIChpc0RlZih2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblx0XHR9XG5cdFx0dGhpcy5xdWVyeS5hZGQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHZhbHVlcyBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFBhcmFtZXRlclZhbHVlcyhuYW1lLCB2YWx1ZXMpIHtcblx0XHR2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFbnN1cmVzIHF1ZXJ5IGludGVybmFsIG1hcCBpcyBpbml0aWFsaXplZCBhbmQgc3luY2VkIHdpdGggaW5pdGlhbCB2YWx1ZVxuXHQgKiBleHRyYWN0ZWQgZnJvbSBVUkkgc2VhcmNoIHBhcnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCkge1xuXHRcdGlmICh0aGlzLnF1ZXJ5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMucXVlcnkgPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR2YXIgc2VhcmNoID0gdGhpcy51cmwuc2VhcmNoO1xuXHRcdGlmIChzZWFyY2gpIHtcblx0XHRcdHNlYXJjaC5zdWJzdHJpbmcoMSkuc3BsaXQoJyYnKS5mb3JFYWNoKChwYXJhbSkgPT4ge1xuXHRcdFx0XHR2YXIgW2tleSwgdmFsdWVdID0gcGFyYW0uc3BsaXQoJz0nKTtcblx0XHRcdFx0aWYgKGlzRGVmKHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhbHVlID0gVXJpLnVybERlY29kZSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRQYXJhbWV0ZXJWYWx1ZShrZXksIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBoYXNoIHBhcnQgb2YgdXJpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRIYXNoKCkge1xuXHRcdHJldHVybiB0aGlzLnVybC5oYXNoIHx8ICcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhvc3QgcGFydCBvZiB1cmkuIEUuZy4gPGNvZGU+W2hvc3RuYW1lXTpbcG9ydF08L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRIb3N0KCkge1xuXHRcdHZhciBob3N0ID0gdGhpcy5nZXRIb3N0bmFtZSgpO1xuXHRcdGlmIChob3N0KSB7XG5cdFx0XHR2YXIgcG9ydCA9IHRoaXMuZ2V0UG9ydCgpO1xuXHRcdFx0aWYgKHBvcnQgJiYgcG9ydCAhPT0gJzgwJykge1xuXHRcdFx0XHRob3N0ICs9ICc6JyArIHBvcnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBob3N0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhvc3RuYW1lIHBhcnQgb2YgdXJpIHdpdGhvdXQgcHJvdG9jb2wgYW5kIHBvcnQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEhvc3RuYW1lKCkge1xuXHRcdHZhciBob3N0bmFtZSA9IHRoaXMudXJsLmhvc3RuYW1lO1xuXHRcdGlmIChob3N0bmFtZSA9PT0gVXJpLkhPU1ROQU1FX1BMQUNFSE9MREVSKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdHJldHVybiBob3N0bmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBvcmlnaW4gcGFydCBvZiB1cmkuIEUuZy4gPGNvZGU+aHR0cDovL1tob3N0bmFtZV06W3BvcnRdPC9jb2RlPi5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0T3JpZ2luKCkge1xuXHRcdHZhciBob3N0ID0gdGhpcy5nZXRIb3N0KCk7XG5cdFx0aWYgKGhvc3QpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFByb3RvY29sKCkgKyAnLy8nICsgaG9zdDtcblx0XHR9XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGZvciBhIGdpdmVuIHBhcmFtZXRlciBvciB1bmRlZmluZWQgaWYgdGhlIGdpdmVuXG5cdCAqIHBhcmFtZXRlciBuYW1lIGRvZXMgbm90IGFwcGVhciBpbiB0aGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lIFVuZXNjYXBlZCBwYXJhbWV0ZXIgbmFtZS5cblx0ICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIGZpcnN0IHZhbHVlIGZvciBhIGdpdmVuIHBhcmFtZXRlciBvclxuXHQgKiAgIHVuZGVmaW5lZCBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUgZG9lcyBub3QgYXBwZWFyIGluIHRoZSBxdWVyeVxuXHQgKiAgIHN0cmluZy5cblx0ICovXG5cdGdldFBhcmFtZXRlclZhbHVlKG5hbWUpIHtcblx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0cmV0dXJuIHRoaXMucXVlcnkuZ2V0KG5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHZhbHVlPGI+czwvYj4gZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIGFzIGEgbGlzdCBvZiBkZWNvZGVkXG5cdCAqIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwYXJhbWV0ZXIgdG8gZ2V0IHZhbHVlcyBmb3IuXG5cdCAqIEByZXR1cm4geyFBcnJheTw/Pn0gVGhlIHZhbHVlcyBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgYXMgYSBsaXN0IG9mIGRlY29kZWRcblx0ICogICBxdWVyeSBwYXJhbWV0ZXIgdmFsdWVzLlxuXHQgKi9cblx0Z2V0UGFyYW1ldGVyVmFsdWVzKG5hbWUpIHtcblx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0cmV0dXJuIHRoaXMucXVlcnkuZ2V0QWxsKG5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5hbWU8Yj5zPC9iPiBvZiB0aGUgcGFyYW1ldGVycy5cblx0ICogQHJldHVybiB7IUFycmF5PHN0cmluZz59IFRoZSBuYW1lcyBmb3IgdGhlIHBhcmFtZXRlcnMgYXMgYSBsaXN0IG9mXG5cdCAqICAgc3RyaW5ncy5cblx0ICovXG5cdGdldFBhcmFtZXRlck5hbWVzKCkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5uYW1lcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGZ1bmN0aW9uIGN1cnJlbnRseSBiZWluZyB1c2VkIHRvIHBhcnNlIFVSSXMuXG5cdCAqIEByZXR1cm4geyFmdW5jdGlvbigpfVxuXHQgKi9cblx0c3RhdGljIGdldFBhcnNlRm4oKSB7XG5cdFx0cmV0dXJuIHBhcnNlRm5fO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBhdGhuYW1lIHBhcnQgb2YgdXJpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRQYXRobmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmwucGF0aG5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9ydCBudW1iZXIgcGFydCBvZiB1cmkgYXMgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRQb3J0KCkge1xuXHRcdHJldHVybiB0aGlzLnVybC5wb3J0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHByb3RvY29sIHBhcnQgb2YgdXJpLiBFLmcuIDxjb2RlPmh0dHA6PC9jb2RlPi5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UHJvdG9jb2woKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsLnByb3RvY29sO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHNlYXJjaCBwYXJ0IG9mIHVyaS4gU2VhcmNoIHZhbHVlIGlzIHJldHJpZXZlZCBmcm9tIHF1ZXJ5XG5cdCAqIHBhcmFtZXRlcnMuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFNlYXJjaCgpIHtcblx0XHR2YXIgc2VhcmNoID0gJyc7XG5cdFx0dmFyIHF1ZXJ5c3RyaW5nID0gJyc7XG5cdFx0dGhpcy5nZXRQYXJhbWV0ZXJOYW1lcygpLmZvckVhY2goKG5hbWUpID0+IHtcblx0XHRcdHRoaXMuZ2V0UGFyYW1ldGVyVmFsdWVzKG5hbWUpLmZvckVhY2goKHZhbHVlKSA9PiB7XG5cdFx0XHRcdHF1ZXJ5c3RyaW5nICs9IG5hbWU7XG5cdFx0XHRcdGlmIChpc0RlZih2YWx1ZSkpIHtcblx0XHRcdFx0XHRxdWVyeXN0cmluZyArPSAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHF1ZXJ5c3RyaW5nICs9ICcmJztcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHF1ZXJ5c3RyaW5nID0gcXVlcnlzdHJpbmcuc2xpY2UoMCwgLTEpO1xuXHRcdGlmIChxdWVyeXN0cmluZykge1xuXHRcdFx0c2VhcmNoICs9ICc/JyArIHF1ZXJ5c3RyaW5nO1xuXHRcdH1cblx0XHRyZXR1cm4gc2VhcmNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB1cmkgY29udGFpbnMgdGhlIHBhcmFtZXRlci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1BhcmFtZXRlcihuYW1lKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdHJldHVybiB0aGlzLnF1ZXJ5LmNvbnRhaW5zKG5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHRoaXMgVVJMIHVuaXF1ZSBieSBhZGRpbmcgYSByYW5kb20gcGFyYW0gdG8gaXQuIFVzZWZ1bCBmb3IgYXZvaWRpbmdcblx0ICogY2FjaGUuXG5cdCAqL1xuXHRtYWtlVW5pcXVlKCkge1xuXHRcdHRoaXMuc2V0UGFyYW1ldGVyVmFsdWUoVXJpLlJBTkRPTV9QQVJBTSwgc3RyaW5nLmdldFJhbmRvbVN0cmluZygpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXliZSBhZGRzIHByb3RvY29sIGFuZCBhIGhvc3RuYW1lIHBsYWNlaG9sZGVyIG9uIGEgcGFyaWFsIFVSSSBpZiBuZWVkZWQuXG5cdCAqIFJlbGV2ZW50IGZvciBjb21wYXRpYmlsaXR5IHdpdGggPGNvZGU+VVJMPC9jb2RlPiBuYXRpdmUgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF91cmlcblx0ICogQHJldHVybiB7c3RyaW5nfSBVUkkgd2l0aCBwcm90b2NvbCBhbmQgaG9zdG5hbWUgcGxhY2Vob2xkZXIuXG5cdCAqL1xuXHRtYXliZUFkZFByb3RvY29sQW5kSG9zdG5hbWVfKG9wdF91cmkpIHtcblx0XHR2YXIgdXJsID0gb3B0X3VyaTtcblx0XHRpZiAob3B0X3VyaS5pbmRleE9mKCc6Ly8nKSA9PT0gLTEgJiZcblx0XHRcdG9wdF91cmkuaW5kZXhPZignamF2YXNjcmlwdDonKSAhPT0gMCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuXHRcdFx0dXJsID0gVXJpLkRFRkFVTFRfUFJPVE9DT0w7XG5cdFx0XHRpZiAob3B0X3VyaVswXSAhPT0gJy8nIHx8IG9wdF91cmlbMV0gIT09ICcvJykge1xuXHRcdFx0XHR1cmwgKz0gJy8vJztcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoIChvcHRfdXJpLmNoYXJBdCgwKSkge1xuXHRcdFx0XHRjYXNlICcuJzpcblx0XHRcdFx0Y2FzZSAnPyc6XG5cdFx0XHRcdGNhc2UgJyMnOlxuXHRcdFx0XHRcdHVybCArPSBVcmkuSE9TVE5BTUVfUExBQ0VIT0xERVI7XG5cdFx0XHRcdFx0dXJsICs9ICcvJztcblx0XHRcdFx0XHR1cmwgKz0gb3B0X3VyaTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnJzpcblx0XHRcdFx0Y2FzZSAnLyc6XG5cdFx0XHRcdFx0aWYgKG9wdF91cmlbMV0gIT09ICcvJykge1xuXHRcdFx0XHRcdFx0dXJsICs9IFVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dXJsICs9IG9wdF91cmk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dXJsICs9IG9wdF91cmk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1cmw7XG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyB0aGUgcGFyc2VkIG9iamVjdCB0byBiZSBpbiB0aGUgZXhwZWN0ZWQgc3RhbmRhcmQuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH1cblx0ICovXG5cdHN0YXRpYyBub3JtYWxpemVPYmplY3QocGFyc2VkKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHBhcnNlZC5wYXRobmFtZSA/IHBhcnNlZC5wYXRobmFtZS5sZW5ndGggOiAwO1xuXHRcdGlmIChsZW5ndGggPiAxICYmIHBhcnNlZC5wYXRobmFtZVtsZW5ndGggLSAxXSA9PT0gJy8nKSB7XG5cdFx0XHRwYXJzZWQucGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWUuc3Vic3RyKDAsIGxlbmd0aCAtIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyc2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3VyaSBPcHRpb25hbCBzdHJpbmcgVVJJIHRvIHBhcnNlXG5cdCAqL1xuXHRzdGF0aWMgcGFyc2Uob3B0X3VyaSkge1xuXHRcdHJldHVybiBVcmkubm9ybWFsaXplT2JqZWN0KHBhcnNlRm5fKG9wdF91cmkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwYXJhbWV0ZXIgdG8gcmVtb3ZlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRyZW1vdmVQYXJhbWV0ZXIobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHR0aGlzLnF1ZXJ5LnJlbW92ZShuYW1lKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHVuaXF1ZW5lc3MgcGFyYW1ldGVyIG9mIHRoZSB1cmkuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHJlbW92ZVVuaXF1ZSgpIHtcblx0XHR0aGlzLnJlbW92ZVBhcmFtZXRlcihVcmkuUkFORE9NX1BBUkFNKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBoYXNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRIYXNoKGhhc2gpIHtcblx0XHR0aGlzLnVybC5oYXNoID0gaGFzaDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBob3N0bmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldEhvc3RuYW1lKGhvc3RuYW1lKSB7XG5cdFx0dGhpcy51cmwuaG9zdG5hbWUgPSBob3N0bmFtZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVycywgY2xlYXJpbmcgcHJldmlvdXMgdmFsdWVzXG5cdCAqIGZvciB0aGF0IGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMucmVtb3ZlUGFyYW1ldGVyKG5hbWUpO1xuXHRcdHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlcyBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVycywgY2xlYXJpbmcgcHJldmlvdXMgdmFsdWVzXG5cdCAqIGZvciB0aGF0IGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSwgdmFsdWVzKSB7XG5cdFx0dGhpcy5yZW1vdmVQYXJhbWV0ZXIobmFtZSk7XG5cdFx0dmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB0aGlzLmFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGF0aG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQYXRobmFtZShwYXRobmFtZSkge1xuXHRcdHRoaXMudXJsLnBhdGhuYW1lID0gcGF0aG5hbWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcG9ydCBudW1iZXIuXG5cdCAqIEBwYXJhbSB7Kn0gcG9ydCBQb3J0IG51bWJlci5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UG9ydChwb3J0KSB7XG5cdFx0dGhpcy51cmwucG9ydCA9IHBvcnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHBhcnNpbmcgdGhlIG9yaWdpbmFsIHN0cmluZyB1cmlcblx0ICogaW50byBhbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHBhcnNlRm5cblx0ICovXG5cdHN0YXRpYyBzZXRQYXJzZUZuKHBhcnNlRm4pIHtcblx0XHRwYXJzZUZuXyA9IHBhcnNlRm47XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcHJvdG9jb2wuIElmIG1pc3NpbmcgPGNvZGU+aHR0cDo8L2NvZGU+IGlzIHVzZWQgYXMgZGVmYXVsdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldFByb3RvY29sKHByb3RvY29sKSB7XG5cdFx0dGhpcy51cmwucHJvdG9jb2wgPSBwcm90b2NvbDtcblx0XHRpZiAodGhpcy51cmwucHJvdG9jb2xbdGhpcy51cmwucHJvdG9jb2wubGVuZ3RoIC0gMV0gIT09ICc6Jykge1xuXHRcdFx0dGhpcy51cmwucHJvdG9jb2wgKz0gJzonO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgdXJsLlxuXHQgKiBAb3ZlcnJpZGVcblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHZhciBocmVmID0gJyc7XG5cdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3QoKTtcblx0XHRpZiAoaG9zdCkge1xuXHRcdFx0aHJlZiArPSB0aGlzLmdldFByb3RvY29sKCkgKyAnLy8nO1xuXHRcdH1cblx0XHRocmVmICs9IGhvc3QgKyB0aGlzLmdldFBhdGhuYW1lKCkgKyB0aGlzLmdldFNlYXJjaCgpICsgdGhpcy5nZXRIYXNoKCk7XG5cdFx0cmV0dXJuIGhyZWY7XG5cdH1cblxuXHQvKipcblx0ICogSm9pbnMgdGhlIGdpdmVuIHBhdGhzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGhcblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IC4uLnBhdGhzIEFueSBudW1iZXIgb2YgcGF0aHMgdG8gYmUgam9pbmVkIHdpdGggdGhlIGJhc2UgdXJsLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgam9pblBhdGhzKGJhc2VQYXRoLCAuLi5wYXRocykge1xuXHRcdGlmIChiYXNlUGF0aC5jaGFyQXQoYmFzZVBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuXHRcdFx0YmFzZVBhdGggPSBiYXNlUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVBhdGgubGVuZ3RoIC0gMSk7XG5cdFx0fVxuXHRcdHBhdGhzID0gcGF0aHMubWFwKHBhdGggPT4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aCk7XG5cdFx0cmV0dXJuIFtiYXNlUGF0aF0uY29uY2F0KHBhdGhzKS5qb2luKCcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVUkwtZGVjb2RlcyB0aGUgc3RyaW5nLiBXZSBuZWVkIHRvIHNwZWNpYWxseSBoYW5kbGUgJysncyBiZWNhdXNlXG5cdCAqIHRoZSBqYXZhc2NyaXB0IGxpYnJhcnkgZG9lc24ndCBjb252ZXJ0IHRoZW0gdG8gc3BhY2VzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdXJsIGRlY29kZS5cblx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGVjb2RlZCB7QGNvZGUgc3RyfS5cblx0ICovXG5cdHN0YXRpYyB1cmxEZWNvZGUoc3RyKSB7XG5cdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuXHR9XG5cbn1cblxuLyoqXG4gKiBEZWZhdWx0IHByb3RvY29sIHZhbHVlLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBkZWZhdWx0IGh0dHA6XG4gKiBAc3RhdGljXG4gKi9cblVyaS5ERUZBVUxUX1BST1RPQ09MID0gJ2h0dHA6JztcblxuLyoqXG4gKiBIb3N0bmFtZSBwbGFjZWhvbGRlci4gUmVsZXZhbnQgdG8gaW50ZXJuYWwgdXNhZ2Ugb25seS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUiA9ICdob3N0bmFtZScgKyBEYXRlLm5vdygpO1xuXG4vKipcbiAqIE5hbWUgdXNlZCBieSB0aGUgcGFyYW0gZ2VuZXJhdGVkIGJ5IGBtYWtlVW5pcXVlYC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblVyaS5SQU5ET01fUEFSQU0gPSAnengnO1xuXG5leHBvcnQgZGVmYXVsdCBVcmk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuXG5mdW5jdGlvbiBhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQoKSB7XG5cdGlmICghZ2xvYmFscy53aW5kb3cpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NpZ24taW4gdHlwZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnREZWZBbmROb3ROdWxsKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKCFjb3JlLmlzRGVmQW5kTm90TnVsbCh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnROb3ROdWxsKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKGNvcmUuaXNOdWxsKHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKCFjb3JlLmlzRnVuY3Rpb24odmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHZhbHVlLCBlcnJvck1lc3NhZ2UpIHtcblx0aWYgKCFjb3JlLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSB7XG5cdGlmICghcmVzcG9uc2Uuc3VjY2VlZGVkKCkpIHtcblx0XHR0aHJvdyByZXNwb25zZS5ib2R5KCk7XG5cdH1cblx0cmV0dXJuIHJlc3BvbnNlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRVc2VyU2lnbmVkSW4odXNlcikge1xuXHRpZiAoIWNvcmUuaXNEZWZBbmROb3ROdWxsKHVzZXIpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBiZSBzaWduZWQtaW4gdG8gcGVyZm9ybSB0aGlzIG9wZXJhdGlvbicpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVyaVdpdGhOb1BhdGgodXJsLCBtZXNzYWdlKSB7XG5cdHZhciB1cmkgPSBuZXcgVXJpKHVybCk7XG5cdGlmICh1cmkuZ2V0UGF0aG5hbWUoKS5sZW5ndGggPiAxKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHR9XG59XG5cbmV4cG9ydCB7IGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCwgYXNzZXJ0RGVmQW5kTm90TnVsbCwgYXNzZXJ0Tm90TnVsbCwgYXNzZXJ0RnVuY3Rpb24sIGFzc2VydE9iamVjdCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQsIGFzc2VydFVzZXJTaWduZWRJbiwgYXNzZXJ0VXJpV2l0aE5vUGF0aCB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuXG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsLCBhc3NlcnRPYmplY3QsIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkIH0gZnJvbSAnLi4vYXNzZXJ0aW9ucyc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHN0b3JpbmcgYXV0aG9yaXphdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgQXV0aCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRva2VuT3JFbWFpbCBFaXRoZXIgdGhlIGF1dGhvcml6YXRpb24gdG9rZW4sIG9yXG5cdCAqICAgdGhlIHVzZXJuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9wYXNzd29yZCBJZiBhIHVzZXJuYW1lIGlzIGdpdmVuIGFzIHRoZSBmaXJzdCBwYXJhbSxcblx0ICogICB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IodG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQgPSBudWxsKSB7XG5cdFx0dGhpcy50b2tlbiA9IGNvcmUuaXNTdHJpbmcob3B0X3Bhc3N3b3JkKSA/IG51bGwgOiB0b2tlbk9yRW1haWw7XG5cdFx0dGhpcy5lbWFpbCA9IGNvcmUuaXNTdHJpbmcob3B0X3Bhc3N3b3JkKSA/IHRva2VuT3JFbWFpbCA6IG51bGw7XG5cdFx0dGhpcy5wYXNzd29yZCA9IG9wdF9wYXNzd29yZDtcblxuXHRcdHRoaXMuY3JlYXRlZEF0ID0gbnVsbDtcblx0XHR0aGlzLmlkID0gbnVsbDtcblx0XHR0aGlzLm5hbWUgPSBudWxsO1xuXHRcdHRoaXMucGhvdG9VcmwgPSBudWxsO1xuXHRcdHRoaXMud2VkZXBsb3lDbGllbnQgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5PclVzZXJuYW1lIEVpdGhlciB0aGUgYXV0aG9yaXphdGlvbiB0b2tlbiwgb3Jcblx0ICogICB0aGUgdXNlcm5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgdXNlcm5hbWUgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiAgIHRoaXMgc2hvdWxkIGJlIHRoZSBwYXNzd29yZC5cblx0ICogQHJldHVybiB7IUF1dGh9XG5cdCAqL1xuXHRzdGF0aWMgY3JlYXRlKHRva2VuT3JVc2VybmFtZSwgb3B0X3Bhc3N3b3JkKSB7XG5cdFx0cmV0dXJuIG5ldyBBdXRoKHRva2VuT3JVc2VybmFtZSwgb3B0X3Bhc3N3b3JkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjcmVhdGVkIGF0IGRhdGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldENyZWF0ZWRBdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVkQXQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZW1haWwuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEVtYWlsKCkge1xuXHRcdHJldHVybiB0aGlzLmVtYWlsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGlkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRJZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5pZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBuYW1lLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXROYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLm5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBhc3N3b3JkKCkge1xuXHRcdHJldHVybiB0aGlzLnBhc3N3b3JkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBob3RvIHVybC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0UGhvdG9VcmwoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGhvdG9Vcmw7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdG9rZW4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFRva2VuKCkge1xuXHRcdHJldHVybiB0aGlzLnRva2VuO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBjcmVhdGVkIGF0IGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc0NyZWF0ZWRBdCgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5jcmVhdGVkQXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZW1haWwgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzRW1haWwoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuZW1haWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgaWQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzSWQoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuaWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgbmFtZSBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNOYW1lKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLm5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGFzc3dvcmQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUGFzc3dvcmQoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucGFzc3dvcmQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGhvdG8gdXJsIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Bob3RvVXJsKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnBob3RvVXJsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHRva2VuIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Rva2VuKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnRva2VuKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGNyZWF0ZWQgYXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjcmVhdGVkQXRcblx0ICovXG5cdHNldENyZWF0ZWRBdChjcmVhdGVkQXQpIHtcblx0XHR0aGlzLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBlbWFpbC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG5cdCAqL1xuXHRzZXRFbWFpbChlbWFpbCkge1xuXHRcdHRoaXMuZW1haWwgPSBlbWFpbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBpZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqL1xuXHRzZXRJZChpZCkge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKi9cblx0c2V0TmFtZShuYW1lKSB7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwYXNzd29yZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG5cdCAqL1xuXHRzZXRQYXNzd29yZChwYXNzd29yZCkge1xuXHRcdHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwaG90byB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwaG90b1VybFxuXHQgKi9cblx0c2V0UGhvdG9VcmwocGhvdG9VcmwpIHtcblx0XHR0aGlzLnBob3RvVXJsID0gcGhvdG9Vcmw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdG9rZW4uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuXHQgKi9cblx0c2V0VG9rZW4odG9rZW4pIHtcblx0XHR0aGlzLnRva2VuID0gdG9rZW47XG5cdH1cblxuXHRzZXRXZWRlcGxveUNsaWVudCh3ZWRlcGxveUNsaWVudCkge1xuXHRcdHRoaXMud2VkZXBsb3lDbGllbnQgPSB3ZWRlcGxveUNsaWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSB1c2VyLlxuXHQgKiBAcGFyYW0geyFvYmplY3R9IGRhdGFcblx0ICogQHJldHVybiB7Q29tcGxldGFibGVGdXR1cmV9XG5cdCAqL1xuXHR1cGRhdGVVc2VyKGRhdGEpIHtcblx0XHRhc3NlcnRPYmplY3QoZGF0YSwgJ1VzZXIgZGF0YSBtdXN0IGJlIHNwZWNpZmllZCBhcyBvYmplY3QnKTtcblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuXHRcdFx0LnBhdGgoJy91c2VycycpXG5cdFx0XHQuYXV0aCh0aGlzKVxuXHRcdFx0LnBhdGNoKGRhdGEpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgdGhlIGN1cnJlbnQgdXNlci5cblx0ICogQHJldHVybiB7Q29tcGxldGFibGVGdXR1cmV9XG5cdCAqL1xuXHRkZWxldGVVc2VyKCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwodGhpcy5pZCwgJ0Nhbm5vdCBkZWxldGUgdXNlciB3aXRob3V0IGlkJyk7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvdXNlcnMnLCB0aGlzLmlkKVxuXHRcdFx0LmF1dGgodGhpcylcblx0XHRcdC5kZWxldGUoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdXRoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aCBmcm9tICcuL2F1dGgvQXV0aCc7XG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsIH0gZnJvbSAnLi9hc3NlcnRpb25zJztcblxuY2xhc3MgQXBpSGVscGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwod2VkZXBsb3lDbGllbnQsICdXZURlcGxveSBjbGllbnQgcmVmZXJlbmNlIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0dGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYXV0aG9yaXphdGlvbiBpbmZvcm1hdGlvbiB0byB0aGlzIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7IUF1dGh8c3RyaW5nfSBhdXRoT3JUb2tlbk9yRW1haWwgRWl0aGVyIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZSxcblx0ICogYW4gYXV0aG9yaXphdGlvbiB0b2tlbiwgb3IgdGhlIGVtYWlsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9wYXNzd29yZCBJZiBhIGVtYWlsIGlzIGdpdmVuIGFzIHRoZSBmaXJzdCBwYXJhbSxcblx0ICogdGhpcyBzaG91bGQgYmUgdGhlIHBhc3N3b3JkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhdXRoKGF1dGhPclRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkKSB7XG5cdFx0dGhpcy5oZWxwZXJBdXRoU2NvcGUgPSBhdXRoT3JUb2tlbk9yRW1haWw7XG5cdFx0aWYgKCEodGhpcy5oZWxwZXJBdXRoU2NvcGUgaW5zdGFuY2VvZiBBdXRoKSkge1xuXHRcdFx0dGhpcy5oZWxwZXJBdXRoU2NvcGUgPSBBdXRoLmNyZWF0ZShhdXRoT3JUb2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBpSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNhcHN1bGF0ZSBwcm92aWRlciBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgQXV0aFByb3ZpZGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5wcm92aWRlciA9IG51bGw7XG5cdFx0dGhpcy5wcm92aWRlclNjb3BlID0gbnVsbDtcblx0XHR0aGlzLnJlZGlyZWN0VXJpID0gbnVsbDtcblx0XHR0aGlzLnNjb3BlID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcHJvdmlkZXIgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNQcm92aWRlcigpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5wcm92aWRlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHNjb3BlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUHJvdmlkZXJTY29wZSgpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5wcm92aWRlclNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcmVkaXJlY3QgdXJpIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUmVkaXJlY3RVcmkoKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucmVkaXJlY3RVcmkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBzY29wZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc1Njb3BlKCkge1xuXHRcdHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlcyBhdXRob3JpemF0aW9uIHVybC5cblx0ICogQHJldHVybiB7c3RyaW5nPX0gQXV0aG9yaXphdGlvbiB1cmwuXG5cdCAqL1xuXHRtYWtlQXV0aG9yaXphdGlvblVybChvcHRfYXV0aFVybCkge1xuXHRcdHZhciB1cmkgPSBuZXcgVXJpKG9wdF9hdXRoVXJsKTtcblxuXHRcdHVyaS5zZXRQYXRobmFtZSgnL29hdXRoL2F1dGhvcml6ZScpO1xuXG5cdFx0aWYgKHRoaXMuaGFzUHJvdmlkZXIoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdwcm92aWRlcicsIHRoaXMuZ2V0UHJvdmlkZXIoKSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmhhc1Byb3ZpZGVyU2NvcGUoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdwcm92aWRlcl9zY29wZScsIHRoaXMuZ2V0UHJvdmlkZXJTY29wZSgpKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaGFzUmVkaXJlY3RVcmkoKSkge1xuXHRcdFx0dXJpLnNldFBhcmFtZXRlclZhbHVlKCdyZWRpcmVjdF91cmknLCB0aGlzLmdldFJlZGlyZWN0VXJpKCkpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5oYXNTY29wZSgpKSB7XG5cdFx0XHR1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3Njb3BlJywgdGhpcy5nZXRTY29wZSgpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBwcm92aWRlciBuYW1lLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fSBQcm92aWRlciBuYW1lLlxuXHQgKi9cblx0Z2V0UHJvdmlkZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvdmlkZXI7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBwcm92aWRlciBzY29wZS5cblx0ICogQHJldHVybiB7c3RyaW5nPX0gU3RyaW5nIHdpdGggc2NvcGVzLlxuXHQgKi9cblx0Z2V0UHJvdmlkZXJTY29wZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm92aWRlclNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fS5cblx0ICovXG5cdGdldFJlZGlyZWN0VXJpKCkge1xuXHRcdHJldHVybiB0aGlzLnJlZGlyZWN0VXJpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgc2NvcGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZz19IFN0cmluZyB3aXRoIHNjb3Blcy5cblx0ICovXG5cdGdldFNjb3BlKCkge1xuXHRcdHJldHVybiB0aGlzLnNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgcHJvdmlkZXIgc2NvcGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2NvcGUgU2NvcGUgc3RyaW5nLiBTZXBhcmF0ZSBieSBzcGFjZSBmb3IgbXVsdGlwbGVcblx0ICogICBzY29wZXMsIGUuZy4gXCJzY29wZTEgc2NvcGUyXCIuXG5cdCAqL1xuXHRzZXRQcm92aWRlclNjb3BlKHByb3ZpZGVyU2NvcGUpIHtcblx0XHRhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwocHJvdmlkZXJTY29wZSwgJ1Byb3ZpZGVyIHNjb3BlIG11c3QgYmUgYSBzdHJpbmcnKTtcblx0XHR0aGlzLnByb3ZpZGVyU2NvcGUgPSBwcm92aWRlclNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IHJlZGlyZWN0VXJpLlxuXHQgKi9cblx0c2V0UmVkaXJlY3RVcmkocmVkaXJlY3RVcmkpIHtcblx0XHRhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwocmVkaXJlY3RVcmksICdSZWRpcmVjdCB1cmkgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdHRoaXMucmVkaXJlY3RVcmkgPSByZWRpcmVjdFVyaTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHNjb3BlLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IHNjb3BlIFNjb3BlIHN0cmluZy4gU2VwYXJhdGUgYnkgc3BhY2UgZm9yIG11bHRpcGxlXG5cdCAqICAgc2NvcGVzLCBlLmcuIFwic2NvcGUxIHNjb3BlMlwiLlxuXHQgKi9cblx0c2V0U2NvcGUoc2NvcGUpIHtcblx0XHRhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwoc2NvcGUsICdTY29wZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ0lmRGVmQW5kTm90TnVsbCh2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG5cdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbCh2YWx1ZSkgJiYgIWNvcmUuaXNTdHJpbmcodmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aFByb3ZpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aFByb3ZpZGVyIGZyb20gJy4vQXV0aFByb3ZpZGVyJztcblxuLyoqXG4gKiBGYWNlYm9vayBhdXRoIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBGYWNlYm9va0F1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBGYWNlYm9va0F1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnByb3ZpZGVyID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVI7XG5cdH1cbn1cblxuRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZmFjZWJvb2snO1xuXG5leHBvcnQgZGVmYXVsdCBGYWNlYm9va0F1dGhQcm92aWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGhQcm92aWRlciBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5cbi8qKlxuICogR2l0aHViIGF1dGggcHJvdmlkZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIEdpdGh1YkF1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBHaXRodWJBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5wcm92aWRlciA9IEdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUjtcblx0fVxufVxuXG5HaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZ2l0aHViJztcblxuZXhwb3J0IGRlZmF1bHQgR2l0aHViQXV0aFByb3ZpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aFByb3ZpZGVyIGZyb20gJy4vQXV0aFByb3ZpZGVyJztcblxuLyoqXG4gKiBHb29nbGUgYXV0aCBwcm92aWRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgR29vZ2xlQXV0aFByb3ZpZGVyIGV4dGVuZHMgQXV0aFByb3ZpZGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEdvb2dsZUF1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnByb3ZpZGVyID0gR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSO1xuXHR9XG59XG5cbkdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUiA9ICdnb29nbGUnO1xuXG5leHBvcnQgZGVmYXVsdCBHb29nbGVBdXRoUHJvdmlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZGF0YSB1c2luZyBzb21lIHBlcnNpc3RlbmNlXG4gKiBtZWNoYW5pc20uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3RvcmFnZU1lY2hhbmlzbSB7XG5cdC8qKlxuXHQgKiBDbGVhciBhbGwgaXRlbXMgZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhbiBpdGVtIGluIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlcmlhbGl6ZSB0byBhIHN0cmluZyBhbmQgc2F2ZS5cblx0ICovXG5cdHNldChrZXksIHZhbHVlKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGdldC5cblx0ICogQHJldHVybiB7Kn0gRGVzZXJpYWxpemVkIHZhbHVlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoaXMgbWVjaGFuaXNtIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyB3aGVuIG5lY2Vzc2FyeS5cblx0ICovXG5cdHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0ga2V5c1xuXHQgKi9cblx0a2V5cygpIHtcblx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlLlxuXHQgKi9cblx0cmVtb3ZlKGtleSkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXRhIGl0ZW1zIHN0b3JlZCBpbiB0aGUgU3RvcmFnZSBvYmplY3QuXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdHNpemUoKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZU1lY2hhbmlzbTtcblxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnbWV0YWwnO1xuaW1wb3J0IFN0b3JhZ2VNZWNoYW5pc20gZnJvbSAnLi9tZWNoYW5pc20vU3RvcmFnZU1lY2hhbmlzbSc7XG5cbmNsYXNzIFN0b3JhZ2Uge1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNvbnZlbmllbnQgQVBJIGZvciBkYXRhIHBlcnNpc3RlbmNlIHVzaW5nIGEgc2VsZWN0ZWQgZGF0YVxuXHQgKiBzdG9yYWdlIG1lY2hhbmlzbS5cblx0ICogQHBhcmFtIHshU3RvcmFnZU1lY2hhbmlzbX0gbWVjaGFuaXNtIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgbWVjaGFuaXNtLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKG1lY2hhbmlzbSkge1xuXHRcdGFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwobWVjaGFuaXNtKTtcblx0XHRhc3NlcnRNZWNoYW5pc21JbnRhbmNlT2YobWVjaGFuaXNtKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtZWNoYW5pc20gdXNlZCB0byBwZXJzaXN0IGtleS12YWx1ZSBwYWlycy5cblx0XHQgKiBAdHlwZSB7U3RvcmFnZU1lY2hhbmlzbX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5tZWNoYW5pc20gPSBtZWNoYW5pc207XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXIgYWxsIGl0ZW1zIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICovXG5cdGNsZWFyKCkge1xuXHRcdHRoaXMubWVjaGFuaXNtLmNsZWFyKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhbiBpdGVtIGluIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlcmlhbGl6ZSB0byBhIHN0cmluZyBhbmQgc2F2ZS5cblx0ICovXG5cdHNldChrZXksIHZhbHVlKSB7XG5cdFx0aWYgKCFjb3JlLmlzRGVmKHZhbHVlKSkge1xuXHRcdFx0dGhpcy5tZWNoYW5pc20ucmVtb3ZlKGtleSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMubWVjaGFuaXNtLnNldChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGdldC5cblx0ICogQHJldHVybiB7Kn0gRGVzZXJpYWxpemVkIHZhbHVlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0dmFyIGpzb247XG5cdFx0dHJ5IHtcblx0XHRcdGpzb24gPSB0aGlzLm1lY2hhbmlzbS5nZXQoa2V5KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoY29yZS5pc051bGwoanNvbikpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aHJvdyBTdG9yYWdlLkVycm9yQ29kZS5JTlZBTElEX1ZBTFVFO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0ga2V5c1xuXHQgKi9cblx0a2V5cygpIHtcblx0XHRyZXR1cm4gdGhpcy5tZWNoYW5pc20ua2V5cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG5cdCAqL1xuXHRyZW1vdmUoa2V5KSB7XG5cdFx0dGhpcy5tZWNoYW5pc20ucmVtb3ZlKGtleSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgaXRlbXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5tZWNoYW5pc20uc2l6ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxpc3Qgb2YgdmFsdWVzIHN0b3JlZCBpbiB0aGUgU3RvcmFnZSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IHZhbHVlc1xuXHQgKi9cblx0dmFsdWVzKCkge1xuXHRcdHJldHVybiB0aGlzLmtleXMoKS5tYXAoKGtleSkgPT4gdGhpcy5nZXQoa2V5KSk7XG5cdH1cbn1cblxuLyoqXG4gKiBFcnJvcnMgdGhyb3duIGJ5IHRoZSBzdG9yYWdlLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuU3RvcmFnZS5FcnJvckNvZGUgPSB7XG5cdElOVkFMSURfVkFMVUU6ICdTdG9yYWdlOiBJbnZhbGlkIHZhbHVlIHdhcyBlbmNvdW50ZXJlZCdcbn07XG5cbmZ1bmN0aW9uIGFzc2VydE1lY2hhbmlzbURlZkFuZE5vdE51bGwobWVjaGFuaXNtKSB7XG5cdGlmICghY29yZS5pc0RlZkFuZE5vdE51bGwobWVjaGFuaXNtKSkge1xuXHRcdHRocm93IEVycm9yKCdTdG9yYWdlIG1lY2hhbmlzbSBpcyByZXF1aXJlZCcpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1lY2hhbmlzbUludGFuY2VPZihtZWNoYW5pc20pIHtcblx0aWYgKCEobWVjaGFuaXNtIGluc3RhbmNlb2YgU3RvcmFnZU1lY2hhbmlzbSkpIHtcblx0XHR0aHJvdyBFcnJvcignU3RvcmFnZSBtZWNoYW5pc20gbXVzdCBtZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBTdG9yYWdlTWVjaGFuaXNtJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFN0b3JhZ2VNZWNoYW5pc20gZnJvbSAnLi9TdG9yYWdlTWVjaGFuaXNtJztcblxuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZGF0YSB1c2luZyBzb21lIHBlcnNpc3RlbmNlXG4gKiBtZWNoYW5pc20uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTG9jYWxTdG9yYWdlTWVjaGFuaXNtIGV4dGVuZHMgU3RvcmFnZU1lY2hhbmlzbSB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJlZmVyZW5jZSBmb3IgZ2xvYmFsIGxvY2FsIHN0b3JhZ2UuIGJ5IGRlZmF1bHRcblx0ICovXG5cdHN0b3JhZ2UoKSB7XG5cdFx0cmV0dXJuIExvY2FsU3RvcmFnZU1lY2hhbmlzbS5nbG9iYWxzLmxvY2FsU3RvcmFnZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5zdG9yYWdlKCkuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0a2V5cygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RvcmFnZSgpLmdldEl0ZW0oa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0c3RhdGljIGlzU3VwcG9ydGVkKCkge1xuXHRcdHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0cmVtb3ZlKGtleSkge1xuXHRcdHRoaXMuc3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0c2V0KGtleSwgdmFsdWUpIHtcblx0XHR0aGlzLnN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLnN0b3JhZ2UoKS5sZW5ndGg7XG5cdH1cbn1cblxuaWYgKExvY2FsU3RvcmFnZU1lY2hhbmlzbS5pc1N1cHBvcnRlZCgpKSB7XG5cdExvY2FsU3RvcmFnZU1lY2hhbmlzbS5nbG9iYWxzID0ge1xuXHRcdGxvY2FsU3RvcmFnZTogd2luZG93LmxvY2FsU3RvcmFnZVxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBMb2NhbFN0b3JhZ2VNZWNoYW5pc207XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBdXRoIGZyb20gJy4vQXV0aCc7XG5pbXBvcnQgQXBpSGVscGVyIGZyb20gJy4uL0FwaUhlbHBlcic7XG5pbXBvcnQgRmFjZWJvb2tBdXRoUHJvdmlkZXIgZnJvbSAnLi9GYWNlYm9va0F1dGhQcm92aWRlcic7XG5pbXBvcnQgR2l0aHViQXV0aFByb3ZpZGVyIGZyb20gJy4vR2l0aHViQXV0aFByb3ZpZGVyJztcbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgR29vZ2xlQXV0aFByb3ZpZGVyIGZyb20gJy4vR29vZ2xlQXV0aFByb3ZpZGVyJztcbmltcG9ydCB7IFN0b3JhZ2UsIExvY2FsU3RvcmFnZU1lY2hhbmlzbSB9IGZyb20gJ21ldGFsLXN0b3JhZ2UnO1xuXG5pbXBvcnQgeyBhc3NlcnREZWZBbmROb3ROdWxsLCBhc3NlcnRGdW5jdGlvbiwgYXNzZXJ0T2JqZWN0LCBhc3NlcnRVc2VyU2lnbmVkSW4sIGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQgfSBmcm9tICcuLi9hc3NlcnRpb25zJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGUgYXV0aCBhcGkgY2FsbHMuXG4gKi9cbmNsYXNzIEF1dGhBcGlIZWxwZXIgZXh0ZW5kcyBBcGlIZWxwZXIge1xuXHQvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXV0aEFwaUhlbHBlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3Iod2VkZXBsb3lDbGllbnQpIHtcblx0XHRzdXBlcih3ZWRlcGxveUNsaWVudCk7XG5cblx0XHR0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcblx0XHR0aGlzLm9uU2lnbkluQ2FsbGJhY2sgPSBudWxsO1xuXHRcdHRoaXMub25TaWduT3V0Q2FsbGJhY2sgPSBudWxsO1xuXHRcdHRoaXMuc3RvcmFnZSA9IG5ldyBTdG9yYWdlKG5ldyBMb2NhbFN0b3JhZ2VNZWNoYW5pc20oKSk7XG5cblx0XHR0aGlzLnByb2Nlc3NTaWduSW5fKCk7XG5cblx0XHR0aGlzLnByb3ZpZGVyID0ge1xuXHRcdFx0RmFjZWJvb2s6IEZhY2Vib29rQXV0aFByb3ZpZGVyLFxuXHRcdFx0R29vZ2xlOiBHb29nbGVBdXRoUHJvdmlkZXIsXG5cdFx0XHRHaXRodWI6IEdpdGh1YkF1dGhQcm92aWRlclxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyB1c2VyLlxuXHQgKiBAcGFyYW0geyFvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdXNlZCB0byBjcmVhdGUgdGhlIHVzZXIuXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGNyZWF0ZVVzZXIoZGF0YSkge1xuXHRcdGFzc2VydE9iamVjdChkYXRhLCAnVXNlciBkYXRhIG11c3QgYmUgc3BlY2lmaWVkIGFzIG9iamVjdCcpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJylcblx0XHRcdC5wb3N0KGRhdGEpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB0aGlzLm1ha2VVc2VyQXV0aEZyb21EYXRhKHJlc3BvbnNlLmJvZHkoKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnQgYnJvd3NlciB1cmwgd2l0aG91dCB0aGUgZnJhZ21lbnQgcGFydC5cblx0ICogQHJldHVybiB7IXN0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0SHJlZldpdGhvdXRGcmFnbWVudF8oKSB7XG5cdFx0dmFyIGxvY2F0aW9uID0gZ2xvYmFscy53aW5kb3cubG9jYXRpb247XG5cdFx0cmV0dXJuIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QgKyBsb2NhdGlvbi5wYXRobmFtZSArIChsb2NhdGlvbi5zZWFyY2ggPyBsb2NhdGlvbi5zZWFyY2ggOiAnJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgYWNjZXNzIHRva2VuIGZyb20gdGhlIHVybCBmcmFnbWVudCBhbmQgcmVtb3ZlcyBpdC5cblx0ICogQHJldHVybiB7P3N0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0UmVkaXJlY3RBY2Nlc3NUb2tlbl8oKSB7XG5cdFx0aWYgKGdsb2JhbHMud2luZG93KSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0aWYgKGZyYWdtZW50LmluZGV4T2YoJyNhY2Nlc3NfdG9rZW49JykgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIGZyYWdtZW50LnN1YnN0cmluZygxNCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdXNlciBieSBpZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB1c2VySWRcblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0Z2V0VXNlcih1c2VySWQpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKHVzZXJJZCwgJ1VzZXIgdXNlcklkIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0YXNzZXJ0VXNlclNpZ25lZEluKHRoaXMuY3VycmVudFVzZXIpO1xuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuYXV0aFVybF8pXG5cdFx0XHQucGF0aCgnL3VzZXJzJywgdXNlcklkKVxuXHRcdFx0LmF1dGgodGhpcy5yZXNvbHZlQXV0aFNjb3BlKCkudG9rZW4pXG5cdFx0XHQuZ2V0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHRoaXMubWFrZVVzZXJBdXRoRnJvbURhdGEocmVzcG9uc2UuYm9keSgpKSk7XG5cdH1cblxuXHQvKipcblx0ICogTG9hZHMgY3VycmVudCB1c2VyLiBSZXF1aXJlcyBhIHVzZXIgdG9rZW4gYXMgYXJndW1lbnQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdG9rZW5cblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0bG9hZEN1cnJlbnRVc2VyKHRva2VuKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbCh0b2tlbiwgJ1VzZXIgdG9rZW4gbXVzdCBiZSBzcGVjaWZpZWQnKTtcblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuXHRcdFx0LnBhdGgoJy91c2VyJylcblx0XHRcdC5hdXRoKHRva2VuKVxuXHRcdFx0LmdldCgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRcdHZhciBkYXRhID0gcmVzcG9uc2UuYm9keSgpO1xuXHRcdFx0XHRkYXRhLnRva2VuID0gdG9rZW47XG5cdFx0XHRcdHRoaXMuY3VycmVudFVzZXIgPSB0aGlzLm1ha2VVc2VyQXV0aEZyb21EYXRhKGRhdGEpO1xuXHRcdFx0XHR0aGlzLnN0b3JhZ2Uuc2V0KCdjdXJyZW50VXNlcicsIGRhdGEpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VXNlcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHVzZXIgQXV0aCBmcm9tIGRhdGEgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtBdXRofVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRtYWtlVXNlckF1dGhGcm9tRGF0YShkYXRhKSB7XG5cdFx0dmFyIGF1dGggPSBuZXcgQXV0aCgpO1xuXHRcdGF1dGguc2V0V2VkZXBsb3lDbGllbnQodGhpcy53ZWRlcGxveUNsaWVudCk7XG5cdFx0YXV0aC5zZXRDcmVhdGVkQXQoZGF0YS5jcmVhdGVkQXQpO1xuXHRcdGF1dGguc2V0RW1haWwoZGF0YS5lbWFpbCk7XG5cdFx0YXV0aC5zZXRJZChkYXRhLmlkKTtcblx0XHRhdXRoLnNldE5hbWUoZGF0YS5uYW1lKTtcblx0XHRhdXRoLnNldFBob3RvVXJsKGRhdGEucGhvdG9VcmwpO1xuXHRcdGF1dGguc2V0VG9rZW4oZGF0YS50b2tlbik7XG5cdFx0cmV0dXJuIGF1dGg7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIG9uIHNpZ24gaW4gY2FsbGJhY2sgaWYgc2V0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRtYXliZUNhbGxPblNpZ25JbkNhbGxiYWNrXygpIHtcblx0XHRpZiAodGhpcy5vblNpZ25JbkNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLm9uU2lnbkluQ2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRVc2VyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIG9uIHNpZ24gb3V0IGNhbGxiYWNrIGlmIHNldC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0bWF5YmVDYWxsT25TaWduT3V0Q2FsbGJhY2tfKCkge1xuXHRcdGlmICh0aGlzLm9uU2lnbk91dENhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLm9uU2lnbk91dENhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5jdXJyZW50VXNlcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEZpcmVzIHBhc3NlZCBjYWxsYmFjayB3aGVuIGEgdXNlciBzaWduLWluLiBOb3RlIHRoYXQgaXQga2VlcHMgb25seSB0aGVcblx0ICogbGFzdCBjYWxsYmFjayBwYXNzZWQuXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFja1xuXHQgKi9cblx0b25TaWduSW4oY2FsbGJhY2spIHtcblx0XHRhc3NlcnRGdW5jdGlvbihjYWxsYmFjaywgJ1NpZ24taW4gY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0dGhpcy5vblNpZ25JbkNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdH1cblxuXHQvKipcblx0ICogRmlyZXMgcGFzc2VkIGNhbGxiYWNrIHdoZW4gYSB1c2VyIHNpZ24tb3V0LiBOb3RlIHRoYXQgaXQga2VlcHMgb25seSB0aGVcblx0ICogbGFzdCBjYWxsYmFjayBwYXNzZWQuXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFja1xuXHQgKi9cblx0b25TaWduT3V0KGNhbGxiYWNrKSB7XG5cdFx0YXNzZXJ0RnVuY3Rpb24oY2FsbGJhY2ssICdTaWduLW91dCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHR0aGlzLm9uU2lnbk91dENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2Vzc2VzIHNpZ24taW4gYnkgZGV0ZWN0aW5nIGEgcHJlc2VuY2Ugb2YgYSBmcmFnbWVudFxuXHQgKiA8Y29kZT4jYWNjZXNzX3Rva2VuPTwvY29kZT4gaW4gdGhlIHVybCBvciwgYWx0ZXJuYXRpdmVseSwgYnkgbG9jYWxcblx0ICogc3RvcmFnZSBjdXJyZW50IHVzZXIuXG5cdCAqL1xuXHRwcm9jZXNzU2lnbkluXygpIHtcblx0XHR2YXIgcmVkaXJlY3RBY2Nlc3NUb2tlbiA9IHRoaXMuZ2V0UmVkaXJlY3RBY2Nlc3NUb2tlbl8oKTtcblx0XHRpZiAocmVkaXJlY3RBY2Nlc3NUb2tlbikge1xuXHRcdFx0dGhpcy5yZW1vdmVVcmxGcmFnbWVudENvbXBsZXRlbHlfKCk7XG5cdFx0XHR0aGlzLmxvYWRDdXJyZW50VXNlcihyZWRpcmVjdEFjY2Vzc1Rva2VuKVxuXHRcdFx0XHQudGhlbigoKSA9PiB0aGlzLm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgY3VycmVudFVzZXIgPSB0aGlzLnN0b3JhZ2UuZ2V0KCdjdXJyZW50VXNlcicpO1xuXHRcdGlmIChjdXJyZW50VXNlcikge1xuXHRcdFx0dGhpcy5jdXJyZW50VXNlciA9IHRoaXMubWFrZVVzZXJBdXRoRnJvbURhdGEoY3VycmVudFVzZXIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGZyYWdtZW50IGZyb20gdXJsIGJ5IHBlcmZvcm1pbmcgYSBwdXNoIHN0YXRlIHRvIHRoZSBjdXJyZW50IHBhdGguXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHJlbW92ZVVybEZyYWdtZW50Q29tcGxldGVseV8oKSB7XG5cdFx0Z2xvYmFscy53aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNvbHZlcyBhdXRoIHNjb3BlIGZyb20gbGFzdCBsb2dpbiBvciBhcGkgaGVscGVyLlxuXHQgKiBAcmV0dXJuIHtBdXRofVxuXHQgKi9cblx0cmVzb2x2ZUF1dGhTY29wZSgpIHtcblx0XHRpZiAodGhpcy5oZWxwZXJBdXRoU2NvcGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmhlbHBlckF1dGhTY29wZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuY3VycmVudFVzZXI7XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgcGFzc3dvcmQgcmVzZXQgZW1haWwgdG8gdGhlIHNwZWNpZmllZCBlbWFpbCBpZiBmb3VuZCBpbiBkYXRhYmFzZS5cblx0ICogRm9yIHNlY3VyaXR5IHJlYXNvbnMgY2FsbCBkbyBub3QgZmFpbCBpZiBlbWFpbCBub3QgZm91bmQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gZW1haWxcblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0c2VuZFBhc3N3b3JkUmVzZXRFbWFpbChlbWFpbCkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoZW1haWwsICdTZW5kIHBhc3N3b3JkIHJlc2V0IGVtYWlsIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvdXNlci9yZWNvdmVyJylcblx0XHRcdC5wYXJhbSgnZW1haWwnLCBlbWFpbClcblx0XHRcdC5wb3N0KClcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSk7XG5cdH1cblxuXHQvKipcblx0ICogU2lnbnMgaW4gdXNpbmcgZW1haWwgYW5kIHBhc3N3b3JkLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IGVtYWlsXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gcGFzc3dvcmRcblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0c2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChlbWFpbCwgJ1NpZ24taW4gZW1haWwgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKHBhc3N3b3JkLCAnU2lnbi1pbiBwYXNzd29yZCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvb2F1dGgvdG9rZW4nKVxuXHRcdFx0LnBhcmFtKCdncmFudF90eXBlJywgJ3Bhc3N3b3JkJylcblx0XHRcdC5wYXJhbSgndXNlcm5hbWUnLCBlbWFpbClcblx0XHRcdC5wYXJhbSgncGFzc3dvcmQnLCBwYXNzd29yZClcblx0XHRcdC5nZXQoKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gdGhpcy5sb2FkQ3VycmVudFVzZXIocmVzcG9uc2UuYm9keSgpLmFjY2Vzc190b2tlbikpXG5cdFx0XHQudGhlbigodXNlcikgPT4ge1xuXHRcdFx0XHR0aGlzLm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKCk7XG5cdFx0XHRcdHJldHVybiB1c2VyO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogU2lnbnMgaW4gd2l0aCByZWRpcmVjdC4gU29tZSBwcm92aWRlcnMgYW5kIGVudmlyb25tZW50IG1heSBub3Qgc3VwcG9ydFxuXHQgKiB0aGlzIGZsb3cuXG5cdCAqIEBwYXJhbSB7QXV0aFByb3ZpZGVyfSBwcm92aWRlclxuXHQgKi9cblx0c2lnbkluV2l0aFJlZGlyZWN0KHByb3ZpZGVyKSB7XG5cdFx0YXNzZXJ0QnJvd3NlckVudmlyb25tZW50KCk7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChwcm92aWRlciwgJ1NpZ24taW4gcHJvdmlkZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG5cdFx0YXNzZXJ0U3VwcG9ydGVkUHJvdmlkZXIocHJvdmlkZXIpO1xuXG5cdFx0aWYgKCFwcm92aWRlci5oYXNSZWRpcmVjdFVyaSgpKSB7XG5cdFx0XHRwcm92aWRlci5zZXRSZWRpcmVjdFVyaSh0aGlzLmdldEhyZWZXaXRob3V0RnJhZ21lbnRfKCkpO1xuXHRcdH1cblx0XHRnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5ocmVmID0gcHJvdmlkZXIubWFrZUF1dGhvcml6YXRpb25VcmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXyk7XG5cdH1cblxuXHQvKipcblx0ICogU2lnbnMgb3V0IDxjb2RlPmN1cnJlbnRVc2VyPC9jb2RlPiBhbmQgcmVtb3ZlcyBmcm9tIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4uXG5cdCAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0c2lnbk91dCgpIHtcblx0XHRhc3NlcnRVc2VyU2lnbmVkSW4odGhpcy5jdXJyZW50VXNlcik7XG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcblx0XHRcdC5wYXRoKCcvb2F1dGgvcmV2b2tlJylcblx0XHRcdC5wYXJhbSgndG9rZW4nLCB0aGlzLmN1cnJlbnRVc2VyLnRva2VuKVxuXHRcdFx0LmdldCgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRcdHRoaXMubWF5YmVDYWxsT25TaWduT3V0Q2FsbGJhY2tfKCk7XG5cdFx0XHRcdHRoaXMudW5sb2FkQ3VycmVudFVzZXJfKCk7XG5cdFx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVubG9hZHMgYWxsIGluZm9ybWF0aW9uIGZvciA8Y29kZT5jdXJyZW50VXNlcjwvY29kZT4gYW5kIHJlbW92ZXMgZnJvbVxuXHQgKiA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IGlmIHByZXNlbnQuXG5cdCAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0dW5sb2FkQ3VycmVudFVzZXJfKCkge1xuXHRcdHRoaXMuY3VycmVudFVzZXIgPSBudWxsO1xuXHRcdHRoaXMuc3RvcmFnZS5yZW1vdmUoJ2N1cnJlbnRVc2VyJyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3VwcG9ydGVkUHJvdmlkZXIocHJvdmlkZXIpIHtcblx0c3dpdGNoIChwcm92aWRlci5jb25zdHJ1Y3Rvci5QUk9WSURFUikge1xuXHRcdGNhc2UgRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVI6XG5cdFx0Y2FzZSBHaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVI6XG5cdFx0Y2FzZSBHb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVI6XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTaWduLWluIHByb3ZpZGVyIG5vdCBzdXBwb3J0ZWQnKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdXRoQXBpSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi9FbWJvZGllZCc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi9SYW5nZSc7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc2VhcmNoIGFnZ3JlZ2F0aW9uLlxuICovXG5jbGFzcyBBZ2dyZWdhdGlvbiB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgYWdncmVnYXRpb24gdmFsdWUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoZmllbGQsIG9wZXJhdG9yLCBvcHRfdmFsdWUpIHtcblx0XHR0aGlzLmZpZWxkXyA9IGZpZWxkO1xuXHRcdHRoaXMub3BlcmF0b3JfID0gb3BlcmF0b3I7XG5cdFx0dGhpcy52YWx1ZV8gPSBvcHRfdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiYXZnXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGF2ZyhmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ2F2ZycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImNvdW50XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGNvdW50KGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnY291bnQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBEaXN0YW5jZUFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImdlb0Rpc3RhbmNlXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb24gVGhlIGFnZ3JlZ2F0aW9uIGxvY2F0aW9uLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEByZXR1cm4geyFEaXN0YW5jZUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZGlzdGFuY2UoZmllbGQsIGxvY2F0aW9uLCAuLi5yYW5nZXMpIHtcblx0XHRyZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uLkRpc3RhbmNlQWdncmVnYXRpb24oZmllbGQsIGxvY2F0aW9uLCAuLi5yYW5nZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImV4dGVuZGVkU3RhdHNcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZXh0ZW5kZWRTdGF0cyhmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ2V4dGVuZGVkU3RhdHMnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoaXMgYWdncmVnYXRpb24ncyBmaWVsZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0RmllbGQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmllbGRfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhpcyBhZ2dyZWdhdGlvbidzIG9wZXJhdG9yLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRPcGVyYXRvcigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcGVyYXRvcl87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZV87XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiaGlzdG9ncmFtXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbCBUaGUgaGlzdG9ncmFtJ3MgaW50ZXJ2YWwuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGhpc3RvZ3JhbShmaWVsZCwgaW50ZXJ2YWwpIHtcblx0XHRyZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uKGZpZWxkLCAnaGlzdG9ncmFtJywgaW50ZXJ2YWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcIm1heFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtYXgoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdtYXgnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJtaW5cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgbWluKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnbWluJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwibWlzc2luZ1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBtaXNzaW5nKGZpZWxkKSB7XG5cdFx0cmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnbWlzc2luZycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZmllbGQoZmllbGQsIG9wZXJhdG9yKSB7XG5cdFx0cmV0dXJuIG5ldyBBZ2dyZWdhdGlvbihmaWVsZCwgb3BlcmF0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIFJhbmdlQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwicmFuZ2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAcmV0dXJuIHshUmFuZ2VBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHJhbmdlKGZpZWxkLCAuLi5yYW5nZXMpIHtcblx0XHRyZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uLlJhbmdlQWdncmVnYXRpb24oZmllbGQsIC4uLnJhbmdlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwic3RhdHNcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc3RhdHMoZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdzdGF0cycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcInN1bVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBzdW0oZmllbGQpIHtcblx0XHRyZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdzdW0nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJ0ZXJtc1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0ZXJtcyhmaWVsZCkge1xuXHRcdHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ3Rlcm1zJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBkaXN0YW5jZSBhZ2dyZWdhdGlvbi5cbiAqIEBleHRlbmRzIHtBZ2dyZWdhdGlvbn1cbiAqL1xuY2xhc3MgRGlzdGFuY2VBZ2dyZWdhdGlvbiBleHRlbmRzIEFnZ3JlZ2F0aW9uIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIERpc3RhbmNlQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uIFRoZSBhZ2dyZWdhdGlvbiBsb2NhdGlvbi5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGZpZWxkLCBsb2NhdGlvbiwgLi4ucmFuZ2VzKSB7XG5cdFx0c3VwZXIoZmllbGQsICdnZW9EaXN0YW5jZScsIHt9KTtcblx0XHR0aGlzLnZhbHVlXy5sb2NhdGlvbiA9IEVtYm9kaWVkLnRvQm9keShsb2NhdGlvbik7XG5cdFx0dGhpcy52YWx1ZV8ucmFuZ2VzID0gcmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSByYW5nZSB0byB0aGlzIGFnZ3JlZ2F0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhbmdlT3JGcm9tXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF90b1xuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0cmFuZ2UocmFuZ2VPckZyb20sIG9wdF90bykge1xuXHRcdHZhciByYW5nZSA9IHJhbmdlT3JGcm9tO1xuXHRcdGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG5cdFx0XHRyYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JGcm9tLCBvcHRfdG8pO1xuXHRcdH1cblx0XHR0aGlzLnZhbHVlXy5yYW5nZXMucHVzaChyYW5nZS5ib2R5KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBhZ2dyZWdhdGlvbidzIHVuaXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1bml0XG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHR1bml0KHVuaXQpIHtcblx0XHR0aGlzLnZhbHVlXy51bml0ID0gdW5pdDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuQWdncmVnYXRpb24uRGlzdGFuY2VBZ2dyZWdhdGlvbiA9IERpc3RhbmNlQWdncmVnYXRpb247XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcmFuZ2UgYWdncmVnYXRpb24uXG4gKiBAZXh0ZW5kcyB7QWdncmVnYXRpb259XG4gKi9cbmNsYXNzIFJhbmdlQWdncmVnYXRpb24gZXh0ZW5kcyBBZ2dyZWdhdGlvbiB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBSYW5nZUFnZ3JlZ2F0aW9ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGZpZWxkLCAuLi5yYW5nZXMpIHtcblx0XHRzdXBlcihmaWVsZCwgJ3JhbmdlJyk7XG5cdFx0dGhpcy52YWx1ZV8gPSByYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHJhbmdlIHRvIHRoaXMgYWdncmVnYXRpb24uXG5cdCAqIEBwYXJhbSB7Kn0gcmFuZ2VPckZyb21cblx0ICogQHBhcmFtIHsqPX0gb3B0X3RvXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRyYW5nZShyYW5nZU9yRnJvbSwgb3B0X3RvKSB7XG5cdFx0dmFyIHJhbmdlID0gcmFuZ2VPckZyb207XG5cdFx0aWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcblx0XHRcdHJhbmdlID0gUmFuZ2UucmFuZ2UocmFuZ2VPckZyb20sIG9wdF90byk7XG5cdFx0fVxuXHRcdHRoaXMudmFsdWVfLnB1c2gocmFuZ2UuYm9keSgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuQWdncmVnYXRpb24uUmFuZ2VBZ2dyZWdhdGlvbiA9IFJhbmdlQWdncmVnYXRpb247XG5cbmV4cG9ydCBkZWZhdWx0IEFnZ3JlZ2F0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgQWdncmVnYXRpb24gZnJvbSAnLi9BZ2dyZWdhdGlvbic7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGJ1aWxkaW5nIHF1ZXJpZXMuXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgRW1ib2RpZWQge1xuXHQvKipcblx0ICogQWRkcyBhbiBhZ2dyZWdhdGlvbiB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhZ2dyZWdhdGlvbiBuYW1lLlxuXHQgKiBAcGFyYW0geyFBZ2dyZWdhdGlvbnxzdHJpbmd9IGFnZ3JlZ2F0aW9uT3JGaWVsZCBFaXRoZXIgYW5cblx0ICogICB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIG9yIHRoZSBuYW1lIG9mIHRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfb3BlcmF0b3IgVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBhZ2dyZWdhdGUobmFtZSwgYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkuYWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiY291bnRcIi5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgY291bnQoKSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLnR5cGUoJ2NvdW50Jyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHF1ZXJ5J3MgdHlwZSB0byBcImZldGNoXCIuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGZldGNoKCkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS50eXBlKCdmZXRjaCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gdGhpcyBRdWVyeS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5maWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSBvZmZzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbnRyeSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZFxuXHQgKiAgIGJ5IHRoaXMgcXVlcnkuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG9mZnNldChvZmZzZXQpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkub2Zmc2V0KG9mZnNldCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGhpZ2hsaWdodCBlbnRyeSB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBoaWdobGlnaHQoZmllbGQpIHtcblx0XHRyZXR1cm4gbmV3IFF1ZXJ5KCkuaGlnaGxpZ2h0KGZpZWxkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSBsaW1pdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IFRoZSBtYXggYW1vdW50IG9mIGVudHJpZXMgdGhhdCB0aGlzIHF1ZXJ5IHNob3VsZCByZXR1cm4uXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGxpbWl0KGxpbWl0KSB7XG5cdFx0cmV0dXJuIG5ldyBRdWVyeSgpLmxpbWl0KGxpbWl0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc2VhcmNoIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmlsdGVyT3JUZXh0T3JGaWVsZCBJZiBubyBvdGhlciBhcmd1bWVudHNcblx0ICogICBhcmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIGVpdGhlciBhIHtAbGluayBGaWx0ZXJ9XG5cdCAqICAgaW5zdGFuY2Ugb3IgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYSBtYXRjaCBmaWx0ZXIuIEluIGJvdGggY2FzZXNcblx0ICogICB0aGUgZmlsdGVyIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgZmllbGRzLiBBbm90aGVyIG9wdGlvbiBpcyB0b1xuXHQgKiAgIHBhc3MgdGhpcyBhcyBhIGZpZWxkIG5hbWUgaW5zdGVhZCwgdG9nZXRoZXIgd2l0aCBvdGhlciBhcmd1bWVudHNcblx0ICogICBzbyB0aGUgZmlsdGVyIGNhbiBiZSBjcmVhdGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90ZXh0T3JPcGVyYXRvciBFaXRoZXIgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYVxuXHQgKiAgIG1hdGNoIGZpbHRlciwgb3IgdGhlIG9wZXJhdG9yIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyLiBTaG91bGRcblx0ICogICBvbmx5IGJlIHBhc3NlZCBpZiBhbiBvcGVyYXRvciB3YXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHNlYXJjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5zZWFyY2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzb3J0IGVudHJ5IHRvIHRoaXMgcXVlcnksIHNwZWNpZnlpbmcgdGhlIGZpZWxkIHRoaXMgcXVlcnkgc2hvdWxkIGJlXG5cdCAqIHNvcnRlZCBieSBhbmQsIG9wdGlvbmFsbHksIHRoZSBzb3J0IGRpcmVjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgc29ydGVkIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgc29ydCBvcGVyYXRpb24gc2hvdWxkIHVzZS5cblx0ICogICBJZiBub25lIGlzIGdpdmVuLCBcImFzY1wiIGlzIHVzZWQgYnkgZGVmYXVsdC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgc29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbikge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS5zb3J0KGZpZWxkLCBvcHRfZGlyZWN0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSB0eXBlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgcXVlcnkncyB0eXBlLiBGb3IgZXhhbXBsZTogXCJjb3VudFwiLCBcImZldGNoXCIuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHR5cGUodHlwZSkge1xuXHRcdHJldHVybiBuZXcgUXVlcnkoKS50eXBlKHR5cGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYWdncmVnYXRpb24gdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWdncmVnYXRpb24gbmFtZS5cblx0ICogQHBhcmFtIHshQWdncmVnYXRpb258c3RyaW5nfSBhZ2dyZWdhdGlvbk9yRmllbGQgRWl0aGVyIGFuXG5cdCAqICAge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSBvciB0aGUgbmFtZSBvZiB0aGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X29wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcikge1xuXHRcdHZhciBhZ2dyZWdhdGlvbiA9IGFnZ3JlZ2F0aW9uT3JGaWVsZDtcblx0XHRpZiAoIShhZ2dyZWdhdGlvbiBpbnN0YW5jZW9mIEFnZ3JlZ2F0aW9uKSkge1xuXHRcdFx0YWdncmVnYXRpb24gPSBBZ2dyZWdhdGlvbi5maWVsZChhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG5cdFx0fVxuXG5cdFx0dmFyIGZpZWxkID0gYWdncmVnYXRpb24uZ2V0RmllbGQoKTtcblx0XHR2YXIgdmFsdWUgPSB7fTtcblx0XHR2YWx1ZVtmaWVsZF0gPSB7XG5cdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0b3BlcmF0b3I6IGFnZ3JlZ2F0aW9uLmdldE9wZXJhdG9yKClcblx0XHR9O1xuXHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChhZ2dyZWdhdGlvbi5nZXRWYWx1ZSgpKSkge1xuXHRcdFx0dmFsdWVbZmllbGRdLnZhbHVlID0gYWdncmVnYXRpb24uZ2V0VmFsdWUoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuYm9keV8uYWdncmVnYXRpb24pIHtcblx0XHRcdHRoaXMuYm9keV8uYWdncmVnYXRpb24gPSBbXTtcblx0XHR9XG5cdFx0dGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbi5wdXNoKHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiY291bnRcIi5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGNvdW50KCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUoJ2NvdW50Jyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHF1ZXJ5J3MgdHlwZSB0byBcImZldGNoXCIuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRmZXRjaCgpIHtcblx0XHRyZXR1cm4gdGhpcy50eXBlKCdmZXRjaCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gdGhpcyBRdWVyeS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHRsZXQgZmlsdGVyID0gRmlsdGVyLnRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG5cdFx0aWYgKCF0aGlzLmJvZHlfLmZpbHRlcikge1xuXHRcdFx0dGhpcy5ib2R5Xy5maWx0ZXIgPSBbXTtcblx0XHR9XG5cdFx0dGhpcy5ib2R5Xy5maWx0ZXIucHVzaChmaWx0ZXIuYm9keSgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSBvZmZzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbnRyeSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZFxuXHQgKiAgIGJ5IHRoaXMgcXVlcnkuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRvZmZzZXQob2Zmc2V0KSB7XG5cdFx0dGhpcy5ib2R5Xy5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGhpZ2hsaWdodCBlbnRyeSB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0aGlnaGxpZ2h0KGZpZWxkKSB7XG5cdFx0aWYgKCF0aGlzLmJvZHlfLmhpZ2hsaWdodCkge1xuXHRcdFx0dGhpcy5ib2R5Xy5oaWdobGlnaHQgPSBbXTtcblx0XHR9XG5cblx0XHR0aGlzLmJvZHlfLmhpZ2hsaWdodC5wdXNoKGZpZWxkKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWVyeSBsaW1pdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IFRoZSBtYXggYW1vdW50IG9mIGVudHJpZXMgdGhhdCB0aGlzIHF1ZXJ5IHNob3VsZCByZXR1cm4uXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRsaW1pdChsaW1pdCkge1xuXHRcdHRoaXMuYm9keV8ubGltaXQgPSBsaW1pdDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc2VhcmNoIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmlsdGVyT3JUZXh0T3JGaWVsZCBJZiBubyBvdGhlciBhcmd1bWVudHNcblx0ICogICBhcmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIGVpdGhlciBhIHtAbGluayBGaWx0ZXJ9XG5cdCAqICAgaW5zdGFuY2Ugb3IgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYSBtYXRjaCBmaWx0ZXIuIEluIGJvdGggY2FzZXNcblx0ICogICB0aGUgZmlsdGVyIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgZmllbGRzLiBBbm90aGVyIG9wdGlvbiBpcyB0b1xuXHQgKiAgIHBhc3MgdGhpcyBhcyBhIGZpZWxkIG5hbWUgaW5zdGVhZCwgdG9nZXRoZXIgd2l0aCBvdGhlciBhcmd1bWVudHNcblx0ICogICBzbyB0aGUgZmlsdGVyIGNhbiBiZSBjcmVhdGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90ZXh0T3JPcGVyYXRvciBFaXRoZXIgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYVxuXHQgKiAgIG1hdGNoIGZpbHRlciwgb3IgdGhlIG9wZXJhdG9yIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyLiBTaG91bGRcblx0ICogICBvbmx5IGJlIHBhc3NlZCBpZiBhbiBvcGVyYXRvciB3YXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRzZWFyY2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpIHtcblx0XHR2YXIgZmlsdGVyID0gZmlsdGVyT3JUZXh0T3JGaWVsZDtcblxuXHRcdGlmIChvcHRfdmFsdWUpIHtcblx0XHRcdGZpbHRlciA9IEZpbHRlci5maWVsZChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSk7XG5cdFx0fSBlbHNlIGlmIChvcHRfdGV4dE9yT3BlcmF0b3IpIHtcblx0XHRcdGZpbHRlciA9IEZpbHRlci5tYXRjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IpO1xuXHRcdH0gZWxzZSBpZiAoIShmaWx0ZXIgaW5zdGFuY2VvZiBGaWx0ZXIpKSB7XG5cdFx0XHRmaWx0ZXIgPSBGaWx0ZXIubWF0Y2goZmlsdGVyT3JUZXh0T3JGaWVsZCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmJvZHlfLnNlYXJjaCkge1xuXHRcdFx0dGhpcy5ib2R5Xy5zZWFyY2ggPSBbXTtcblx0XHR9XG5cblx0XHRpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwoZmlsdGVyT3JUZXh0T3JGaWVsZCkpIHtcblx0XHRcdHRoaXMuYm9keV8uc2VhcmNoLnB1c2goZmlsdGVyLmJvZHkoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYm9keV8uc2VhcmNoLnB1c2goe30pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzb3J0IGVudHJ5IHRvIHRoaXMgcXVlcnksIHNwZWNpZnlpbmcgdGhlIGZpZWxkIHRoaXMgcXVlcnkgc2hvdWxkIGJlXG5cdCAqIHNvcnRlZCBieSBhbmQsIG9wdGlvbmFsbHksIHRoZSBzb3J0IGRpcmVjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgc29ydGVkIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgc29ydCBvcGVyYXRpb24gc2hvdWxkIHVzZS5cblx0ICogICBJZiBub25lIGlzIGdpdmVuLCBcImFzY1wiIGlzIHVzZWQgYnkgZGVmYXVsdC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcblx0XHRpZiAoIXRoaXMuYm9keV8uc29ydCkge1xuXHRcdFx0dGhpcy5ib2R5Xy5zb3J0ID0gW107XG5cdFx0fVxuXHRcdHZhciBzb3J0RW50cnkgPSB7fTtcblx0XHRzb3J0RW50cnlbZmllbGRdID0gb3B0X2RpcmVjdGlvbiB8fCAnYXNjJztcblx0XHR0aGlzLmJvZHlfLnNvcnQucHVzaChzb3J0RW50cnkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IHR5cGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBxdWVyeSdzIHR5cGUuIEZvciBleGFtcGxlOiBcImNvdW50XCIsIFwiZmV0Y2hcIi5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHR5cGUodHlwZSkge1xuXHRcdHRoaXMuYm9keV8udHlwZSA9IHR5cGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUXVlcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBcGlIZWxwZXIgZnJvbSAnLi4vQXBpSGVscGVyJztcbmltcG9ydCBRdWVyeSBmcm9tICcuLi8uLi9hcGktcXVlcnkvUXVlcnknO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi9hcGktcXVlcnkvRmlsdGVyJztcbmltcG9ydCB7IGFzc2VydERlZkFuZE5vdE51bGwsIGFzc2VydE9iamVjdCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQgfSBmcm9tICcuLi9hc3NlcnRpb25zJztcbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY2Fwc3VsYXRlIGRhdGEgYXBpIGNhbGxzLlxuICovXG5jbGFzcyBEYXRhQXBpSGVscGVyIGV4dGVuZHMgQXBpSGVscGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIERhdGFBcGlIZWxwZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuXHRcdHN1cGVyKHdlZGVwbG95Q2xpZW50KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0uXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEgRmlsdGVyIGluc3RhbmNlIG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHR3aGVyZShmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcblx0XHR0aGlzLmdldE9yQ3JlYXRlRmlsdGVyXygpLmFuZChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgXCJvclwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqICAgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0b3IoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCkuYm9keSgpLmFuZC5sZW5ndGggPT09IDApIHtcblx0XHRcdHRocm93IEVycm9yKCdJdFxcJ3MgcmVxdWlyZWQgdG8gaGF2ZSBhIGNvbmRpdGlvbiBiZWZvcmUgdXNpbmcgYW4gXFwnb3IoKVxcJyBmb3IgdGhlIGZpcnN0IHRpbWUuJyk7XG5cdFx0fVxuXHRcdHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCkub3IoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcIm5vbmVcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwuLi4qKX0gYXJncyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqIHRoZSBcIm5vbmVcIiBvcGVyYXRvci4gQ2FuIGJlIHBhc3NlZCBlaXRoZXIgYXMgYSBzaW5nbGUgYXJyYXkgb3IgYXNcblx0ICogc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0bm9uZShmaWVsZCwgLi4uYXJncykge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5ub25lKGZpZWxkLCBhcmdzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJtYXRjaFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0bWF0Y2goZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLm1hdGNoKGZpZWxkLCB2YWx1ZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwic2ltaWxhclwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRPclF1ZXJ5IElmIG5vIHNlY29uZCBzdHJpbmcgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXNcblx0ICogc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0gez9zdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRzaW1pbGFyKGZpZWxkT3JRdWVyeSwgcXVlcnkpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIuc2ltaWxhcihmaWVsZE9yUXVlcnksIHF1ZXJ5KSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cbiAgICogQHN0YXRpY1xuXHQgKi9cblx0bHQoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLmx0KGZpZWxkLCB2YWx1ZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPD1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuICAgKiBAc3RhdGljXG5cdCAqL1xuXHRsdGUoZmllbGQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLmx0ZShmaWVsZCwgdmFsdWUpKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwiYW55XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyEoQXJyYXl8Li4uKil9IGFyZ3MgQSB2YXJpYWJsZSBhbW91bnQgb2YgdmFsdWVzIHRvIGJlIHVzZWQgd2l0aFxuXHQgKiB0aGUgXCJub25lXCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqIHNlcGFyYXRlIHBhcmFtcy5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGFueShmaWVsZCwgLi4uYXJncykge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5hbnkoZmllbGQsIGFyZ3MpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcImdwXCIgb3BlcmF0b3IuIFRoaXMgaXMgYVxuXHQgKiBzcGVjaWFsIHVzZSBjYXNlIG9mIGBGaWx0ZXIucG9seWdvbmAgZm9yIGJvdW5kaW5nIGJveGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSBib3hPclVwcGVyTGVmdCBFaXRoZXIgYSBgR2VvLkJvdW5kaW5nQm94YCBpbnN0YW5jZSwgb3IgYVxuXHQgKiBib3VuZGluZyBib3gncyB1cHBlciBsZWZ0IGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9sb3dlclJpZ2h0IEEgYm91bmRpbmcgYm94J3MgbG93ZXIgcmlnaHQgY29vcmRpbmF0ZS5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdGJvdW5kaW5nQm94KGZpZWxkLCBib3hPclVwcGVyTGVmdCwgb3B0X2xvd2VyUmlnaHQpIHtcblx0XHRyZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIuYm91bmRpbmdCb3goZmllbGQsIGJveE9yVXBwZXJMZWZ0LCBvcHRfbG93ZXJSaWdodCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwiZ2RcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb25PckNpcmNsZSBFaXRoZXIgYSBgR2VvLkNpcmNsZWAgaW5zdGFuY2Ugb3IgYVxuXHQgKiBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfHN0cmluZz19IG9wdF9yYW5nZU9yRGlzdGFuY2UgRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvclxuXHQgKiB0aGUgZGlzdGFuY2UgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuXHRkaXN0YW5jZShmaWVsZCwgbG9jYXRpb25PckNpcmNsZSwgb3B0X3JhbmdlT3JEaXN0YW5jZSkge1xuXHRcdHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5kaXN0YW5jZShmaWVsZCwgbG9jYXRpb25PckNpcmNsZSwgb3B0X3JhbmdlT3JEaXN0YW5jZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwicmFuZ2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gcmFuZ2VPck1pbiBFaXRoZXIgYSBgUmFuZ2VgIGluc3RhbmNlIG9yIGEgdGhlIHJhbmdlJ3MgbWluXG5cdCAqIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfbWF4IFRoZSByYW5nZSdzIG1heCB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQGNoYWlubmFibGVcblx0ICovXG5cdHJhbmdlKGZpZWxkLCByYW5nZU9yTWluLCBvcHRfbWF4KSB7XG5cdFx0cmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLnJhbmdlKGZpZWxkLCByYW5nZU9yTWluLCBvcHRfbWF4KSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbGltaXQgZm9yIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgbWF4IGFtb3VudCBvZiBlbnRyaWVzIHRoYXQgdGhpcyByZXF1ZXN0IHNob3VsZCByZXR1cm4uXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGxpbWl0KGxpbWl0KSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLmxpbWl0KGxpbWl0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBvZmZzZXQgZm9yIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbnRyeSB0aGF0IHNob3VsZCBiZVxuXHQgKiByZXR1cm5lZCBieSB0aGlzIHF1ZXJ5LlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRvZmZzZXQob2Zmc2V0KSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLm9mZnNldChvZmZzZXQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBoaWdobGlnaHQgZW50cnkgdG8gdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGhpZ2hsaWdodChmaWVsZCkge1xuXHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5oaWdobGlnaHQoZmllbGQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYWdncmVnYXRpb24gdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWdncmVnYXRpb24gbmFtZS5cblx0ICogQHBhcmFtIHshQWdncmVnYXRpb258c3RyaW5nfSBhZ2dyZWdhdGlvbk9yRmllbGQgRWl0aGVyIGFuIHtAbGlua1xuXHQgKiBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugb3IgdGhlIG5hbWUgb2YgdGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9vcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcikge1xuXHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5hZ2dyZWdhdGUobmFtZSwgYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyByZXF1ZXN0J3MgcXVlcnkgdHlwZSB0byAnY291bnQnLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0Y291bnQoKSB7XG5cdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLnR5cGUoJ2NvdW50Jyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNvcnQgcXVlcnkgdG8gdGhpcyByZXF1ZXN0J3MgYm9keS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgc29ydGVkIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgc29ydCBvcGVyYXRpb24gc2hvdWxkXG5cdCAqIHVzZS4gSWYgbm9uZSBpcyBnaXZlbiwgJ2FzYycgaXMgdXNlZCBieSBkZWZhdWx0LlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cblx0b3JkZXJCeShmaWVsZCwgb3B0X2RpcmVjdGlvbikge1xuXHRcdHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5zb3J0KGZpZWxkLCBvcHRfZGlyZWN0aW9uKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgYW5kIHNhdmVzIGl0IHRvIFdlRGVwbG95IGRhdGEuIElmXG5cdCAqIHRoZXJlJ3MgYSB2YWxpZGF0aW9uIHJlZ2lzdGVyZWQgaW4gdGhlIGNvbGxlY3Rpb24gYW5kIHRoZSByZXF1ZXN0IGlzXG5cdCAqIHN1Y2Nlc3NmdWwsIHRoZSByZXN1bHRpbmcgb2JqZWN0IChvciBhcnJheSBvZiBvYmplY3RzKSBpcyByZXR1cm5lZC4gVGhlXG5cdCAqIGRhdGEgcGFyYW1ldGVyIGNhbiBiZSBlaXRoZXIgYW4gT2JqZWN0IG9yIGFuIEFycmF5IG9mIE9iamVjdHMuXG5cdCAqIFRoZXNlIE9iamVjdHMgZGVzY3JpYmUgdGhlIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdHMgdGhhdCBhcmUgdG8gYmUgY3JlYXRlZC5cblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiB2YXIgZGF0YSA9IFdlRGVwbG95LmRhdGEoJ2h0dHA6Ly9kZW1vZGF0YS53ZWRlcGxveS5pbycpO1xuXHQgKlxuXHQgKiBkYXRhLmNyZWF0ZSgnbW92aWVzJywgeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIEkg4oCTIFRoZSBQaGFudG9tIE1lbmFjZSd9KVxuXHQgKiBcdFx0IC50aGVuKGZ1bmN0aW9uKG1vdmllKXtcblx0ICogXHRcdFx0IGNvbnNvbGUubG9nKG1vdmllKVxuXHQgKiAgICAgfSk7XG5cdCAqXG5cdCAqIGRhdGEuY3JlYXRlKCdtb3ZpZXMnLCBbeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIElJIOKAkyBBdHRhY2sgb2YgdGhlIENsb25lcyd9LFxuXHQgKiBcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSUlJIOKAkyBSZXZlbmdlIG9mIHRoZSBTaXRoJ30pXG5cdCAqIFx0XHQgLnRoZW4oZnVuY3Rpb24obW92aWVzKXtcblx0ICogXHRcdFx0IGNvbnNvbGUubG9nKG1vdmllcylcblx0ICogICAgIH0pO1xuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb24gQ29sbGVjdGlvbiAoa2V5KSB1c2VkIHRvIGNyZWF0ZSB0aGUgbmV3IGRhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCB0aGF0IGlzIHRvIGJlIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRjcmVhdGUoY29sbGVjdGlvbiwgZGF0YSkge1xuXHRcdGFzc2VydERlZkFuZE5vdE51bGwoY29sbGVjdGlvbiwgJ0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkLicpO1xuXHRcdGFzc2VydE9iamVjdChkYXRhLCAnRGF0YSBjYW5cXCd0IGJlIGVtcHR5LicpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKVxuXHRcdFx0LnBhdGgoY29sbGVjdGlvbilcblx0XHRcdC5wb3N0KGRhdGEpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgYXR0cmlidXRlcyBvZiBhIGRvY3VtZW50IGZvcm0gdGhlIHBhc3NlZC1pbiBvYmplY3QgYW5kIHNhdmVzXG5cdCAqIHRoZSByZWNvcmQuIElmIHRoZSBvYmplY3QgaXMgaW52YWxpZCwgdGhlIHNhdmluZyB3aWxsIGZhaWwgYW5kIGFuIGVycm9yXG5cdCAqIG9iamVjdCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKlxuXHQgKiBgYGBqYXZhc2NyaXB0XG5cdCAqIHZhciBkYXRhID0gV2VEZXBsb3kuZGF0YSgnaHR0cDovL2RlbW9kYXRhLndlZGVwbG95LmlvJyk7XG5cdCAqXG5cdCAqIGRhdGEudXBkYXRlKCdtb3ZpZXMvMTAxOTExMjM1MycsIHsndGl0bGUnPT4gJ1N0YXIgV2FyczogRXBpc29kZSBJJ30pXG5cdCAqIFx0XHQgLnRoZW4oZnVuY3Rpb24obW92aWUpe1xuXHQgKiBcdFx0XHQgY29uc29sZS5sb2cobW92aWUpXG5cdCAqICAgICB9KTtcblx0ICogYGBgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudCBLZXkgdXNlZCB0byB1cGRhdGUgdGhlIGRvY3VtZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QgdGhhdCBpcyB0byBiZSB1cGRhdGVkLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0dXBkYXRlKGRvY3VtZW50LCBkYXRhKSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChkb2N1bWVudCwgJ0RvY3VtZW50IGtleSBtdXN0IGJlIHNwZWNpZmllZC4nKTtcblx0XHRhc3NlcnRPYmplY3QoZGF0YSwgJ0RhdGEgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LmF1dGgodGhpcy5oZWxwZXJBdXRoU2NvcGUpXG5cdFx0XHQucGF0aChkb2N1bWVudClcblx0XHRcdC5wdXQoZGF0YSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBhIFtkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uXS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgdXNlZCB0byBkZWxldGUgdGhlXG5cdCAqIGRvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb24uXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRkZWxldGUoa2V5KSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChrZXksICdEb2N1bWVudC9GaWVsZC9Db2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG5cdFx0cmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcblx0XHRcdC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5kYXRhVXJsXylcblx0XHRcdC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKVxuXHRcdFx0LnBhdGgoa2V5KVxuXHRcdFx0LmRlbGV0ZSgpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlIGRhdGEgZnJvbSBhIFtkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uXS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgdXNlZCB0byBkZWxldGUgdGhlIGRvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb24uXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChrZXksICdEb2N1bWVudC9GaWVsZC9Db2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG5cdFx0dGhpcy5hZGRGaWx0ZXJzVG9RdWVyeV8oKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuZGF0YVVybF8pXG5cdFx0XHQuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSlcblx0XHRcdC5wYXRoKGtleSlcblx0XHRcdC5nZXQodGhpcy5xdWVyeV8pXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlIGRhdGEgZnJvbSBhIFtkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uXSBhbmQgcHV0IGl0IGluIGEgc2VhcmNoXG5cdCAqIGZvcm1hdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgdXNlZCB0byBkZWxldGUgdGhlIGRvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb24uXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRzZWFyY2goa2V5KSB7XG5cdFx0YXNzZXJ0RGVmQW5kTm90TnVsbChrZXksICdEb2N1bWVudC9GaWVsZC9Db2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG5cdFx0dGhpcy5vblNlYXJjaF8oKTtcblxuXHRcdHRoaXMuYWRkRmlsdGVyc1RvUXVlcnlfKCk7XG5cblx0XHRyZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuXHRcdFx0LnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuXHRcdFx0LmF1dGgodGhpcy5oZWxwZXJBdXRoU2NvcGUpXG5cdFx0XHQucGF0aChrZXkpXG5cdFx0XHQuZ2V0KHRoaXMucXVlcnlfKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIG5ldyBzb2NrZXQuaW8gaW5zdGFuY2UuIE1vbml0b3IgdGhlIGFycml2YWwgb2YgbmV3IGJyb2FkY2FzdGVkXG5cdCAqIGRhdGEuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gY29sbGVjdGlvbiBrZXkvY29sbGVjdGlvbiB1c2VkIHRvIGZpbmQgb3JnYW5pemVkIGRhdGEuXG5cdCAqIEBwYXJhbSAge09iamVjdD19IG9wdF9vcHRpb25zIE9iamVjdCB3aXRoIFNvY2tldCBJTyBvcHRpb25zLlxuXHQgKiBAcmV0dXJuIHshaW99IFNvY2tldCBJTyByZWZlcmVuY2UuIFNlcnZlciBldmVudHMgY2FuIGJlIGxpc3RlbmVkIG9uIGl0LlxuXHQgKi9cblx0d2F0Y2goY29sbGVjdGlvbiwgb3B0X29wdGlvbnMpIHtcblx0XHRhc3NlcnREZWZBbmROb3ROdWxsKGNvbGxlY3Rpb24sICdDb2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG5cdFx0dGhpcy5hZGRGaWx0ZXJzVG9RdWVyeV8oKTtcblxuXHRcdHJldHVybiB0aGlzLndlZGVwbG95Q2xpZW50XG5cdFx0XHQudXJsKHRoaXMud2VkZXBsb3lDbGllbnQuZGF0YVVybF8pXG5cdFx0XHQuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSlcblx0XHRcdC5wYXRoKGNvbGxlY3Rpb24pXG5cdFx0XHQud2F0Y2godGhpcy5xdWVyeV8sIG9wdF9vcHRpb25zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bCB1c2VkIG1haW4ge0BsaW5rIEZpbHRlcn0gb2JqZWN0LiBJZiBub25lIGV4aXN0cyB5ZXQsIGFcblx0ICogbmV3IG9uZSBpcyBjcmVhdGVkLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGdldE9yQ3JlYXRlRmlsdGVyXygpIHtcblx0XHRpZiAoIXRoaXMuZmlsdGVyXykge1xuXHRcdFx0dGhpcy5maWx0ZXJfID0gbmV3IEZpbHRlcigpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXJfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnRseSB1c2VkIHtAbGluayBRdWVyeX0gb2JqZWN0LiBJZiBub25lIGV4aXN0cyB5ZXQsXG5cdCAqIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGdldE9yQ3JlYXRlUXVlcnlfKCkge1xuXHRcdGlmICghdGhpcy5xdWVyeV8pIHtcblx0XHRcdHRoaXMucXVlcnlfID0gbmV3IFF1ZXJ5KCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnF1ZXJ5Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBMb2FkIHRoZSBjdXJyZW50bHkgdXNlZCBtYWluIHtAbGluayBGaWx0ZXJ9IG9iamVjdCBpbnRvIHRoZSBjdXJyZW50bHlcblx0ICogdXNlZCB7QGxpbmsgUXVlcnl9LlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGFkZEZpbHRlcnNUb1F1ZXJ5XygpIHtcblx0XHRpZiAoY29yZS5pc0RlZih0aGlzLmZpbHRlcl8pICYmIHRoaXMudG9TZWFyY2hfICE9PSB0cnVlKSB7XG5cdFx0XHR0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuZmlsdGVyKHRoaXMuZmlsdGVyXyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzZWFyY2ggdG8gdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRvblNlYXJjaF8oKSB7XG5cdFx0aWYgKGNvcmUuaXNEZWYodGhpcy5maWx0ZXJfKSkge1xuXHRcdFx0dGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLnNlYXJjaCh0aGlzLmdldE9yQ3JlYXRlRmlsdGVyXygpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0l0XFwncyByZXF1aXJlZCB0byBoYXZlIGEgY29uZGl0aW9uIGJlZm9yZSB1c2luZyBhbiBcXCdzZWFyY2goKVxcJyBmb3IgdGhlIGZpcnN0IHRpbWUuJyk7XG5cdFx0fVxuXHRcdHRoaXMudG9TZWFyY2hfID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFBcGlIZWxwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQWJzdHJhY3Rpb24gbGF5ZXIgZm9yIHN0cmluZyB0byBiYXNlNjQgY29udmVyc2lvblxuICogcmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzM0NjJcbiAqL1xuY2xhc3MgQmFzZTY0IHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBiYXNlLTY0IGVuY29kZWQgQVNDSUkgc3RyaW5nIGZyb20gYSBcInN0cmluZ1wiIG9mIGJpbmFyeSBkYXRhLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGJlIGVuY29kZWQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGVuY29kZVN0cmluZyhzdHJpbmcpIHtcblx0XHRpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBidG9hKHN0cmluZyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBCdWZmZXIoc3RyaW5nLnRvU3RyaW5nKCksICdiaW5hcnknKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlNjQ7XG4iLCIvKiFcbiAqIFByb21pc2VzIHBvbHlmaWxsIGZyb20gR29vZ2xlJ3MgQ2xvc3VyZSBMaWJyYXJ5LlxuICpcbiAqICAgICAgQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVEUoZWR1YXJkbyk6IFByb21pc2Ugc3VwcG9ydCBpcyBub3QgcmVhZHkgb24gYWxsIHN1cHBvcnRlZCBicm93c2VycyxcbiAqIHRoZXJlZm9yZSBtZXRhbC1wcm9taXNlIGlzIHRlbXBvcmFyaWx5IHVzaW5nIEdvb2dsZSdzIHByb21pc2VzIGFzIHBvbHlmaWxsLlxuICogSXQgc3VwcG9ydHMgY2FuY2VsbGFibGUgcHJvbWlzZXMgYW5kIGhhcyBjbGVhbiBhbmQgZmFzdCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGlzRGVmLCBpc0Z1bmN0aW9uLCBpc09iamVjdCB9IGZyb20gJ21ldGFsJztcbmltcG9ydCB7IGFzeW5jIH0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgbW9yZSBzdHJpY3QgaW50ZXJmYWNlIGZvciBUaGVuYWJsZXMgaW4gdGVybXMgb2ZcbiAqIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbSBmb3IgaW50ZXJvcCB3aXRoIHtAc2VlIENhbmNlbGxhYmxlUHJvbWlzZX0uXG4gKlxuICogQGludGVyZmFjZVxuICogQGV4dGVuZHMge0lUaGVuYWJsZS48VFlQRT59XG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG52YXIgVGhlbmFibGUgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIEFkZHMgY2FsbGJhY2tzIHRoYXQgd2lsbCBvcGVyYXRlIG9uIHRoZSByZXN1bHQgb2YgdGhlIFRoZW5hYmxlLCByZXR1cm5pbmcgYVxuICogbmV3IGNoaWxkIFByb21pc2UuXG4gKlxuICogSWYgdGhlIFRoZW5hYmxlIGlzIGZ1bGZpbGxlZCwgdGhlIHtAY29kZSBvbkZ1bGZpbGxlZH0gY2FsbGJhY2sgd2lsbCBiZVxuICogaW52b2tlZCB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGxcbiAqIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrLiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzXG4gKiBhbiBleGNlcHRpb24sIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlXG4gKiBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSBUaGVuYWJsZSBpcyByZWplY3RlZCwgdGhlIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWRcbiAqIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gYXMgYXJndW1lbnQsIGFuZCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkXG4gKiB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrIG9yIHRocm93biB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gez8oZnVuY3Rpb24odGhpczpUSElTLCBUWVBFKTpcbiAqICAgICAgICAgICAgIChSRVNVTFR8SVRoZW5hYmxlLjxSRVNVTFQ+fFRoZW5hYmxlKSk9fSBvcHRfb25GdWxmaWxsZWQgQVxuICogICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlmIHRoZSBQcm9taXNlXG4gKiAgICAgaXMgZnVsbGZpbGxlZC5cbiAqIEBwYXJhbSB7PyhmdW5jdGlvbigqKTogKik9fSBvcHRfb25SZWplY3RlZCBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkXG4gKiAgICAgd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBpZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZC5cbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IEFuIG9wdGlvbmFsIGNvbnRleHQgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGVcbiAqICAgICBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrcy4gQnkgZGVmYXVsdCwgZnVuY3Rpb25zIGFyZSBleGVjdXRlZFxuICogICAgIHdpdGggdGhlIGRlZmF1bHQgdGhpcy5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFJFU1VMVD59IEEgbmV3IFByb21pc2UgdGhhdCB3aWxsIHJlY2VpdmUgdGhlXG4gKiAgICAgcmVzdWx0IG9mIHRoZSBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gY2FsbGJhY2suXG4gKiBAdGVtcGxhdGUgUkVTVUxULFRISVNcbiAqL1xuVGhlbmFibGUucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8qKlxuICogQW4gZXhwYW5kbyBwcm9wZXJ0eSB0byBpbmRpY2F0ZSB0aGF0IGFuIG9iamVjdCBpbXBsZW1lbnRzXG4gKiB7QGNvZGUgVGhlbmFibGV9LlxuICpcbiAqIHtAc2VlIGFkZEltcGxlbWVudGF0aW9ufS5cbiAqXG4gKiBAY29uc3RcbiAqL1xuVGhlbmFibGUuSU1QTEVNRU5URURfQllfUFJPUCA9ICckZ29vZ19UaGVuYWJsZSc7XG5cblxuLyoqXG4gKiBNYXJrcyBhIGdpdmVuIGNsYXNzIChjb25zdHJ1Y3RvcikgYXMgYW4gaW1wbGVtZW50YXRpb24gb2YgVGhlbmFibGUsIHNvXG4gKiB0aGF0IHdlIGNhbiBxdWVyeSB0aGF0IGZhY3QgYXQgcnVudGltZS4gVGhlIGNsYXNzIG11c3QgaGF2ZSBhbHJlYWR5XG4gKiBpbXBsZW1lbnRlZCB0aGUgaW50ZXJmYWNlLlxuICogRXhwb3J0cyBhICd0aGVuJyBtZXRob2Qgb24gdGhlIGNvbnN0cnVjdG9yIHByb3RvdHlwZSwgc28gdGhhdCB0aGUgb2JqZWN0c1xuICogYWxzbyBpbXBsZW1lbnQgdGhlIGV4dGVybiB7QHNlZSBUaGVuYWJsZX0gaW50ZXJmYWNlIGZvciBpbnRlcm9wIHdpdGhcbiAqIG90aGVyIFByb21pc2UgaW1wbGVtZW50YXRpb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6VGhlbmFibGUsLi4uWz9dKX0gY3RvciBUaGUgY2xhc3MgY29uc3RydWN0b3IuIFRoZVxuICogICAgIGNvcnJlc3BvbmRpbmcgY2xhc3MgbXVzdCBoYXZlIGFscmVhZHkgaW1wbGVtZW50ZWQgdGhlIGludGVyZmFjZS5cbiAqL1xuVGhlbmFibGUuYWRkSW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbihjdG9yKSB7XG4gIGN0b3IucHJvdG90eXBlLnRoZW4gPSBjdG9yLnByb3RvdHlwZS50aGVuO1xuICBjdG9yLnByb3RvdHlwZS4kZ29vZ19UaGVuYWJsZSA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBnaXZlbiBpbnN0YW5jZSBpbXBsZW1lbnRzIHtAY29kZSBUaGVuYWJsZX0uXG4gKiAgICAgVGhlIGNsYXNzL3N1cGVyY2xhc3Mgb2YgdGhlIGluc3RhbmNlIG11c3QgY2FsbCB7QGNvZGUgYWRkSW1wbGVtZW50YXRpb259LlxuICovXG5UaGVuYWJsZS5pc0ltcGxlbWVudGVkQnkgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gISFvYmplY3QuJGdvb2dfVGhlbmFibGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBQcm9wZXJ0eSBhY2Nlc3Mgc2VlbXMgdG8gYmUgZm9yYmlkZGVuLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIExpa2UgYmluZCgpLCBleGNlcHQgdGhhdCBhICd0aGlzIG9iamVjdCcgaXMgbm90IHJlcXVpcmVkLiBVc2VmdWwgd2hlbiB0aGVcbiAqIHRhcmdldCBmdW5jdGlvbiBpcyBhbHJlYWR5IGJvdW5kLlxuICpcbiAqIFVzYWdlOlxuICogdmFyIGcgPSBwYXJ0aWFsKGYsIGFyZzEsIGFyZzIpO1xuICogZyhhcmczLCBhcmc0KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBhcmUgcGFydGlhbGx5IGFwcGxpZWQgdG8gZm4uXG4gKiBAcmV0dXJuIHshRnVuY3Rpb259IEEgcGFydGlhbGx5LWFwcGxpZWQgZm9ybSBvZiB0aGUgZnVuY3Rpb24gYmluZCgpIHdhc1xuICogICAgIGludm9rZWQgYXMgYSBtZXRob2Qgb2YuXG4gKi9cbnZhciBwYXJ0aWFsID0gZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5ICh3aXRoIHNsaWNlKCkpIGFuZCBhcHBlbmQgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAvLyB0byB0aGUgZXhpc3RpbmcgYXJndW1lbnRzLlxuICAgIHZhciBuZXdBcmdzID0gYXJncy5zbGljZSgpO1xuICAgIG5ld0FyZ3MucHVzaC5hcHBseShuZXdBcmdzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUHJvbWlzZXMgcHJvdmlkZSBhIHJlc3VsdCB0aGF0IG1heSBiZSByZXNvbHZlZCBhc3luY2hyb25vdXNseS4gQSBQcm9taXNlIG1heVxuICogYmUgcmVzb2x2ZWQgYnkgYmVpbmcgZnVsZmlsbGVkIG9yIHJlamVjdGVkIHdpdGggYSB2YWx1ZSwgd2hpY2ggd2lsbCBiZSBrbm93blxuICogYXMgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIG9yIHRoZSByZWplY3Rpb24gcmVhc29uLiBXaGV0aGVyIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQsIHRoZSBQcm9taXNlIHJlc3VsdCBpcyBpbW11dGFibGUgb25jZSBpdCBpcyBzZXQuXG4gKlxuICogUHJvbWlzZXMgbWF5IHJlcHJlc2VudCByZXN1bHRzIG9mIGFueSB0eXBlLCBpbmNsdWRpbmcgdW5kZWZpbmVkLiBSZWplY3Rpb25cbiAqIHJlYXNvbnMgYXJlIHR5cGljYWxseSBFcnJvcnMsIGJ1dCBtYXkgYWxzbyBiZSBvZiBhbnkgdHlwZS4gQ2xvc3VyZSBQcm9taXNlc1xuICogYWxsb3cgZm9yIG9wdGlvbmFsIHR5cGUgYW5ub3RhdGlvbnMgdGhhdCBlbmZvcmNlIHRoYXQgZnVsZmlsbG1lbnQgdmFsdWVzIGFyZVxuICogb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGVzIGF0IGNvbXBpbGUgdGltZS5cbiAqXG4gKiBUaGUgcmVzdWx0IG9mIGEgUHJvbWlzZSBpcyBhY2Nlc3NpYmxlIGJ5IGNhbGxpbmcge0Bjb2RlIHRoZW59IGFuZCByZWdpc3RlcmluZ1xuICoge0Bjb2RlIG9uRnVsZmlsbGVkfSBhbmQge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcy4gT25jZSB0aGUgUHJvbWlzZVxuICogcmVzb2x2ZXMsIHRoZSByZWxldmFudCBjYWxsYmFja3MgYXJlIGludm9rZWQgd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgb3JcbiAqIHJlamVjdGlvbiByZWFzb24gYXMgYXJndW1lbnQuIENhbGxiYWNrcyBhcmUgYWx3YXlzIGludm9rZWQgaW4gdGhlIG9yZGVyIHRoZXlcbiAqIHdlcmUgcmVnaXN0ZXJlZCwgZXZlbiB3aGVuIGFkZGl0aW9uYWwge0Bjb2RlIHRoZW59IGNhbGxzIGFyZSBtYWRlIGZyb20gaW5zaWRlXG4gKiBhbm90aGVyIGNhbGxiYWNrLiBBIGNhbGxiYWNrIGlzIGFsd2F5cyBydW4gYXN5bmNocm9ub3VzbHkgc29tZXRpbWUgYWZ0ZXIgdGhlXG4gKiBzY29wZSBjb250YWluaW5nIHRoZSByZWdpc3RlcmluZyB7QGNvZGUgdGhlbn0gaW52b2NhdGlvbiBoYXMgcmV0dXJuZWQuXG4gKlxuICogSWYgYSBQcm9taXNlIGlzIHJlc29sdmVkIHdpdGggYW5vdGhlciBQcm9taXNlLCB0aGUgZmlyc3QgUHJvbWlzZSB3aWxsIGJsb2NrXG4gKiB1bnRpbCB0aGUgc2Vjb25kIGlzIHJlc29sdmVkLCBhbmQgdGhlbiBhc3N1bWVzIHRoZSBzYW1lIHJlc3VsdCBhcyB0aGUgc2Vjb25kXG4gKiBQcm9taXNlLiBUaGlzIGFsbG93cyBQcm9taXNlcyB0byBkZXBlbmQgb24gdGhlIHJlc3VsdHMgb2Ygb3RoZXIgUHJvbWlzZXMsXG4gKiBsaW5raW5nIHRvZ2V0aGVyIG11bHRpcGxlIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBQcm9taXNlcy9BKyBzcGVjaWZpY2F0aW9uIGFuZFxuICogcGFzc2VzIHRoYXQgc3BlY2lmaWNhdGlvbidzIGNvbmZvcm1hbmNlIHRlc3Qgc3VpdGUuIEEgQ2xvc3VyZSBQcm9taXNlIG1heSBiZVxuICogcmVzb2x2ZWQgd2l0aCBhIFByb21pc2UgaW5zdGFuY2UgKG9yIHN1ZmZpY2llbnRseSBjb21wYXRpYmxlIFByb21pc2UtbGlrZVxuICogb2JqZWN0KSBjcmVhdGVkIGJ5IG90aGVyIFByb21pc2UgaW1wbGVtZW50YXRpb25zLiBGcm9tIHRoZSBzcGVjaWZpY2F0aW9uLFxuICogUHJvbWlzZS1saWtlIG9iamVjdHMgYXJlIGtub3duIGFzIFwiVGhlbmFibGVzXCIuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihcbiAqICAgICAgICAgICAgIHRoaXM6UkVTT0xWRVJfQ09OVEVYVCxcbiAqICAgICAgICAgICAgIGZ1bmN0aW9uKChUWVBFfElUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpKSxcbiAqICAgICAgICAgICAgIGZ1bmN0aW9uKCopKTogdm9pZH0gcmVzb2x2ZXJcbiAqICAgICBJbml0aWFsaXphdGlvbiBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWQgaW1tZWRpYXRlbHkgd2l0aCB7QGNvZGUgcmVzb2x2ZX1cbiAqICAgICBhbmQge0Bjb2RlIHJlamVjdH0gZnVuY3Rpb25zIGFzIGFyZ3VtZW50cy4gVGhlIFByb21pc2UgaXMgcmVzb2x2ZWQgb3JcbiAqICAgICByZWplY3RlZCB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gZWl0aGVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtSRVNPTFZFUl9DT05URVhUPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBmb3IgZXhlY3V0aW5nIHRoZVxuICogICAgIHJlc29sdmVyIGZ1bmN0aW9uLiBJZiB1bnNwZWNpZmllZCwgdGhlIHJlc29sdmVyIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZGVmYXVsdCBzY29wZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICogQGZpbmFsXG4gKiBAaW1wbGVtZW50cyB7VGhlbmFibGUuPFRZUEU+fVxuICogQHRlbXBsYXRlIFRZUEUsUkVTT0xWRVJfQ09OVEVYVFxuICovXG52YXIgQ2FuY2VsbGFibGVQcm9taXNlID0gZnVuY3Rpb24ocmVzb2x2ZXIsIG9wdF9jb250ZXh0KSB7XG4gIC8qKlxuICAgKiBUaGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhpcyBQcm9taXNlLiBFaXRoZXIgUEVORElORywgRlVMRklMTEVELCBSRUpFQ1RFRCwgb3JcbiAgICogQkxPQ0tFRC5cbiAgICogQHByaXZhdGUge0NhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV99XG4gICAqL1xuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcblxuICAvKipcbiAgICogVGhlIHJlc29sdmVkIHJlc3VsdCBvZiB0aGUgUHJvbWlzZS4gSW1tdXRhYmxlIG9uY2Ugc2V0IHdpdGggZWl0aGVyIGFcbiAgICogZnVsZmlsbG1lbnQgdmFsdWUgb3IgcmVqZWN0aW9uIHJlYXNvbi5cbiAgICogQHByaXZhdGUgeyp9XG4gICAqL1xuICB0aGlzLnJlc3VsdF8gPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEZvciBQcm9taXNlcyBjcmVhdGVkIGJ5IGNhbGxpbmcge0Bjb2RlIHRoZW4oKX0sIHRoZSBvcmlnaW5hdGluZyBwYXJlbnQuXG4gICAqIEBwcml2YXRlIHtDYW5jZWxsYWJsZVByb21pc2V9XG4gICAqL1xuICB0aGlzLnBhcmVudF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIGFkZGVkIHRvXG4gICAqIHRoaXMgUHJvbWlzZSBieSBjYWxscyB0byB7QGNvZGUgdGhlbigpfS5cbiAgICogQHByaXZhdGUge0FycmF5LjxDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV8+fVxuICAgKi9cbiAgdGhpcy5jYWxsYmFja0VudHJpZXNfID0gbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgUHJvbWlzZSBpcyBpbiB0aGUgcXVldWUgb2YgUHJvbWlzZXMgdG8gZXhlY3V0ZS5cbiAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmV4ZWN1dGluZ18gPSBmYWxzZTtcblxuICBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPiAwKSB7XG4gICAgLyoqXG4gICAgICogQSB0aW1lb3V0IElEIHVzZWQgd2hlbiB0aGUge0Bjb2RlIFVOSEFORExFRF9SRUpFQ1RJT05fREVMQVl9IGlzIGdyZWF0ZXJcbiAgICAgKiB0aGFuIDAgbWlsbGlzZWNvbmRzLiBUaGUgSUQgaXMgc2V0IHdoZW4gdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGFuZFxuICAgICAqIGNsZWFyZWQgb25seSBpZiBhbiB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgaXMgaW52b2tlZCBmb3IgdGhlXG4gICAgICogUHJvbWlzZSAob3Igb25lIG9mIGl0cyBkZXNjZW5kYW50cykgYmVmb3JlIHRoZSBkZWxheSBpcyBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSByZWplY3Rpb24gaXMgbm90IGhhbmRsZWQgYmVmb3JlIHRoZSB0aW1lb3V0IGNvbXBsZXRlcywgdGhlXG4gICAgICogcmVqZWN0aW9uIHJlYXNvbiBpcyBwYXNzZWQgdG8gdGhlIHVuaGFuZGxlZCByZWplY3Rpb24gaGFuZGxlci5cbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudW5oYW5kbGVkUmVqZWN0aW9uSWRfID0gMDtcbiAgfSBlbHNlIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA9PT0gMCkge1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHtAY29kZSBVTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZfSBpcyBzZXQgdG8gMCBtaWxsaXNlY29uZHMsIGFcbiAgICAgKiBib29sZWFuIHRoYXQgaXMgc2V0IGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBhbmQgcmVzZXQgdG8gZmFsc2UgaWYgYW5cbiAgICAgKiB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgaXMgaW52b2tlZCBmb3IgdGhlIFByb21pc2UgKG9yIG9uZSBvZiBpdHNcbiAgICAgKiBkZXNjZW5kYW50cykuIElmIHRoZSByZWplY3Rpb24gaXMgbm90IGhhbmRsZWQgYmVmb3JlIHRoZSBuZXh0IHRpbWVzdGVwLFxuICAgICAqIHRoZSByZWplY3Rpb24gcmVhc29uIGlzIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmVzb2x2ZXIuY2FsbChcbiAgICAgIG9wdF9jb250ZXh0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVELCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgc2VsZi5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCByZWFzb24pO1xuICAgICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIGUpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIGEgcmVqZWN0ZWQgUHJvbWlzZSdzIHJlYXNvbiBpcyBwYXNzZWQgdG9cbiAqIHRoZSByZWplY3Rpb24gaGFuZGxlci4gQnkgZGVmYXVsdCwgdGhlIHJlamVjdGlvbiBoYW5kbGVyIHJldGhyb3dzIHRoZVxuICogcmVqZWN0aW9uIHJlYXNvbiBzbyB0aGF0IGl0IGFwcGVhcnMgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIG9yXG4gKiB7QGNvZGUgd2luZG93Lm9uZXJyb3J9IGhhbmRsZXIuXG4gKiBSZWplY3Rpb25zIGFyZSByZXRocm93biBhcyBxdWlja2x5IGFzIHBvc3NpYmxlIGJ5IGRlZmF1bHQuIEEgbmVnYXRpdmUgdmFsdWVcbiAqIGRpc2FibGVzIHJlamVjdGlvbiBoYW5kbGluZyBlbnRpcmVseS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID0gMDtcblxuXG4vKipcbiAqIFRoZSBwb3NzaWJsZSBpbnRlcm5hbCBzdGF0ZXMgZm9yIGEgUHJvbWlzZS4gVGhlc2Ugc3RhdGVzIGFyZSBub3QgZGlyZWN0bHlcbiAqIG9ic2VydmFibGUgdG8gZXh0ZXJuYWwgY2FsbGVycy5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfID0ge1xuICAvKiogVGhlIFByb21pc2UgaXMgd2FpdGluZyBmb3IgcmVzb2x1dGlvbi4gKi9cbiAgUEVORElORzogMCxcblxuICAvKiogVGhlIFByb21pc2UgaXMgYmxvY2tlZCB3YWl0aW5nIGZvciB0aGUgcmVzdWx0IG9mIGFub3RoZXIgVGhlbmFibGUuICovXG4gIEJMT0NLRUQ6IDEsXG5cbiAgLyoqIFRoZSBQcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggYSBmdWxmaWxsbWVudCB2YWx1ZS4gKi9cbiAgRlVMRklMTEVEOiAyLFxuXG4gIC8qKiBUaGUgUHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZCB3aXRoIGEgcmVqZWN0aW9uIHJlYXNvbi4gKi9cbiAgUkVKRUNURUQ6IDNcbn07XG5cblxuLyoqXG4gKiBUeXBlZGVmIGZvciBlbnRyaWVzIGluIHRoZSBjYWxsYmFjayBjaGFpbi4gRWFjaCBjYWxsIHRvIHtAY29kZSB0aGVufSxcbiAqIHtAY29kZSB0aGVuQ2F0Y2h9LCBvciB7QGNvZGUgdGhlbkFsd2F5c30gY3JlYXRlcyBhbiBlbnRyeSBjb250YWluaW5nIHRoZVxuICogZnVuY3Rpb25zIHRoYXQgbWF5IGJlIGludm9rZWQgb25jZSB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZC5cbiAqXG4gKiBAdHlwZWRlZiB7e1xuICogICBjaGlsZDogQ2FuY2VsbGFibGVQcm9taXNlLFxuICogICBvbkZ1bGZpbGxlZDogZnVuY3Rpb24oKiksXG4gKiAgIG9uUmVqZWN0ZWQ6IGZ1bmN0aW9uKCopXG4gKiB9fVxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlfID0gbnVsbDtcblxuXG4vKipcbiAqIEBwYXJhbSB7KFRZUEV8VGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT19IG9wdF92YWx1ZVxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IEEgbmV3IFByb21pc2UgdGhhdCBpcyBpbW1lZGlhdGVseSByZXNvbHZlZFxuICogICAgIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbihvcHRfdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZShvcHRfdmFsdWUpO1xuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7Kj19IG9wdF9yZWFzb25cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IEEgbmV3IFByb21pc2UgdGhhdCBpcyBpbW1lZGlhdGVseSByZWplY3RlZCB3aXRoIHRoZVxuICogICAgIGdpdmVuIHJlYXNvbi5cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKG9wdF9yZWFzb24pIHtcbiAgcmV0dXJuIG5ldyBDYW5jZWxsYWJsZVByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWplY3Qob3B0X3JlYXNvbik7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshQXJyYXkuPCEoVGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT59IHByb21pc2VzXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxUWVBFPn0gQSBQcm9taXNlIHRoYXQgcmVjZWl2ZXMgdGhlIHJlc3VsdCBvZiB0aGVcbiAqICAgICBmaXJzdCBQcm9taXNlIChvciBQcm9taXNlLWxpa2UpIGlucHV0IHRvIGNvbXBsZXRlLlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnJhY2UgPSBmdW5jdGlvbihwcm9taXNlcykge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICghcHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyAocHJvbWlzZSA9IHByb21pc2VzW2ldKTsgaSsrKSB7XG4gICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjwhKFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk+fSBwcm9taXNlc1xuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48IUFycmF5LjxUWVBFPj59IEEgUHJvbWlzZSB0aGF0IHJlY2VpdmVzIGEgbGlzdCBvZlxuICogICAgIGV2ZXJ5IGZ1bGZpbGxlZCB2YWx1ZSBvbmNlIGV2ZXJ5IGlucHV0IFByb21pc2UgKG9yIFByb21pc2UtbGlrZSkgaXNcbiAqICAgICBzdWNjZXNzZnVsbHkgZnVsZmlsbGVkLCBvciBpcyByZWplY3RlZCBieSB0aGUgZmlyc3QgcmVqZWN0aW9uIHJlc3VsdC5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5hbGwgPSBmdW5jdGlvbihwcm9taXNlcykge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciB0b0Z1bGZpbGwgPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICAgIGlmICghdG9GdWxmaWxsKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb25GdWxmaWxsID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRvRnVsZmlsbC0tO1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIGlmICh0b0Z1bGZpbGwgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvblJlamVjdCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyAocHJvbWlzZSA9IHByb21pc2VzW2ldKTsgaSsrKSB7XG4gICAgICAgIHByb21pc2UudGhlbihwYXJ0aWFsKG9uRnVsZmlsbCwgaSksIG9uUmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheS48IShUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPn0gcHJvbWlzZXNcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBBIFByb21pc2UgdGhhdCByZWNlaXZlcyB0aGUgdmFsdWUgb2ZcbiAqICAgICB0aGUgZmlyc3QgaW5wdXQgdG8gYmUgZnVsZmlsbGVkLCBvciBpcyByZWplY3RlZCB3aXRoIGEgbGlzdCBvZiBldmVyeVxuICogICAgIHJlamVjdGlvbiByZWFzb24gaWYgYWxsIGlucHV0cyBhcmUgcmVqZWN0ZWQuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuZmlyc3RGdWxmaWxsZWQgPSBmdW5jdGlvbihwcm9taXNlcykge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciB0b1JlamVjdCA9IHByb21pc2VzLmxlbmd0aDtcbiAgICAgIHZhciByZWFzb25zID0gW107XG5cbiAgICAgIGlmICghdG9SZWplY3QpIHtcbiAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvbkZ1bGZpbGwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBvblJlamVjdCA9IGZ1bmN0aW9uKGluZGV4LCByZWFzb24pIHtcbiAgICAgICAgdG9SZWplY3QtLTtcbiAgICAgICAgcmVhc29uc1tpbmRleF0gPSByZWFzb247XG4gICAgICAgIGlmICh0b1JlamVjdCA9PT0gMCkge1xuICAgICAgICAgIHJlamVjdChyZWFzb25zKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IChwcm9taXNlID0gcHJvbWlzZXNbaV0pOyBpKyspIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKG9uRnVsZmlsbCwgcGFydGlhbChvblJlamVjdCwgaSkpO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEFkZHMgY2FsbGJhY2tzIHRoYXQgd2lsbCBvcGVyYXRlIG9uIHRoZSByZXN1bHQgb2YgdGhlIFByb21pc2UsIHJldHVybmluZyBhXG4gKiBuZXcgY2hpbGQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgUHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSB7QGNvZGUgb25GdWxmaWxsZWR9IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgYXMgYXJndW1lbnQsIGFuZCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlXG4gKiBmdWxmaWxsZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjay4gSWYgdGhlIGNhbGxiYWNrIHRocm93cyBhblxuICogZXhjZXB0aW9uLCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHRocm93biB2YWx1ZSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCB0aGUge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWRcbiAqIHdpdGggdGhlIHJldHVybiB2YWx1ZSAob3IgdGhyb3duIHZhbHVlKSBvZiB0aGUgY2FsbGJhY2suXG4gKlxuICogQG92ZXJyaWRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9wdF9vbkZ1bGZpbGxlZCwgb3B0X29uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmFkZENoaWxkUHJvbWlzZV8oXG4gICAgaXNGdW5jdGlvbihvcHRfb25GdWxmaWxsZWQpID8gb3B0X29uRnVsZmlsbGVkIDogbnVsbCxcbiAgICBpc0Z1bmN0aW9uKG9wdF9vblJlamVjdGVkKSA/IG9wdF9vblJlamVjdGVkIDogbnVsbCxcbiAgICBvcHRfY29udGV4dCk7XG59O1xuVGhlbmFibGUuYWRkSW1wbGVtZW50YXRpb24oQ2FuY2VsbGFibGVQcm9taXNlKTtcblxuXG4vKipcbiAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGV0aGVyIHRoZSBQcm9taXNlIGlzIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQuIFRoZSBjYWxsYmFjayByZWNlaXZlcyBubyBhcmd1bWVudCwgYW5kIG5vIG5ldyBjaGlsZCBQcm9taXNlIGlzXG4gKiBjcmVhdGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBjbGVhbnVwIHRha2VzIHBsYWNlIGFmdGVyIGNlcnRhaW5cbiAqIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLiBDYWxsYmFja3MgYWRkZWQgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30gd2lsbCBiZVxuICogZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgd2l0aCBvdGhlciBjYWxscyB0byB7QGNvZGUgdGhlbn0sXG4gKiB7QGNvZGUgdGhlbkFsd2F5c30sIG9yIHtAY29kZSB0aGVuQ2F0Y2h9LlxuICpcbiAqIFNpbmNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSBuZXcgY2hpbGQgUHJvbWlzZSwgY2FuY2VsbGF0aW9uIHByb3BhZ2F0aW9uIGlzXG4gKiBub3QgcHJldmVudGVkIGJ5IGFkZGluZyBjYWxsYmFja3Mgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30uIEEgUHJvbWlzZSB0aGF0IGhhc1xuICogYSBjbGVhbnVwIGhhbmRsZXIgYWRkZWQgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30gd2lsbCBiZSBjYW5jZWxlZCBpZiBhbGwgb2ZcbiAqIGl0cyBjaGlsZHJlbiBjcmVhdGVkIGJ5IHtAY29kZSB0aGVufSAob3Ige0Bjb2RlIHRoZW5DYXRjaH0pIGFyZSBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyk6IHZvaWR9IG9uUmVzb2x2ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxuICogICAgIHdoZW4gdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IFRoaXMgUHJvbWlzZSwgZm9yIGNoYWluaW5nIGFkZGl0aW9uYWwgY2FsbHMuXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5BbHdheXMgPSBmdW5jdGlvbihvblJlc29sdmVkLCBvcHRfY29udGV4dCkge1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gb25SZXNvbHZlZC5cbiAgICAgIG9uUmVzb2x2ZWQuY2FsbChvcHRfY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXy5jYWxsKG51bGwsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuYWRkQ2FsbGJhY2tFbnRyeV8oe1xuICAgIGNoaWxkOiBudWxsLFxuICAgIG9uUmVqZWN0ZWQ6IGNhbGxiYWNrLFxuICAgIG9uRnVsZmlsbGVkOiBjYWxsYmFja1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIG9ubHkgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXNcbiAqIGlzIGVxdWl2YWxlbnQgdG8ge0Bjb2RlIHRoZW4obnVsbCwgb25SZWplY3RlZCl9LlxuICpcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKHRoaXM6VEhJUywgKik6ICp9IG9uUmVqZWN0ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgICBpbnZva2VkIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gQSBuZXcgUHJvbWlzZSB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IG9mIHRoZVxuICogICAgIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQ2F0Y2ggPSBmdW5jdGlvbihvblJlamVjdGVkLCBvcHRfY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5hZGRDaGlsZFByb21pc2VfKG51bGwsIG9uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KTtcbn07XG5cbi8qKlxuICogQWxpYXMgb2Yge0BsaW5rIENhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhdGNofVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhdGNoID0gQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQ2F0Y2g7XG5cblxuLyoqXG4gKiBDYW5jZWxzIHRoZSBQcm9taXNlIGlmIGl0IGlzIHN0aWxsIHBlbmRpbmcgYnkgcmVqZWN0aW5nIGl0IHdpdGggYSBjYW5jZWxcbiAqIEVycm9yLiBObyBhY3Rpb24gaXMgcGVyZm9ybWVkIGlmIHRoZSBQcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQuXG4gKlxuICogQWxsIGNoaWxkIFByb21pc2VzIG9mIHRoZSBjYW5jZWxlZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICogY2FuY2VsIGVycm9yLCBhcyB3aXRoIG5vcm1hbCBQcm9taXNlIHJlamVjdGlvbi4gSWYgdGhlIFByb21pc2UgdG8gYmUgY2FuY2VsZWRcbiAqIGlzIHRoZSBvbmx5IGNoaWxkIG9mIGEgcGVuZGluZyBQcm9taXNlLCB0aGUgcGFyZW50IFByb21pc2Ugd2lsbCBhbHNvIGJlXG4gKiBjYW5jZWxlZC4gQ2FuY2VsbGF0aW9uIG1heSBwcm9wYWdhdGUgdXB3YXJkIHRocm91Z2ggbXVsdGlwbGUgZ2VuZXJhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBBbiBvcHRpb25hbCBkZWJ1Z2dpbmcgbWVzc2FnZSBmb3IgZGVzY3JpYmluZyB0aGVcbiAqICAgICBjYW5jZWxsYXRpb24gcmVhc29uLlxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKG9wdF9tZXNzYWdlKSB7XG4gIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HKSB7XG4gICAgYXN5bmMucnVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBDYW5jZWxsYWJsZVByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3Iob3B0X21lc3NhZ2UpO1xuICAgICAgZXJyLklTX0NBTkNFTExBVElPTl9FUlJPUiA9IHRydWU7XG4gICAgICB0aGlzLmNhbmNlbEludGVybmFsXyhlcnIpO1xuICAgIH0sIHRoaXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2FuY2VscyB0aGlzIFByb21pc2Ugd2l0aCB0aGUgZ2l2ZW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHshRXJyb3J9IGVyciBUaGUgY2FuY2VsbGF0aW9uIGVycm9yLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWxJbnRlcm5hbF8gPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRfKSB7XG4gICAgICAvLyBDYW5jZWwgdGhlIFByb21pc2UgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBwYXJlbnQncyBjaGlsZCBsaXN0LlxuICAgICAgdGhpcy5wYXJlbnRfLmNhbmNlbENoaWxkXyh0aGlzLCBlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIGVycik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQ2FuY2VscyBhIGNoaWxkIFByb21pc2UgZnJvbSB0aGUgbGlzdCBvZiBjYWxsYmFjayBlbnRyaWVzLiBJZiB0aGUgUHJvbWlzZSBoYXNcbiAqIG5vdCBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQsIHJlamVjdCBpdCB3aXRoIGEgY2FuY2VsIGVycm9yLiBJZiB0aGVyZSBhcmUgbm9cbiAqIG90aGVyIGNoaWxkcmVuIGluIHRoZSBsaXN0IG9mIGNhbGxiYWNrIGVudHJpZXMsIHByb3BhZ2F0ZSB0aGUgY2FuY2VsbGF0aW9uXG4gKiBieSBjYW5jZWxpbmcgdGhpcyBQcm9taXNlIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHshQ2FuY2VsbGFibGVQcm9taXNlfSBjaGlsZFByb21pc2UgVGhlIFByb21pc2UgdG8gY2FuY2VsLlxuICogQHBhcmFtIHshRXJyb3J9IGVyciBUaGUgY2FuY2VsIGVycm9yIHRvIHVzZSBmb3IgcmVqZWN0aW5nIHRoZSBQcm9taXNlLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWxDaGlsZF8gPSBmdW5jdGlvbihjaGlsZFByb21pc2UsIGVycikge1xuICBpZiAoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRDb3VudCA9IDA7XG4gIHZhciBjaGlsZEluZGV4ID0gLTE7XG5cbiAgLy8gRmluZCB0aGUgY2FsbGJhY2sgZW50cnkgZm9yIHRoZSBjaGlsZFByb21pc2UsIGFuZCBjb3VudCB3aGV0aGVyIHRoZXJlIGFyZVxuICAvLyBhZGRpdGlvbmFsIGNoaWxkIFByb21pc2VzLlxuICBmb3IgKHZhciBpID0gMCwgZW50cnk7IChlbnRyeSA9IHRoaXMuY2FsbGJhY2tFbnRyaWVzX1tpXSk7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGVudHJ5LmNoaWxkO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY2hpbGRDb3VudCsrO1xuICAgICAgaWYgKGNoaWxkID09PSBjaGlsZFByb21pc2UpIHtcbiAgICAgICAgY2hpbGRJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRJbmRleCA+PSAwICYmIGNoaWxkQ291bnQgPiAxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBjaGlsZCBQcm9taXNlIHdhcyB0aGUgb25seSBjaGlsZCwgY2FuY2VsIHRoaXMgUHJvbWlzZSBhcyB3ZWxsLlxuICAvLyBPdGhlcndpc2UsIHJlamVjdCBvbmx5IHRoZSBjaGlsZCBQcm9taXNlIHdpdGggdGhlIGNhbmNlbCBlcnJvci5cbiAgaWYgKGNoaWxkSW5kZXggPj0gMCkge1xuICAgIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HICYmIGNoaWxkQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuY2FuY2VsSW50ZXJuYWxfKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjYWxsYmFja0VudHJ5ID0gdGhpcy5jYWxsYmFja0VudHJpZXNfLnNwbGljZShjaGlsZEluZGV4LCAxKVswXTtcbiAgICAgIHRoaXMuZXhlY3V0ZUNhbGxiYWNrXyhcbiAgICAgICAgY2FsbGJhY2tFbnRyeSwgQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgZXJyKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgY2FsbGJhY2sgZW50cnkgdG8gdGhlIGN1cnJlbnQgUHJvbWlzZSwgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICogZXhlY3V0aW9uIGlmIHRoZSBQcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQuXG4gKlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV99IGNhbGxiYWNrRW50cnkgUmVjb3JkIGNvbnRhaW5pbmdcbiAqICAgICB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIHRvIGV4ZWN1dGUgYWZ0ZXJcbiAqICAgICB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuYWRkQ2FsbGJhY2tFbnRyeV8gPSBmdW5jdGlvbihjYWxsYmFja0VudHJ5KSB7XG4gIGlmICgoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXyB8fCAhdGhpcy5jYWxsYmFja0VudHJpZXNfLmxlbmd0aCkgJiZcbiAgICAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVEIHx8XG4gICAgdGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQpKSB7XG4gICAgdGhpcy5zY2hlZHVsZUNhbGxiYWNrc18oKTtcbiAgfVxuICBpZiAoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXykge1xuICAgIHRoaXMuY2FsbGJhY2tFbnRyaWVzXyA9IFtdO1xuICB9XG4gIHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5wdXNoKGNhbGxiYWNrRW50cnkpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjaGlsZCBQcm9taXNlIGFuZCBhZGRzIGl0IHRvIHRoZSBjYWxsYmFjayBlbnRyeSBsaXN0LiBUaGUgcmVzdWx0IG9mXG4gKiB0aGUgY2hpbGQgUHJvbWlzZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzdGF0ZSBvZiB0aGUgcGFyZW50IFByb21pc2UgYW5kIHRoZVxuICogcmVzdWx0IG9mIHRoZSB7QGNvZGUgb25GdWxmaWxsZWR9IG9yIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgYXNcbiAqIHNwZWNpZmllZCBpbiB0aGUgUHJvbWlzZSByZXNvbHV0aW9uIHByb2NlZHVyZS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8jdGhlX19tZXRob2RcbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlRISVMsIFRZUEUpOlxuICogICAgICAgICAgKFJFU1VMVHxDYW5jZWxsYWJsZVByb21pc2UuPFJFU1VMVD58VGhlbmFibGUpfSBvbkZ1bGZpbGxlZCBBIGNhbGxiYWNrIHRoYXRcbiAqICAgICB3aWxsIGJlIGludm9rZWQgaWYgdGhlIFByb21pc2UgaXMgZnVsbGZpbGxlZCwgb3IgbnVsbC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6VEhJUywgKik6ICp9IG9uUmVqZWN0ZWQgQSBjYWxsYmFjayB0aGF0IHdpbGwgYmVcbiAqICAgICBpbnZva2VkIGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBvciBudWxsLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuXG4gKiAgICAgaW4gdGhlIGRlZmF1bHQgY2FsbGluZyBjb250ZXh0LlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gVGhlIGNoaWxkIFByb21pc2UuXG4gKiBAdGVtcGxhdGUgUkVTVUxULFRISVNcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuYWRkQ2hpbGRQcm9taXNlXyA9IGZ1bmN0aW9uKFxub25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KSB7XG5cbiAgdmFyIGNhbGxiYWNrRW50cnkgPSB7XG4gICAgY2hpbGQ6IG51bGwsXG4gICAgb25GdWxmaWxsZWQ6IG51bGwsXG4gICAgb25SZWplY3RlZDogbnVsbFxuICB9O1xuXG4gIGNhbGxiYWNrRW50cnkuY2hpbGQgPSBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIEludm9rZSBvbkZ1bGZpbGxlZCwgb3IgcmVzb2x2ZSB3aXRoIHRoZSBwYXJlbnQncyB2YWx1ZSBpZiBhYnNlbnQuXG4gICAgY2FsbGJhY2tFbnRyeS5vbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBvbkZ1bGZpbGxlZC5jYWxsKG9wdF9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9IDogcmVzb2x2ZTtcblxuICAgIC8vIEludm9rZSBvblJlamVjdGVkLCBvciByZWplY3Qgd2l0aCB0aGUgcGFyZW50J3MgcmVhc29uIGlmIGFic2VudC5cbiAgICBjYWxsYmFja0VudHJ5Lm9uUmVqZWN0ZWQgPSBvblJlamVjdGVkID8gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb25SZWplY3RlZC5jYWxsKG9wdF9jb250ZXh0LCByZWFzb24pO1xuICAgICAgICBpZiAoIWlzRGVmKHJlc3VsdCkgJiYgcmVhc29uLklTX0NBTkNFTExBVElPTl9FUlJPUikge1xuICAgICAgICAgIC8vIFByb3BhZ2F0ZSBjYW5jZWxsYXRpb24gdG8gY2hpbGRyZW4gaWYgbm8gb3RoZXIgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0gOiByZWplY3Q7XG4gIH0pO1xuXG4gIGNhbGxiYWNrRW50cnkuY2hpbGQucGFyZW50XyA9IHRoaXM7XG4gIHRoaXMuYWRkQ2FsbGJhY2tFbnRyeV8oXG4gICAgLyoqIEB0eXBlIHtDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV99ICovIChjYWxsYmFja0VudHJ5KSk7XG4gIHJldHVybiBjYWxsYmFja0VudHJ5LmNoaWxkO1xufTtcblxuXG4vKipcbiAqIFVuYmxvY2tzIHRoZSBQcm9taXNlIGFuZCBmdWxmaWxscyBpdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1RZUEV9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnVuYmxvY2tBbmRGdWxmaWxsXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0aGlzLnN0YXRlXyAhPT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5jZWxsYWJsZVByb21pc2UgaXMgbm90IGJsb2NrZWQuJyk7XG4gIH1cbiAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkc7XG4gIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQsIHZhbHVlKTtcbn07XG5cblxuLyoqXG4gKiBVbmJsb2NrcyB0aGUgUHJvbWlzZSBhbmQgcmVqZWN0cyBpdCB3aXRoIHRoZSBnaXZlbiByZWplY3Rpb24gcmVhc29uLlxuICpcbiAqIEBwYXJhbSB7Kn0gcmVhc29uXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnVuYmxvY2tBbmRSZWplY3RfID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGlmICh0aGlzLnN0YXRlXyAhPT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5jZWxsYWJsZVByb21pc2UgaXMgbm90IGJsb2NrZWQuJyk7XG4gIH1cbiAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkc7XG4gIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgcmVhc29uKTtcbn07XG5cblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXNvbHZlIGEgUHJvbWlzZSB3aXRoIGEgZ2l2ZW4gcmVzb2x1dGlvbiBzdGF0ZSBhbmQgdmFsdWUuIFRoaXNcbiAqIGlzIGEgbm8tb3AgaWYgdGhlIGdpdmVuIFByb21pc2UgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZC5cbiAqXG4gKiBJZiB0aGUgZ2l2ZW4gcmVzdWx0IGlzIGEgVGhlbmFibGUgKHN1Y2ggYXMgYW5vdGhlciBQcm9taXNlKSwgdGhlIFByb21pc2Ugd2lsbFxuICogYmUgcmVzb2x2ZWQgd2l0aCB0aGUgc2FtZSBzdGF0ZSBhbmQgcmVzdWx0IGFzIHRoZSBUaGVuYWJsZSBvbmNlIGl0IGlzIGl0c2VsZlxuICogcmVzb2x2ZWQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHJlc3VsdCBpcyBub3QgYSBUaGVuYWJsZSwgdGhlIFByb21pc2Ugd2lsbCBiZSBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkIHdpdGggdGhhdCByZXN1bHQgYmFzZWQgb24gdGhlIGdpdmVuIHN0YXRlLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyN0aGVfcHJvbWlzZV9yZXNvbHV0aW9uX3Byb2NlZHVyZVxuICpcbiAqIEBwYXJhbSB7Q2FuY2VsbGFibGVQcm9taXNlLlN0YXRlX30gc3RhdGVcbiAqIEBwYXJhbSB7Kn0geCBUaGUgcmVzdWx0IHRvIGFwcGx5IHRvIHRoZSBQcm9taXNlLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5yZXNvbHZlXyA9IGZ1bmN0aW9uKHN0YXRlLCB4KSB7XG4gIGlmICh0aGlzLnN0YXRlXyAhPT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMgPT09IHgpIHtcbiAgICBzdGF0ZSA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQ7XG4gICAgeCA9IG5ldyBUeXBlRXJyb3IoJ0NhbmNlbGxhYmxlUHJvbWlzZSBjYW5ub3QgcmVzb2x2ZSB0byBpdHNlbGYnKTtcblxuICB9IGVsc2UgaWYgKFRoZW5hYmxlLmlzSW1wbGVtZW50ZWRCeSh4KSkge1xuICAgIHggPSAvKiogQHR5cGUgeyFUaGVuYWJsZX0gKi8gKHgpO1xuICAgIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEO1xuICAgIHgudGhlbih0aGlzLnVuYmxvY2tBbmRGdWxmaWxsXywgdGhpcy51bmJsb2NrQW5kUmVqZWN0XywgdGhpcyk7XG4gICAgcmV0dXJuO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoeCkpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoZW4gPSB4LnRoZW47XG4gICAgICBpZiAoaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICB0aGlzLnRyeVRoZW5fKHgsIHRoZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3RhdGUgPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEO1xuICAgICAgeCA9IGU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZXN1bHRfID0geDtcbiAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgdGhpcy5zY2hlZHVsZUNhbGxiYWNrc18oKTtcblxuICBpZiAoc3RhdGUgPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQgJiYgIXguSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SKSB7XG4gICAgQ2FuY2VsbGFibGVQcm9taXNlLmFkZFVuaGFuZGxlZFJlamVjdGlvbl8odGhpcywgeCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBjYWxsIHRoZSB7QGNvZGUgdGhlbn0gbWV0aG9kIG9uIGFuIG9iamVjdCBpbiB0aGUgaG9wZXMgdGhhdCBpdCBpc1xuICogYSBQcm9taXNlLWNvbXBhdGlibGUgaW5zdGFuY2UuIFRoaXMgYWxsb3dzIGludGVyb3BlcmF0aW9uIGJldHdlZW4gZGlmZmVyZW50XG4gKiBQcm9taXNlIGltcGxlbWVudGF0aW9ucywgaG93ZXZlciBhIG5vbi1jb21wbGlhbnQgb2JqZWN0IG1heSBjYXVzZSBhIFByb21pc2VcbiAqIHRvIGhhbmcgaW5kZWZpbml0ZWx5LiBJZiB0aGUge0Bjb2RlIHRoZW59IG1ldGhvZCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB0aGVcbiAqIGRlcGVuZGVudCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03MFxuICpcbiAqIEBwYXJhbSB7VGhlbmFibGV9IHRoZW5hYmxlIEFuIG9iamVjdCB3aXRoIGEge0Bjb2RlIHRoZW59IG1ldGhvZCB0aGF0IG1heSBiZVxuICogICAgIGNvbXBhdGlibGUgd2l0aCB0aGUgUHJvbWlzZS9BKyBzcGVjaWZpY2F0aW9uLlxuICogQHBhcmFtIHshRnVuY3Rpb259IHRoZW4gVGhlIHtAY29kZSB0aGVufSBtZXRob2Qgb2YgdGhlIFRoZW5hYmxlIG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudHJ5VGhlbl8gPSBmdW5jdGlvbih0aGVuYWJsZSwgdGhlbikge1xuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uQkxPQ0tFRDtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvbWlzZS51bmJsb2NrQW5kRnVsZmlsbF8odmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBwcm9taXNlLnVuYmxvY2tBbmRSZWplY3RfKHJlYXNvbik7XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgdGhlbi5jYWxsKHRoZW5hYmxlLCByZXNvbHZlLCByZWplY3QpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KGUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHBlbmRpbmcgY2FsbGJhY2tzIG9mIGEgcmVzb2x2ZWQgUHJvbWlzZSBhZnRlciBhIHRpbWVvdXQuXG4gKlxuICogU2VjdGlvbiAyLjIuNCBvZiB0aGUgUHJvbWlzZXMvQSsgc3BlY2lmaWNhdGlvbiByZXF1aXJlcyB0aGF0IFByb21pc2VcbiAqIGNhbGxiYWNrcyBtdXN0IG9ubHkgYmUgaW52b2tlZCBmcm9tIGEgY2FsbCBzdGFjayB0aGF0IG9ubHkgY29udGFpbnMgUHJvbWlzZVxuICogaW1wbGVtZW50YXRpb24gY29kZSwgd2hpY2ggd2UgYWNjb21wbGlzaCBieSBpbnZva2luZyBjYWxsYmFjayBleGVjdXRpb24gYWZ0ZXJcbiAqIGEgdGltZW91dC4gSWYge0Bjb2RlIHN0YXJ0RXhlY3V0aW9uX30gaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZVxuICogUHJvbWlzZSwgdGhlIGNhbGxiYWNrIGNoYWluIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgb25jZS4gQWRkaXRpb25hbCBjYWxsYmFja3NcbiAqIG1heSBiZSBhZGRlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24gcGhhc2UsIGFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lXG4gKiBldmVudCBsb29wLlxuICpcbiAqIEFsbCBQcm9taXNlcyBhZGRlZCB0byB0aGUgd2FpdGluZyBsaXN0IGR1cmluZyB0aGUgc2FtZSBicm93c2VyIGV2ZW50IGxvb3BcbiAqIHdpbGwgYmUgZXhlY3V0ZWQgaW4gb25lIGJhdGNoIHRvIGF2b2lkIHVzaW5nIGEgc2VwYXJhdGUgdGltZW91dCBwZXIgUHJvbWlzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnNjaGVkdWxlQ2FsbGJhY2tzXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZXhlY3V0aW5nXykge1xuICAgIHRoaXMuZXhlY3V0aW5nXyA9IHRydWU7XG4gICAgYXN5bmMucnVuKHRoaXMuZXhlY3V0ZUNhbGxiYWNrc18sIHRoaXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRXhlY3V0ZXMgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIGZvciB0aGlzIFByb21pc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5leGVjdXRlQ2FsbGJhY2tzXyA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5jYWxsYmFja0VudHJpZXNfICYmIHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5sZW5ndGgpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuY2FsbGJhY2tFbnRyaWVzXztcbiAgICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5leGVjdXRlQ2FsbGJhY2tfKGVudHJpZXNbaV0sIHRoaXMuc3RhdGVfLCB0aGlzLnJlc3VsdF8pO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4ZWN1dGluZ18gPSBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBFeGVjdXRlcyBhIHBlbmRpbmcgY2FsbGJhY2sgZm9yIHRoaXMgUHJvbWlzZS4gSW52b2tlcyBhbiB7QGNvZGUgb25GdWxmaWxsZWR9XG4gKiBvciB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgYmFzZWQgb24gdGhlIHJlc29sdmVkIHN0YXRlIG9mIHRoZSBQcm9taXNlLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5X30gY2FsbGJhY2tFbnRyeSBBbiBlbnRyeSBjb250YWluaW5nIHRoZVxuICogICAgIG9uRnVsZmlsbGVkIGFuZC9vciBvblJlamVjdGVkIGNhbGxiYWNrcyBmb3IgdGhpcyBzdGVwLlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVffSBzdGF0ZSBUaGUgcmVzb2x1dGlvbiBzdGF0dXMgb2YgdGhlIFByb21pc2UsXG4gKiAgICAgZWl0aGVyIEZVTEZJTExFRCBvciBSRUpFQ1RFRC5cbiAqIEBwYXJhbSB7Kn0gcmVzdWx0IFRoZSByZXNvbHZlZCByZXN1bHQgb2YgdGhlIFByb21pc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmV4ZWN1dGVDYWxsYmFja18gPSBmdW5jdGlvbihcbmNhbGxiYWNrRW50cnksIHN0YXRlLCByZXN1bHQpIHtcbiAgaWYgKHN0YXRlID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkZVTEZJTExFRCkge1xuICAgIGNhbGxiYWNrRW50cnkub25GdWxmaWxsZWQocmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlbW92ZVVuaGFuZGxlZFJlamVjdGlvbl8oKTtcbiAgICBjYWxsYmFja0VudHJ5Lm9uUmVqZWN0ZWQocmVzdWx0KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIE1hcmtzIHRoaXMgcmVqZWN0ZWQgUHJvbWlzZSBhcyBoYXZpbmcgYmVpbmcgaGFuZGxlZC4gQWxzbyBtYXJrcyBhbnkgcGFyZW50XG4gKiBQcm9taXNlcyBpbiB0aGUgcmVqZWN0ZWQgc3RhdGUgYXMgaGFuZGxlZC4gVGhlIHJlamVjdGlvbiBoYW5kbGVyIHdpbGwgbm9cbiAqIGxvbmdlciBiZSBpbnZva2VkIGZvciB0aGlzIFByb21pc2UgKGlmIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgYWxyZWFkeSkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5yZW1vdmVVbmhhbmRsZWRSZWplY3Rpb25fID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwO1xuICBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPiAwKSB7XG4gICAgZm9yIChwID0gdGhpczsgcCAmJiBwLnVuaGFuZGxlZFJlamVjdGlvbklkXzsgcCA9IHAucGFyZW50Xykge1xuICAgICAgY2xlYXJUaW1lb3V0KHAudW5oYW5kbGVkUmVqZWN0aW9uSWRfKTtcbiAgICAgIHAudW5oYW5kbGVkUmVqZWN0aW9uSWRfID0gMDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPT09IDApIHtcbiAgICBmb3IgKHAgPSB0aGlzOyBwICYmIHAuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXzsgcCA9IHAucGFyZW50Xykge1xuICAgICAgcC5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogTWFya3MgdGhpcyByZWplY3RlZCBQcm9taXNlIGFzIHVuaGFuZGxlZC4gSWYgbm8ge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrXG4gKiBpcyBjYWxsZWQgZm9yIHRoaXMgUHJvbWlzZSBiZWZvcmUgdGhlIHtAY29kZSBVTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZfVxuICogZXhwaXJlcywgdGhlIHJlYXNvbiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLiBUaGVcbiAqIGhhbmRsZXIgdHlwaWNhbGx5IHJldGhyb3dzIHRoZSByZWplY3Rpb24gcmVhc29uIHNvIHRoYXQgaXQgYmVjb21lcyB2aXNpYmxlIGluXG4gKiB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUuXG4gKlxuICogQHBhcmFtIHshQ2FuY2VsbGFibGVQcm9taXNlfSBwcm9taXNlIFRoZSByZWplY3RlZCBQcm9taXNlLlxuICogQHBhcmFtIHsqfSByZWFzb24gVGhlIFByb21pc2UgcmVqZWN0aW9uIHJlYXNvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5hZGRVbmhhbmRsZWRSZWplY3Rpb25fID0gZnVuY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA+IDApIHtcbiAgICBwcm9taXNlLnVuaGFuZGxlZFJlamVjdGlvbklkXyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXy5jYWxsKG51bGwsIHJlYXNvbik7XG4gICAgfSwgQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkpO1xuXG4gIH0gZWxzZSBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPT09IDApIHtcbiAgICBwcm9taXNlLmhhZFVuaGFuZGxlZFJlamVjdGlvbl8gPSB0cnVlO1xuICAgIGFzeW5jLnJ1bihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwcm9taXNlLmhhZFVuaGFuZGxlZFJlamVjdGlvbl8pIHtcbiAgICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCByZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQSBtZXRob2QgdGhhdCBpcyBpbnZva2VkIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb25zIGZvciBQcm9taXNlcyB0aGF0IGFyZVxuICogcmVqZWN0ZWQgYnV0IGhhdmUgbm8ge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcyByZWdpc3RlcmVkIHlldC5cbiAqIEB0eXBlIHtmdW5jdGlvbigqKX1cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fID0gYXN5bmMudGhyb3dFeGNlcHRpb247XG5cblxuLyoqXG4gKiBTZXRzIGEgaGFuZGxlciB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggcmVhc29ucyBmcm9tIHVuaGFuZGxlZCByZWplY3RlZFxuICogUHJvbWlzZXMuIElmIHRoZSByZWplY3RlZCBQcm9taXNlIChvciBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzKSBoYXMgYW5cbiAqIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayByZWdpc3RlcmVkLCB0aGUgcmVqZWN0aW9uIHdpbGwgYmUgY29uc2lkZXJlZFxuICogaGFuZGxlZCwgYW5kIHRoZSByZWplY3Rpb24gaGFuZGxlciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gKlxuICogQnkgZGVmYXVsdCwgdW5oYW5kbGVkIHJlamVjdGlvbnMgYXJlIHJldGhyb3duIHNvIHRoYXQgdGhlIGVycm9yIG1heSBiZVxuICogY2FwdHVyZWQgYnkgdGhlIGRldmVsb3BlciBjb25zb2xlIG9yIGEge0Bjb2RlIHdpbmRvdy5vbmVycm9yfSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IGhhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggcmVhc29ucyBmcm9tXG4gKiAgICAgcmVqZWN0ZWQgUHJvbWlzZXMuIERlZmF1bHRzIHRvIHtAY29kZSBhc3luYy50aHJvd0V4Y2VwdGlvbn0uXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5zZXRVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXyA9IGhhbmRsZXI7XG59O1xuXG5cblxuLyoqXG4gKiBFcnJvciB1c2VkIGFzIGEgcmVqZWN0aW9uIHJlYXNvbiBmb3IgY2FuY2VsZWQgUHJvbWlzZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAZmluYWxcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdF9tZXNzYWdlKSB7XG4gICAgIHN1cGVyKG9wdF9tZXNzYWdlKTtcblxuICAgICBpZiAob3B0X21lc3NhZ2UpIHtcbiAgICAgICB0aGlzLm1lc3NhZ2UgPSBvcHRfbWVzc2FnZTtcbiAgICAgfVxuICAgfVxufTtcblxuLyoqIEBvdmVycmlkZSAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ2NhbmNlbCc7XG5cbmV4cG9ydCB7Q2FuY2VsbGFibGVQcm9taXNlfTtcbmV4cG9ydCBkZWZhdWx0IENhbmNlbGxhYmxlUHJvbWlzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgaXNEZWYsIGlzRGVmQW5kTm90TnVsbCB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBVcmkgZnJvbSAnbWV0YWwtdXJpJztcbmltcG9ydCB7IENhbmNlbGxhYmxlUHJvbWlzZSBhcyBQcm9taXNlIH0gZnJvbSAnbWV0YWwtcHJvbWlzZSc7XG5cbmNsYXNzIEFqYXgge1xuXG5cdC8qKlxuXHQgKiBYbWxIdHRwUmVxdWVzdCdzIGdldEFsbFJlc3BvbnNlSGVhZGVycygpIG1ldGhvZCByZXR1cm5zIGEgc3RyaW5nIG9mXG5cdCAqIHJlc3BvbnNlIGhlYWRlcnMgYWNjb3JkaW5nIHRvIHRoZSBmb3JtYXQgZGVzY3JpYmVkIG9uIHRoZSBzcGVjOlxuXHQgKiB7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3RoZS1nZXRhbGxyZXNwb25zZWhlYWRlcnMtbWV0aG9kfS5cblx0ICogVGhpcyBtZXRob2QgcGFyc2VzIHRoYXQgc3RyaW5nIGludG8gYSB1c2VyLWZyaWVuZGx5IG5hbWUvdmFsdWUgcGFpclxuXHQgKiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhbGxIZWFkZXJzIEFsbCBoZWFkZXJzIGFzIHN0cmluZy5cblx0ICogQHJldHVybiB7IUFycmF5LjxPYmplY3Q8c3RyaW5nLCBzdHJpbmc+Pn1cblx0ICovXG5cdHN0YXRpYyBwYXJzZVJlc3BvbnNlSGVhZGVycyhhbGxIZWFkZXJzKSB7XG5cdFx0dmFyIGhlYWRlcnMgPSBbXTtcblx0XHRpZiAoIWFsbEhlYWRlcnMpIHtcblx0XHRcdHJldHVybiBoZWFkZXJzO1xuXHRcdH1cblx0XHR2YXIgcGFpcnMgPSBhbGxIZWFkZXJzLnNwbGl0KCdcXHUwMDBkXFx1MDAwYScpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpbmRleCA9IHBhaXJzW2ldLmluZGV4T2YoJ1xcdTAwM2FcXHUwMDIwJyk7XG5cdFx0XHRpZiAoaW5kZXggPiAwKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gcGFpcnNbaV0uc3Vic3RyaW5nKDAsIGluZGV4KTtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFpcnNbaV0uc3Vic3RyaW5nKGluZGV4ICsgMik7XG5cdFx0XHRcdGhlYWRlcnMucHVzaCh7XG5cdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBoZWFkZXJzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcXVlc3RzIHRoZSB1cmwgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdXJsXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gbWV0aG9kXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gYm9keVxuXHQgKiBAcGFyYW0ge011bHRpTWFwPX0gb3B0X2hlYWRlcnNcblx0ICogQHBhcmFtIHtNdWx0aU1hcD19IG9wdF9wYXJhbXNcblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfdGltZW91dFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc3luY1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfd2l0aENyZWRlbnRpYWxzXG5cdCAqIEByZXR1cm4ge1Byb21pc2V9IERlZmVycmVkIGFqYXggcmVxdWVzdC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c3RhdGljIHJlcXVlc3QodXJsLCBtZXRob2QsIGJvZHksIG9wdF9oZWFkZXJzLCBvcHRfcGFyYW1zLCBvcHRfdGltZW91dCwgb3B0X3N5bmMsIG9wdF93aXRoQ3JlZGVudGlhbHMpIHtcblx0XHR1cmwgPSB1cmwgfHwgJyc7XG5cdFx0bWV0aG9kID0gbWV0aG9kIHx8ICdHRVQnO1xuXG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRyZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG5cdFx0XHRcdFx0cmVxdWVzdC5vbmVycm9yKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc29sdmUocmVxdWVzdCk7XG5cdFx0XHR9O1xuXHRcdFx0cmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcignUmVxdWVzdCBlcnJvcicpO1xuXHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcblx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdH07XG5cdFx0fSkudGhlbkNhdGNoKGZ1bmN0aW9uKHJlYXNvbikge1xuXHRcdFx0cmVxdWVzdC5hYm9ydCgpO1xuXHRcdFx0dGhyb3cgcmVhc29uO1xuXHRcdH0pLnRoZW5BbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0fSk7XG5cblx0XHRpZiAob3B0X3BhcmFtcykge1xuXHRcdFx0dXJsID0gbmV3IFVyaSh1cmwpLmFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAob3B0X3BhcmFtcykudG9TdHJpbmcoKTtcblx0XHR9XG5cblx0XHRyZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsICFvcHRfc3luYyk7XG5cblx0XHRpZiAob3B0X3dpdGhDcmVkZW50aWFscykge1xuXHRcdFx0cmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChvcHRfaGVhZGVycykge1xuXHRcdFx0b3B0X2hlYWRlcnMubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0cmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG9wdF9oZWFkZXJzLmdldEFsbChuYW1lKS5qb2luKCcsICcpKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcXVlc3Quc2VuZChpc0RlZihib2R5KSA/IGJvZHkgOiBudWxsKTtcblxuXHRcdGlmIChpc0RlZkFuZE5vdE51bGwob3B0X3RpbWVvdXQpKSB7XG5cdFx0XHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHByb21pc2UuY2FuY2VsKCdSZXF1ZXN0IHRpbWVvdXQnKTtcblx0XHRcdH0sIG9wdF90aW1lb3V0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFqYXg7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBjb252ZW5pZW50IGludGVyZmFjZSBmb3IgZGF0YSB0cmFuc3BvcnQuXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFRyYW5zcG9ydCB7XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgbWVzc2FnZSBmb3IgdGhlIHNwZWNpZmllZCBjbGllbnQuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3Rcblx0ICogQHJldHVybiB7IVByb21pc2V9IERlZmVycmVkIHJlcXVlc3QuXG5cdCAqL1xuXHRzZW5kKCkge31cblxufVxuXG5leHBvcnQgZGVmYXVsdCBUcmFuc3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGllbnQgbWVzc2FnZSAoZS5nLiBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZSkuXG4gKi9cbmNsYXNzIENsaWVudE1lc3NhZ2Uge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IGJvZHkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9ib2R5IFJlcXVlc3QgYm9keSB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGJvZHkgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7Kn0gUmV0dXJucyByZXF1ZXN0IGJvZHkgaWYgbm8gYm9keSB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZVxuXHQgKiAgIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdGJvZHkob3B0X2JvZHkpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfYm9keSkpIHtcblx0XHRcdHRoaXMuYm9keV8gPSBvcHRfYm9keTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5ib2R5Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiBhIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90IGJlXG5cdCAqIG92ZXJ3cml0dGVuLCBidXQgdGhlIG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBhcyB3ZWxsLiBUaGUgb3JkZXIgaXMgcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0aGVhZGVyKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcblx0XHR9XG5cdFx0dGhpcy5oZWFkZXJzXy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVxdWVzdCBoZWFkZXJzLlxuXHQgKiBAcGFyYW0ge011bHRpTWFwfE9iamVjdD19IG9wdF9oZWFkZXJzIFJlcXVlc3QgaGVhZGVycyBsaXN0IHRvXG5cdCAqICAgYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBoZWFkZXJzIHdpbGxcblx0ICogICBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IU11bHRpTWFwfENsaWVudE1lc3NhZ2V9IFJldHVybnMgbWFwIG9mIHJlcXVlc3QgaGVhZGVyc1xuXHQgKiAgIGlmIG5vIG5ldyB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX1cblx0ICogICBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdGhlYWRlcnMob3B0X2hlYWRlcnMpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfaGVhZGVycykpIHtcblx0XHRcdGlmIChvcHRfaGVhZGVycyBpbnN0YW5jZW9mIE11bHRpTWFwKSB7XG5cdFx0XHRcdHRoaXMuaGVhZGVyc18gPSBvcHRfaGVhZGVycztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuaGVhZGVyc18udmFsdWVzID0gb3B0X2hlYWRlcnM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3B0X2hlYWRlcnM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmhlYWRlcnNfO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGJvZHkuXG5cdCAqL1xuXHRyZW1vdmVCb2R5KCkge1xuXHRcdHRoaXMuYm9keV8gPSB1bmRlZmluZWQ7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50TWVzc2FnZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBDbGllbnRNZXNzYWdlIGZyb20gJy4vQ2xpZW50TWVzc2FnZSc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsaWVudCByZXNwb25zZSBvYmplY3QuXG4gKiBAZXh0ZW5kcyB7Q2xpZW50TWVzc2FnZX1cbiAqL1xuY2xhc3MgQ2xpZW50UmVzcG9uc2UgZXh0ZW5kcyBDbGllbnRNZXNzYWdlIHtcblx0Y29uc3RydWN0b3IoY2xpZW50UmVxdWVzdCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0aWYgKCFjbGllbnRSZXF1ZXN0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY3JlYXRlIHJlc3BvbnNlIHdpdGhvdXQgcmVxdWVzdCcpO1xuXHRcdH1cblx0XHR0aGlzLmNsaWVudFJlcXVlc3RfID0gY2xpZW50UmVxdWVzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJlcXVlc3QgdGhhdCBjcmVhdGVkIHRoaXMgcmVzcG9uc2UuXG5cdCAqIEByZXR1cm4geyFDbGllbnRSZXF1ZXN0fVxuXHQgKi9cblx0cmVxdWVzdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGllbnRSZXF1ZXN0Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9zdGF0dXNDb2RlIFJlcXVlc3Qgc3RhdHVzIGNvZGUgdG8gYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuLFxuXHQgKiAgIHRoZSBjdXJyZW50IHN0YXR1cyBjb2RlIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfG51bWJlcn0gUmV0dXJucyByZXNwb25zZSBzdGF0dXMgY29kZSBpZiBubyBuZXcgdmFsdWUgd2FzXG5cdCAqICAgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuXG5cdCAqICAgYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdHN0YXR1c0NvZGUob3B0X3N0YXR1c0NvZGUpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfc3RhdHVzQ29kZSkpIHtcblx0XHRcdHRoaXMuc3RhdHVzQ29kZV8gPSBvcHRfc3RhdHVzQ29kZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdGF0dXNDb2RlXztcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlc3BvbnNlIHN0YXR1cyB0ZXh0LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zdGF0dXNUZXh0IFJlcXVlc3Qgc3RhdHVzIHRleHQgdG8gYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuLFxuXHQgKiAgIHRoZSBjdXJyZW50IHN0YXR1cyB0ZXh0IHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfG51bWJlcn0gUmV0dXJucyByZXNwb25zZSBzdGF0dXMgdGV4dCBpZiBubyBuZXcgdmFsdWUgd2FzXG5cdCAqICAgZ2l2ZW4uIE90aGVyd2lzZSByZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuXG5cdCAqICAgYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG5cdHN0YXR1c1RleHQob3B0X3N0YXR1c1RleHQpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfc3RhdHVzVGV4dCkpIHtcblx0XHRcdHRoaXMuc3RhdHVzVGV4dF8gPSBvcHRfc3RhdHVzVGV4dDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdGF0dXNUZXh0Xztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcmVzcG9uc2Ugc3VjY2VlZGVkLiBBbnkgc3RhdHVzIGNvZGUgMnh4IG9yIDN4eCBpcyBjb25zaWRlcmVkIHZhbGlkLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3VjY2VlZGVkKCkge1xuXHRcdHJldHVybiB0aGlzLnN0YXR1c0NvZGUoKSA+PSAyMDAgJiYgdGhpcy5zdGF0dXNDb2RlKCkgPD0gMzk5O1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50UmVzcG9uc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBamF4IGZyb20gJ21ldGFsLWFqYXgnO1xuaW1wb3J0IFRyYW5zcG9ydCBmcm9tICcuLi9UcmFuc3BvcnQnO1xuaW1wb3J0IENsaWVudFJlc3BvbnNlIGZyb20gJy4uL0NsaWVudFJlc3BvbnNlJztcblxuLyoqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgYW4gYWpheCB0cmFuc3BvcnQgdG8gYmUgdXNlZCB3aXRoIHtAbGluayBXZURlcGxveX0uXG4gKiBAZXh0ZW5kcyB7VHJhbnNwb3J0fVxuICovXG5jbGFzcyBBamF4VHJhbnNwb3J0IGV4dGVuZHMgVHJhbnNwb3J0IHtcblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRzZW5kKGNsaWVudFJlcXVlc3QpIHtcblx0XHR2YXIgZGVmZXJyZWQgPSBBamF4LnJlcXVlc3QoXG5cdFx0XHRjbGllbnRSZXF1ZXN0LnVybCgpLCBjbGllbnRSZXF1ZXN0Lm1ldGhvZCgpLCBjbGllbnRSZXF1ZXN0LmJvZHkoKSxcblx0XHRcdGNsaWVudFJlcXVlc3QuaGVhZGVycygpLCBjbGllbnRSZXF1ZXN0LnBhcmFtcygpLCBudWxsLCBmYWxzZSwgY2xpZW50UmVxdWVzdC53aXRoQ3JlZGVudGlhbHMoKSk7XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuXHRcdFx0dmFyIGNsaWVudFJlc3BvbnNlID0gbmV3IENsaWVudFJlc3BvbnNlKGNsaWVudFJlcXVlc3QpO1xuXHRcdFx0Y2xpZW50UmVzcG9uc2UuYm9keShyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuXHRcdFx0Y2xpZW50UmVzcG9uc2Uuc3RhdHVzQ29kZShyZXNwb25zZS5zdGF0dXMpO1xuXHRcdFx0Y2xpZW50UmVzcG9uc2Uuc3RhdHVzVGV4dChyZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRcdEFqYXgucGFyc2VSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG5cdFx0XHRcdGNsaWVudFJlc3BvbnNlLmhlYWRlcihoZWFkZXIubmFtZSwgaGVhZGVyLnZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGNsaWVudFJlc3BvbnNlO1xuXHRcdH0pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFqYXhUcmFuc3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBamF4VHJhbnNwb3J0IGZyb20gJy4vYnJvd3Nlci9BamF4VHJhbnNwb3J0JztcblxuLyoqXG4gKiBQcm92aWRlcyBhIGZhY3RvcnkgZm9yIGRhdGEgdHJhbnNwb3J0LlxuICovXG5jbGFzcyBUcmFuc3BvcnRGYWN0b3J5IHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy50cmFuc3BvcnRzID0ge307XG5cdFx0dGhpcy50cmFuc3BvcnRzW1RyYW5zcG9ydEZhY3RvcnkuREVGQVVMVF9UUkFOU1BPUlRfTkFNRV0gPSBUcmFuc3BvcnRGYWN0b3J5W1RyYW5zcG9ydEZhY3RvcnkuREVGQVVMVF9UUkFOU1BPUlRfTkFNRV07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB7QGxpbmsgVHJhbnNwb3J0RmFjdG9yeX0gaW5zdGFuY2UuXG5cdCAqL1xuXHRzdGF0aWMgaW5zdGFuY2UoKSB7XG5cdFx0aWYgKCFUcmFuc3BvcnRGYWN0b3J5Lmluc3RhbmNlXykge1xuXHRcdFx0VHJhbnNwb3J0RmFjdG9yeS5pbnN0YW5jZV8gPSBuZXcgVHJhbnNwb3J0RmFjdG9yeSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gVHJhbnNwb3J0RmFjdG9yeS5pbnN0YW5jZV87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbiBpbnN0YW5jZSBvZiB0aGUgdHJhbnNwb3J0IGltcGxlbWVudGF0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbXBsZW1lbnRhdGlvbk5hbWVcblx0ICogQHJldHVybiB7IVRyYW5zcG9ydH1cblx0ICovXG5cdGdldChpbXBsZW1lbnRhdGlvbk5hbWUpIHtcblx0XHR2YXIgVHJhbnNwb3J0Q2xhc3MgPSB0aGlzLnRyYW5zcG9ydHNbaW1wbGVtZW50YXRpb25OYW1lXTtcblxuXHRcdGlmICghVHJhbnNwb3J0Q2xhc3MpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc3BvcnQgbmFtZTogJyArIGltcGxlbWVudGF0aW9uTmFtZSk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBuZXcgKFRyYW5zcG9ydENsYXNzKSgpO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNyZWF0ZSB0cmFuc3BvcnQnLCBlcnIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHJldHVybiB7IVRyYW5zcG9ydH1cblx0ICovXG5cdGdldERlZmF1bHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0KFRyYW5zcG9ydEZhY3RvcnkuREVGQVVMVF9UUkFOU1BPUlRfTkFNRSk7XG5cdH1cbn1cblxuVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FID0gJ2RlZmF1bHQnO1xuXG5UcmFuc3BvcnRGYWN0b3J5W1RyYW5zcG9ydEZhY3RvcnkuREVGQVVMVF9UUkFOU1BPUlRfTkFNRV0gPSBBamF4VHJhbnNwb3J0O1xuXG5leHBvcnQgZGVmYXVsdCBUcmFuc3BvcnRGYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IENsaWVudE1lc3NhZ2UgZnJvbSAnLi9DbGllbnRNZXNzYWdlJztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsaWVudCByZXF1ZXN0IG9iamVjdC5cbiAqIEBleHRlbmRzIHtDbGllbnRNZXNzYWdlfVxuICovXG5jbGFzcyBDbGllbnRSZXF1ZXN0IGV4dGVuZHMgQ2xpZW50TWVzc2FnZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5wYXJhbXNfID0gbmV3IE11bHRpTWFwKCk7XG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHNfID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHdpdGggY3JlZGVudGlhbHMgb3B0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfd2l0aENyZWRlbnRpYWxzXG5cdCAqIEBjaGFpbmFibGUgQ2hhaW5hYmxlIHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG5cdCAqL1xuXHR3aXRoQ3JlZGVudGlhbHMob3B0X3dpdGhDcmVkZW50aWFscykge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF93aXRoQ3JlZGVudGlhbHMpKSB7XG5cdFx0XHR0aGlzLndpdGhDcmVkZW50aWFsc18gPSAhIW9wdF93aXRoQ3JlZGVudGlhbHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMud2l0aENyZWRlbnRpYWxzXztcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlcXVlc3QgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXRob2QgUmVxdWVzdCBtZXRob2QgdG8gYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuLFxuXHQgKiAgIHRoZSBjdXJyZW50IG1ldGhvZCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50TWVzc2FnZXxzdHJpbmd9IFJldHVybnMgcmVxdWVzdCBtZXRob2QgaWYgbm8gbmV3IHZhbHVlIHdhc1xuXHQgKiAgIGdpdmVuLiBPdGhlcndpc2UgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGUgQ2hhaW5hYmxlIHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG5cdCAqL1xuXHRtZXRob2Qob3B0X21ldGhvZCkge1xuXHRcdGlmIChjb3JlLmlzRGVmKG9wdF9tZXRob2QpKSB7XG5cdFx0XHR0aGlzLm1ldGhvZF8gPSBvcHRfbWV0aG9kO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLm1ldGhvZF8gfHwgQ2xpZW50UmVxdWVzdC5ERUZBVUxUX01FVEhPRDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgcXVlcnkuIElmIGEgcXVlcnkgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIG5vdFxuXHQgKiBiZSBvdmVyd3JpdHRlbiwgYnV0IG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBhcyB3ZWxsLiBUaGUgb3JkZXIgaXMgcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cGFyYW0obmFtZSwgdmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuXHRcdH1cblx0XHR0aGlzLnBhcmFtc18uc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlcXVlc3QgcXVlcnlzdHJpbmcuXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXB8T2JqZWN0PX0gb3B0X3BhcmFtcyBSZXF1ZXN0IHF1ZXJ5c3RyaW5nIG1hcCB0byBiZSBzZXQuXG5cdCAqICAgSWYgbm9uZSBpcyBnaXZlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcGFyYW1zIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFNdWx0aU1hcHxDbGllbnRNZXNzYWdlfSBSZXR1cm5zIG1hcCBvZiByZXF1ZXN0IHF1ZXJ5c3RyaW5nIGlmXG5cdCAqICAgbm8gbmV3IHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKi9cblx0cGFyYW1zKG9wdF9wYXJhbXMpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfcGFyYW1zKSkge1xuXHRcdFx0aWYgKG9wdF9wYXJhbXMgaW5zdGFuY2VvZiBNdWx0aU1hcCkge1xuXHRcdFx0XHR0aGlzLnBhcmFtc18gPSBvcHRfcGFyYW1zO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wYXJhbXNfLnZhbHVlcyA9IG9wdF9wYXJhbXM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3B0X3BhcmFtcztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucGFyYW1zXztcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlcXVlc3QgdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF91cmwgUmVxdWVzdCB1cmwgdG8gYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuLFxuXHQgKiAgIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB1cmwgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8c3RyaW5nfSBSZXR1cm5zIHJlcXVlc3QgdXJsIGlmIG5vIG5ldyB2YWx1ZSB3YXMgZ2l2ZW4uXG5cdCAqICAgT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cblx0dXJsKG9wdF91cmwpIHtcblx0XHRpZiAoY29yZS5pc0RlZihvcHRfdXJsKSkge1xuXHRcdFx0dGhpcy51cmxfID0gb3B0X3VybDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy51cmxfO1xuXHR9XG5cbn1cblxuQ2xpZW50UmVxdWVzdC5ERUZBVUxUX01FVEhPRCA9ICdHRVQnO1xuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRSZXF1ZXN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCBBdXRoIGZyb20gJy4vYXV0aC9BdXRoJztcbmltcG9ydCBBdXRoQXBpSGVscGVyIGZyb20gJy4vYXV0aC9BdXRoQXBpSGVscGVyJztcbmltcG9ydCBEYXRhQXBpSGVscGVyIGZyb20gJy4vZGF0YS9EYXRhQXBpSGVscGVyJztcbmltcG9ydCBCYXNlNjQgZnJvbSAnLi4vY3J5cHQvQmFzZTY0JztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuLi9hcGktcXVlcnkvRW1ib2RpZWQnO1xuaW1wb3J0IFF1ZXJ5IGZyb20gJy4uL2FwaS1xdWVyeS9RdWVyeSc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uL2FwaS1xdWVyeS9GaWx0ZXInO1xuaW1wb3J0IFRyYW5zcG9ydEZhY3RvcnkgZnJvbSAnLi9UcmFuc3BvcnRGYWN0b3J5JztcbmltcG9ydCBDbGllbnRSZXF1ZXN0IGZyb20gJy4vQ2xpZW50UmVxdWVzdCc7XG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuaW1wb3J0IHsgYXNzZXJ0VXJpV2l0aE5vUGF0aCB9IGZyb20gJy4vYXNzZXJ0aW9ucyc7XG5cblxudmFyIGlvO1xuXG4vLyBPcHRpbWlzdGljIGluaXRpYWxpemF0aW9uIG9mIGBpb2AgcmVmZXJlbmNlIGZyb20gZ2xvYmFsIGBnbG9iYWxzLndpbmRvdy5pb2AuXG5pZiAodHlwZW9mIGdsb2JhbHMud2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRpbyA9IGdsb2JhbHMud2luZG93LmlvO1xufVxuXG4vKipcbiAqIFRoZSBtYWluIGNsYXNzIGZvciBtYWtpbmcgYXBpIHJlcXVlc3RzLiBTZW5kaW5nIHJlcXVlc3RzIHJldHVybnMgYSBwcm9taXNlXG4gKiB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHJlc3BvbnNlIGFycml2ZXMuIFVzYWdlIGV4YW1wbGU6XG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBXZURlcGxveVxuICogICAudXJsKCcvZGF0YS90YXNrcycpXG4gKiAgIC5wb3N0KHtkZXNjOiAnQnV5IG1pbGtsJ30pXG4gKiAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgLy8gSGFuZGxlIHJlc3BvbnNlIGhlcmUuXG4gKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2UuYm9keSgpKVxuICogICB9KTtcbiAqIGBgYFxuICovXG5jbGFzcyBXZURlcGxveSB7XG5cdC8qKlxuXHQgKiBXZURlcGxveSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSB1cmwuXG5cdCAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXRocyBBbnkgYW1vdW50IG9mIHBhdGhzIHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBiYXNlXG5cdCAqIHVybC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIC4uLnBhdGhzKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMsIHRyeSBgbmV3IFdlRGVwbG95KGJhc2VVcmwsIHVybClgJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5hdXRoXyA9IG51bGw7XG5cdFx0dGhpcy5ib2R5XyA9IG51bGw7XG5cdFx0dGhpcy51cmxfID0gVXJpLmpvaW5QYXRocyh1cmwgfHwgJycsIC4uLnBhdGhzKTtcblx0XHR0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG5cdFx0dGhpcy5wYXJhbXNfID0gbmV3IE11bHRpTWFwKCk7XG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHNfID0gdHJ1ZTtcblxuXHRcdHRoaXMuaGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdHRoaXMuaGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG5cdH1cblxuXHQvKipcblx0ICogU3RhdGljIGZhY3RvcnkgZm9yIGNyZWF0aW5nIFdlRGVwbG95IGRhdGEgZm9yIHRoZSBnaXZlbiB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RhdGFVcmwgVGhlIHVybCB0aGF0IHBvaW50cyB0byB0aGUgZGF0YSBzZXJ2aWNlcy5cblx0ICogQHJldHVybiBAcmV0dXJuIHtkYXRhfSBXZURlcGxveSBkYXRhIGluc3RhbmNlLlxuXHQgKi9cblx0c3RhdGljIGRhdGEob3B0X2RhdGFVcmwpIHtcblx0XHRhc3NlcnRVcmlXaXRoTm9QYXRoKG9wdF9kYXRhVXJsLCAnVGhlIGRhdGEgdXJsIHNob3VsZCBub3QgaGF2ZSBhIHBhdGgnKTtcblxuXHRcdGlmIChjb3JlLmlzU3RyaW5nKG9wdF9kYXRhVXJsKSkge1xuXHRcdFx0V2VEZXBsb3kuZGF0YVVybF8gPSBvcHRfZGF0YVVybDtcblx0XHR9XG5cblx0XHRsZXQgZGF0YSA9IG5ldyBEYXRhQXBpSGVscGVyKFdlRGVwbG95KTtcblxuXHRcdGRhdGEuYXV0aChXZURlcGxveS5hdXRoKCkuY3VycmVudFVzZXIpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIHRvIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQXV0aHxzdHJpbmd9IGF1dGhPclRva2VuT3JFbWFpbCBFaXRoZXIgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLFxuXHQgKiBhbiBhdXRob3JpemF0aW9uIHRva2VuLCBvciB0aGUgZW1haWwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgZW1haWwgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGF1dGgoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpIHtcblx0XHR0aGlzLmF1dGhfID0gYXV0aE9yVG9rZW5PckVtYWlsO1xuXHRcdGlmICghKHRoaXMuYXV0aF8gaW5zdGFuY2VvZiBBdXRoKSkge1xuXHRcdFx0dGhpcy5hdXRoXyA9IEF1dGguY3JlYXRlKGF1dGhPclRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU3RhdGljIGZhY3RvcnkgZm9yIGNyZWF0aW5nIFdlRGVwbG95IGF1dGggZm9yIHRoZSBnaXZlbiB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2F1dGhVcmwgVGhlIHVybCB0aGF0IHBvaW50cyB0byB0aGUgYXV0aCBzZXJ2aWNlLlxuXHQgKi9cblx0c3RhdGljIGF1dGgob3B0X2F1dGhVcmwpIHtcblx0XHRpZiAoY29yZS5pc1N0cmluZyhvcHRfYXV0aFVybCkpIHtcblx0XHRcdFdlRGVwbG95LmF1dGhVcmxfID0gb3B0X2F1dGhVcmw7XG5cdFx0fVxuXHRcdGlmICghV2VEZXBsb3kuYXV0aF8pIHtcblx0XHRcdFdlRGVwbG95LmF1dGhfID0gbmV3IEF1dGhBcGlIZWxwZXIoV2VEZXBsb3kpO1xuXHRcdH1cblx0XHRyZXR1cm4gV2VEZXBsb3kuYXV0aF87XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgYm9keSB0aGF0IHdpbGwgYmUgc2VudCB3aXRoIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHsqfSBib2R5XG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGJvZHkoYm9keSkge1xuXHRcdHRoaXMuYm9keV8gPSBib2R5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBib2R5IG9iamVjdCB0byBxdWVyeSBwYXJhbXMuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3QgQ2xpZW50IHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRjb252ZXJ0Qm9keVRvUGFyYW1zXyhjbGllbnRSZXF1ZXN0LCBib2R5KSB7XG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcoYm9keSkpIHtcblx0XHRcdGJvZHkgPSB7XG5cdFx0XHRcdGJvZHk6IGJvZHlcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgRW1ib2RpZWQpIHtcblx0XHRcdGJvZHkgPSBib2R5LmJvZHkoKTtcblx0XHR9XG5cdFx0T2JqZWN0LmtleXMoYm9keSB8fCB7fSkuZm9yRWFjaChuYW1lID0+IGNsaWVudFJlcXVlc3QucGFyYW0obmFtZSwgYm9keVtuYW1lXSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgY2xpZW50IHJlcXVlc3QgYW5kIGVuY29kZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuXHQgKiBAcGFyYW0geyp9IGJvZHlcblx0ICogQHJldHVybiB7IUNsaWVudFJlcXVlc3R9IENsaWVudCByZXF1ZXN0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRjcmVhdGVDbGllbnRSZXF1ZXN0XyhtZXRob2QsIGJvZHkpIHtcblx0XHRjb25zdCBjbGllbnRSZXF1ZXN0ID0gbmV3IENsaWVudFJlcXVlc3QoKTtcblxuXHRcdGNsaWVudFJlcXVlc3QuYm9keShib2R5IHx8IHRoaXMuYm9keV8pO1xuXG5cdFx0aWYgKCFjb3JlLmlzRGVmQW5kTm90TnVsbChjbGllbnRSZXF1ZXN0LmJvZHkoKSkpIHtcblx0XHRcdGlmICh0aGlzLmZvcm1EYXRhXykge1xuXHRcdFx0XHRjbGllbnRSZXF1ZXN0LmJvZHkodGhpcy5mb3JtRGF0YV8pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNsaWVudFJlcXVlc3QubWV0aG9kKG1ldGhvZCk7XG5cdFx0Y2xpZW50UmVxdWVzdC5oZWFkZXJzKHRoaXMuaGVhZGVycygpKTtcblx0XHRjbGllbnRSZXF1ZXN0LnBhcmFtcyh0aGlzLnBhcmFtcygpKTtcblx0XHRjbGllbnRSZXF1ZXN0LnVybCh0aGlzLnVybCgpKTtcblx0XHRjbGllbnRSZXF1ZXN0LndpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFsc18pO1xuXG5cdFx0dGhpcy5lbmNvZGUoY2xpZW50UmVxdWVzdCk7XG5cblx0XHRyZXR1cm4gY2xpZW50UmVxdWVzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGNsaWVudFJlc3BvbnNlIGJvZHksIHBhcnNpbmcgdGhlIGJvZHkgZm9yIGV4YW1wbGUuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlc3BvbnNlfSBjbGllbnRSZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0IHRvIGJlXG5cdCAqIGRlY29kZWQuXG5cdCAqIEByZXR1cm4geyFDbGllbnRSZXNwb25zZX0gVGhlIGRlY29kZWQgcmVzcG9uc2UuXG5cdCAqL1xuXHRkZWNvZGUoY2xpZW50UmVzcG9uc2UpIHtcblx0XHRpZiAoV2VEZXBsb3kuaXNDb250ZW50VHlwZUpzb24oY2xpZW50UmVzcG9uc2UpKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjbGllbnRSZXNwb25zZS5ib2R5KEpTT04ucGFyc2UoY2xpZW50UmVzcG9uc2UuYm9keSgpKSk7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHt9XG5cdFx0fVxuXHRcdHJldHVybiBjbGllbnRSZXNwb25zZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIERFTEVURSBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2JvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdGRlbGV0ZShvcHRfYm9keSkge1xuXHRcdHJldHVybiB0aGlzLnNlbmRBc3luYygnREVMRVRFJywgb3B0X2JvZHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgdGhlIGdpdmVuIHtAbGluayBDbGllbnRSZXF1ZXN0fSwgY29udmVydGluZyBpdHMgYm9keSB0byBhblxuXHQgKiBhcHByb3ByaWF0ZSBmb3JtYXQgZm9yIGV4YW1wbGUuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3QgVGhlIHJlcXVlc3Qgb2JqZWN0IHRvIGVuY29kZS5cblx0ICogQHJldHVybiB7IUNsaWVudFJlcXVlc3R9IFRoZSBlbmNvZGVkIHJlcXVlc3QuXG5cdCAqL1xuXHRlbmNvZGUoY2xpZW50UmVxdWVzdCkge1xuXHRcdGxldCBib2R5ID0gY2xpZW50UmVxdWVzdC5ib2R5KCk7XG5cblx0XHRpZiAoY29yZS5pc0VsZW1lbnQoYm9keSkpIHtcblx0XHRcdGJvZHkgPSBuZXcgRm9ybURhdGEoYm9keSk7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmJvZHkoYm9keSk7XG5cdFx0fVxuXG5cdFx0Ym9keSA9IHRoaXMubWF5YmVXcmFwV2l0aFF1ZXJ5Xyhib2R5KTtcblx0XHRpZiAoY2xpZW50UmVxdWVzdC5tZXRob2QoKSA9PT0gJ0dFVCcpIHtcblx0XHRcdHRoaXMuY29udmVydEJvZHlUb1BhcmFtc18oY2xpZW50UmVxdWVzdCwgYm9keSk7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LnJlbW92ZUJvZHkoKTtcblx0XHRcdGJvZHkgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5oZWFkZXJzKCkucmVtb3ZlKCdjb250ZW50LXR5cGUnKTtcblx0XHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5ib2R5KGJvZHkudG9TdHJpbmcoKSk7XG5cdFx0fSBlbHNlIGlmIChXZURlcGxveS5pc0NvbnRlbnRUeXBlSnNvbihjbGllbnRSZXF1ZXN0KSkge1xuXHRcdFx0Y2xpZW50UmVxdWVzdC5ib2R5KEpTT04uc3RyaW5naWZ5KGNsaWVudFJlcXVlc3QuYm9keSgpKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbmNvZGVQYXJhbXNfKGNsaWVudFJlcXVlc3QpO1xuXHRcdHRoaXMucmVzb2x2ZUF1dGhlbnRpY2F0aW9uXyhjbGllbnRSZXF1ZXN0KTtcblxuXHRcdHJldHVybiBjbGllbnRSZXF1ZXN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgdGhlIHBhcmFtcyBmb3IgdGhlIGdpdmVuIHJlcXVlc3QsIGFjY29yZGluZyB0byB0aGVpciB0eXBlcy5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRlbmNvZGVQYXJhbXNfKGNsaWVudFJlcXVlc3QpIHtcblx0XHRsZXQgcGFyYW1zID0gY2xpZW50UmVxdWVzdC5wYXJhbXMoKTtcblx0XHRwYXJhbXMubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdGxldCB2YWx1ZXMgPSBwYXJhbXMuZ2V0QWxsKG5hbWUpO1xuXHRcdFx0dmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVtYm9kaWVkKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNvcmUuaXNPYmplY3QodmFsdWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBrZXkvdmFsdWUgcGFpciB0byBiZSBzZW50IHZpYSB0aGUgYm9keSBpbiBhIGBtdWx0aXBhcnQvZm9ybS1kYXRhYCBmb3JtYXQuXG5cdCAqIElmIHRoZSBib2R5IGlzIHNldCBieSBvdGhlciBtZWFucyAoZm9yIGV4YW1wbGUsIHRocm91Z2ggdGhlIGBib2R5YCBtZXRob2QpLCB0aGlzXG5cdCAqIHdpbGwgYmUgaWdub3JlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRmb3JtKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiBGb3JtRGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignZm9ybSgpIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gRm9ybURhdGEgQVBJIGlzIGF2YWlsYWJsZS4nKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuZm9ybURhdGFfKSB7XG5cdFx0XHR0aGlzLmZvcm1EYXRhXyA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdH1cblx0XHR0aGlzLmZvcm1EYXRhXy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgR0VUIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3BhcmFtcyBQYXJhbXMgdG8gYmUgYWRkZWQgdG8gdGhlIHJlcXVlc3QgdXJsLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0Z2V0KG9wdF9wYXJhbXMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ0dFVCcsIG9wdF9wYXJhbXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBoZWFkZXIuIElmIHRoZSBoZWFkZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsXG5cdCAqIG5vdCBiZSBvdmVyd3JpdHRlbiwgYnV0IG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZC4gVGhlIG9yZGVyIGlzIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgSGVhZGVyIGtleS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBIZWFkZXIgdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGhlYWRlcihuYW1lLCB2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG5cdFx0fVxuXHRcdHRoaXMuaGVhZGVyc18uc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBoZWFkZXJzLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB9XG5cdCAqL1xuXHRoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzLmhlYWRlcnNfO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyYXBzIHRoZSBnaXZlbiBgRW1ib2RpZWRgIGluc3RhbmNlIHdpdGggYSB7QGxpbmsgUXVlcnl9IGluc3RhbmNlIGlmIG5lZWRlZC5cblx0ICogQHBhcmFtIHtFbWJvZGllZH0gZW1ib2RpZWRcblx0ICogQHJldHVybiB7RW1ib2RpZWR9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG1heWJlV3JhcFdpdGhRdWVyeV8oZW1ib2RpZWQpIHtcblx0XHRpZiAoZW1ib2RpZWQgaW5zdGFuY2VvZiBGaWx0ZXIpIHtcblx0XHRcdGVtYm9kaWVkID0gUXVlcnkuZmlsdGVyKGVtYm9kaWVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVtYm9kaWVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBxdWVyeS4gSWYgdGhlIHF1ZXJ5IHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBub3Rcblx0ICogYmUgb3ZlcndyaXR0ZW4sIGJ1dCBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQuIFRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFBhcmFtIGtleS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBQYXJhbSB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cGFyYW0obmFtZSwgdmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuXHRcdH1cblx0XHR0aGlzLnBhcmFtc18uc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBxdWVyeSBzdHJpbmdzIG1hcC5cblx0ICogQHJldHVybiB7IU11bHRpTWFwfVxuXHQgKi9cblx0cGFyYW1zKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmFtc187XG5cdH1cblxuXHQvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBQQVRDSCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2JvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG5cdHBhdGNoKG9wdF9ib2R5KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdQQVRDSCcsIG9wdF9ib2R5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBXZURlcGxveX0gaW5zdGFuY2UgZm9yIGhhbmRsaW5nIHRoZSB1cmwgcmVzdWx0aW5nIGluIHRoZVxuXHQgKiB1bmlvbiBvZiB0aGUgY3VycmVudCB1cmwgd2l0aCB0aGUgZ2l2ZW4gcGF0aHMuXG5cdCAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXRocyBBbnkgbnVtYmVyIG9mIHBhdGhzLlxuXHQgKiBAcmV0dXJuIHshV2VEZXBsb3l9IEEgbmV3IHtAbGluayBXZURlcGxveX0gaW5zdGFuY2UgZm9yIGhhbmRsaW5nIHRoZSBnaXZlbiBwYXRocy5cblx0ICovXG5cdHBhdGgoLi4ucGF0aHMpIHtcblx0XHRyZXR1cm4gbmV3IFdlRGVwbG95KHRoaXMudXJsKCksIC4uLnBhdGhzKS51c2UodGhpcy5jdXN0b21UcmFuc3BvcnRfKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIFBPU1QgaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9ib2R5IENvbnRlbnQgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuXHRwb3N0KG9wdF9ib2R5KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdQT1NUJywgb3B0X2JvZHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgUFVUIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cblx0cHV0KG9wdF9ib2R5KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdQVVQnLCBvcHRfYm9keSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgYXV0aGVudGljYXRpb24gaW5mb3JtYXRpb24gdG8gdGhlIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cmVzb2x2ZUF1dGhlbnRpY2F0aW9uXyhjbGllbnRSZXF1ZXN0KSB7XG5cdFx0aWYgKCF0aGlzLmF1dGhfKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICh0aGlzLmF1dGhfLmhhc1Rva2VuKCkpIHtcblx0XHRcdGNsaWVudFJlcXVlc3QuaGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0JlYXJlciAnICsgdGhpcy5hdXRoXy50b2tlbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGNyZWRlbnRpYWxzID0gdGhpcy5hdXRoXy5lbWFpbCArICc6JyArIHRoaXMuYXV0aF8ucGFzc3dvcmQ7XG5cdFx0XHRjbGllbnRSZXF1ZXN0LmhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgQmFzZTY0LmVuY29kZVN0cmluZyhjcmVkZW50aWFscykpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VzIHRyYW5zcG9ydCB0byBzZW5kIHJlcXVlc3Qgd2l0aCBnaXZlbiBtZXRob2QgbmFtZSBhbmQgYm9keVxuXHQgKiBhc3luY2hyb25vdXNseS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgSFRUUCBtZXRob2QgdG8gYmUgdXNlZCB3aGVuIHNlbmRpbmcgZGF0YS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gRGVmZXJyZWQgcmVxdWVzdC5cblx0ICovXG5cdHNlbmRBc3luYyhtZXRob2QsIGJvZHkpIHtcblx0XHRjb25zdCB0cmFuc3BvcnQgPSB0aGlzLmN1c3RvbVRyYW5zcG9ydF8gfHwgVHJhbnNwb3J0RmFjdG9yeS5pbnN0YW5jZSgpLmdldERlZmF1bHQoKTtcblxuXHRcdGNvbnN0IGNsaWVudFJlcXVlc3QgPSB0aGlzLmNyZWF0ZUNsaWVudFJlcXVlc3RfKG1ldGhvZCwgYm9keSk7XG5cblx0XHRyZXR1cm4gdHJhbnNwb3J0LnNlbmQoY2xpZW50UmVxdWVzdCkudGhlbih0aGlzLmRlY29kZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgc29ja2V0IHRyYW5zcG9ydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc29ja2V0IGltcGxlbWVudGF0aW9uIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyBzb2NrZXQoc29ja2V0KSB7XG5cdFx0aW8gPSBzb2NrZXQ7XG5cdH1cblxuXHQvKipcblx0ICogU3RhdGljIGZhY3RvcnkgZm9yIGNyZWF0aW5nIFdlRGVwbG95IGNsaWVudCBmb3IgdGhlIGdpdmVuIHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIHRoYXQgdGhlIGNsaWVudCBzaG91bGQgdXNlIGZvciBzZW5kaW5nIHJlcXVlc3RzLlxuXHQgKi9cblx0c3RhdGljIHVybCh1cmwpIHtcblx0XHRyZXR1cm4gbmV3IFdlRGVwbG95KHVybCkudXNlKHRoaXMuY3VzdG9tVHJhbnNwb3J0Xyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgVVJMIHVzZWQgYnkgdGhpcyBjbGllbnQuXG5cdCAqL1xuXHR1cmwoKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsXztcblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMge0BsaW5rIFRyYW5zcG9ydH0gaW1wbGVtZW50YXRpb24uXG5cdCAqIEBwYXJhbSB7IVRyYW5zcG9ydH0gdHJhbnNwb3J0IFRoZSB0cmFuc3BvcnQgaW1wbGVtZW50YXRpb24gdGhhdCBzaG91bGQgYmVcblx0ICogdXNlZC5cblx0ICovXG5cdHVzZSh0cmFuc3BvcnQpIHtcblx0XHR0aGlzLmN1c3RvbVRyYW5zcG9ydF8gPSB0cmFuc3BvcnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBuZXcgc29ja2V0LmlvIGluc3RhbmNlLiBUaGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gc29ja2V0LmlvXG5cdCAqIGNvbnN0cnVjdG9yIHdpbGwgYmUgcHJvdmlkZWQ6XG5cdCAqXG5cdCAqIGBgYGphdmFzY3JpcHRcblx0ICogV2VEZXBsb3kudXJsKCdodHRwOi8vZG9tYWluOjgwODAvcGF0aC9hJykud2F0Y2goe2lkOiAnbXlJZCd9LCB7Zm9vOiB0cnVlfSk7XG5cdCAqIC8vIEVxdWFsczpcblx0ICogaW8oJ2RvbWFpbjo4MDgwLz91cmw9cGF0aCUyRmElM0ZpZCUzRG15SWQnLCB7Zm9vOiB0cnVlfSk7XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdD19IG9wdF9wYXJhbXMgUGFyYW1zIHRvIGJlIHNlbnQgd2l0aCB0aGUgU29ja2V0IElPIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29wdGlvbnMgT2JqZWN0IHdpdGggU29ja2V0IElPIG9wdGlvbnMuXG5cdCAqIEByZXR1cm4geyFpb30gU29ja2V0IElPIHJlZmVyZW5jZS4gU2VydmVyIGV2ZW50cyBjYW4gYmUgbGlzdGVuZWQgb24gaXQuXG5cdCAqL1xuXHR3YXRjaChvcHRfcGFyYW1zLCBvcHRfb3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2YgaW8gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NvY2tldC5pbyBjbGllbnQgbm90IGxvYWRlZCcpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNsaWVudFJlcXVlc3QgPSB0aGlzLmNyZWF0ZUNsaWVudFJlcXVlc3RfKCdHRVQnLCBvcHRfcGFyYW1zKTtcblx0XHRjb25zdCB1cmkgPSBuZXcgVXJpKGNsaWVudFJlcXVlc3QudXJsKCkpO1xuXHRcdHVyaS5hZGRQYXJhbWV0ZXJzRnJvbU11bHRpTWFwKGNsaWVudFJlcXVlc3QucGFyYW1zKCkpO1xuXG5cdFx0b3B0X29wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7XG5cdFx0XHRmb3JjZU5ldzogdHJ1ZVxuXHRcdH07XG5cdFx0b3B0X29wdGlvbnMucXVlcnkgPSAndXJsPScgKyBlbmNvZGVVUklDb21wb25lbnQodXJpLmdldFBhdGhuYW1lKCkgKyB1cmkuZ2V0U2VhcmNoKCkpO1xuXHRcdG9wdF9vcHRpb25zLnBhdGggPSBvcHRfb3B0aW9ucy5wYXRoIHx8IHVyaS5nZXRQYXRobmFtZSgpO1xuXG5cdFx0cmV0dXJuIGlvKHVyaS5nZXRIb3N0KCksIG9wdF9vcHRpb25zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdF93aXRoQ3JlZGVudGlhbHNcblx0ICovXG5cdHdpdGhDcmVkZW50aWFscyh3aXRoQ3JlZGVudGlhbHMpIHtcblx0XHR0aGlzLndpdGhDcmVkZW50aWFsc18gPSAhIXdpdGhDcmVkZW50aWFscztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5XZURlcGxveS5pc0NvbnRlbnRUeXBlSnNvbiA9IGZ1bmN0aW9uKGNsaWVudE1lc3NhZ2UpIHtcblx0Y29uc3QgY29udGVudFR5cGUgPSBjbGllbnRNZXNzYWdlLmhlYWRlcnMoKS5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuXHRyZXR1cm4gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID09PSAwO1xufTtcblxuV2VEZXBsb3kuYXV0aF8gPSBudWxsO1xuV2VEZXBsb3kuYXV0aFVybF8gPSAnJztcbldlRGVwbG95LmRhdGFfID0gbnVsbDtcbldlRGVwbG95LmRhdGFVcmxfID0gJyc7XG5cbmV4cG9ydCBkZWZhdWx0IFdlRGVwbG95O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi9hcGktcXVlcnkvRmlsdGVyJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vYXBpLXF1ZXJ5L0dlbyc7XG5pbXBvcnQgV2VEZXBsb3kgZnJvbSAnLi4vYXBpL1dlRGVwbG95JztcbmltcG9ydCBRdWVyeSBmcm9tICcuLi9hcGktcXVlcnkvUXVlcnknO1xuaW1wb3J0IFJhbmdlIGZyb20gJy4uL2FwaS1xdWVyeS9SYW5nZSc7XG5cbmdsb2JhbHMud2luZG93LkZpbHRlciA9IEZpbHRlcjtcbmdsb2JhbHMud2luZG93LkdlbyA9IEdlbztcbmdsb2JhbHMud2luZG93LlF1ZXJ5ID0gUXVlcnk7XG5nbG9iYWxzLndpbmRvdy5SYW5nZSA9IFJhbmdlO1xuZ2xvYmFscy53aW5kb3cuV2VEZXBsb3kgPSBXZURlcGxveTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
